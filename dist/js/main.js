// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"hGrKA":[function(require,module,exports) {
"use strict";
var HMR_HOST = null;
var HMR_PORT = 54190;
var HMR_SECURE = false;
var HMR_ENV_HASH = "62b4c8a1dd9cbcca";
module.bundle.HMR_BUNDLE_ID = "f1a33f3a193ef3c0";
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else if ('reload' in location) location.reload();
            else {
                // Web extension context
                var ext = typeof chrome === 'undefined' ? typeof browser === 'undefined' ? null : browser : chrome;
                if (ext && ext.runtime && ext.runtime.reload) ext.runtime.reload();
            }
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('ðŸš¨ [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] ðŸš¨ Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] âœ¨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>ðŸ’¡ ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                var oldDeps = modules[asset.id][1];
                for(var dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    var id = oldDeps[dep];
                    var parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id1) {
    var modules = bundle.modules;
    if (!modules) return;
    if (modules[id1]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        var deps = modules[id1][1];
        var orphans = [];
        for(var dep in deps){
            var parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id1];
        delete bundle.cache[id1]; // Now delete the orphans.
        orphans.forEach(function(id) {
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id1);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    var parents = getParents(module.bundle.root, id);
    var accepted = false;
    while(parents.length > 0){
        var v = parents.shift();
        var a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            var p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push.apply(parents, _toConsumableArray(p));
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"iGeph":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _chartJs = require("chart.js");
var _core = require("@fullcalendar/core");
var _timegrid = require("@fullcalendar/timegrid");
var _timegridDefault = parcelHelpers.interopDefault(_timegrid);
var _daygrid = require("@fullcalendar/daygrid");
var _daygridDefault = parcelHelpers.interopDefault(_daygrid);
var _interaction = require("@fullcalendar/interaction");
var _interactionDefault = parcelHelpers.interopDefault(_interaction);
var _list = require("@fullcalendar/list");
var _listDefault = parcelHelpers.interopDefault(_list);
// Bootstrap JS
var bootstrap = require('bootstrap');
// Charts
let apexLineChart = require('./apex-charts/line');
let apexBarChart = require('./apex-charts/bar');
let apexUsersChart = require('./apex-charts/users');
let apexSparkChart = require('./apex-charts/spark');
// Libs
let datepicker = require('./datepicker');
const { Dropzone  } = require("dropzone");
Dropzone.autoDiscover = false;
Dropzone.options.previewa = {
    init: function() {
        Dropzone.options.previewaDropzone = false;
    }
};
document.addEventListener('DOMContentLoaded', ()=>{
    const isCalendarPage = window.location.pathname.includes('/pages/calendar');
    const isCreatePage = window.location.pathname.includes('/pages/create');
    if (isCreatePage) {
        // Images dropzone
        let myDropzone1 = new Dropzone("#dropzone-posts-1", {
            url: '/url1.json'
        });
        let myDropzone2 = new Dropzone("#dropzone-posts-2", {
            url: '/url2.json'
        });
        let myDropzone3 = new Dropzone("#dropzone-posts-3", {
            url: '/url3.json'
        });
        let myDropzone4 = new Dropzone("#dropzone-posts-4", {
            url: '/url4.json'
        });
        let myDropzone5 = new Dropzone("#dropzone-posts-5", {
            url: '/url5.json'
        });
        let myDropzone6 = new Dropzone("#dropzone-posts-6", {
            url: '/url6.json'
        });
        let myDropzoneS1 = new Dropzone("#dropzone-stories-1", {
            url: '/url1.json'
        });
        let myDropzoneS2 = new Dropzone("#dropzone-stories-2", {
            url: '/url2.json'
        });
        myDropzone1.on("addedfile", (file)=>{
            console.log(`File added: ${file.name}`);
        });
    }
    if (isCreatePage) {
        // chart.js
        _chartJs.Chart.register(_chartJs.ArcElement, _chartJs.LineElement, _chartJs.BarElement, _chartJs.PointElement, _chartJs.BarController, _chartJs.BubbleController, _chartJs.DoughnutController, _chartJs.LineController, _chartJs.PieController, _chartJs.PolarAreaController, _chartJs.RadarController, _chartJs.ScatterController, _chartJs.CategoryScale, _chartJs.LinearScale, _chartJs.LogarithmicScale, _chartJs.RadialLinearScale, _chartJs.TimeScale, _chartJs.TimeSeriesScale, _chartJs.Decimation, _chartJs.Filler, _chartJs.Legend, _chartJs.Title, _chartJs.Tooltip);
        const ctx = document.getElementById('dateChart').getContext('2d');
        const ctxStory = document.getElementById('dateChartStory').getContext('2d');
        const myChart = new _chartJs.Chart(ctx, {
            type: 'bar',
            data: {
                labels: [
                    '0',
                    '3',
                    '6',
                    '9',
                    '12',
                    '15',
                    '18',
                    '21'
                ],
                datasets: [
                    {
                        label: 'Best hours to post',
                        data: [
                            0,
                            3,
                            7,
                            10,
                            10,
                            7,
                            3,
                            0
                        ],
                        backgroundColor: [
                            '#71A3F3',
                            '#71A3F3',
                            '#71A3F3',
                            '#71A3F3',
                            '#E3954A',
                            '#71A3F3',
                            '#71A3F3',
                            '#71A3F3', 
                        ]
                    }
                ]
            },
            options: {
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            display: false,
                            drawBorder: false
                        },
                        ticks: {
                            display: false
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        }
                    }
                }
            }
        });
        const myChartStory = new _chartJs.Chart(ctxStory, {
            type: 'bar',
            data: {
                labels: [
                    '0',
                    '3',
                    '6',
                    '9',
                    '12',
                    '15',
                    '18',
                    '21'
                ],
                datasets: [
                    {
                        label: 'Best hours to post',
                        data: [
                            0,
                            3,
                            7,
                            10,
                            10,
                            7,
                            3,
                            0
                        ],
                        backgroundColor: [
                            '#71A3F3',
                            '#71A3F3',
                            '#71A3F3',
                            '#71A3F3',
                            '#E3954A',
                            '#71A3F3',
                            '#71A3F3',
                            '#71A3F3', 
                        ]
                    }
                ]
            },
            options: {
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            display: false,
                            drawBorder: false
                        },
                        ticks: {
                            display: false
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        }
                    }
                }
            }
        });
    }
    if (isCreatePage) {
        // Fullcalendar Create
        const calendarEl = document.querySelector("#create-fullcalendar");
        let calendar = new _core.Calendar(calendarEl, {
            plugins: [
                _timegridDefault.default
            ],
            headerToolbar: {
                // left: 'prev, next today',
                left: 'prev, next'
            },
            dayHeaderFormat: {
                weekday: 'short',
                day: 'numeric',
                omitCommas: true
            },
            initialView: 'timeGridWeek',
            validRange: function(today) {
                return {
                    start: today
                };
            },
            events: 'https://fullcalendar.io/demo-events.json'
        });
        calendar.render();
    }
    // Radio functionality
    var checkedRadio = $('input[name = "flexRadioDefault"]');
    checkedRadio.click(function() {
        var isCustomRadio = $(this).attr("id") === 'flexRadioDefault3';
        if (isCustomRadio) $('#customDateRadio').removeClass('d-none');
        else $('#customDateRadio').addClass('d-none');
    });
    var checkedRadioStory = $('input[name = "flexRadioDefaultStory"]');
    checkedRadioStory.click(function() {
        var isCustomRadio = $(this).attr("id") === 'flexRadioDefaultStory3';
        if (isCustomRadio) $('#customDateRadioStory').removeClass('d-none');
        else $('#customDateRadioStory').addClass('d-none');
    });
    // Date picker
    $('#datepicker').datepicker({
        format: 'dd-mm-yyyy',
        startDate: '+1d',
        altField: "#datepicker-input"
    });
    $('#datepickerStory').datepicker({
        format: 'dd-mm-yyyy',
        startDate: '+1d',
        altField: "#datepicker-input-story"
    });
    // Scheduled switcher
    $('.scheduled-switcher a').click(function() {
        var switchA = $(this);
        var switchAll = $('#allSwitch');
        var switchSchedule = $('#scheduleSwitch');
        $('.scheduled-switcher a').removeClass('active');
        if (switchA.attr('id') === 'allSwitch') switchAll.addClass('active');
        else switchSchedule.addClass('active');
    });
    // Instagram hover block
    $('.instagram-item').hover(function() {
        $(this).find('.hover-block').toggleClass('is-hover');
    });
    // Instagram modal
    $('.phone-type-switcher .instagram-item').click(function() {
        var currentImage = $(this).find('img');
        var instagramModal = $('#postImageModal');
        var instagramModalImg = instagramModal.find('.instagram-image img');
        if (currentImage) {
            if (instagramModalImg) instagramModalImg.attr('src', currentImage[0].src);
        }
    });
    // Calendar page
    $('.all-filter').click(function() {
        $(this).toggleClass('active');
    });
    if (isCalendarPage) {
        const calendarEl = document.querySelector("#calendar-fullcalendar");
        let calendar = new _core.Calendar(calendarEl, {
            plugins: [
                _timegridDefault.default,
                _daygridDefault.default,
                _listDefault.default,
                _interactionDefault.default
            ],
            headerToolbar: {
                left: 'prev, title, next',
                center: 'listWeek',
                right: 'dayGridMonth, timeGridWeek, today'
            },
            dayHeaderFormat: {
                weekday: 'short',
                day: 'numeric',
                omitCommas: true
            },
            initialView: 'dayGridMonth',
            eventClick: function(event) {
                $("#schedule-edit").modal('show');
            },
            dateClick: function(date, jsEvent, view) {
                $('#schedule-add').modal('show');
            },
            selectable: true,
            selectHelper: true,
            editable: true,
            validRange: function(today) {
                return {
                    start: today
                };
            },
            events: 'https://fullcalendar.io/demo-events.json'
        });
        calendar.render();
    }
    // Line chart
    const lineChartEl = document.querySelector("#chart-line");
    if (lineChartEl) new apexLineChart().init(lineChartEl);
    // Bar chart
    const barChartEl = document.querySelector("#chart-bar");
    if (barChartEl) new apexBarChart().init(barChartEl);
    // Users chart
    const usersChartEl = document.querySelector("#chart-users");
    if (usersChartEl) new apexUsersChart().init(usersChartEl);
    // Spark chart
    const sparkChartsEl = document.querySelectorAll("[data-toggle='spark-chart']");
    if (sparkChartsEl) Array.prototype.forEach.call(sparkChartsEl, function(el) {
        new apexSparkChart().init(el);
    });
    // Light Gallery
    const galleryEl = document.querySelector("#lightgallery");
    if (barChartEl) new lightGallery().init(galleryEl);
    // Datepicker
    const dateRangePickerEl = document.querySelector(".daterangepicker");
    if (dateRangePickerEl) new datepicker().range('.daterangepicker');
    const datepickerEl = document.querySelector(".datepicker");
    if (datepickerEl) new datepicker().init('.datepicker');
});

},{"bootstrap":"4VxGl","./apex-charts/line":"ixfcR","./apex-charts/bar":"eBeiv","./apex-charts/users":"6kPXv","./apex-charts/spark":"beBa7","./datepicker":"dvEkG","@fullcalendar/core":"5UuDO","@fullcalendar/timegrid":"lpFmL","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo","chart.js":"7J4yz","dropzone":"koWJM","@fullcalendar/list":"fYCNr","@fullcalendar/daygrid":"1Spto","@fullcalendar/interaction":"2Lwrt"}],"4VxGl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Alert", ()=>Alert
);
parcelHelpers.export(exports, "Button", ()=>Button
);
parcelHelpers.export(exports, "Carousel", ()=>Carousel
);
parcelHelpers.export(exports, "Collapse", ()=>Collapse
);
parcelHelpers.export(exports, "Dropdown", ()=>Dropdown
);
parcelHelpers.export(exports, "Modal", ()=>Modal
);
parcelHelpers.export(exports, "Offcanvas", ()=>Offcanvas
);
parcelHelpers.export(exports, "Popover", ()=>Popover
);
parcelHelpers.export(exports, "ScrollSpy", ()=>ScrollSpy
);
parcelHelpers.export(exports, "Tab", ()=>Tab
);
parcelHelpers.export(exports, "Toast", ()=>Toast
);
parcelHelpers.export(exports, "Tooltip", ()=>Tooltip
);
/*!
  * Bootstrap v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */ var _core = require("@popperjs/core");
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): util/index.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ const MAX_UID = 1000000;
const MILLISECONDS_MULTIPLIER = 1000;
const TRANSITION_END = 'transitionend'; // Shoutout AngusCroll (https://goo.gl/pxwQGp)
const toType = (obj)=>{
    if (obj === null || obj === undefined) return `${obj}`;
    return ({}).toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
};
/**
 * --------------------------------------------------------------------------
 * Public Util Api
 * --------------------------------------------------------------------------
 */ const getUID = (prefix)=>{
    do prefix += Math.floor(Math.random() * MAX_UID);
    while (document.getElementById(prefix))
    return prefix;
};
const getSelector = (element)=>{
    let selector = element.getAttribute('data-bs-target');
    if (!selector || selector === '#') {
        let hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
        // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
        // `document.querySelector` will rightfully complain it is invalid.
        // See https://github.com/twbs/bootstrap/issues/32273
        if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) return null;
         // Just in case some CMS puts out a full URL with the anchor appended
        if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) hrefAttr = `#${hrefAttr.split('#')[1]}`;
        selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;
    }
    return selector;
};
const getSelectorFromElement = (element)=>{
    const selector = getSelector(element);
    if (selector) return document.querySelector(selector) ? selector : null;
    return null;
};
const getElementFromSelector = (element)=>{
    const selector = getSelector(element);
    return selector ? document.querySelector(selector) : null;
};
const getTransitionDurationFromElement = (element)=>{
    if (!element) return 0;
     // Get transition-duration of the element
    let { transitionDuration , transitionDelay  } = window.getComputedStyle(element);
    const floatTransitionDuration = Number.parseFloat(transitionDuration);
    const floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found
    if (!floatTransitionDuration && !floatTransitionDelay) return 0;
     // If multiple durations are defined, take the first
    transitionDuration = transitionDuration.split(',')[0];
    transitionDelay = transitionDelay.split(',')[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
};
const triggerTransitionEnd = (element)=>{
    element.dispatchEvent(new Event(TRANSITION_END));
};
const isElement = (obj)=>{
    if (!obj || typeof obj !== 'object') return false;
    if (typeof obj.jquery !== 'undefined') obj = obj[0];
    return typeof obj.nodeType !== 'undefined';
};
const getElement = (obj)=>{
    if (isElement(obj)) // it's a jQuery object or a node element
    return obj.jquery ? obj[0] : obj;
    if (typeof obj === 'string' && obj.length > 0) return document.querySelector(obj);
    return null;
};
const typeCheckConfig = (componentName, config, configTypes)=>{
    Object.keys(configTypes).forEach((property)=>{
        const expectedTypes = configTypes[property];
        const value = config[property];
        const valueType = value && isElement(value) ? 'element' : toType(value);
        if (!new RegExp(expectedTypes).test(valueType)) throw new TypeError(`${componentName.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
    });
};
const isVisible = (element)=>{
    if (!isElement(element) || element.getClientRects().length === 0) return false;
    return getComputedStyle(element).getPropertyValue('visibility') === 'visible';
};
const isDisabled = (element)=>{
    if (!element || element.nodeType !== Node.ELEMENT_NODE) return true;
    if (element.classList.contains('disabled')) return true;
    if (typeof element.disabled !== 'undefined') return element.disabled;
    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
};
const findShadowRoot = (element)=>{
    if (!document.documentElement.attachShadow) return null;
     // Can find the shadow root otherwise it'll return the document
    if (typeof element.getRootNode === 'function') {
        const root = element.getRootNode();
        return root instanceof ShadowRoot ? root : null;
    }
    if (element instanceof ShadowRoot) return element;
     // when we don't find a shadow root
    if (!element.parentNode) return null;
    return findShadowRoot(element.parentNode);
};
const noop = ()=>{};
/**
 * Trick to restart an element's animation
 *
 * @param {HTMLElement} element
 * @return void
 *
 * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
 */ const reflow = (element)=>{
    // eslint-disable-next-line no-unused-expressions
    element.offsetHeight;
};
const getjQuery = ()=>{
    const { jQuery  } = window;
    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) return jQuery;
    return null;
};
const DOMContentLoadedCallbacks = [];
const onDOMContentLoaded = (callback1)=>{
    if (document.readyState === 'loading') {
        // add listener on the first call when the document is in loading state
        if (!DOMContentLoadedCallbacks.length) document.addEventListener('DOMContentLoaded', ()=>{
            DOMContentLoadedCallbacks.forEach((callback)=>callback()
            );
        });
        DOMContentLoadedCallbacks.push(callback1);
    } else callback1();
};
const isRTL = ()=>document.documentElement.dir === 'rtl'
;
const defineJQueryPlugin = (plugin)=>{
    onDOMContentLoaded(()=>{
        const $ = getjQuery();
        /* istanbul ignore if */ if ($) {
            const name = plugin.NAME;
            const JQUERY_NO_CONFLICT = $.fn[name];
            $.fn[name] = plugin.jQueryInterface;
            $.fn[name].Constructor = plugin;
            $.fn[name].noConflict = ()=>{
                $.fn[name] = JQUERY_NO_CONFLICT;
                return plugin.jQueryInterface;
            };
        }
    });
};
const execute = (callback)=>{
    if (typeof callback === 'function') callback();
};
const executeAfterTransition = (callback, transitionElement, waitForTransition = true)=>{
    if (!waitForTransition) {
        execute(callback);
        return;
    }
    const durationPadding = 5;
    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
    let called = false;
    const handler = ({ target  })=>{
        if (target !== transitionElement) return;
        called = true;
        transitionElement.removeEventListener(TRANSITION_END, handler);
        execute(callback);
    };
    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(()=>{
        if (!called) triggerTransitionEnd(transitionElement);
    }, emulatedDuration);
};
/**
 * Return the previous/next element of a list.
 *
 * @param {array} list    The list of elements
 * @param activeElement   The active element
 * @param shouldGetNext   Choose to get next or previous element
 * @param isCycleAllowed
 * @return {Element|elem} The proper element
 */ const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed)=>{
    let index = list.indexOf(activeElement); // if the element does not exist in the list return an element depending on the direction and if cycle is allowed
    if (index === -1) return list[!shouldGetNext && isCycleAllowed ? list.length - 1 : 0];
    const listLength = list.length;
    index += shouldGetNext ? 1 : -1;
    if (isCycleAllowed) index = (index + listLength) % listLength;
    return list[Math.max(0, Math.min(index, listLength - 1))];
};
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): dom/event-handler.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */ const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
const stripNameRegex = /\..*/;
const stripUidRegex = /::\d+$/;
const eventRegistry = {}; // Events storage
let uidEvent = 1;
const customEvents = {
    mouseenter: 'mouseover',
    mouseleave: 'mouseout'
};
const customEventsRegex = /^(mouseenter|mouseleave)/i;
const nativeEvents = new Set([
    'click',
    'dblclick',
    'mouseup',
    'mousedown',
    'contextmenu',
    'mousewheel',
    'DOMMouseScroll',
    'mouseover',
    'mouseout',
    'mousemove',
    'selectstart',
    'selectend',
    'keydown',
    'keypress',
    'keyup',
    'orientationchange',
    'touchstart',
    'touchmove',
    'touchend',
    'touchcancel',
    'pointerdown',
    'pointermove',
    'pointerup',
    'pointerleave',
    'pointercancel',
    'gesturestart',
    'gesturechange',
    'gestureend',
    'focus',
    'blur',
    'change',
    'reset',
    'select',
    'submit',
    'focusin',
    'focusout',
    'load',
    'unload',
    'beforeunload',
    'resize',
    'move',
    'DOMContentLoaded',
    'readystatechange',
    'error',
    'abort',
    'scroll'
]);
/**
 * ------------------------------------------------------------------------
 * Private methods
 * ------------------------------------------------------------------------
 */ function getUidEvent(element, uid) {
    return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
}
function getEvent(element) {
    const uid = getUidEvent(element);
    element.uidEvent = uid;
    eventRegistry[uid] = eventRegistry[uid] || {};
    return eventRegistry[uid];
}
function bootstrapHandler(element, fn) {
    return function handler(event) {
        event.delegateTarget = element;
        if (handler.oneOff) EventHandler.off(element, event.type, fn);
        return fn.apply(element, [
            event
        ]);
    };
}
function bootstrapDelegationHandler(element, selector, fn) {
    return function handler(event) {
        const domElements = element.querySelectorAll(selector);
        for(let { target  } = event; target && target !== this; target = target.parentNode){
            for(let i = domElements.length; i--;)if (domElements[i] === target) {
                event.delegateTarget = target;
                if (handler.oneOff) EventHandler.off(element, event.type, selector, fn);
                return fn.apply(target, [
                    event
                ]);
            }
        } // To please ESLint
        return null;
    };
}
function findHandler(events, handler, delegationSelector = null) {
    const uidEventList = Object.keys(events);
    for(let i = 0, len = uidEventList.length; i < len; i++){
        const event = events[uidEventList[i]];
        if (event.originalHandler === handler && event.delegationSelector === delegationSelector) return event;
    }
    return null;
}
function normalizeParams(originalTypeEvent, handler, delegationFn) {
    const delegation = typeof handler === 'string';
    const originalHandler = delegation ? delegationFn : handler;
    let typeEvent = getTypeEvent(originalTypeEvent);
    const isNative = nativeEvents.has(typeEvent);
    if (!isNative) typeEvent = originalTypeEvent;
    return [
        delegation,
        originalHandler,
        typeEvent
    ];
}
function addHandler(element, originalTypeEvent, handler, delegationFn, oneOff) {
    if (typeof originalTypeEvent !== 'string' || !element) return;
    if (!handler) {
        handler = delegationFn;
        delegationFn = null;
    } // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
    // this prevents the handler from being dispatched the same way as mouseover or mouseout does
    if (customEventsRegex.test(originalTypeEvent)) {
        const wrapFn = (fn)=>{
            return function(event) {
                if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) return fn.call(this, event);
            };
        };
        if (delegationFn) delegationFn = wrapFn(delegationFn);
        else handler = wrapFn(handler);
    }
    const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn);
    const events = getEvent(element);
    const handlers = events[typeEvent] || (events[typeEvent] = {});
    const previousFn = findHandler(handlers, originalHandler, delegation ? handler : null);
    if (previousFn) {
        previousFn.oneOff = previousFn.oneOff && oneOff;
        return;
    }
    const uid = getUidEvent(originalHandler, originalTypeEvent.replace(namespaceRegex, ''));
    const fn1 = delegation ? bootstrapDelegationHandler(element, handler, delegationFn) : bootstrapHandler(element, handler);
    fn1.delegationSelector = delegation ? handler : null;
    fn1.originalHandler = originalHandler;
    fn1.oneOff = oneOff;
    fn1.uidEvent = uid;
    handlers[uid] = fn1;
    element.addEventListener(typeEvent, fn1, delegation);
}
function removeHandler(element, events, typeEvent, handler, delegationSelector) {
    const fn = findHandler(events[typeEvent], handler, delegationSelector);
    if (!fn) return;
    element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
    delete events[typeEvent][fn.uidEvent];
}
function removeNamespacedHandlers(element, events, typeEvent, namespace) {
    const storeElementEvent = events[typeEvent] || {};
    Object.keys(storeElementEvent).forEach((handlerKey)=>{
        if (handlerKey.includes(namespace)) {
            const event = storeElementEvent[handlerKey];
            removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);
        }
    });
}
function getTypeEvent(event) {
    // allow to get the native events from namespaced events ('click.bs.button' --> 'click')
    event = event.replace(stripNameRegex, '');
    return customEvents[event] || event;
}
const EventHandler = {
    on (element, event, handler, delegationFn) {
        addHandler(element, event, handler, delegationFn, false);
    },
    one (element, event, handler, delegationFn) {
        addHandler(element, event, handler, delegationFn, true);
    },
    off (element, originalTypeEvent, handler, delegationFn) {
        if (typeof originalTypeEvent !== 'string' || !element) return;
        const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn);
        const inNamespace = typeEvent !== originalTypeEvent;
        const events = getEvent(element);
        const isNamespace = originalTypeEvent.startsWith('.');
        if (typeof originalHandler !== 'undefined') {
            // Simplest case: handler is passed, remove that listener ONLY.
            if (!events || !events[typeEvent]) return;
            removeHandler(element, events, typeEvent, originalHandler, delegation ? handler : null);
            return;
        }
        if (isNamespace) Object.keys(events).forEach((elementEvent)=>{
            removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
        });
        const storeElementEvent = events[typeEvent] || {};
        Object.keys(storeElementEvent).forEach((keyHandlers)=>{
            const handlerKey = keyHandlers.replace(stripUidRegex, '');
            if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
                const event = storeElementEvent[keyHandlers];
                removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);
            }
        });
    },
    trigger (element, event, args) {
        if (typeof event !== 'string' || !element) return null;
        const $ = getjQuery();
        const typeEvent = getTypeEvent(event);
        const inNamespace = event !== typeEvent;
        const isNative = nativeEvents.has(typeEvent);
        let jQueryEvent;
        let bubbles = true;
        let nativeDispatch = true;
        let defaultPrevented = false;
        let evt = null;
        if (inNamespace && $) {
            jQueryEvent = $.Event(event, args);
            $(element).trigger(jQueryEvent);
            bubbles = !jQueryEvent.isPropagationStopped();
            nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
            defaultPrevented = jQueryEvent.isDefaultPrevented();
        }
        if (isNative) {
            evt = document.createEvent('HTMLEvents');
            evt.initEvent(typeEvent, bubbles, true);
        } else evt = new CustomEvent(event, {
            bubbles,
            cancelable: true
        });
         // merge custom information in our event
        if (typeof args !== 'undefined') Object.keys(args).forEach((key)=>{
            Object.defineProperty(evt, key, {
                get () {
                    return args[key];
                }
            });
        });
        if (defaultPrevented) evt.preventDefault();
        if (nativeDispatch) element.dispatchEvent(evt);
        if (evt.defaultPrevented && typeof jQueryEvent !== 'undefined') jQueryEvent.preventDefault();
        return evt;
    }
};
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): dom/data.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */ const elementMap = new Map();
const Data = {
    set (element, key, instance) {
        if (!elementMap.has(element)) elementMap.set(element, new Map());
        const instanceMap = elementMap.get(element); // make it clear we only want one instance per element
        // can be removed later when multiple key/instances are fine to be used
        if (!instanceMap.has(key) && instanceMap.size !== 0) {
            // eslint-disable-next-line no-console
            console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
            return;
        }
        instanceMap.set(key, instance);
    },
    get (element, key) {
        if (elementMap.has(element)) return elementMap.get(element).get(key) || null;
        return null;
    },
    remove (element, key) {
        if (!elementMap.has(element)) return;
        const instanceMap = elementMap.get(element);
        instanceMap.delete(key); // free up element references if there are no instances left for an element
        if (instanceMap.size === 0) elementMap.delete(element);
    }
};
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): base-component.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */ const VERSION = '5.1.3';
class BaseComponent {
    dispose() {
        Data.remove(this._element, this.constructor.DATA_KEY);
        EventHandler.off(this._element, this.constructor.EVENT_KEY);
        Object.getOwnPropertyNames(this).forEach((propertyName)=>{
            this[propertyName] = null;
        });
    }
    _queueCallback(callback, element, isAnimated = true) {
        executeAfterTransition(callback, element, isAnimated);
    }
    /** Static */ static getInstance(element) {
        return Data.get(getElement(element), this.DATA_KEY);
    }
    static getOrCreateInstance(element, config = {}) {
        return this.getInstance(element) || new this(element, typeof config === 'object' ? config : null);
    }
    static get VERSION() {
        return VERSION;
    }
    static get NAME() {
        throw new Error('You have to implement the static method "NAME", for each component!');
    }
    static get DATA_KEY() {
        return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
        return `.${this.DATA_KEY}`;
    }
    constructor(element){
        element = getElement(element);
        if (!element) return;
        this._element = element;
        Data.set(this._element, this.constructor.DATA_KEY, this);
    }
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): util/component-functions.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ const enableDismissTrigger = (component, method = 'hide')=>{
    const clickEvent = `click.dismiss${component.EVENT_KEY}`;
    const name = component.NAME;
    EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function(event) {
        if ([
            'A',
            'AREA'
        ].includes(this.tagName)) event.preventDefault();
        if (isDisabled(this)) return;
        const target = getElementFromSelector(this) || this.closest(`.${name}`);
        const instance = component.getOrCreateInstance(target); // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method
        instance[method]();
    });
};
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): alert.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */ const NAME$d = 'alert';
const DATA_KEY$c = 'bs.alert';
const EVENT_KEY$c = `.${DATA_KEY$c}`;
const EVENT_CLOSE = `close${EVENT_KEY$c}`;
const EVENT_CLOSED = `closed${EVENT_KEY$c}`;
const CLASS_NAME_FADE$5 = 'fade';
const CLASS_NAME_SHOW$8 = 'show';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */ class Alert extends BaseComponent {
    // Getters
    static get NAME() {
        return NAME$d;
    }
    close() {
        const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
        if (closeEvent.defaultPrevented) return;
        this._element.classList.remove(CLASS_NAME_SHOW$8);
        const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
        this._queueCallback(()=>this._destroyElement()
        , this._element, isAnimated);
    }
    _destroyElement() {
        this._element.remove();
        EventHandler.trigger(this._element, EVENT_CLOSED);
        this.dispose();
    }
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Alert.getOrCreateInstance(this);
            if (typeof config !== 'string') return;
            if (data[config] === undefined || config.startsWith('_') || config === 'constructor') throw new TypeError(`No method named "${config}"`);
            data[config](this);
        });
    }
}
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */ enableDismissTrigger(Alert, 'close');
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Alert to jQuery only if jQuery is present
 */ defineJQueryPlugin(Alert);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): button.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */ const NAME$c = 'button';
const DATA_KEY$b = 'bs.button';
const EVENT_KEY$b = `.${DATA_KEY$b}`;
const DATA_API_KEY$7 = '.data-api';
const CLASS_NAME_ACTIVE$3 = 'active';
const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$b}${DATA_API_KEY$7}`;
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */ class Button extends BaseComponent {
    // Getters
    static get NAME() {
        return NAME$c;
    }
    toggle() {
        // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method
        this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
    }
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Button.getOrCreateInstance(this);
            if (config === 'toggle') data[config]();
        });
    }
}
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */ EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event)=>{
    event.preventDefault();
    const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
    const data = Button.getOrCreateInstance(button);
    data.toggle();
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Button to jQuery only if jQuery is present
 */ defineJQueryPlugin(Button);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): dom/manipulator.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ function normalizeData(val) {
    if (val === 'true') return true;
    if (val === 'false') return false;
    if (val === Number(val).toString()) return Number(val);
    if (val === '' || val === 'null') return null;
    return val;
}
function normalizeDataKey(key) {
    return key.replace(/[A-Z]/g, (chr)=>`-${chr.toLowerCase()}`
    );
}
const Manipulator = {
    setDataAttribute (element, key, value) {
        element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
    },
    removeDataAttribute (element, key) {
        element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
    },
    getDataAttributes (element) {
        if (!element) return {};
        const attributes = {};
        Object.keys(element.dataset).filter((key)=>key.startsWith('bs')
        ).forEach((key)=>{
            let pureKey = key.replace(/^bs/, '');
            pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
            attributes[pureKey] = normalizeData(element.dataset[key]);
        });
        return attributes;
    },
    getDataAttribute (element, key) {
        return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
    },
    offset (element) {
        const rect = element.getBoundingClientRect();
        return {
            top: rect.top + window.pageYOffset,
            left: rect.left + window.pageXOffset
        };
    },
    position (element) {
        return {
            top: element.offsetTop,
            left: element.offsetLeft
        };
    }
};
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): dom/selector-engine.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ const NODE_TEXT = 3;
const SelectorEngine = {
    find (selector, element = document.documentElement) {
        return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
    },
    findOne (selector, element = document.documentElement) {
        return Element.prototype.querySelector.call(element, selector);
    },
    children (element, selector) {
        return [].concat(...element.children).filter((child)=>child.matches(selector)
        );
    },
    parents (element, selector) {
        const parents = [];
        let ancestor = element.parentNode;
        while(ancestor && ancestor.nodeType === Node.ELEMENT_NODE && ancestor.nodeType !== NODE_TEXT){
            if (ancestor.matches(selector)) parents.push(ancestor);
            ancestor = ancestor.parentNode;
        }
        return parents;
    },
    prev (element, selector) {
        let previous = element.previousElementSibling;
        while(previous){
            if (previous.matches(selector)) return [
                previous
            ];
            previous = previous.previousElementSibling;
        }
        return [];
    },
    next (element, selector) {
        let next = element.nextElementSibling;
        while(next){
            if (next.matches(selector)) return [
                next
            ];
            next = next.nextElementSibling;
        }
        return [];
    },
    focusableChildren (element) {
        const focusables = [
            'a',
            'button',
            'input',
            'textarea',
            'select',
            'details',
            '[tabindex]',
            '[contenteditable="true"]'
        ].map((selector)=>`${selector}:not([tabindex^="-"])`
        ).join(', ');
        return this.find(focusables, element).filter((el)=>!isDisabled(el) && isVisible(el)
        );
    }
};
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): carousel.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */ const NAME$b = 'carousel';
const DATA_KEY$a = 'bs.carousel';
const EVENT_KEY$a = `.${DATA_KEY$a}`;
const DATA_API_KEY$6 = '.data-api';
const ARROW_LEFT_KEY = 'ArrowLeft';
const ARROW_RIGHT_KEY = 'ArrowRight';
const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch
const SWIPE_THRESHOLD = 40;
const Default$a = {
    interval: 5000,
    keyboard: true,
    slide: false,
    pause: 'hover',
    wrap: true,
    touch: true
};
const DefaultType$a = {
    interval: '(number|boolean)',
    keyboard: 'boolean',
    slide: '(boolean|string)',
    pause: '(string|boolean)',
    wrap: 'boolean',
    touch: 'boolean'
};
const ORDER_NEXT = 'next';
const ORDER_PREV = 'prev';
const DIRECTION_LEFT = 'left';
const DIRECTION_RIGHT = 'right';
const KEY_TO_DIRECTION = {
    [ARROW_LEFT_KEY]: DIRECTION_RIGHT,
    [ARROW_RIGHT_KEY]: DIRECTION_LEFT
};
const EVENT_SLIDE = `slide${EVENT_KEY$a}`;
const EVENT_SLID = `slid${EVENT_KEY$a}`;
const EVENT_KEYDOWN = `keydown${EVENT_KEY$a}`;
const EVENT_MOUSEENTER = `mouseenter${EVENT_KEY$a}`;
const EVENT_MOUSELEAVE = `mouseleave${EVENT_KEY$a}`;
const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$a}`;
const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$a}`;
const EVENT_TOUCHEND = `touchend${EVENT_KEY$a}`;
const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$a}`;
const EVENT_POINTERUP = `pointerup${EVENT_KEY$a}`;
const EVENT_DRAG_START = `dragstart${EVENT_KEY$a}`;
const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$a}${DATA_API_KEY$6}`;
const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
const CLASS_NAME_CAROUSEL = 'carousel';
const CLASS_NAME_ACTIVE$2 = 'active';
const CLASS_NAME_SLIDE = 'slide';
const CLASS_NAME_END = 'carousel-item-end';
const CLASS_NAME_START = 'carousel-item-start';
const CLASS_NAME_NEXT = 'carousel-item-next';
const CLASS_NAME_PREV = 'carousel-item-prev';
const CLASS_NAME_POINTER_EVENT = 'pointer-event';
const SELECTOR_ACTIVE$1 = '.active';
const SELECTOR_ACTIVE_ITEM = '.active.carousel-item';
const SELECTOR_ITEM = '.carousel-item';
const SELECTOR_ITEM_IMG = '.carousel-item img';
const SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev';
const SELECTOR_INDICATORS = '.carousel-indicators';
const SELECTOR_INDICATOR = '[data-bs-target]';
const SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';
const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
const POINTER_TYPE_TOUCH = 'touch';
const POINTER_TYPE_PEN = 'pen';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */ class Carousel extends BaseComponent {
    static get Default() {
        return Default$a;
    }
    static get NAME() {
        return NAME$b;
    }
    next() {
        this._slide(ORDER_NEXT);
    }
    nextWhenVisible() {
        // Don't call next when the page isn't visible
        // or the carousel or its parent isn't visible
        if (!document.hidden && isVisible(this._element)) this.next();
    }
    prev() {
        this._slide(ORDER_PREV);
    }
    pause(event) {
        if (!event) this._isPaused = true;
        if (SelectorEngine.findOne(SELECTOR_NEXT_PREV, this._element)) {
            triggerTransitionEnd(this._element);
            this.cycle(true);
        }
        clearInterval(this._interval);
        this._interval = null;
    }
    cycle(event) {
        if (!event) this._isPaused = false;
        if (this._interval) {
            clearInterval(this._interval);
            this._interval = null;
        }
        if (this._config && this._config.interval && !this._isPaused) {
            this._updateInterval();
            this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
        }
    }
    to(index) {
        this._activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
        const activeIndex = this._getItemIndex(this._activeElement);
        if (index > this._items.length - 1 || index < 0) return;
        if (this._isSliding) {
            EventHandler.one(this._element, EVENT_SLID, ()=>this.to(index)
            );
            return;
        }
        if (activeIndex === index) {
            this.pause();
            this.cycle();
            return;
        }
        const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
        this._slide(order, this._items[index]);
    }
    _getConfig(config) {
        config = {
            ...Default$a,
            ...Manipulator.getDataAttributes(this._element),
            ...typeof config === 'object' ? config : {}
        };
        typeCheckConfig(NAME$b, config, DefaultType$a);
        return config;
    }
    _handleSwipe() {
        const absDeltax = Math.abs(this.touchDeltaX);
        if (absDeltax <= SWIPE_THRESHOLD) return;
        const direction = absDeltax / this.touchDeltaX;
        this.touchDeltaX = 0;
        if (!direction) return;
        this._slide(direction > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT);
    }
    _addEventListeners() {
        if (this._config.keyboard) EventHandler.on(this._element, EVENT_KEYDOWN, (event)=>this._keydown(event)
        );
        if (this._config.pause === 'hover') {
            EventHandler.on(this._element, EVENT_MOUSEENTER, (event)=>this.pause(event)
            );
            EventHandler.on(this._element, EVENT_MOUSELEAVE, (event)=>this.cycle(event)
            );
        }
        if (this._config.touch && this._touchSupported) this._addTouchEventListeners();
    }
    _addTouchEventListeners() {
        const hasPointerPenTouch = (event)=>{
            return this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
        };
        const start = (event)=>{
            if (hasPointerPenTouch(event)) this.touchStartX = event.clientX;
            else if (!this._pointerEvent) this.touchStartX = event.touches[0].clientX;
        };
        const move = (event)=>{
            // ensure swiping with one touch and not pinching
            this.touchDeltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this.touchStartX;
        };
        const end = (event1)=>{
            if (hasPointerPenTouch(event1)) this.touchDeltaX = event1.clientX - this.touchStartX;
            this._handleSwipe();
            if (this._config.pause === 'hover') {
                // If it's a touch-enabled device, mouseenter/leave are fired as
                // part of the mouse compatibility events on first tap - the carousel
                // would stop cycling until user tapped out of it;
                // here, we listen for touchend, explicitly pause the carousel
                // (as if it's the second time we tap on it, mouseenter compat event
                // is NOT fired) and after a timeout (to allow for mouse compatibility
                // events to fire) we explicitly restart cycling
                this.pause();
                if (this.touchTimeout) clearTimeout(this.touchTimeout);
                this.touchTimeout = setTimeout((event)=>this.cycle(event)
                , TOUCHEVENT_COMPAT_WAIT + this._config.interval);
            }
        };
        SelectorEngine.find(SELECTOR_ITEM_IMG, this._element).forEach((itemImg)=>{
            EventHandler.on(itemImg, EVENT_DRAG_START, (event)=>event.preventDefault()
            );
        });
        if (this._pointerEvent) {
            EventHandler.on(this._element, EVENT_POINTERDOWN, (event)=>start(event)
            );
            EventHandler.on(this._element, EVENT_POINTERUP, (event)=>end(event)
            );
            this._element.classList.add(CLASS_NAME_POINTER_EVENT);
        } else {
            EventHandler.on(this._element, EVENT_TOUCHSTART, (event)=>start(event)
            );
            EventHandler.on(this._element, EVENT_TOUCHMOVE, (event)=>move(event)
            );
            EventHandler.on(this._element, EVENT_TOUCHEND, (event)=>end(event)
            );
        }
    }
    _keydown(event) {
        if (/input|textarea/i.test(event.target.tagName)) return;
        const direction = KEY_TO_DIRECTION[event.key];
        if (direction) {
            event.preventDefault();
            this._slide(direction);
        }
    }
    _getItemIndex(element) {
        this._items = element && element.parentNode ? SelectorEngine.find(SELECTOR_ITEM, element.parentNode) : [];
        return this._items.indexOf(element);
    }
    _getItemByOrder(order, activeElement) {
        const isNext = order === ORDER_NEXT;
        return getNextActiveElement(this._items, activeElement, isNext, this._config.wrap);
    }
    _triggerSlideEvent(relatedTarget, eventDirectionName) {
        const targetIndex = this._getItemIndex(relatedTarget);
        const fromIndex = this._getItemIndex(SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element));
        return EventHandler.trigger(this._element, EVENT_SLIDE, {
            relatedTarget,
            direction: eventDirectionName,
            from: fromIndex,
            to: targetIndex
        });
    }
    _setActiveIndicatorElement(element) {
        if (this._indicatorsElement) {
            const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE$1, this._indicatorsElement);
            activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
            activeIndicator.removeAttribute('aria-current');
            const indicators = SelectorEngine.find(SELECTOR_INDICATOR, this._indicatorsElement);
            for(let i = 0; i < indicators.length; i++)if (Number.parseInt(indicators[i].getAttribute('data-bs-slide-to'), 10) === this._getItemIndex(element)) {
                indicators[i].classList.add(CLASS_NAME_ACTIVE$2);
                indicators[i].setAttribute('aria-current', 'true');
                break;
            }
        }
    }
    _updateInterval() {
        const element = this._activeElement || SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
        if (!element) return;
        const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);
        if (elementInterval) {
            this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
            this._config.interval = elementInterval;
        } else this._config.interval = this._config.defaultInterval || this._config.interval;
    }
    _slide(directionOrOrder, element) {
        const order = this._directionToOrder(directionOrOrder);
        const activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
        const activeElementIndex = this._getItemIndex(activeElement);
        const nextElement = element || this._getItemByOrder(order, activeElement);
        const nextElementIndex = this._getItemIndex(nextElement);
        const isCycling = Boolean(this._interval);
        const isNext = order === ORDER_NEXT;
        const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
        const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
        const eventDirectionName = this._orderToDirection(order);
        if (nextElement && nextElement.classList.contains(CLASS_NAME_ACTIVE$2)) {
            this._isSliding = false;
            return;
        }
        if (this._isSliding) return;
        const slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);
        if (slideEvent.defaultPrevented) return;
        if (!activeElement || !nextElement) // Some weirdness is happening, so we bail
        return;
        this._isSliding = true;
        if (isCycling) this.pause();
        this._setActiveIndicatorElement(nextElement);
        this._activeElement = nextElement;
        const triggerSlidEvent = ()=>{
            EventHandler.trigger(this._element, EVENT_SLID, {
                relatedTarget: nextElement,
                direction: eventDirectionName,
                from: activeElementIndex,
                to: nextElementIndex
            });
        };
        if (this._element.classList.contains(CLASS_NAME_SLIDE)) {
            nextElement.classList.add(orderClassName);
            reflow(nextElement);
            activeElement.classList.add(directionalClassName);
            nextElement.classList.add(directionalClassName);
            const completeCallBack = ()=>{
                nextElement.classList.remove(directionalClassName, orderClassName);
                nextElement.classList.add(CLASS_NAME_ACTIVE$2);
                activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
                this._isSliding = false;
                setTimeout(triggerSlidEvent, 0);
            };
            this._queueCallback(completeCallBack, activeElement, true);
        } else {
            activeElement.classList.remove(CLASS_NAME_ACTIVE$2);
            nextElement.classList.add(CLASS_NAME_ACTIVE$2);
            this._isSliding = false;
            triggerSlidEvent();
        }
        if (isCycling) this.cycle();
    }
    _directionToOrder(direction) {
        if (![
            DIRECTION_RIGHT,
            DIRECTION_LEFT
        ].includes(direction)) return direction;
        if (isRTL()) return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
        return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
    }
    _orderToDirection(order) {
        if (![
            ORDER_NEXT,
            ORDER_PREV
        ].includes(order)) return order;
        if (isRTL()) return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
        return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
    }
    static carouselInterface(element, config) {
        const data = Carousel.getOrCreateInstance(element, config);
        let { _config  } = data;
        if (typeof config === 'object') _config = {
            ..._config,
            ...config
        };
        const action = typeof config === 'string' ? config : _config.slide;
        if (typeof config === 'number') data.to(config);
        else if (typeof action === 'string') {
            if (typeof data[action] === 'undefined') throw new TypeError(`No method named "${action}"`);
            data[action]();
        } else if (_config.interval && _config.ride) {
            data.pause();
            data.cycle();
        }
    }
    static jQueryInterface(config) {
        return this.each(function() {
            Carousel.carouselInterface(this, config);
        });
    }
    static dataApiClickHandler(event) {
        const target = getElementFromSelector(this);
        if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) return;
        const config = {
            ...Manipulator.getDataAttributes(target),
            ...Manipulator.getDataAttributes(this)
        };
        const slideIndex = this.getAttribute('data-bs-slide-to');
        if (slideIndex) config.interval = false;
        Carousel.carouselInterface(target, config);
        if (slideIndex) Carousel.getInstance(target).to(slideIndex);
        event.preventDefault();
    }
    constructor(element, config){
        super(element);
        this._items = null;
        this._interval = null;
        this._activeElement = null;
        this._isPaused = false;
        this._isSliding = false;
        this.touchTimeout = null;
        this.touchStartX = 0;
        this.touchDeltaX = 0;
        this._config = this._getConfig(config);
        this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
        this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
        this._pointerEvent = Boolean(window.PointerEvent);
        this._addEventListeners();
    }
}
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */ EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler);
EventHandler.on(window, EVENT_LOAD_DATA_API$2, ()=>{
    const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
    for(let i = 0, len = carousels.length; i < len; i++)Carousel.carouselInterface(carousels[i], Carousel.getInstance(carousels[i]));
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Carousel to jQuery only if jQuery is present
 */ defineJQueryPlugin(Carousel);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): collapse.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */ const NAME$a = 'collapse';
const DATA_KEY$9 = 'bs.collapse';
const EVENT_KEY$9 = `.${DATA_KEY$9}`;
const DATA_API_KEY$5 = '.data-api';
const Default$9 = {
    toggle: true,
    parent: null
};
const DefaultType$9 = {
    toggle: 'boolean',
    parent: '(null|element)'
};
const EVENT_SHOW$5 = `show${EVENT_KEY$9}`;
const EVENT_SHOWN$5 = `shown${EVENT_KEY$9}`;
const EVENT_HIDE$5 = `hide${EVENT_KEY$9}`;
const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$9}`;
const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$9}${DATA_API_KEY$5}`;
const CLASS_NAME_SHOW$7 = 'show';
const CLASS_NAME_COLLAPSE = 'collapse';
const CLASS_NAME_COLLAPSING = 'collapsing';
const CLASS_NAME_COLLAPSED = 'collapsed';
const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
const CLASS_NAME_HORIZONTAL = 'collapse-horizontal';
const WIDTH = 'width';
const HEIGHT = 'height';
const SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';
const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */ class Collapse extends BaseComponent {
    static get Default() {
        return Default$9;
    }
    static get NAME() {
        return NAME$a;
    }
    toggle() {
        if (this._isShown()) this.hide();
        else this.show();
    }
    show() {
        if (this._isTransitioning || this._isShown()) return;
        let actives = [];
        let activesData;
        if (this._config.parent) {
            const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
            actives = SelectorEngine.find(SELECTOR_ACTIVES, this._config.parent).filter((elem)=>!children.includes(elem)
            ); // remove children if greater depth
        }
        const container = SelectorEngine.findOne(this._selector);
        if (actives.length) {
            const tempActiveData = actives.find((elem)=>container !== elem
            );
            activesData = tempActiveData ? Collapse.getInstance(tempActiveData) : null;
            if (activesData && activesData._isTransitioning) return;
        }
        const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$5);
        if (startEvent.defaultPrevented) return;
        actives.forEach((elemActive)=>{
            if (container !== elemActive) Collapse.getOrCreateInstance(elemActive, {
                toggle: false
            }).hide();
            if (!activesData) Data.set(elemActive, DATA_KEY$9, null);
        });
        const dimension = this._getDimension();
        this._element.classList.remove(CLASS_NAME_COLLAPSE);
        this._element.classList.add(CLASS_NAME_COLLAPSING);
        this._element.style[dimension] = 0;
        this._addAriaAndCollapsedClass(this._triggerArray, true);
        this._isTransitioning = true;
        const complete = ()=>{
            this._isTransitioning = false;
            this._element.classList.remove(CLASS_NAME_COLLAPSING);
            this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
            this._element.style[dimension] = '';
            EventHandler.trigger(this._element, EVENT_SHOWN$5);
        };
        const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
        const scrollSize = `scroll${capitalizedDimension}`;
        this._queueCallback(complete, this._element, true);
        this._element.style[dimension] = `${this._element[scrollSize]}px`;
    }
    hide() {
        if (this._isTransitioning || !this._isShown()) return;
        const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$5);
        if (startEvent.defaultPrevented) return;
        const dimension = this._getDimension();
        this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
        reflow(this._element);
        this._element.classList.add(CLASS_NAME_COLLAPSING);
        this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
        const triggerArrayLength = this._triggerArray.length;
        for(let i = 0; i < triggerArrayLength; i++){
            const trigger = this._triggerArray[i];
            const elem = getElementFromSelector(trigger);
            if (elem && !this._isShown(elem)) this._addAriaAndCollapsedClass([
                trigger
            ], false);
        }
        this._isTransitioning = true;
        const complete = ()=>{
            this._isTransitioning = false;
            this._element.classList.remove(CLASS_NAME_COLLAPSING);
            this._element.classList.add(CLASS_NAME_COLLAPSE);
            EventHandler.trigger(this._element, EVENT_HIDDEN$5);
        };
        this._element.style[dimension] = '';
        this._queueCallback(complete, this._element, true);
    }
    _isShown(element = this._element) {
        return element.classList.contains(CLASS_NAME_SHOW$7);
    }
    _getConfig(config) {
        config = {
            ...Default$9,
            ...Manipulator.getDataAttributes(this._element),
            ...config
        };
        config.toggle = Boolean(config.toggle); // Coerce string values
        config.parent = getElement(config.parent);
        typeCheckConfig(NAME$a, config, DefaultType$9);
        return config;
    }
    _getDimension() {
        return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
    }
    _initializeChildren() {
        if (!this._config.parent) return;
        const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
        SelectorEngine.find(SELECTOR_DATA_TOGGLE$4, this._config.parent).filter((elem)=>!children.includes(elem)
        ).forEach((element)=>{
            const selected = getElementFromSelector(element);
            if (selected) this._addAriaAndCollapsedClass([
                element
            ], this._isShown(selected));
        });
    }
    _addAriaAndCollapsedClass(triggerArray, isOpen) {
        if (!triggerArray.length) return;
        triggerArray.forEach((elem)=>{
            if (isOpen) elem.classList.remove(CLASS_NAME_COLLAPSED);
            else elem.classList.add(CLASS_NAME_COLLAPSED);
            elem.setAttribute('aria-expanded', isOpen);
        });
    }
    static jQueryInterface(config) {
        return this.each(function() {
            const _config = {};
            if (typeof config === 'string' && /show|hide/.test(config)) _config.toggle = false;
            const data = Collapse.getOrCreateInstance(this, _config);
            if (typeof config === 'string') {
                if (typeof data[config] === 'undefined') throw new TypeError(`No method named "${config}"`);
                data[config]();
            }
        });
    }
    constructor(element, config){
        super(element);
        this._isTransitioning = false;
        this._config = this._getConfig(config);
        this._triggerArray = [];
        const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
        for(let i = 0, len = toggleList.length; i < len; i++){
            const elem = toggleList[i];
            const selector = getSelectorFromElement(elem);
            const filterElement = SelectorEngine.find(selector).filter((foundElem)=>foundElem === this._element
            );
            if (selector !== null && filterElement.length) {
                this._selector = selector;
                this._triggerArray.push(elem);
            }
        }
        this._initializeChildren();
        if (!this._config.parent) this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
        if (this._config.toggle) this.toggle();
    }
}
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */ EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {
    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
    if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') event.preventDefault();
    const selector = getSelectorFromElement(this);
    const selectorElements = SelectorEngine.find(selector);
    selectorElements.forEach((element)=>{
        Collapse.getOrCreateInstance(element, {
            toggle: false
        }).toggle();
    });
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Collapse to jQuery only if jQuery is present
 */ defineJQueryPlugin(Collapse);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): dropdown.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */ const NAME$9 = 'dropdown';
const DATA_KEY$8 = 'bs.dropdown';
const EVENT_KEY$8 = `.${DATA_KEY$8}`;
const DATA_API_KEY$4 = '.data-api';
const ESCAPE_KEY$2 = 'Escape';
const SPACE_KEY = 'Space';
const TAB_KEY$1 = 'Tab';
const ARROW_UP_KEY = 'ArrowUp';
const ARROW_DOWN_KEY = 'ArrowDown';
const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button
const REGEXP_KEYDOWN = new RegExp(`${ARROW_UP_KEY}|${ARROW_DOWN_KEY}|${ESCAPE_KEY$2}`);
const EVENT_HIDE$4 = `hide${EVENT_KEY$8}`;
const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$8}`;
const EVENT_SHOW$4 = `show${EVENT_KEY$8}`;
const EVENT_SHOWN$4 = `shown${EVENT_KEY$8}`;
const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$8}${DATA_API_KEY$4}`;
const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$8}${DATA_API_KEY$4}`;
const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$8}${DATA_API_KEY$4}`;
const CLASS_NAME_SHOW$6 = 'show';
const CLASS_NAME_DROPUP = 'dropup';
const CLASS_NAME_DROPEND = 'dropend';
const CLASS_NAME_DROPSTART = 'dropstart';
const CLASS_NAME_NAVBAR = 'navbar';
const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]';
const SELECTOR_MENU = '.dropdown-menu';
const SELECTOR_NAVBAR_NAV = '.navbar-nav';
const SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';
const PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';
const PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';
const PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';
const PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';
const PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';
const PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';
const Default$8 = {
    offset: [
        0,
        2
    ],
    boundary: 'clippingParents',
    reference: 'toggle',
    display: 'dynamic',
    popperConfig: null,
    autoClose: true
};
const DefaultType$8 = {
    offset: '(array|string|function)',
    boundary: '(string|element)',
    reference: '(string|element|object)',
    display: 'string',
    popperConfig: '(null|object|function)',
    autoClose: '(boolean|string)'
};
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */ class Dropdown extends BaseComponent {
    static get Default() {
        return Default$8;
    }
    static get DefaultType() {
        return DefaultType$8;
    }
    static get NAME() {
        return NAME$9;
    }
    toggle() {
        return this._isShown() ? this.hide() : this.show();
    }
    show() {
        if (isDisabled(this._element) || this._isShown(this._menu)) return;
        const relatedTarget = {
            relatedTarget: this._element
        };
        const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, relatedTarget);
        if (showEvent.defaultPrevented) return;
        const parent = Dropdown.getParentFromElement(this._element); // Totally disable Popper for Dropdowns in Navbar
        if (this._inNavbar) Manipulator.setDataAttribute(this._menu, 'popper', 'none');
        else this._createPopper(parent);
         // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
        if ('ontouchstart' in document.documentElement && !parent.closest(SELECTOR_NAVBAR_NAV)) [].concat(...document.body.children).forEach((elem)=>EventHandler.on(elem, 'mouseover', noop)
        );
        this._element.focus();
        this._element.setAttribute('aria-expanded', true);
        this._menu.classList.add(CLASS_NAME_SHOW$6);
        this._element.classList.add(CLASS_NAME_SHOW$6);
        EventHandler.trigger(this._element, EVENT_SHOWN$4, relatedTarget);
    }
    hide() {
        if (isDisabled(this._element) || !this._isShown(this._menu)) return;
        const relatedTarget = {
            relatedTarget: this._element
        };
        this._completeHide(relatedTarget);
    }
    dispose() {
        if (this._popper) this._popper.destroy();
        super.dispose();
    }
    update() {
        this._inNavbar = this._detectNavbar();
        if (this._popper) this._popper.update();
    }
    _completeHide(relatedTarget) {
        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4, relatedTarget);
        if (hideEvent.defaultPrevented) return;
         // If this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support
        if ('ontouchstart' in document.documentElement) [].concat(...document.body.children).forEach((elem)=>EventHandler.off(elem, 'mouseover', noop)
        );
        if (this._popper) this._popper.destroy();
        this._menu.classList.remove(CLASS_NAME_SHOW$6);
        this._element.classList.remove(CLASS_NAME_SHOW$6);
        this._element.setAttribute('aria-expanded', 'false');
        Manipulator.removeDataAttribute(this._menu, 'popper');
        EventHandler.trigger(this._element, EVENT_HIDDEN$4, relatedTarget);
    }
    _getConfig(config) {
        config = {
            ...this.constructor.Default,
            ...Manipulator.getDataAttributes(this._element),
            ...config
        };
        typeCheckConfig(NAME$9, config, this.constructor.DefaultType);
        if (typeof config.reference === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') // Popper virtual elements require a getBoundingClientRect method
        throw new TypeError(`${NAME$9.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
        return config;
    }
    _createPopper(parent) {
        if (typeof _core === 'undefined') throw new TypeError('Bootstrap\'s dropdowns require Popper (https://popper.js.org)');
        let referenceElement = this._element;
        if (this._config.reference === 'parent') referenceElement = parent;
        else if (isElement(this._config.reference)) referenceElement = getElement(this._config.reference);
        else if (typeof this._config.reference === 'object') referenceElement = this._config.reference;
        const popperConfig = this._getPopperConfig();
        const isDisplayStatic = popperConfig.modifiers.find((modifier)=>modifier.name === 'applyStyles' && modifier.enabled === false
        );
        this._popper = _core.createPopper(referenceElement, this._menu, popperConfig);
        if (isDisplayStatic) Manipulator.setDataAttribute(this._menu, 'popper', 'static');
    }
    _isShown(element = this._element) {
        return element.classList.contains(CLASS_NAME_SHOW$6);
    }
    _getMenuElement() {
        return SelectorEngine.next(this._element, SELECTOR_MENU)[0];
    }
    _getPlacement() {
        const parentDropdown = this._element.parentNode;
        if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) return PLACEMENT_RIGHT;
        if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) return PLACEMENT_LEFT;
         // We need to trim the value because custom properties can also include spaces
        const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';
        if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
        return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
    }
    _detectNavbar() {
        return this._element.closest(`.${CLASS_NAME_NAVBAR}`) !== null;
    }
    _getOffset() {
        const { offset  } = this._config;
        if (typeof offset === 'string') return offset.split(',').map((val)=>Number.parseInt(val, 10)
        );
        if (typeof offset === 'function') return (popperData)=>offset(popperData, this._element)
        ;
        return offset;
    }
    _getPopperConfig() {
        const defaultBsPopperConfig = {
            placement: this._getPlacement(),
            modifiers: [
                {
                    name: 'preventOverflow',
                    options: {
                        boundary: this._config.boundary
                    }
                },
                {
                    name: 'offset',
                    options: {
                        offset: this._getOffset()
                    }
                }
            ]
        }; // Disable Popper if we have a static display
        if (this._config.display === 'static') defaultBsPopperConfig.modifiers = [
            {
                name: 'applyStyles',
                enabled: false
            }
        ];
        return {
            ...defaultBsPopperConfig,
            ...typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig
        };
    }
    _selectMenuItem({ key , target  }) {
        const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(isVisible);
        if (!items.length) return;
         // if target isn't included in items (e.g. when expanding the dropdown)
        // allow cycling to get the last item in case key equals ARROW_UP_KEY
        getNextActiveElement(items, target, key === ARROW_DOWN_KEY, !items.includes(target)).focus();
    }
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Dropdown.getOrCreateInstance(this, config);
            if (typeof config !== 'string') return;
            if (typeof data[config] === 'undefined') throw new TypeError(`No method named "${config}"`);
            data[config]();
        });
    }
    static clearMenus(event) {
        if (event && (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1)) return;
        const toggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE$3);
        for(let i = 0, len = toggles.length; i < len; i++){
            const context = Dropdown.getInstance(toggles[i]);
            if (!context || context._config.autoClose === false) continue;
            if (!context._isShown()) continue;
            const relatedTarget = {
                relatedTarget: context._element
            };
            if (event) {
                const composedPath = event.composedPath();
                const isMenuTarget = composedPath.includes(context._menu);
                if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) continue;
                 // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu
                if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) continue;
                if (event.type === 'click') relatedTarget.clickEvent = event;
            }
            context._completeHide(relatedTarget);
        }
    }
    static getParentFromElement(element) {
        return getElementFromSelector(element) || element.parentNode;
    }
    static dataApiKeydownHandler(event) {
        // If not input/textarea:
        //  - And not a key in REGEXP_KEYDOWN => not a dropdown command
        // If input/textarea:
        //  - If space key => not a dropdown command
        //  - If key is other than escape
        //    - If key is not up or down => not a dropdown command
        //    - If trigger inside the menu => not a dropdown command
        if (/input|textarea/i.test(event.target.tagName) ? event.key === SPACE_KEY || event.key !== ESCAPE_KEY$2 && (event.key !== ARROW_DOWN_KEY && event.key !== ARROW_UP_KEY || event.target.closest(SELECTOR_MENU)) : !REGEXP_KEYDOWN.test(event.key)) return;
        const isActive = this.classList.contains(CLASS_NAME_SHOW$6);
        if (!isActive && event.key === ESCAPE_KEY$2) return;
        event.preventDefault();
        event.stopPropagation();
        if (isDisabled(this)) return;
        const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0];
        const instance = Dropdown.getOrCreateInstance(getToggleButton);
        if (event.key === ESCAPE_KEY$2) {
            instance.hide();
            return;
        }
        if (event.key === ARROW_UP_KEY || event.key === ARROW_DOWN_KEY) {
            if (!isActive) instance.show();
            instance._selectMenuItem(event);
            return;
        }
        if (!isActive || event.key === SPACE_KEY) Dropdown.clearMenus();
    }
    constructor(element, config){
        super(element);
        this._popper = null;
        this._config = this._getConfig(config);
        this._menu = this._getMenuElement();
        this._inNavbar = this._detectNavbar();
    }
}
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */ EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
    event.preventDefault();
    Dropdown.getOrCreateInstance(this).toggle();
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Dropdown to jQuery only if jQuery is present
 */ defineJQueryPlugin(Dropdown);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): util/scrollBar.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ const SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
const SELECTOR_STICKY_CONTENT = '.sticky-top';
class ScrollBarHelper {
    getWidth() {
        // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
        const documentWidth = document.documentElement.clientWidth;
        return Math.abs(window.innerWidth - documentWidth);
    }
    hide() {
        const width = this.getWidth();
        this._disableOverFlow(); // give padding to element to balance the hidden scrollbar width
        this._setElementAttributes(this._element, 'paddingRight', (calculatedValue)=>calculatedValue + width
        ); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth
        this._setElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight', (calculatedValue)=>calculatedValue + width
        );
        this._setElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight', (calculatedValue)=>calculatedValue - width
        );
    }
    _disableOverFlow() {
        this._saveInitialAttribute(this._element, 'overflow');
        this._element.style.overflow = 'hidden';
    }
    _setElementAttributes(selector, styleProp, callback) {
        const scrollbarWidth = this.getWidth();
        const manipulationCallBack = (element)=>{
            if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) return;
            this._saveInitialAttribute(element, styleProp);
            const calculatedValue = window.getComputedStyle(element)[styleProp];
            element.style[styleProp] = `${callback(Number.parseFloat(calculatedValue))}px`;
        };
        this._applyManipulationCallback(selector, manipulationCallBack);
    }
    reset() {
        this._resetElementAttributes(this._element, 'overflow');
        this._resetElementAttributes(this._element, 'paddingRight');
        this._resetElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight');
        this._resetElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight');
    }
    _saveInitialAttribute(element, styleProp) {
        const actualValue = element.style[styleProp];
        if (actualValue) Manipulator.setDataAttribute(element, styleProp, actualValue);
    }
    _resetElementAttributes(selector, styleProp) {
        const manipulationCallBack = (element)=>{
            const value = Manipulator.getDataAttribute(element, styleProp);
            if (typeof value === 'undefined') element.style.removeProperty(styleProp);
            else {
                Manipulator.removeDataAttribute(element, styleProp);
                element.style[styleProp] = value;
            }
        };
        this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _applyManipulationCallback(selector, callBack) {
        if (isElement(selector)) callBack(selector);
        else SelectorEngine.find(selector, this._element).forEach(callBack);
    }
    isOverflowing() {
        return this.getWidth() > 0;
    }
    constructor(){
        this._element = document.body;
    }
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): util/backdrop.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ const Default$7 = {
    className: 'modal-backdrop',
    isVisible: true,
    // if false, we use the backdrop helper without adding any element to the dom
    isAnimated: false,
    rootElement: 'body',
    // give the choice to place backdrop under different elements
    clickCallback: null
};
const DefaultType$7 = {
    className: 'string',
    isVisible: 'boolean',
    isAnimated: 'boolean',
    rootElement: '(element|string)',
    clickCallback: '(function|null)'
};
const NAME$8 = 'backdrop';
const CLASS_NAME_FADE$4 = 'fade';
const CLASS_NAME_SHOW$5 = 'show';
const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$8}`;
class Backdrop {
    show(callback) {
        if (!this._config.isVisible) {
            execute(callback);
            return;
        }
        this._append();
        if (this._config.isAnimated) reflow(this._getElement());
        this._getElement().classList.add(CLASS_NAME_SHOW$5);
        this._emulateAnimation(()=>{
            execute(callback);
        });
    }
    hide(callback) {
        if (!this._config.isVisible) {
            execute(callback);
            return;
        }
        this._getElement().classList.remove(CLASS_NAME_SHOW$5);
        this._emulateAnimation(()=>{
            this.dispose();
            execute(callback);
        });
    }
    _getElement() {
        if (!this._element) {
            const backdrop = document.createElement('div');
            backdrop.className = this._config.className;
            if (this._config.isAnimated) backdrop.classList.add(CLASS_NAME_FADE$4);
            this._element = backdrop;
        }
        return this._element;
    }
    _getConfig(config) {
        config = {
            ...Default$7,
            ...typeof config === 'object' ? config : {}
        }; // use getElement() with the default "body" to get a fresh Element on each instantiation
        config.rootElement = getElement(config.rootElement);
        typeCheckConfig(NAME$8, config, DefaultType$7);
        return config;
    }
    _append() {
        if (this._isAppended) return;
        this._config.rootElement.append(this._getElement());
        EventHandler.on(this._getElement(), EVENT_MOUSEDOWN, ()=>{
            execute(this._config.clickCallback);
        });
        this._isAppended = true;
    }
    dispose() {
        if (!this._isAppended) return;
        EventHandler.off(this._element, EVENT_MOUSEDOWN);
        this._element.remove();
        this._isAppended = false;
    }
    _emulateAnimation(callback) {
        executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
    }
    constructor(config){
        this._config = this._getConfig(config);
        this._isAppended = false;
        this._element = null;
    }
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): util/focustrap.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ const Default$6 = {
    trapElement: null,
    // The element to trap focus inside of
    autofocus: true
};
const DefaultType$6 = {
    trapElement: 'element',
    autofocus: 'boolean'
};
const NAME$7 = 'focustrap';
const DATA_KEY$7 = 'bs.focustrap';
const EVENT_KEY$7 = `.${DATA_KEY$7}`;
const EVENT_FOCUSIN$1 = `focusin${EVENT_KEY$7}`;
const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$7}`;
const TAB_KEY = 'Tab';
const TAB_NAV_FORWARD = 'forward';
const TAB_NAV_BACKWARD = 'backward';
class FocusTrap {
    activate() {
        const { trapElement , autofocus  } = this._config;
        if (this._isActive) return;
        if (autofocus) trapElement.focus();
        EventHandler.off(document, EVENT_KEY$7); // guard against infinite focus loop
        EventHandler.on(document, EVENT_FOCUSIN$1, (event)=>this._handleFocusin(event)
        );
        EventHandler.on(document, EVENT_KEYDOWN_TAB, (event)=>this._handleKeydown(event)
        );
        this._isActive = true;
    }
    deactivate() {
        if (!this._isActive) return;
        this._isActive = false;
        EventHandler.off(document, EVENT_KEY$7);
    }
    _handleFocusin(event) {
        const { target  } = event;
        const { trapElement  } = this._config;
        if (target === document || target === trapElement || trapElement.contains(target)) return;
        const elements = SelectorEngine.focusableChildren(trapElement);
        if (elements.length === 0) trapElement.focus();
        else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) elements[elements.length - 1].focus();
        else elements[0].focus();
    }
    _handleKeydown(event) {
        if (event.key !== TAB_KEY) return;
        this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
    }
    _getConfig(config) {
        config = {
            ...Default$6,
            ...typeof config === 'object' ? config : {}
        };
        typeCheckConfig(NAME$7, config, DefaultType$6);
        return config;
    }
    constructor(config){
        this._config = this._getConfig(config);
        this._isActive = false;
        this._lastTabNavDirection = null;
    }
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): modal.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */ const NAME$6 = 'modal';
const DATA_KEY$6 = 'bs.modal';
const EVENT_KEY$6 = `.${DATA_KEY$6}`;
const DATA_API_KEY$3 = '.data-api';
const ESCAPE_KEY$1 = 'Escape';
const Default$5 = {
    backdrop: true,
    keyboard: true,
    focus: true
};
const DefaultType$5 = {
    backdrop: '(boolean|string)',
    keyboard: 'boolean',
    focus: 'boolean'
};
const EVENT_HIDE$3 = `hide${EVENT_KEY$6}`;
const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$6}`;
const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$6}`;
const EVENT_SHOW$3 = `show${EVENT_KEY$6}`;
const EVENT_SHOWN$3 = `shown${EVENT_KEY$6}`;
const EVENT_RESIZE = `resize${EVENT_KEY$6}`;
const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$6}`;
const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$6}`;
const EVENT_MOUSEUP_DISMISS = `mouseup.dismiss${EVENT_KEY$6}`;
const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$6}`;
const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
const CLASS_NAME_OPEN = 'modal-open';
const CLASS_NAME_FADE$3 = 'fade';
const CLASS_NAME_SHOW$4 = 'show';
const CLASS_NAME_STATIC = 'modal-static';
const OPEN_SELECTOR$1 = '.modal.show';
const SELECTOR_DIALOG = '.modal-dialog';
const SELECTOR_MODAL_BODY = '.modal-body';
const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */ class Modal extends BaseComponent {
    static get Default() {
        return Default$5;
    }
    static get NAME() {
        return NAME$6;
    }
    toggle(relatedTarget) {
        return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
        if (this._isShown || this._isTransitioning) return;
        const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
            relatedTarget
        });
        if (showEvent.defaultPrevented) return;
        this._isShown = true;
        if (this._isAnimated()) this._isTransitioning = true;
        this._scrollBar.hide();
        document.body.classList.add(CLASS_NAME_OPEN);
        this._adjustDialog();
        this._setEscapeEvent();
        this._setResizeEvent();
        EventHandler.on(this._dialog, EVENT_MOUSEDOWN_DISMISS, ()=>{
            EventHandler.one(this._element, EVENT_MOUSEUP_DISMISS, (event)=>{
                if (event.target === this._element) this._ignoreBackdropClick = true;
            });
        });
        this._showBackdrop(()=>this._showElement(relatedTarget)
        );
    }
    hide() {
        if (!this._isShown || this._isTransitioning) return;
        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
        if (hideEvent.defaultPrevented) return;
        this._isShown = false;
        const isAnimated = this._isAnimated();
        if (isAnimated) this._isTransitioning = true;
        this._setEscapeEvent();
        this._setResizeEvent();
        this._focustrap.deactivate();
        this._element.classList.remove(CLASS_NAME_SHOW$4);
        EventHandler.off(this._element, EVENT_CLICK_DISMISS);
        EventHandler.off(this._dialog, EVENT_MOUSEDOWN_DISMISS);
        this._queueCallback(()=>this._hideModal()
        , this._element, isAnimated);
    }
    dispose() {
        [
            window,
            this._dialog
        ].forEach((htmlElement)=>EventHandler.off(htmlElement, EVENT_KEY$6)
        );
        this._backdrop.dispose();
        this._focustrap.deactivate();
        super.dispose();
    }
    handleUpdate() {
        this._adjustDialog();
    }
    _initializeBackDrop() {
        return new Backdrop({
            isVisible: Boolean(this._config.backdrop),
            // 'static' option will be translated to true, and booleans will keep their value
            isAnimated: this._isAnimated()
        });
    }
    _initializeFocusTrap() {
        return new FocusTrap({
            trapElement: this._element
        });
    }
    _getConfig(config) {
        config = {
            ...Default$5,
            ...Manipulator.getDataAttributes(this._element),
            ...typeof config === 'object' ? config : {}
        };
        typeCheckConfig(NAME$6, config, DefaultType$5);
        return config;
    }
    _showElement(relatedTarget) {
        const isAnimated = this._isAnimated();
        const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
        if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) // Don't move modal's DOM position
        document.body.append(this._element);
        this._element.style.display = 'block';
        this._element.removeAttribute('aria-hidden');
        this._element.setAttribute('aria-modal', true);
        this._element.setAttribute('role', 'dialog');
        this._element.scrollTop = 0;
        if (modalBody) modalBody.scrollTop = 0;
        if (isAnimated) reflow(this._element);
        this._element.classList.add(CLASS_NAME_SHOW$4);
        const transitionComplete = ()=>{
            if (this._config.focus) this._focustrap.activate();
            this._isTransitioning = false;
            EventHandler.trigger(this._element, EVENT_SHOWN$3, {
                relatedTarget
            });
        };
        this._queueCallback(transitionComplete, this._dialog, isAnimated);
    }
    _setEscapeEvent() {
        if (this._isShown) EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event)=>{
            if (this._config.keyboard && event.key === ESCAPE_KEY$1) {
                event.preventDefault();
                this.hide();
            } else if (!this._config.keyboard && event.key === ESCAPE_KEY$1) this._triggerBackdropTransition();
        });
        else EventHandler.off(this._element, EVENT_KEYDOWN_DISMISS$1);
    }
    _setResizeEvent() {
        if (this._isShown) EventHandler.on(window, EVENT_RESIZE, ()=>this._adjustDialog()
        );
        else EventHandler.off(window, EVENT_RESIZE);
    }
    _hideModal() {
        this._element.style.display = 'none';
        this._element.setAttribute('aria-hidden', true);
        this._element.removeAttribute('aria-modal');
        this._element.removeAttribute('role');
        this._isTransitioning = false;
        this._backdrop.hide(()=>{
            document.body.classList.remove(CLASS_NAME_OPEN);
            this._resetAdjustments();
            this._scrollBar.reset();
            EventHandler.trigger(this._element, EVENT_HIDDEN$3);
        });
    }
    _showBackdrop(callback) {
        EventHandler.on(this._element, EVENT_CLICK_DISMISS, (event)=>{
            if (this._ignoreBackdropClick) {
                this._ignoreBackdropClick = false;
                return;
            }
            if (event.target !== event.currentTarget) return;
            if (this._config.backdrop === true) this.hide();
            else if (this._config.backdrop === 'static') this._triggerBackdropTransition();
        });
        this._backdrop.show(callback);
    }
    _isAnimated() {
        return this._element.classList.contains(CLASS_NAME_FADE$3);
    }
    _triggerBackdropTransition() {
        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
        if (hideEvent.defaultPrevented) return;
        const { classList , scrollHeight , style  } = this._element;
        const isModalOverflowing = scrollHeight > document.documentElement.clientHeight; // return if the following background transition hasn't yet completed
        if (!isModalOverflowing && style.overflowY === 'hidden' || classList.contains(CLASS_NAME_STATIC)) return;
        if (!isModalOverflowing) style.overflowY = 'hidden';
        classList.add(CLASS_NAME_STATIC);
        this._queueCallback(()=>{
            classList.remove(CLASS_NAME_STATIC);
            if (!isModalOverflowing) this._queueCallback(()=>{
                style.overflowY = '';
            }, this._dialog);
        }, this._dialog);
        this._element.focus();
    }
    // the following methods are used to handle overflowing modals
    // ----------------------------------------------------------------------
    _adjustDialog() {
        const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
        const scrollbarWidth = this._scrollBar.getWidth();
        const isBodyOverflowing = scrollbarWidth > 0;
        if (!isBodyOverflowing && isModalOverflowing && !isRTL() || isBodyOverflowing && !isModalOverflowing && isRTL()) this._element.style.paddingLeft = `${scrollbarWidth}px`;
        if (isBodyOverflowing && !isModalOverflowing && !isRTL() || !isBodyOverflowing && isModalOverflowing && isRTL()) this._element.style.paddingRight = `${scrollbarWidth}px`;
    }
    _resetAdjustments() {
        this._element.style.paddingLeft = '';
        this._element.style.paddingRight = '';
    }
    static jQueryInterface(config, relatedTarget) {
        return this.each(function() {
            const data = Modal.getOrCreateInstance(this, config);
            if (typeof config !== 'string') return;
            if (typeof data[config] === 'undefined') throw new TypeError(`No method named "${config}"`);
            data[config](relatedTarget);
        });
    }
    constructor(element, config){
        super(element);
        this._config = this._getConfig(config);
        this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
        this._backdrop = this._initializeBackDrop();
        this._focustrap = this._initializeFocusTrap();
        this._isShown = false;
        this._ignoreBackdropClick = false;
        this._isTransitioning = false;
        this._scrollBar = new ScrollBarHelper();
    }
}
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */ EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
    const target = getElementFromSelector(this);
    if ([
        'A',
        'AREA'
    ].includes(this.tagName)) event.preventDefault();
    EventHandler.one(target, EVENT_SHOW$3, (showEvent)=>{
        if (showEvent.defaultPrevented) // only register focus restorer if modal will actually get shown
        return;
        EventHandler.one(target, EVENT_HIDDEN$3, ()=>{
            if (isVisible(this)) this.focus();
        });
    }); // avoid conflict when clicking moddal toggler while another one is open
    const allReadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
    if (allReadyOpen) Modal.getInstance(allReadyOpen).hide();
    const data = Modal.getOrCreateInstance(target);
    data.toggle(this);
});
enableDismissTrigger(Modal);
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Modal to jQuery only if jQuery is present
 */ defineJQueryPlugin(Modal);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): offcanvas.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */ const NAME$5 = 'offcanvas';
const DATA_KEY$5 = 'bs.offcanvas';
const EVENT_KEY$5 = `.${DATA_KEY$5}`;
const DATA_API_KEY$2 = '.data-api';
const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$5}${DATA_API_KEY$2}`;
const ESCAPE_KEY = 'Escape';
const Default$4 = {
    backdrop: true,
    keyboard: true,
    scroll: false
};
const DefaultType$4 = {
    backdrop: 'boolean',
    keyboard: 'boolean',
    scroll: 'boolean'
};
const CLASS_NAME_SHOW$3 = 'show';
const CLASS_NAME_BACKDROP = 'offcanvas-backdrop';
const OPEN_SELECTOR = '.offcanvas.show';
const EVENT_SHOW$2 = `show${EVENT_KEY$5}`;
const EVENT_SHOWN$2 = `shown${EVENT_KEY$5}`;
const EVENT_HIDE$2 = `hide${EVENT_KEY$5}`;
const EVENT_HIDDEN$2 = `hidden${EVENT_KEY$5}`;
const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$5}${DATA_API_KEY$2}`;
const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$5}`;
const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */ class Offcanvas extends BaseComponent {
    static get NAME() {
        return NAME$5;
    }
    static get Default() {
        return Default$4;
    }
    toggle(relatedTarget) {
        return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
        if (this._isShown) return;
        const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$2, {
            relatedTarget
        });
        if (showEvent.defaultPrevented) return;
        this._isShown = true;
        this._element.style.visibility = 'visible';
        this._backdrop.show();
        if (!this._config.scroll) new ScrollBarHelper().hide();
        this._element.removeAttribute('aria-hidden');
        this._element.setAttribute('aria-modal', true);
        this._element.setAttribute('role', 'dialog');
        this._element.classList.add(CLASS_NAME_SHOW$3);
        const completeCallBack = ()=>{
            if (!this._config.scroll) this._focustrap.activate();
            EventHandler.trigger(this._element, EVENT_SHOWN$2, {
                relatedTarget
            });
        };
        this._queueCallback(completeCallBack, this._element, true);
    }
    hide() {
        if (!this._isShown) return;
        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$2);
        if (hideEvent.defaultPrevented) return;
        this._focustrap.deactivate();
        this._element.blur();
        this._isShown = false;
        this._element.classList.remove(CLASS_NAME_SHOW$3);
        this._backdrop.hide();
        const completeCallback = ()=>{
            this._element.setAttribute('aria-hidden', true);
            this._element.removeAttribute('aria-modal');
            this._element.removeAttribute('role');
            this._element.style.visibility = 'hidden';
            if (!this._config.scroll) new ScrollBarHelper().reset();
            EventHandler.trigger(this._element, EVENT_HIDDEN$2);
        };
        this._queueCallback(completeCallback, this._element, true);
    }
    dispose() {
        this._backdrop.dispose();
        this._focustrap.deactivate();
        super.dispose();
    }
    _getConfig(config) {
        config = {
            ...Default$4,
            ...Manipulator.getDataAttributes(this._element),
            ...typeof config === 'object' ? config : {}
        };
        typeCheckConfig(NAME$5, config, DefaultType$4);
        return config;
    }
    _initializeBackDrop() {
        return new Backdrop({
            className: CLASS_NAME_BACKDROP,
            isVisible: this._config.backdrop,
            isAnimated: true,
            rootElement: this._element.parentNode,
            clickCallback: ()=>this.hide()
        });
    }
    _initializeFocusTrap() {
        return new FocusTrap({
            trapElement: this._element
        });
    }
    _addEventListeners() {
        EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event)=>{
            if (this._config.keyboard && event.key === ESCAPE_KEY) this.hide();
        });
    }
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Offcanvas.getOrCreateInstance(this, config);
            if (typeof config !== 'string') return;
            if (data[config] === undefined || config.startsWith('_') || config === 'constructor') throw new TypeError(`No method named "${config}"`);
            data[config](this);
        });
    }
    constructor(element, config){
        super(element);
        this._config = this._getConfig(config);
        this._isShown = false;
        this._backdrop = this._initializeBackDrop();
        this._focustrap = this._initializeFocusTrap();
        this._addEventListeners();
    }
}
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */ EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
    const target = getElementFromSelector(this);
    if ([
        'A',
        'AREA'
    ].includes(this.tagName)) event.preventDefault();
    if (isDisabled(this)) return;
    EventHandler.one(target, EVENT_HIDDEN$2, ()=>{
        // focus on trigger when it is closed
        if (isVisible(this)) this.focus();
    }); // avoid conflict when clicking a toggler of an offcanvas, while another is open
    const allReadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
    if (allReadyOpen && allReadyOpen !== target) Offcanvas.getInstance(allReadyOpen).hide();
    const data = Offcanvas.getOrCreateInstance(target);
    data.toggle(this);
});
EventHandler.on(window, EVENT_LOAD_DATA_API$1, ()=>SelectorEngine.find(OPEN_SELECTOR).forEach((el)=>Offcanvas.getOrCreateInstance(el).show()
    )
);
enableDismissTrigger(Offcanvas);
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 */ defineJQueryPlugin(Offcanvas);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): util/sanitizer.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ const uriAttributes = new Set([
    'background',
    'cite',
    'href',
    'itemtype',
    'longdesc',
    'poster',
    'src',
    'xlink:href'
]);
const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
/**
 * A pattern that recognizes a commonly useful subset of URLs that are safe.
 *
 * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
 */ const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
/**
 * A pattern that matches safe data URLs. Only matches image, video and audio types.
 *
 * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
 */ const DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
const allowedAttribute = (attribute, allowedAttributeList)=>{
    const attributeName = attribute.nodeName.toLowerCase();
    if (allowedAttributeList.includes(attributeName)) {
        if (uriAttributes.has(attributeName)) return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));
        return true;
    }
    const regExp = allowedAttributeList.filter((attributeRegex)=>attributeRegex instanceof RegExp
    ); // Check if a regular expression validates the attribute.
    for(let i = 0, len = regExp.length; i < len; i++){
        if (regExp[i].test(attributeName)) return true;
    }
    return false;
};
const DefaultAllowlist = {
    // Global attributes allowed on any supplied element below.
    '*': [
        'class',
        'dir',
        'id',
        'lang',
        'role',
        ARIA_ATTRIBUTE_PATTERN
    ],
    a: [
        'target',
        'href',
        'title',
        'rel'
    ],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    div: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: [
        'src',
        'srcset',
        'alt',
        'title',
        'width',
        'height'
    ],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
};
function sanitizeHtml(unsafeHtml, allowList, sanitizeFn) {
    if (!unsafeHtml.length) return unsafeHtml;
    if (sanitizeFn && typeof sanitizeFn === 'function') return sanitizeFn(unsafeHtml);
    const domParser = new window.DOMParser();
    const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
    const elements = [].concat(...createdDocument.body.querySelectorAll('*'));
    for(let i = 0, len = elements.length; i < len; i++){
        const element = elements[i];
        const elementName = element.nodeName.toLowerCase();
        if (!Object.keys(allowList).includes(elementName)) {
            element.remove();
            continue;
        }
        const attributeList = [].concat(...element.attributes);
        const allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);
        attributeList.forEach((attribute)=>{
            if (!allowedAttribute(attribute, allowedAttributes)) element.removeAttribute(attribute.nodeName);
        });
    }
    return createdDocument.body.innerHTML;
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): tooltip.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */ const NAME$4 = 'tooltip';
const DATA_KEY$4 = 'bs.tooltip';
const EVENT_KEY$4 = `.${DATA_KEY$4}`;
const CLASS_PREFIX$1 = 'bs-tooltip';
const DISALLOWED_ATTRIBUTES = new Set([
    'sanitize',
    'allowList',
    'sanitizeFn'
]);
const DefaultType$3 = {
    animation: 'boolean',
    template: 'string',
    title: '(string|element|function)',
    trigger: 'string',
    delay: '(number|object)',
    html: 'boolean',
    selector: '(string|boolean)',
    placement: '(string|function)',
    offset: '(array|string|function)',
    container: '(string|element|boolean)',
    fallbackPlacements: 'array',
    boundary: '(string|element)',
    customClass: '(string|function)',
    sanitize: 'boolean',
    sanitizeFn: '(null|function)',
    allowList: 'object',
    popperConfig: '(null|object|function)'
};
const AttachmentMap = {
    AUTO: 'auto',
    TOP: 'top',
    RIGHT: isRTL() ? 'left' : 'right',
    BOTTOM: 'bottom',
    LEFT: isRTL() ? 'right' : 'left'
};
const Default$3 = {
    animation: true,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    selector: false,
    placement: 'top',
    offset: [
        0,
        0
    ],
    container: false,
    fallbackPlacements: [
        'top',
        'right',
        'bottom',
        'left'
    ],
    boundary: 'clippingParents',
    customClass: '',
    sanitize: true,
    sanitizeFn: null,
    allowList: DefaultAllowlist,
    popperConfig: null
};
const Event$2 = {
    HIDE: `hide${EVENT_KEY$4}`,
    HIDDEN: `hidden${EVENT_KEY$4}`,
    SHOW: `show${EVENT_KEY$4}`,
    SHOWN: `shown${EVENT_KEY$4}`,
    INSERTED: `inserted${EVENT_KEY$4}`,
    CLICK: `click${EVENT_KEY$4}`,
    FOCUSIN: `focusin${EVENT_KEY$4}`,
    FOCUSOUT: `focusout${EVENT_KEY$4}`,
    MOUSEENTER: `mouseenter${EVENT_KEY$4}`,
    MOUSELEAVE: `mouseleave${EVENT_KEY$4}`
};
const CLASS_NAME_FADE$2 = 'fade';
const CLASS_NAME_MODAL = 'modal';
const CLASS_NAME_SHOW$2 = 'show';
const HOVER_STATE_SHOW = 'show';
const HOVER_STATE_OUT = 'out';
const SELECTOR_TOOLTIP_INNER = '.tooltip-inner';
const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
const EVENT_MODAL_HIDE = 'hide.bs.modal';
const TRIGGER_HOVER = 'hover';
const TRIGGER_FOCUS = 'focus';
const TRIGGER_CLICK = 'click';
const TRIGGER_MANUAL = 'manual';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */ class Tooltip extends BaseComponent {
    static get Default() {
        return Default$3;
    }
    static get NAME() {
        return NAME$4;
    }
    static get Event() {
        return Event$2;
    }
    static get DefaultType() {
        return DefaultType$3;
    }
    enable() {
        this._isEnabled = true;
    }
    disable() {
        this._isEnabled = false;
    }
    toggleEnabled() {
        this._isEnabled = !this._isEnabled;
    }
    toggle(event) {
        if (!this._isEnabled) return;
        if (event) {
            const context = this._initializeOnDelegatedTarget(event);
            context._activeTrigger.click = !context._activeTrigger.click;
            if (context._isWithActiveTrigger()) context._enter(null, context);
            else context._leave(null, context);
        } else {
            if (this.getTipElement().classList.contains(CLASS_NAME_SHOW$2)) {
                this._leave(null, this);
                return;
            }
            this._enter(null, this);
        }
    }
    dispose() {
        clearTimeout(this._timeout);
        EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
        if (this.tip) this.tip.remove();
        this._disposePopper();
        super.dispose();
    }
    show() {
        if (this._element.style.display === 'none') throw new Error('Please use show on visible elements');
        if (!(this.isWithContent() && this._isEnabled)) return;
        const showEvent = EventHandler.trigger(this._element, this.constructor.Event.SHOW);
        const shadowRoot = findShadowRoot(this._element);
        const isInTheDom = shadowRoot === null ? this._element.ownerDocument.documentElement.contains(this._element) : shadowRoot.contains(this._element);
        if (showEvent.defaultPrevented || !isInTheDom) return;
         // A trick to recreate a tooltip in case a new title is given by using the NOT documented `data-bs-original-title`
        // This will be removed later in favor of a `setContent` method
        if (this.constructor.NAME === 'tooltip' && this.tip && this.getTitle() !== this.tip.querySelector(SELECTOR_TOOLTIP_INNER).innerHTML) {
            this._disposePopper();
            this.tip.remove();
            this.tip = null;
        }
        const tip = this.getTipElement();
        const tipId = getUID(this.constructor.NAME);
        tip.setAttribute('id', tipId);
        this._element.setAttribute('aria-describedby', tipId);
        if (this._config.animation) tip.classList.add(CLASS_NAME_FADE$2);
        const placement = typeof this._config.placement === 'function' ? this._config.placement.call(this, tip, this._element) : this._config.placement;
        const attachment = this._getAttachment(placement);
        this._addAttachmentClass(attachment);
        const { container  } = this._config;
        Data.set(tip, this.constructor.DATA_KEY, this);
        if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
            container.append(tip);
            EventHandler.trigger(this._element, this.constructor.Event.INSERTED);
        }
        if (this._popper) this._popper.update();
        else this._popper = _core.createPopper(this._element, tip, this._getPopperConfig(attachment));
        tip.classList.add(CLASS_NAME_SHOW$2);
        const customClass = this._resolvePossibleFunction(this._config.customClass);
        if (customClass) tip.classList.add(...customClass.split(' '));
         // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
        if ('ontouchstart' in document.documentElement) [].concat(...document.body.children).forEach((element)=>{
            EventHandler.on(element, 'mouseover', noop);
        });
        const complete = ()=>{
            const prevHoverState = this._hoverState;
            this._hoverState = null;
            EventHandler.trigger(this._element, this.constructor.Event.SHOWN);
            if (prevHoverState === HOVER_STATE_OUT) this._leave(null, this);
        };
        const isAnimated = this.tip.classList.contains(CLASS_NAME_FADE$2);
        this._queueCallback(complete, this.tip, isAnimated);
    }
    hide() {
        if (!this._popper) return;
        const tip = this.getTipElement();
        const complete = ()=>{
            if (this._isWithActiveTrigger()) return;
            if (this._hoverState !== HOVER_STATE_SHOW) tip.remove();
            this._cleanTipClass();
            this._element.removeAttribute('aria-describedby');
            EventHandler.trigger(this._element, this.constructor.Event.HIDDEN);
            this._disposePopper();
        };
        const hideEvent = EventHandler.trigger(this._element, this.constructor.Event.HIDE);
        if (hideEvent.defaultPrevented) return;
        tip.classList.remove(CLASS_NAME_SHOW$2); // If this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support
        if ('ontouchstart' in document.documentElement) [].concat(...document.body.children).forEach((element)=>EventHandler.off(element, 'mouseover', noop)
        );
        this._activeTrigger[TRIGGER_CLICK] = false;
        this._activeTrigger[TRIGGER_FOCUS] = false;
        this._activeTrigger[TRIGGER_HOVER] = false;
        const isAnimated = this.tip.classList.contains(CLASS_NAME_FADE$2);
        this._queueCallback(complete, this.tip, isAnimated);
        this._hoverState = '';
    }
    update() {
        if (this._popper !== null) this._popper.update();
    }
    isWithContent() {
        return Boolean(this.getTitle());
    }
    getTipElement() {
        if (this.tip) return this.tip;
        const element = document.createElement('div');
        element.innerHTML = this._config.template;
        const tip = element.children[0];
        this.setContent(tip);
        tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
        this.tip = tip;
        return this.tip;
    }
    setContent(tip) {
        this._sanitizeAndSetContent(tip, this.getTitle(), SELECTOR_TOOLTIP_INNER);
    }
    _sanitizeAndSetContent(template, content, selector) {
        const templateElement = SelectorEngine.findOne(selector, template);
        if (!content && templateElement) {
            templateElement.remove();
            return;
        } // we use append for html objects to maintain js events
        this.setElementContent(templateElement, content);
    }
    setElementContent(element, content) {
        if (element === null) return;
        if (isElement(content)) {
            content = getElement(content); // content is a DOM node or a jQuery
            if (this._config.html) {
                if (content.parentNode !== element) {
                    element.innerHTML = '';
                    element.append(content);
                }
            } else element.textContent = content.textContent;
            return;
        }
        if (this._config.html) {
            if (this._config.sanitize) content = sanitizeHtml(content, this._config.allowList, this._config.sanitizeFn);
            element.innerHTML = content;
        } else element.textContent = content;
    }
    getTitle() {
        const title = this._element.getAttribute('data-bs-original-title') || this._config.title;
        return this._resolvePossibleFunction(title);
    }
    updateAttachment(attachment) {
        if (attachment === 'right') return 'end';
        if (attachment === 'left') return 'start';
        return attachment;
    }
    _initializeOnDelegatedTarget(event, context) {
        return context || this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
    }
    _getOffset() {
        const { offset  } = this._config;
        if (typeof offset === 'string') return offset.split(',').map((val)=>Number.parseInt(val, 10)
        );
        if (typeof offset === 'function') return (popperData)=>offset(popperData, this._element)
        ;
        return offset;
    }
    _resolvePossibleFunction(content) {
        return typeof content === 'function' ? content.call(this._element) : content;
    }
    _getPopperConfig(attachment) {
        const defaultBsPopperConfig = {
            placement: attachment,
            modifiers: [
                {
                    name: 'flip',
                    options: {
                        fallbackPlacements: this._config.fallbackPlacements
                    }
                },
                {
                    name: 'offset',
                    options: {
                        offset: this._getOffset()
                    }
                },
                {
                    name: 'preventOverflow',
                    options: {
                        boundary: this._config.boundary
                    }
                },
                {
                    name: 'arrow',
                    options: {
                        element: `.${this.constructor.NAME}-arrow`
                    }
                },
                {
                    name: 'onChange',
                    enabled: true,
                    phase: 'afterWrite',
                    fn: (data)=>this._handlePopperPlacementChange(data)
                }
            ],
            onFirstUpdate: (data)=>{
                if (data.options.placement !== data.placement) this._handlePopperPlacementChange(data);
            }
        };
        return {
            ...defaultBsPopperConfig,
            ...typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig
        };
    }
    _addAttachmentClass(attachment) {
        this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(attachment)}`);
    }
    _getAttachment(placement) {
        return AttachmentMap[placement.toUpperCase()];
    }
    _setListeners() {
        const triggers = this._config.trigger.split(' ');
        triggers.forEach((trigger)=>{
            if (trigger === 'click') EventHandler.on(this._element, this.constructor.Event.CLICK, this._config.selector, (event)=>this.toggle(event)
            );
            else if (trigger !== TRIGGER_MANUAL) {
                const eventIn = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN;
                const eventOut = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
                EventHandler.on(this._element, eventIn, this._config.selector, (event)=>this._enter(event)
                );
                EventHandler.on(this._element, eventOut, this._config.selector, (event)=>this._leave(event)
                );
            }
        });
        this._hideModalHandler = ()=>{
            if (this._element) this.hide();
        };
        EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
        if (this._config.selector) this._config = {
            ...this._config,
            trigger: 'manual',
            selector: ''
        };
        else this._fixTitle();
    }
    _fixTitle() {
        const title = this._element.getAttribute('title');
        const originalTitleType = typeof this._element.getAttribute('data-bs-original-title');
        if (title || originalTitleType !== 'string') {
            this._element.setAttribute('data-bs-original-title', title || '');
            if (title && !this._element.getAttribute('aria-label') && !this._element.textContent) this._element.setAttribute('aria-label', title);
            this._element.setAttribute('title', '');
        }
    }
    _enter(event, context) {
        context = this._initializeOnDelegatedTarget(event, context);
        if (event) context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
        if (context.getTipElement().classList.contains(CLASS_NAME_SHOW$2) || context._hoverState === HOVER_STATE_SHOW) {
            context._hoverState = HOVER_STATE_SHOW;
            return;
        }
        clearTimeout(context._timeout);
        context._hoverState = HOVER_STATE_SHOW;
        if (!context._config.delay || !context._config.delay.show) {
            context.show();
            return;
        }
        context._timeout = setTimeout(()=>{
            if (context._hoverState === HOVER_STATE_SHOW) context.show();
        }, context._config.delay.show);
    }
    _leave(event, context) {
        context = this._initializeOnDelegatedTarget(event, context);
        if (event) context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
        if (context._isWithActiveTrigger()) return;
        clearTimeout(context._timeout);
        context._hoverState = HOVER_STATE_OUT;
        if (!context._config.delay || !context._config.delay.hide) {
            context.hide();
            return;
        }
        context._timeout = setTimeout(()=>{
            if (context._hoverState === HOVER_STATE_OUT) context.hide();
        }, context._config.delay.hide);
    }
    _isWithActiveTrigger() {
        for(const trigger in this._activeTrigger){
            if (this._activeTrigger[trigger]) return true;
        }
        return false;
    }
    _getConfig(config) {
        const dataAttributes = Manipulator.getDataAttributes(this._element);
        Object.keys(dataAttributes).forEach((dataAttr)=>{
            if (DISALLOWED_ATTRIBUTES.has(dataAttr)) delete dataAttributes[dataAttr];
        });
        config = {
            ...this.constructor.Default,
            ...dataAttributes,
            ...typeof config === 'object' && config ? config : {}
        };
        config.container = config.container === false ? document.body : getElement(config.container);
        if (typeof config.delay === 'number') config.delay = {
            show: config.delay,
            hide: config.delay
        };
        if (typeof config.title === 'number') config.title = config.title.toString();
        if (typeof config.content === 'number') config.content = config.content.toString();
        typeCheckConfig(NAME$4, config, this.constructor.DefaultType);
        if (config.sanitize) config.template = sanitizeHtml(config.template, config.allowList, config.sanitizeFn);
        return config;
    }
    _getDelegateConfig() {
        const config = {};
        for(const key in this._config)if (this.constructor.Default[key] !== this._config[key]) config[key] = this._config[key];
         // In the future can be replaced with:
        // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])
        // `Object.fromEntries(keysWithDifferentValues)`
        return config;
    }
    _cleanTipClass() {
        const tip = this.getTipElement();
        const basicClassPrefixRegex = new RegExp(`(^|\\s)${this._getBasicClassPrefix()}\\S+`, 'g');
        const tabClass = tip.getAttribute('class').match(basicClassPrefixRegex);
        if (tabClass !== null && tabClass.length > 0) tabClass.map((token)=>token.trim()
        ).forEach((tClass)=>tip.classList.remove(tClass)
        );
    }
    _getBasicClassPrefix() {
        return CLASS_PREFIX$1;
    }
    _handlePopperPlacementChange(popperData) {
        const { state  } = popperData;
        if (!state) return;
        this.tip = state.elements.popper;
        this._cleanTipClass();
        this._addAttachmentClass(this._getAttachment(state.placement));
    }
    _disposePopper() {
        if (this._popper) {
            this._popper.destroy();
            this._popper = null;
        }
    }
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Tooltip.getOrCreateInstance(this, config);
            if (typeof config === 'string') {
                if (typeof data[config] === 'undefined') throw new TypeError(`No method named "${config}"`);
                data[config]();
            }
        });
    }
    constructor(element, config){
        if (typeof _core === 'undefined') throw new TypeError('Bootstrap\'s tooltips require Popper (https://popper.js.org)');
        super(element); // private
        this._isEnabled = true;
        this._timeout = 0;
        this._hoverState = '';
        this._activeTrigger = {};
        this._popper = null; // Protected
        this._config = this._getConfig(config);
        this.tip = null;
        this._setListeners();
    }
}
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Tooltip to jQuery only if jQuery is present
 */ defineJQueryPlugin(Tooltip);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): popover.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */ const NAME$3 = 'popover';
const DATA_KEY$3 = 'bs.popover';
const EVENT_KEY$3 = `.${DATA_KEY$3}`;
const CLASS_PREFIX = 'bs-popover';
const Default$2 = {
    ...Tooltip.Default,
    placement: 'right',
    offset: [
        0,
        8
    ],
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
};
const DefaultType$2 = {
    ...Tooltip.DefaultType,
    content: '(string|element|function)'
};
const Event$1 = {
    HIDE: `hide${EVENT_KEY$3}`,
    HIDDEN: `hidden${EVENT_KEY$3}`,
    SHOW: `show${EVENT_KEY$3}`,
    SHOWN: `shown${EVENT_KEY$3}`,
    INSERTED: `inserted${EVENT_KEY$3}`,
    CLICK: `click${EVENT_KEY$3}`,
    FOCUSIN: `focusin${EVENT_KEY$3}`,
    FOCUSOUT: `focusout${EVENT_KEY$3}`,
    MOUSEENTER: `mouseenter${EVENT_KEY$3}`,
    MOUSELEAVE: `mouseleave${EVENT_KEY$3}`
};
const SELECTOR_TITLE = '.popover-header';
const SELECTOR_CONTENT = '.popover-body';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */ class Popover extends Tooltip {
    // Getters
    static get Default() {
        return Default$2;
    }
    static get NAME() {
        return NAME$3;
    }
    static get Event() {
        return Event$1;
    }
    static get DefaultType() {
        return DefaultType$2;
    }
    isWithContent() {
        return this.getTitle() || this._getContent();
    }
    setContent(tip) {
        this._sanitizeAndSetContent(tip, this.getTitle(), SELECTOR_TITLE);
        this._sanitizeAndSetContent(tip, this._getContent(), SELECTOR_CONTENT);
    }
    _getContent() {
        return this._resolvePossibleFunction(this._config.content);
    }
    _getBasicClassPrefix() {
        return CLASS_PREFIX;
    }
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Popover.getOrCreateInstance(this, config);
            if (typeof config === 'string') {
                if (typeof data[config] === 'undefined') throw new TypeError(`No method named "${config}"`);
                data[config]();
            }
        });
    }
}
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Popover to jQuery only if jQuery is present
 */ defineJQueryPlugin(Popover);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): scrollspy.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */ const NAME$2 = 'scrollspy';
const DATA_KEY$2 = 'bs.scrollspy';
const EVENT_KEY$2 = `.${DATA_KEY$2}`;
const DATA_API_KEY$1 = '.data-api';
const Default$1 = {
    offset: 10,
    method: 'auto',
    target: ''
};
const DefaultType$1 = {
    offset: 'number',
    method: 'string',
    target: '(string|element)'
};
const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
const EVENT_SCROLL = `scroll${EVENT_KEY$2}`;
const EVENT_LOAD_DATA_API = `load${EVENT_KEY$2}${DATA_API_KEY$1}`;
const CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';
const CLASS_NAME_ACTIVE$1 = 'active';
const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
const SELECTOR_NAV_LIST_GROUP$1 = '.nav, .list-group';
const SELECTOR_NAV_LINKS = '.nav-link';
const SELECTOR_NAV_ITEMS = '.nav-item';
const SELECTOR_LIST_ITEMS = '.list-group-item';
const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}, .${CLASS_NAME_DROPDOWN_ITEM}`;
const SELECTOR_DROPDOWN$1 = '.dropdown';
const SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';
const METHOD_OFFSET = 'offset';
const METHOD_POSITION = 'position';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */ class ScrollSpy extends BaseComponent {
    static get Default() {
        return Default$1;
    }
    static get NAME() {
        return NAME$2;
    }
    refresh() {
        const autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;
        const offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
        const offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;
        this._offsets = [];
        this._targets = [];
        this._scrollHeight = this._getScrollHeight();
        const targets = SelectorEngine.find(SELECTOR_LINK_ITEMS, this._config.target);
        targets.map((element)=>{
            const targetSelector = getSelectorFromElement(element);
            const target = targetSelector ? SelectorEngine.findOne(targetSelector) : null;
            if (target) {
                const targetBCR = target.getBoundingClientRect();
                if (targetBCR.width || targetBCR.height) return [
                    Manipulator[offsetMethod](target).top + offsetBase,
                    targetSelector
                ];
            }
            return null;
        }).filter((item)=>item
        ).sort((a, b)=>a[0] - b[0]
        ).forEach((item)=>{
            this._offsets.push(item[0]);
            this._targets.push(item[1]);
        });
    }
    dispose() {
        EventHandler.off(this._scrollElement, EVENT_KEY$2);
        super.dispose();
    }
    _getConfig(config) {
        config = {
            ...Default$1,
            ...Manipulator.getDataAttributes(this._element),
            ...typeof config === 'object' && config ? config : {}
        };
        config.target = getElement(config.target) || document.documentElement;
        typeCheckConfig(NAME$2, config, DefaultType$1);
        return config;
    }
    _getScrollTop() {
        return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
    }
    _getScrollHeight() {
        return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    }
    _getOffsetHeight() {
        return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
    }
    _process() {
        const scrollTop = this._getScrollTop() + this._config.offset;
        const scrollHeight = this._getScrollHeight();
        const maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();
        if (this._scrollHeight !== scrollHeight) this.refresh();
        if (scrollTop >= maxScroll) {
            const target = this._targets[this._targets.length - 1];
            if (this._activeTarget !== target) this._activate(target);
            return;
        }
        if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
            this._activeTarget = null;
            this._clear();
            return;
        }
        for(let i = this._offsets.length; i--;){
            const isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);
            if (isActiveTarget) this._activate(this._targets[i]);
        }
    }
    _activate(target) {
        this._activeTarget = target;
        this._clear();
        const queries = SELECTOR_LINK_ITEMS.split(',').map((selector)=>`${selector}[data-bs-target="${target}"],${selector}[href="${target}"]`
        );
        const link = SelectorEngine.findOne(queries.join(','), this._config.target);
        link.classList.add(CLASS_NAME_ACTIVE$1);
        if (link.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, link.closest(SELECTOR_DROPDOWN$1)).classList.add(CLASS_NAME_ACTIVE$1);
        else SelectorEngine.parents(link, SELECTOR_NAV_LIST_GROUP$1).forEach((listGroup)=>{
            // Set triggered links parents as active
            // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
            SelectorEngine.prev(listGroup, `${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`).forEach((item)=>item.classList.add(CLASS_NAME_ACTIVE$1)
            ); // Handle special case when .nav-link is inside .nav-item
            SelectorEngine.prev(listGroup, SELECTOR_NAV_ITEMS).forEach((navItem)=>{
                SelectorEngine.children(navItem, SELECTOR_NAV_LINKS).forEach((item)=>item.classList.add(CLASS_NAME_ACTIVE$1)
                );
            });
        });
        EventHandler.trigger(this._scrollElement, EVENT_ACTIVATE, {
            relatedTarget: target
        });
    }
    _clear() {
        SelectorEngine.find(SELECTOR_LINK_ITEMS, this._config.target).filter((node)=>node.classList.contains(CLASS_NAME_ACTIVE$1)
        ).forEach((node)=>node.classList.remove(CLASS_NAME_ACTIVE$1)
        );
    }
    static jQueryInterface(config) {
        return this.each(function() {
            const data = ScrollSpy.getOrCreateInstance(this, config);
            if (typeof config !== 'string') return;
            if (typeof data[config] === 'undefined') throw new TypeError(`No method named "${config}"`);
            data[config]();
        });
    }
    constructor(element, config){
        super(element);
        this._scrollElement = this._element.tagName === 'BODY' ? window : this._element;
        this._config = this._getConfig(config);
        this._offsets = [];
        this._targets = [];
        this._activeTarget = null;
        this._scrollHeight = 0;
        EventHandler.on(this._scrollElement, EVENT_SCROLL, ()=>this._process()
        );
        this.refresh();
        this._process();
    }
}
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */ EventHandler.on(window, EVENT_LOAD_DATA_API, ()=>{
    SelectorEngine.find(SELECTOR_DATA_SPY).forEach((spy)=>new ScrollSpy(spy)
    );
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .ScrollSpy to jQuery only if jQuery is present
 */ defineJQueryPlugin(ScrollSpy);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): tab.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */ const NAME$1 = 'tab';
const DATA_KEY$1 = 'bs.tab';
const EVENT_KEY$1 = `.${DATA_KEY$1}`;
const DATA_API_KEY = '.data-api';
const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}${DATA_API_KEY}`;
const CLASS_NAME_DROPDOWN_MENU = 'dropdown-menu';
const CLASS_NAME_ACTIVE = 'active';
const CLASS_NAME_FADE$1 = 'fade';
const CLASS_NAME_SHOW$1 = 'show';
const SELECTOR_DROPDOWN = '.dropdown';
const SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
const SELECTOR_ACTIVE = '.active';
const SELECTOR_ACTIVE_UL = ':scope > li > .active';
const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
const SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
const SELECTOR_DROPDOWN_ACTIVE_CHILD = ':scope > .dropdown-menu .active';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */ class Tab extends BaseComponent {
    // Getters
    static get NAME() {
        return NAME$1;
    }
    show() {
        if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(CLASS_NAME_ACTIVE)) return;
        let previous;
        const target = getElementFromSelector(this._element);
        const listElement = this._element.closest(SELECTOR_NAV_LIST_GROUP);
        if (listElement) {
            const itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;
            previous = SelectorEngine.find(itemSelector, listElement);
            previous = previous[previous.length - 1];
        }
        const hideEvent = previous ? EventHandler.trigger(previous, EVENT_HIDE$1, {
            relatedTarget: this._element
        }) : null;
        const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$1, {
            relatedTarget: previous
        });
        if (showEvent.defaultPrevented || hideEvent !== null && hideEvent.defaultPrevented) return;
        this._activate(this._element, listElement);
        const complete = ()=>{
            EventHandler.trigger(previous, EVENT_HIDDEN$1, {
                relatedTarget: this._element
            });
            EventHandler.trigger(this._element, EVENT_SHOWN$1, {
                relatedTarget: previous
            });
        };
        if (target) this._activate(target, target.parentNode, complete);
        else complete();
    }
    _activate(element, container, callback) {
        const activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? SelectorEngine.find(SELECTOR_ACTIVE_UL, container) : SelectorEngine.children(container, SELECTOR_ACTIVE);
        const active = activeElements[0];
        const isTransitioning = callback && active && active.classList.contains(CLASS_NAME_FADE$1);
        const complete = ()=>this._transitionComplete(element, active, callback)
        ;
        if (active && isTransitioning) {
            active.classList.remove(CLASS_NAME_SHOW$1);
            this._queueCallback(complete, element, true);
        } else complete();
    }
    _transitionComplete(element, active, callback) {
        if (active) {
            active.classList.remove(CLASS_NAME_ACTIVE);
            const dropdownChild = SelectorEngine.findOne(SELECTOR_DROPDOWN_ACTIVE_CHILD, active.parentNode);
            if (dropdownChild) dropdownChild.classList.remove(CLASS_NAME_ACTIVE);
            if (active.getAttribute('role') === 'tab') active.setAttribute('aria-selected', false);
        }
        element.classList.add(CLASS_NAME_ACTIVE);
        if (element.getAttribute('role') === 'tab') element.setAttribute('aria-selected', true);
        reflow(element);
        if (element.classList.contains(CLASS_NAME_FADE$1)) element.classList.add(CLASS_NAME_SHOW$1);
        let parent = element.parentNode;
        if (parent && parent.nodeName === 'LI') parent = parent.parentNode;
        if (parent && parent.classList.contains(CLASS_NAME_DROPDOWN_MENU)) {
            const dropdownElement = element.closest(SELECTOR_DROPDOWN);
            if (dropdownElement) SelectorEngine.find(SELECTOR_DROPDOWN_TOGGLE, dropdownElement).forEach((dropdown)=>dropdown.classList.add(CLASS_NAME_ACTIVE)
            );
            element.setAttribute('aria-expanded', true);
        }
        if (callback) callback();
    }
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Tab.getOrCreateInstance(this);
            if (typeof config === 'string') {
                if (typeof data[config] === 'undefined') throw new TypeError(`No method named "${config}"`);
                data[config]();
            }
        });
    }
}
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */ EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
    if ([
        'A',
        'AREA'
    ].includes(this.tagName)) event.preventDefault();
    if (isDisabled(this)) return;
    const data = Tab.getOrCreateInstance(this);
    data.show();
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Tab to jQuery only if jQuery is present
 */ defineJQueryPlugin(Tab);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): toast.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */ const NAME = 'toast';
const DATA_KEY = 'bs.toast';
const EVENT_KEY = `.${DATA_KEY}`;
const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
const EVENT_HIDE = `hide${EVENT_KEY}`;
const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
const EVENT_SHOW = `show${EVENT_KEY}`;
const EVENT_SHOWN = `shown${EVENT_KEY}`;
const CLASS_NAME_FADE = 'fade';
const CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility
const CLASS_NAME_SHOW = 'show';
const CLASS_NAME_SHOWING = 'showing';
const DefaultType = {
    animation: 'boolean',
    autohide: 'boolean',
    delay: 'number'
};
const Default = {
    animation: true,
    autohide: true,
    delay: 5000
};
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */ class Toast extends BaseComponent {
    static get DefaultType() {
        return DefaultType;
    }
    static get Default() {
        return Default;
    }
    static get NAME() {
        return NAME;
    }
    show() {
        const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
        if (showEvent.defaultPrevented) return;
        this._clearTimeout();
        if (this._config.animation) this._element.classList.add(CLASS_NAME_FADE);
        const complete = ()=>{
            this._element.classList.remove(CLASS_NAME_SHOWING);
            EventHandler.trigger(this._element, EVENT_SHOWN);
            this._maybeScheduleHide();
        };
        this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated
        reflow(this._element);
        this._element.classList.add(CLASS_NAME_SHOW);
        this._element.classList.add(CLASS_NAME_SHOWING);
        this._queueCallback(complete, this._element, this._config.animation);
    }
    hide() {
        if (!this._element.classList.contains(CLASS_NAME_SHOW)) return;
        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
        if (hideEvent.defaultPrevented) return;
        const complete = ()=>{
            this._element.classList.add(CLASS_NAME_HIDE); // @deprecated
            this._element.classList.remove(CLASS_NAME_SHOWING);
            this._element.classList.remove(CLASS_NAME_SHOW);
            EventHandler.trigger(this._element, EVENT_HIDDEN);
        };
        this._element.classList.add(CLASS_NAME_SHOWING);
        this._queueCallback(complete, this._element, this._config.animation);
    }
    dispose() {
        this._clearTimeout();
        if (this._element.classList.contains(CLASS_NAME_SHOW)) this._element.classList.remove(CLASS_NAME_SHOW);
        super.dispose();
    }
    _getConfig(config) {
        config = {
            ...Default,
            ...Manipulator.getDataAttributes(this._element),
            ...typeof config === 'object' && config ? config : {}
        };
        typeCheckConfig(NAME, config, this.constructor.DefaultType);
        return config;
    }
    _maybeScheduleHide() {
        if (!this._config.autohide) return;
        if (this._hasMouseInteraction || this._hasKeyboardInteraction) return;
        this._timeout = setTimeout(()=>{
            this.hide();
        }, this._config.delay);
    }
    _onInteraction(event, isInteracting) {
        switch(event.type){
            case 'mouseover':
            case 'mouseout':
                this._hasMouseInteraction = isInteracting;
                break;
            case 'focusin':
            case 'focusout':
                this._hasKeyboardInteraction = isInteracting;
                break;
        }
        if (isInteracting) {
            this._clearTimeout();
            return;
        }
        const nextElement = event.relatedTarget;
        if (this._element === nextElement || this._element.contains(nextElement)) return;
        this._maybeScheduleHide();
    }
    _setListeners() {
        EventHandler.on(this._element, EVENT_MOUSEOVER, (event)=>this._onInteraction(event, true)
        );
        EventHandler.on(this._element, EVENT_MOUSEOUT, (event)=>this._onInteraction(event, false)
        );
        EventHandler.on(this._element, EVENT_FOCUSIN, (event)=>this._onInteraction(event, true)
        );
        EventHandler.on(this._element, EVENT_FOCUSOUT, (event)=>this._onInteraction(event, false)
        );
    }
    _clearTimeout() {
        clearTimeout(this._timeout);
        this._timeout = null;
    }
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Toast.getOrCreateInstance(this, config);
            if (typeof config === 'string') {
                if (typeof data[config] === 'undefined') throw new TypeError(`No method named "${config}"`);
                data[config](this);
            }
        });
    }
    constructor(element, config){
        super(element);
        this._config = this._getConfig(config);
        this._timeout = null;
        this._hasMouseInteraction = false;
        this._hasKeyboardInteraction = false;
        this._setListeners();
    }
}
enableDismissTrigger(Toast);
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Toast to jQuery only if jQuery is present
 */ defineJQueryPlugin(Toast);

},{"@popperjs/core":"gT5OD","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"gT5OD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "popperGenerator", ()=>_createPopperJs.popperGenerator
) // eslint-disable-next-line import/no-unused-modules
;
parcelHelpers.export(exports, "detectOverflow", ()=>_createPopperJs.detectOverflow
);
parcelHelpers.export(exports, "createPopperBase", ()=>_createPopperJs.createPopper
);
parcelHelpers.export(exports, "createPopper", ()=>_popperJs.createPopper
) // eslint-disable-next-line import/no-unused-modules
;
parcelHelpers.export(exports, "createPopperLite", ()=>_popperLiteJs.createPopper
);
var _enumsJs = require("./enums.js");
parcelHelpers.exportAll(_enumsJs, exports);
var _indexJs = require("./modifiers/index.js"); // eslint-disable-next-line import/no-unused-modules
parcelHelpers.exportAll(_indexJs, exports);
var _createPopperJs = require("./createPopper.js");
var _popperJs = require("./popper.js");
var _popperLiteJs = require("./popper-lite.js");

},{"./enums.js":"qxiOM","./modifiers/index.js":"bSOA6","./createPopper.js":"g1Jyk","./popper.js":"dg9kH","./popper-lite.js":"bxdRR","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"qxiOM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "top", ()=>top
);
parcelHelpers.export(exports, "bottom", ()=>bottom
);
parcelHelpers.export(exports, "right", ()=>right
);
parcelHelpers.export(exports, "left", ()=>left
);
parcelHelpers.export(exports, "auto", ()=>auto
);
parcelHelpers.export(exports, "basePlacements", ()=>basePlacements
);
parcelHelpers.export(exports, "start", ()=>start
);
parcelHelpers.export(exports, "end", ()=>end
);
parcelHelpers.export(exports, "clippingParents", ()=>clippingParents
);
parcelHelpers.export(exports, "viewport", ()=>viewport
);
parcelHelpers.export(exports, "popper", ()=>popper
);
parcelHelpers.export(exports, "reference", ()=>reference
);
parcelHelpers.export(exports, "variationPlacements", ()=>variationPlacements
);
parcelHelpers.export(exports, "placements", ()=>placements
);
parcelHelpers.export(exports, "beforeRead", ()=>beforeRead
);
parcelHelpers.export(exports, "read", ()=>read
);
parcelHelpers.export(exports, "afterRead", ()=>afterRead
);
parcelHelpers.export(exports, "beforeMain", ()=>beforeMain
);
parcelHelpers.export(exports, "main", ()=>main
);
parcelHelpers.export(exports, "afterMain", ()=>afterMain
);
parcelHelpers.export(exports, "beforeWrite", ()=>beforeWrite
);
parcelHelpers.export(exports, "write", ()=>write
);
parcelHelpers.export(exports, "afterWrite", ()=>afterWrite
);
parcelHelpers.export(exports, "modifierPhases", ()=>modifierPhases
);
var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [
    top,
    bottom,
    right,
    left
];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/ basePlacements.reduce(function(acc, placement) {
    return acc.concat([
        placement + "-" + start,
        placement + "-" + end
    ]);
}, []);
var placements = /*#__PURE__*/ [].concat(basePlacements, [
    auto
]).reduce(function(acc, placement) {
    return acc.concat([
        placement,
        placement + "-" + start,
        placement + "-" + end
    ]);
}, []); // modifiers that need to read the DOM
var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers
var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)
var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [
    beforeRead,
    read,
    afterRead,
    beforeMain,
    main,
    afterMain,
    beforeWrite,
    write,
    afterWrite
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"6jXwo":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"bSOA6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "applyStyles", ()=>_applyStylesJsDefault.default
);
parcelHelpers.export(exports, "arrow", ()=>_arrowJsDefault.default
);
parcelHelpers.export(exports, "computeStyles", ()=>_computeStylesJsDefault.default
);
parcelHelpers.export(exports, "eventListeners", ()=>_eventListenersJsDefault.default
);
parcelHelpers.export(exports, "flip", ()=>_flipJsDefault.default
);
parcelHelpers.export(exports, "hide", ()=>_hideJsDefault.default
);
parcelHelpers.export(exports, "offset", ()=>_offsetJsDefault.default
);
parcelHelpers.export(exports, "popperOffsets", ()=>_popperOffsetsJsDefault.default
);
parcelHelpers.export(exports, "preventOverflow", ()=>_preventOverflowJsDefault.default
);
var _applyStylesJs = require("./applyStyles.js");
var _applyStylesJsDefault = parcelHelpers.interopDefault(_applyStylesJs);
var _arrowJs = require("./arrow.js");
var _arrowJsDefault = parcelHelpers.interopDefault(_arrowJs);
var _computeStylesJs = require("./computeStyles.js");
var _computeStylesJsDefault = parcelHelpers.interopDefault(_computeStylesJs);
var _eventListenersJs = require("./eventListeners.js");
var _eventListenersJsDefault = parcelHelpers.interopDefault(_eventListenersJs);
var _flipJs = require("./flip.js");
var _flipJsDefault = parcelHelpers.interopDefault(_flipJs);
var _hideJs = require("./hide.js");
var _hideJsDefault = parcelHelpers.interopDefault(_hideJs);
var _offsetJs = require("./offset.js");
var _offsetJsDefault = parcelHelpers.interopDefault(_offsetJs);
var _popperOffsetsJs = require("./popperOffsets.js");
var _popperOffsetsJsDefault = parcelHelpers.interopDefault(_popperOffsetsJs);
var _preventOverflowJs = require("./preventOverflow.js");
var _preventOverflowJsDefault = parcelHelpers.interopDefault(_preventOverflowJs);

},{"./applyStyles.js":"cPbqH","./arrow.js":"6eCC1","./computeStyles.js":"3aFNf","./eventListeners.js":"lGj0Q","./flip.js":"bwIX2","./hide.js":"jeIWi","./offset.js":"4yTnb","./popperOffsets.js":"jCAMm","./preventOverflow.js":"gAFAP","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"cPbqH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNodeNameJs = require("../dom-utils/getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _instanceOfJs = require("../dom-utils/instanceOf.js"); // This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow
function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name1) {
        var style = state.styles[name1] || {};
        var attributes = state.attributes[name1] || {};
        var element = state.elements[name1]; // arrow is optional + virtual elements
        if (!_instanceOfJs.isHTMLElement(element) || !_getNodeNameJsDefault.default(element)) return;
         // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(name) {
            var value = attributes[name];
            if (value === false) element.removeAttribute(name);
            else element.setAttribute(name, value === true ? '' : value);
        });
    });
}
function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
        popper: {
            position: state.options.strategy,
            left: '0',
            top: '0',
            margin: '0'
        },
        arrow: {
            position: 'absolute'
        },
        reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) Object.assign(state.elements.arrow.style, initialStyles.arrow);
    return function() {
        Object.keys(state.elements).forEach(function(name) {
            var element = state.elements[name];
            var attributes = state.attributes[name] || {};
            var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them
            var style1 = styleProperties.reduce(function(style, property) {
                style[property] = '';
                return style;
            }, {}); // arrow is optional + virtual elements
            if (!_instanceOfJs.isHTMLElement(element) || !_getNodeNameJsDefault.default(element)) return;
            Object.assign(element.style, style1);
            Object.keys(attributes).forEach(function(attribute) {
                element.removeAttribute(attribute);
            });
        });
    };
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'applyStyles',
    enabled: true,
    phase: 'write',
    fn: applyStyles,
    effect: effect,
    requires: [
        'computeStyles'
    ]
};

},{"../dom-utils/getNodeName.js":"dO1na","../dom-utils/instanceOf.js":"1C4Db","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"dO1na":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getNodeName(element) {
    return element ? (element.nodeName || '').toLowerCase() : null;
}
exports.default = getNodeName;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"1C4Db":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isElement", ()=>isElement
);
parcelHelpers.export(exports, "isHTMLElement", ()=>isHTMLElement
);
parcelHelpers.export(exports, "isShadowRoot", ()=>isShadowRoot
);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
function isElement(node) {
    var OwnElement = _getWindowJsDefault.default(node).Element;
    return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
    var OwnElement = _getWindowJsDefault.default(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
    // IE 11 has no ShadowRoot
    if (typeof ShadowRoot === 'undefined') return false;
    var OwnElement = _getWindowJsDefault.default(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
}

},{"./getWindow.js":"kY3PJ","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"kY3PJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getWindow(node) {
    if (node == null) return window;
    if (node.toString() !== '[object Window]') {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
}
exports.default = getWindow;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"6eCC1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getLayoutRectJs = require("../dom-utils/getLayoutRect.js");
var _getLayoutRectJsDefault = parcelHelpers.interopDefault(_getLayoutRectJs);
var _containsJs = require("../dom-utils/contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _getOffsetParentJs = require("../dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _getMainAxisFromPlacementJs = require("../utils/getMainAxisFromPlacement.js");
var _getMainAxisFromPlacementJsDefault = parcelHelpers.interopDefault(_getMainAxisFromPlacementJs);
var _withinJs = require("../utils/within.js");
var _mergePaddingObjectJs = require("../utils/mergePaddingObject.js");
var _mergePaddingObjectJsDefault = parcelHelpers.interopDefault(_mergePaddingObjectJs);
var _expandToHashMapJs = require("../utils/expandToHashMap.js");
var _expandToHashMapJsDefault = parcelHelpers.interopDefault(_expandToHashMapJs);
var _enumsJs = require("../enums.js");
var _instanceOfJs = require("../dom-utils/instanceOf.js"); // eslint-disable-next-line import/no-unused-modules
var toPaddingObject = function toPaddingObject(padding, state) {
    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
        placement: state.placement
    })) : padding;
    return _mergePaddingObjectJsDefault.default(typeof padding !== 'number' ? padding : _expandToHashMapJsDefault.default(padding, _enumsJs.basePlacements));
};
function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets = state.modifiersData.popperOffsets;
    var basePlacement = _getBasePlacementJsDefault.default(state.placement);
    var axis = _getMainAxisFromPlacementJsDefault.default(basePlacement);
    var isVertical = [
        _enumsJs.left,
        _enumsJs.right
    ].indexOf(basePlacement) >= 0;
    var len = isVertical ? 'height' : 'width';
    if (!arrowElement || !popperOffsets) return;
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = _getLayoutRectJsDefault.default(arrowElement);
    var minProp = axis === 'y' ? _enumsJs.top : _enumsJs.left;
    var maxProp = axis === 'y' ? _enumsJs.bottom : _enumsJs.right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
    var startDiff = popperOffsets[axis] - state.rects.reference[axis];
    var arrowOffsetParent = _getOffsetParentJsDefault.default(arrowElement);
    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
    // outside of the popper bounds
    var min = paddingObject[minProp];
    var max = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset = _withinJs.within(min, center, max); // Prevents breaking syntax highlighting...
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}
function effect(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;
    if (arrowElement == null) return;
     // CSS selector
    if (typeof arrowElement === 'string') {
        arrowElement = state.elements.popper.querySelector(arrowElement);
        if (!arrowElement) return;
    }
    if (!_instanceOfJs.isHTMLElement(arrowElement)) console.error([
        'Popper: "arrow" element must be an HTMLElement (not an SVGElement).',
        'To use an SVG arrow, wrap it in an HTMLElement that will be used as',
        'the arrow.'
    ].join(' '));
    if (!_containsJsDefault.default(state.elements.popper, arrowElement)) {
        console.error([
            'Popper: "arrow" modifier\'s `element` must be a child of the popper',
            'element.'
        ].join(' '));
        return;
    }
    state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'arrow',
    enabled: true,
    phase: 'main',
    fn: arrow,
    effect: effect,
    requires: [
        'popperOffsets'
    ],
    requiresIfExists: [
        'preventOverflow'
    ]
};

},{"../utils/getBasePlacement.js":"hArkE","../dom-utils/getLayoutRect.js":"8ol2m","../dom-utils/contains.js":"cdkv2","../dom-utils/getOffsetParent.js":"jtCXH","../utils/getMainAxisFromPlacement.js":"4EL78","../utils/within.js":"fpOgl","../utils/mergePaddingObject.js":"f6Q8J","../utils/expandToHashMap.js":"lnSnJ","../enums.js":"qxiOM","../dom-utils/instanceOf.js":"1C4Db","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"hArkE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js");
function getBasePlacement(placement) {
    return placement.split('-')[0];
}
exports.default = getBasePlacement;

},{"../enums.js":"qxiOM","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"8ol2m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getBoundingClientRectJs = require("./getBoundingClientRect.js"); // Returns the layout rect of an element relative to its offsetParent. Layout
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
function getLayoutRect(element) {
    var clientRect = _getBoundingClientRectJsDefault.default(element); // Use the clientRect sizes if it's not been transformed.
    // Fixes https://github.com/popperjs/popper-core/issues/1223
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) width = clientRect.width;
    if (Math.abs(clientRect.height - height) <= 1) height = clientRect.height;
    return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
    };
}
exports.default = getLayoutRect;

},{"./getBoundingClientRect.js":"hyXFK","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"hyXFK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _instanceOfJs = require("./instanceOf.js");
var _mathJs = require("../utils/math.js");
function getBoundingClientRect(element, includeScale) {
    if (includeScale === void 0) includeScale = false;
    var rect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (_instanceOfJs.isHTMLElement(element) && includeScale) {
        var offsetHeight = element.offsetHeight;
        var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale
        // Fallback to 1 in case both values are `0`
        if (offsetWidth > 0) scaleX = _mathJs.round(rect.width) / offsetWidth || 1;
        if (offsetHeight > 0) scaleY = _mathJs.round(rect.height) / offsetHeight || 1;
    }
    return {
        width: rect.width / scaleX,
        height: rect.height / scaleY,
        top: rect.top / scaleY,
        right: rect.right / scaleX,
        bottom: rect.bottom / scaleY,
        left: rect.left / scaleX,
        x: rect.left / scaleX,
        y: rect.top / scaleY
    };
}
exports.default = getBoundingClientRect;

},{"./instanceOf.js":"1C4Db","../utils/math.js":"9Zwjh","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"9Zwjh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "max", ()=>max
);
parcelHelpers.export(exports, "min", ()=>min
);
parcelHelpers.export(exports, "round", ()=>round
);
var max = Math.max;
var min = Math.min;
var round = Math.round;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"cdkv2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _instanceOfJs = require("./instanceOf.js");
function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method
    if (parent.contains(child)) return true;
    else if (rootNode && _instanceOfJs.isShadowRoot(rootNode)) {
        var next = child;
        do {
            if (next && parent.isSameNode(next)) return true;
             // $FlowFixMe[prop-missing]: need a better way to handle this...
            next = next.parentNode || next.host;
        }while (next)
    } // Give up, the result is false
    return false;
}
exports.default = contains;

},{"./instanceOf.js":"1C4Db","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"jtCXH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _instanceOfJs = require("./instanceOf.js");
var _isTableElementJs = require("./isTableElement.js");
var _isTableElementJsDefault = parcelHelpers.interopDefault(_isTableElementJs);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
function getTrueOffsetParent(element) {
    if (!_instanceOfJs.isHTMLElement(element) || _getComputedStyleJsDefault.default(element).position === 'fixed') return null;
    return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block
function getContainingBlock(element) {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
    var isIE = navigator.userAgent.indexOf('Trident') !== -1;
    if (isIE && _instanceOfJs.isHTMLElement(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = _getComputedStyleJsDefault.default(element);
        if (elementCss.position === 'fixed') return null;
    }
    var currentNode = _getParentNodeJsDefault.default(element);
    if (_instanceOfJs.isShadowRoot(currentNode)) currentNode = currentNode.host;
    while(_instanceOfJs.isHTMLElement(currentNode) && [
        'html',
        'body'
    ].indexOf(_getNodeNameJsDefault.default(currentNode)) < 0){
        var css = _getComputedStyleJsDefault.default(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
        if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || [
            'transform',
            'perspective'
        ].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') return currentNode;
        else currentNode = currentNode.parentNode;
    }
    return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
function getOffsetParent(element) {
    var window = _getWindowJsDefault.default(element);
    var offsetParent = getTrueOffsetParent(element);
    while(offsetParent && _isTableElementJsDefault.default(offsetParent) && _getComputedStyleJsDefault.default(offsetParent).position === 'static')offsetParent = getTrueOffsetParent(offsetParent);
    if (offsetParent && (_getNodeNameJsDefault.default(offsetParent) === 'html' || _getNodeNameJsDefault.default(offsetParent) === 'body' && _getComputedStyleJsDefault.default(offsetParent).position === 'static')) return window;
    return offsetParent || getContainingBlock(element) || window;
}
exports.default = getOffsetParent;

},{"./getWindow.js":"kY3PJ","./getNodeName.js":"dO1na","./getComputedStyle.js":"cYNQK","./instanceOf.js":"1C4Db","./isTableElement.js":"kSISy","./getParentNode.js":"575sS","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"cYNQK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
function getComputedStyle(element) {
    return _getWindowJsDefault.default(element).getComputedStyle(element);
}
exports.default = getComputedStyle;

},{"./getWindow.js":"kY3PJ","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"kSISy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
function isTableElement(element) {
    return [
        'table',
        'td',
        'th'
    ].indexOf(_getNodeNameJsDefault.default(element)) >= 0;
}
exports.default = isTableElement;

},{"./getNodeName.js":"dO1na","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"575sS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _instanceOfJs = require("./instanceOf.js");
function getParentNode(element) {
    if (_getNodeNameJsDefault.default(element) === 'html') return element;
    return(// $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || element.parentNode || (_instanceOfJs.isShadowRoot(element) ? element.host : null) || // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    _getDocumentElementJsDefault.default(element) // fallback
    );
}
exports.default = getParentNode;

},{"./getNodeName.js":"dO1na","./getDocumentElement.js":"dX7bp","./instanceOf.js":"1C4Db","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"dX7bp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _instanceOfJs = require("./instanceOf.js");
function getDocumentElement(element) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return ((_instanceOfJs.isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
exports.default = getDocumentElement;

},{"./instanceOf.js":"1C4Db","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"4EL78":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getMainAxisFromPlacement(placement) {
    return [
        'top',
        'bottom'
    ].indexOf(placement) >= 0 ? 'x' : 'y';
}
exports.default = getMainAxisFromPlacement;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"fpOgl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "within", ()=>within
);
parcelHelpers.export(exports, "withinMaxClamp", ()=>withinMaxClamp
);
var _mathJs = require("./math.js");
function within(min, value, max) {
    return _mathJs.max(min, _mathJs.min(value, max));
}
function withinMaxClamp(min, value, max) {
    var v = within(min, value, max);
    return v > max ? max : v;
}

},{"./math.js":"9Zwjh","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"f6Q8J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getFreshSideObjectJs = require("./getFreshSideObject.js");
var _getFreshSideObjectJsDefault = parcelHelpers.interopDefault(_getFreshSideObjectJs);
function mergePaddingObject(paddingObject) {
    return Object.assign({}, _getFreshSideObjectJsDefault.default(), paddingObject);
}
exports.default = mergePaddingObject;

},{"./getFreshSideObject.js":"lXEWs","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"lXEWs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getFreshSideObject() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    };
}
exports.default = getFreshSideObject;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"lnSnJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
        hashMap[key] = value;
        return hashMap;
    }, {});
}
exports.default = expandToHashMap;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"3aFNf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapToStyles", ()=>mapToStyles
);
var _enumsJs = require("../enums.js");
var _getOffsetParentJs = require("../dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _getWindowJs = require("../dom-utils/getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _getDocumentElementJs = require("../dom-utils/getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getComputedStyleJs = require("../dom-utils/getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getVariationJs = require("../utils/getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _mathJs = require("../utils/math.js"); // eslint-disable-next-line import/no-unused-modules
var unsetSides = {
    top: 'auto',
    right: 'auto',
    bottom: 'auto',
    left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.
function roundOffsetsByDPR(_ref) {
    var x = _ref.x, y = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
        x: _mathJs.round(x * dpr) / dpr || 0,
        y: _mathJs.round(y * dpr) / dpr || 0
    };
}
function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
        x: x,
        y: y
    }) : {
        x: x,
        y: y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty('x');
    var hasY = offsets.hasOwnProperty('y');
    var sideX = _enumsJs.left;
    var sideY = _enumsJs.top;
    var win = window;
    if (adaptive) {
        var offsetParent = _getOffsetParentJsDefault.default(popper);
        var heightProp = 'clientHeight';
        var widthProp = 'clientWidth';
        if (offsetParent === _getWindowJsDefault.default(popper)) {
            offsetParent = _getDocumentElementJsDefault.default(popper);
            if (_getComputedStyleJsDefault.default(offsetParent).position !== 'static' && position === 'absolute') {
                heightProp = 'scrollHeight';
                widthProp = 'scrollWidth';
            }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it
        if (placement === _enumsJs.top || (placement === _enumsJs.left || placement === _enumsJs.right) && variation === _enumsJs.end) {
            sideY = _enumsJs.bottom;
            var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
            y -= offsetY - popperRect.height;
            y *= gpuAcceleration ? 1 : -1;
        }
        if (placement === _enumsJs.left || (placement === _enumsJs.top || placement === _enumsJs.bottom) && variation === _enumsJs.end) {
            sideX = _enumsJs.right;
            var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
            x -= offsetX - popperRect.width;
            x *= gpuAcceleration ? 1 : -1;
        }
    }
    var commonStyles = Object.assign({
        position: position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x,
        y: y
    }) : {
        x: x,
        y: y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}
function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var transitionProperty = _getComputedStyleJsDefault.default(state.elements.popper).transitionProperty || '';
    if (adaptive && [
        'transform',
        'top',
        'right',
        'bottom',
        'left'
    ].some(function(property) {
        return transitionProperty.indexOf(property) >= 0;
    })) console.warn([
        'Popper: Detected CSS transitions on at least one of the following',
        'CSS properties: "transform", "top", "right", "bottom", "left".',
        '\n\n',
        'Disable the "computeStyles" modifier\'s `adaptive` option to allow',
        'for smooth transitions, or remove these properties from the CSS',
        'transition declaration on the popper element if only transitioning',
        'opacity or background-color for example.',
        '\n\n',
        'We recommend using the popper element as a wrapper around an inner',
        'element that can have any CSS property transitioned for animations.'
    ].join(' '));
    var commonStyles = {
        placement: _getBasePlacementJsDefault.default(state.placement),
        variation: _getVariationJsDefault.default(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration,
        isFixed: state.options.strategy === 'fixed'
    };
    if (state.modifiersData.popperOffsets != null) state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive: adaptive,
        roundOffsets: roundOffsets
    })));
    if (state.modifiersData.arrow != null) state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: 'absolute',
        adaptive: false,
        roundOffsets: roundOffsets
    })));
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-placement': state.placement
    });
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'computeStyles',
    enabled: true,
    phase: 'beforeWrite',
    fn: computeStyles,
    data: {}
};

},{"../enums.js":"qxiOM","../dom-utils/getOffsetParent.js":"jtCXH","../dom-utils/getWindow.js":"kY3PJ","../dom-utils/getDocumentElement.js":"dX7bp","../dom-utils/getComputedStyle.js":"cYNQK","../utils/getBasePlacement.js":"hArkE","../utils/getVariation.js":"lWBoq","../utils/math.js":"9Zwjh","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"lWBoq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getVariation(placement) {
    return placement.split('-')[1];
}
exports.default = getVariation;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"lGj0Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowJs = require("../dom-utils/getWindow.js"); // eslint-disable-next-line import/no-unused-modules
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var passive = {
    passive: true
};
function effect(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window = _getWindowJsDefault.default(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener('scroll', instance.update, passive);
    });
    if (resize) window.addEventListener('resize', instance.update, passive);
    return function() {
        if (scroll) scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener('scroll', instance.update, passive);
        });
        if (resize) window.removeEventListener('resize', instance.update, passive);
    };
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'eventListeners',
    enabled: true,
    phase: 'write',
    fn: function fn() {},
    effect: effect,
    data: {}
};

},{"../dom-utils/getWindow.js":"kY3PJ","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"bwIX2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getOppositePlacementJs = require("../utils/getOppositePlacement.js");
var _getOppositePlacementJsDefault = parcelHelpers.interopDefault(_getOppositePlacementJs);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getOppositeVariationPlacementJs = require("../utils/getOppositeVariationPlacement.js");
var _getOppositeVariationPlacementJsDefault = parcelHelpers.interopDefault(_getOppositeVariationPlacementJs);
var _detectOverflowJs = require("../utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _computeAutoPlacementJs = require("../utils/computeAutoPlacement.js");
var _computeAutoPlacementJsDefault = parcelHelpers.interopDefault(_computeAutoPlacementJs);
var _enumsJs = require("../enums.js");
var _getVariationJs = require("../utils/getVariation.js"); // eslint-disable-next-line import/no-unused-modules
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
function getExpandedFallbackPlacements(placement) {
    if (_getBasePlacementJsDefault.default(placement) === _enumsJs.auto) return [];
    var oppositePlacement = _getOppositePlacementJsDefault.default(placement);
    return [
        _getOppositeVariationPlacementJsDefault.default(placement),
        oppositePlacement,
        _getOppositeVariationPlacementJsDefault.default(oppositePlacement)
    ];
}
function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) return;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = _getBasePlacementJsDefault.default(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [
        _getOppositePlacementJsDefault.default(preferredPlacement)
    ] : getExpandedFallbackPlacements(preferredPlacement));
    var placements = [
        preferredPlacement
    ].concat(fallbackPlacements).reduce(function(acc, placement) {
        return acc.concat(_getBasePlacementJsDefault.default(placement) === _enumsJs.auto ? _computeAutoPlacementJsDefault.default(state, {
            placement: placement,
            boundary: boundary,
            rootBoundary: rootBoundary,
            padding: padding,
            flipVariations: flipVariations,
            allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements[0];
    for(var i = 0; i < placements.length; i++){
        var placement1 = placements[i];
        var _basePlacement = _getBasePlacementJsDefault.default(placement1);
        var isStartVariation = _getVariationJsDefault.default(placement1) === _enumsJs.start;
        var isVertical = [
            _enumsJs.top,
            _enumsJs.bottom
        ].indexOf(_basePlacement) >= 0;
        var len = isVertical ? 'width' : 'height';
        var overflow = _detectOverflowJsDefault.default(state, {
            placement: placement1,
            boundary: boundary,
            rootBoundary: rootBoundary,
            altBoundary: altBoundary,
            padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? _enumsJs.right : _enumsJs.left : isStartVariation ? _enumsJs.bottom : _enumsJs.top;
        if (referenceRect[len] > popperRect[len]) mainVariationSide = _getOppositePlacementJsDefault.default(mainVariationSide);
        var altVariationSide = _getOppositePlacementJsDefault.default(mainVariationSide);
        var checks = [];
        if (checkMainAxis) checks.push(overflow[_basePlacement] <= 0);
        if (checkAltAxis) checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        if (checks.every(function(check) {
            return check;
        })) {
            firstFittingPlacement = placement1;
            makeFallbackChecks = false;
            break;
        }
        checksMap.set(placement1, checks);
    }
    if (makeFallbackChecks) {
        // `2` may be desired in some cases â€“ research later
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop(_i) {
            var fittingPlacement = placements.find(function(placement) {
                var checks = checksMap.get(placement);
                if (checks) return checks.slice(0, _i).every(function(check) {
                    return check;
                });
            });
            if (fittingPlacement) {
                firstFittingPlacement = fittingPlacement;
                return "break";
            }
        };
        for(var _i1 = numberOfChecks; _i1 > 0; _i1--){
            var _ret = _loop(_i1);
            if (_ret === "break") break;
        }
    }
    if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
    }
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'flip',
    enabled: true,
    phase: 'main',
    fn: flip,
    requiresIfExists: [
        'offset'
    ],
    data: {
        _skip: false
    }
};

},{"../utils/getOppositePlacement.js":"3EoOM","../utils/getBasePlacement.js":"hArkE","../utils/getOppositeVariationPlacement.js":"6vYk7","../utils/detectOverflow.js":"bOwkj","../utils/computeAutoPlacement.js":"fMVLR","../enums.js":"qxiOM","../utils/getVariation.js":"lWBoq","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"3EoOM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var hash = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
};
function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash[matched];
    });
}
exports.default = getOppositePlacement;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"6vYk7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var hash = {
    start: 'end',
    end: 'start'
};
function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
        return hash[matched];
    });
}
exports.default = getOppositeVariationPlacement;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"bOwkj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getClippingRectJs = require("../dom-utils/getClippingRect.js");
var _getClippingRectJsDefault = parcelHelpers.interopDefault(_getClippingRectJs);
var _getDocumentElementJs = require("../dom-utils/getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getBoundingClientRectJs = require("../dom-utils/getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _computeOffsetsJs = require("./computeOffsets.js");
var _computeOffsetsJsDefault = parcelHelpers.interopDefault(_computeOffsetsJs);
var _rectToClientRectJs = require("./rectToClientRect.js");
var _rectToClientRectJsDefault = parcelHelpers.interopDefault(_rectToClientRectJs);
var _enumsJs = require("../enums.js");
var _instanceOfJs = require("../dom-utils/instanceOf.js");
var _mergePaddingObjectJs = require("./mergePaddingObject.js");
var _mergePaddingObjectJsDefault = parcelHelpers.interopDefault(_mergePaddingObjectJs);
var _expandToHashMapJs = require("./expandToHashMap.js"); // eslint-disable-next-line import/no-unused-modules
var _expandToHashMapJsDefault = parcelHelpers.interopDefault(_expandToHashMapJs);
function detectOverflow(state, options) {
    if (options === void 0) options = {};
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? _enumsJs.clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? _enumsJs.viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? _enumsJs.popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = _mergePaddingObjectJsDefault.default(typeof padding !== 'number' ? padding : _expandToHashMapJsDefault.default(padding, _enumsJs.basePlacements));
    var altContext = elementContext === _enumsJs.popper ? _enumsJs.reference : _enumsJs.popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = _getClippingRectJsDefault.default(_instanceOfJs.isElement(element) ? element : element.contextElement || _getDocumentElementJsDefault.default(state.elements.popper), boundary, rootBoundary);
    var referenceClientRect = _getBoundingClientRectJsDefault.default(state.elements.reference);
    var popperOffsets = _computeOffsetsJsDefault.default({
        reference: referenceClientRect,
        element: popperRect,
        strategy: 'absolute',
        placement: placement
    });
    var popperClientRect = _rectToClientRectJsDefault.default(Object.assign({}, popperRect, popperOffsets));
    var elementClientRect = elementContext === _enumsJs.popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
    // 0 or negative = within the clipping rect
    var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element
    if (elementContext === _enumsJs.popper && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key) {
            var multiply = [
                _enumsJs.right,
                _enumsJs.bottom
            ].indexOf(key) >= 0 ? 1 : -1;
            var axis = [
                _enumsJs.top,
                _enumsJs.bottom
            ].indexOf(key) >= 0 ? 'y' : 'x';
            overflowOffsets[key] += offset[axis] * multiply;
        });
    }
    return overflowOffsets;
}
exports.default = detectOverflow;

},{"../dom-utils/getClippingRect.js":"lfSy5","../dom-utils/getDocumentElement.js":"dX7bp","../dom-utils/getBoundingClientRect.js":"hyXFK","./computeOffsets.js":"7HSss","./rectToClientRect.js":"aCg1y","../enums.js":"qxiOM","../dom-utils/instanceOf.js":"1C4Db","./mergePaddingObject.js":"f6Q8J","./expandToHashMap.js":"lnSnJ","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"lfSy5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js");
var _getViewportRectJs = require("./getViewportRect.js");
var _getViewportRectJsDefault = parcelHelpers.interopDefault(_getViewportRectJs);
var _getDocumentRectJs = require("./getDocumentRect.js");
var _getDocumentRectJsDefault = parcelHelpers.interopDefault(_getDocumentRectJs);
var _listScrollParentsJs = require("./listScrollParents.js");
var _listScrollParentsJsDefault = parcelHelpers.interopDefault(_listScrollParentsJs);
var _getOffsetParentJs = require("./getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _instanceOfJs = require("./instanceOf.js");
var _getBoundingClientRectJs = require("./getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _rectToClientRectJs = require("../utils/rectToClientRect.js");
var _rectToClientRectJsDefault = parcelHelpers.interopDefault(_rectToClientRectJs);
var _mathJs = require("../utils/math.js");
function getInnerBoundingClientRect(element) {
    var rect = _getBoundingClientRectJsDefault.default(element);
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
    return clippingParent === _enumsJs.viewport ? _rectToClientRectJsDefault.default(_getViewportRectJsDefault.default(element)) : _instanceOfJs.isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : _rectToClientRectJsDefault.default(_getDocumentRectJsDefault.default(_getDocumentElementJsDefault.default(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`
function getClippingParents(element) {
    var clippingParents = _listScrollParentsJsDefault.default(_getParentNodeJsDefault.default(element));
    var canEscapeClipping = [
        'absolute',
        'fixed'
    ].indexOf(_getComputedStyleJsDefault.default(element).position) >= 0;
    var clipperElement = canEscapeClipping && _instanceOfJs.isHTMLElement(element) ? _getOffsetParentJsDefault.default(element) : element;
    if (!_instanceOfJs.isElement(clipperElement)) return [];
     // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414
    return clippingParents.filter(function(clippingParent) {
        return _instanceOfJs.isElement(clippingParent) && _containsJsDefault.default(clippingParent, clipperElement) && _getNodeNameJsDefault.default(clippingParent) !== 'body';
    });
} // Gets the maximum area that the element is visible in due to any number of
function getClippingRect(element, boundary, rootBoundary) {
    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
    var clippingParents = [].concat(mainClippingParents, [
        rootBoundary
    ]);
    var firstClippingParent = clippingParents[0];
    var clippingRect = clippingParents.reduce(function(accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent);
        accRect.top = _mathJs.max(rect.top, accRect.top);
        accRect.right = _mathJs.min(rect.right, accRect.right);
        accRect.bottom = _mathJs.min(rect.bottom, accRect.bottom);
        accRect.left = _mathJs.max(rect.left, accRect.left);
        return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
}
exports.default = getClippingRect;

},{"../enums.js":"qxiOM","./getViewportRect.js":"27oX5","./getDocumentRect.js":"gk86k","./listScrollParents.js":"4CRHK","./getOffsetParent.js":"jtCXH","./getDocumentElement.js":"dX7bp","./getComputedStyle.js":"cYNQK","./instanceOf.js":"1C4Db","./getBoundingClientRect.js":"hyXFK","./getParentNode.js":"575sS","./contains.js":"cdkv2","./getNodeName.js":"dO1na","../utils/rectToClientRect.js":"aCg1y","../utils/math.js":"9Zwjh","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"27oX5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getWindowScrollBarXJs = require("./getWindowScrollBarX.js");
var _getWindowScrollBarXJsDefault = parcelHelpers.interopDefault(_getWindowScrollBarXJs);
function getViewportRect(element) {
    var win = _getWindowJsDefault.default(element);
    var html = _getDocumentElementJsDefault.default(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
    // can be obscured underneath it.
    // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
    // if it isn't open, so if this isn't available, the popper will be detected
    // to overflow the bottom of the screen too early.
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
        // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
        // errors due to floating point numbers, so we need to check precision.
        // Safari returns a number <= 0, usually < -1 when pinch-zoomed
        // Feature detection fails in mobile emulation mode in Chrome.
        // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
        // 0.001
        // Fallback here: "Not Safari" userAgent
        if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
        }
    }
    return {
        width: width,
        height: height,
        x: x + _getWindowScrollBarXJsDefault.default(element),
        y: y
    };
}
exports.default = getViewportRect;

},{"./getWindow.js":"kY3PJ","./getDocumentElement.js":"dX7bp","./getWindowScrollBarX.js":"k8Ha2","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"k8Ha2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getBoundingClientRectJs = require("./getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getWindowScrollJs = require("./getWindowScroll.js");
var _getWindowScrollJsDefault = parcelHelpers.interopDefault(_getWindowScrollJs);
function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    // Popper 1 is broken in this case and never had a bug report so let's assume
    // it's not an issue. I don't think anyone ever specifies width on <html>
    // anyway.
    // Browsers where the left scrollbar doesn't cause an issue report `0` for
    // this (e.g. Edge 2019, IE11, Safari)
    return _getBoundingClientRectJsDefault.default(_getDocumentElementJsDefault.default(element)).left + _getWindowScrollJsDefault.default(element).scrollLeft;
}
exports.default = getWindowScrollBarX;

},{"./getBoundingClientRect.js":"hyXFK","./getDocumentElement.js":"dX7bp","./getWindowScroll.js":"8B9D1","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"8B9D1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
function getWindowScroll(node) {
    var win = _getWindowJsDefault.default(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
    };
}
exports.default = getWindowScroll;

},{"./getWindow.js":"kY3PJ","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"gk86k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _getWindowScrollBarXJs = require("./getWindowScrollBarX.js");
var _getWindowScrollBarXJsDefault = parcelHelpers.interopDefault(_getWindowScrollBarXJs);
var _getWindowScrollJs = require("./getWindowScroll.js");
var _getWindowScrollJsDefault = parcelHelpers.interopDefault(_getWindowScrollJs);
var _mathJs = require("../utils/math.js"); // Gets the entire size of the scrollable document area, even extending outside
function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = _getDocumentElementJsDefault.default(element);
    var winScroll = _getWindowScrollJsDefault.default(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = _mathJs.max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = _mathJs.max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + _getWindowScrollBarXJsDefault.default(element);
    var y = -winScroll.scrollTop;
    if (_getComputedStyleJsDefault.default(body || html).direction === 'rtl') x += _mathJs.max(html.clientWidth, body ? body.clientWidth : 0) - width;
    return {
        width: width,
        height: height,
        x: x,
        y: y
    };
}
exports.default = getDocumentRect;

},{"./getDocumentElement.js":"dX7bp","./getComputedStyle.js":"cYNQK","./getWindowScrollBarX.js":"k8Ha2","./getWindowScroll.js":"8B9D1","../utils/math.js":"9Zwjh","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"4CRHK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getScrollParentJs = require("./getScrollParent.js");
var _getScrollParentJsDefault = parcelHelpers.interopDefault(_getScrollParentJs);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _isScrollParentJs = require("./isScrollParent.js");
var _isScrollParentJsDefault = parcelHelpers.interopDefault(_isScrollParentJs);
function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) list = [];
    var scrollParent = _getScrollParentJsDefault.default(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = _getWindowJsDefault.default(scrollParent);
    var target = isBody ? [
        win
    ].concat(win.visualViewport || [], _isScrollParentJsDefault.default(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat(listScrollParents(_getParentNodeJsDefault.default(target)));
}
exports.default = listScrollParents;

},{"./getScrollParent.js":"fuhVK","./getParentNode.js":"575sS","./getWindow.js":"kY3PJ","./isScrollParent.js":"7nATc","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"fuhVK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
var _isScrollParentJs = require("./isScrollParent.js");
var _isScrollParentJsDefault = parcelHelpers.interopDefault(_isScrollParentJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _instanceOfJs = require("./instanceOf.js");
function getScrollParent(node) {
    if ([
        'html',
        'body',
        '#document'
    ].indexOf(_getNodeNameJsDefault.default(node)) >= 0) // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
    if (_instanceOfJs.isHTMLElement(node) && _isScrollParentJsDefault.default(node)) return node;
    return getScrollParent(_getParentNodeJsDefault.default(node));
}
exports.default = getScrollParent;

},{"./getParentNode.js":"575sS","./isScrollParent.js":"7nATc","./getNodeName.js":"dO1na","./instanceOf.js":"1C4Db","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"7nATc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
function isScrollParent(element) {
    // Firefox wants us to check `-x` and `-y` variations as well
    var _getComputedStyle = _getComputedStyleJsDefault.default(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
exports.default = isScrollParent;

},{"./getComputedStyle.js":"cYNQK","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"aCg1y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function rectToClientRect(rect) {
    return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
    });
}
exports.default = rectToClientRect;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"7HSss":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getBasePlacementJs = require("./getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getVariationJs = require("./getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _getMainAxisFromPlacementJs = require("./getMainAxisFromPlacement.js");
var _getMainAxisFromPlacementJsDefault = parcelHelpers.interopDefault(_getMainAxisFromPlacementJs);
var _enumsJs = require("../enums.js");
function computeOffsets(_ref) {
    var reference = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? _getBasePlacementJsDefault.default(placement) : null;
    var variation = placement ? _getVariationJsDefault.default(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;
    switch(basePlacement){
        case _enumsJs.top:
            offsets = {
                x: commonX,
                y: reference.y - element.height
            };
            break;
        case _enumsJs.bottom:
            offsets = {
                x: commonX,
                y: reference.y + reference.height
            };
            break;
        case _enumsJs.right:
            offsets = {
                x: reference.x + reference.width,
                y: commonY
            };
            break;
        case _enumsJs.left:
            offsets = {
                x: reference.x - element.width,
                y: commonY
            };
            break;
        default:
            offsets = {
                x: reference.x,
                y: reference.y
            };
    }
    var mainAxis = basePlacement ? _getMainAxisFromPlacementJsDefault.default(basePlacement) : null;
    if (mainAxis != null) {
        var len = mainAxis === 'y' ? 'height' : 'width';
        switch(variation){
            case _enumsJs.start:
                offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
                break;
            case _enumsJs.end:
                offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
                break;
            default:
        }
    }
    return offsets;
}
exports.default = computeOffsets;

},{"./getBasePlacement.js":"hArkE","./getVariation.js":"lWBoq","./getMainAxisFromPlacement.js":"4EL78","../enums.js":"qxiOM","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"fMVLR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getVariationJs = require("./getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _enumsJs = require("../enums.js");
var _detectOverflowJs = require("./detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _getBasePlacementJs = require("./getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
function computeAutoPlacement(state, options) {
    if (options === void 0) options = {};
    var _options = options, placement1 = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enumsJs.placements : _options$allowedAutoP;
    var variation = _getVariationJsDefault.default(placement1);
    var placements = variation ? flipVariations ? _enumsJs.variationPlacements : _enumsJs.variationPlacements.filter(function(placement) {
        return _getVariationJsDefault.default(placement) === variation;
    }) : _enumsJs.basePlacements;
    var allowedPlacements = placements.filter(function(placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
    });
    if (allowedPlacements.length === 0) {
        allowedPlacements = placements;
        console.error([
            'Popper: The `allowedAutoPlacements` option did not allow any',
            'placements. Ensure the `placement` option matches the variation',
            'of the allowed placements.',
            'For example, "auto" cannot be used to allow "bottom-start".',
            'Use "auto-start" instead.'
        ].join(' '));
    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...
    var overflows = allowedPlacements.reduce(function(acc, placement) {
        acc[placement] = _detectOverflowJsDefault.default(state, {
            placement: placement,
            boundary: boundary,
            rootBoundary: rootBoundary,
            padding: padding
        })[_getBasePlacementJsDefault.default(placement)];
        return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
        return overflows[a] - overflows[b];
    });
}
exports.default = computeAutoPlacement;

},{"./getVariation.js":"lWBoq","../enums.js":"qxiOM","./detectOverflow.js":"bOwkj","./getBasePlacement.js":"hArkE","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"jeIWi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js");
var _detectOverflowJs = require("../utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) preventedOffsets = {
        x: 0,
        y: 0
    };
    return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
    };
}
function isAnySideFullyClipped(overflow) {
    return [
        _enumsJs.top,
        _enumsJs.right,
        _enumsJs.bottom,
        _enumsJs.left
    ].some(function(side) {
        return overflow[side] >= 0;
    });
}
function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = _detectOverflowJsDefault.default(state, {
        elementContext: 'reference'
    });
    var popperAltOverflow = _detectOverflowJsDefault.default(state, {
        altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-reference-hidden': isReferenceHidden,
        'data-popper-escaped': hasPopperEscaped
    });
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'hide',
    enabled: true,
    phase: 'main',
    requiresIfExists: [
        'preventOverflow'
    ],
    fn: hide
};

},{"../enums.js":"qxiOM","../utils/detectOverflow.js":"bOwkj","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"4yTnb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distanceAndSkiddingToXY", ()=>distanceAndSkiddingToXY
);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _enumsJs = require("../enums.js"); // eslint-disable-next-line import/no-unused-modules
function distanceAndSkiddingToXY(placement, rects, offset1) {
    var basePlacement = _getBasePlacementJsDefault.default(placement);
    var invertDistance = [
        _enumsJs.left,
        _enumsJs.top
    ].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset1 === 'function' ? offset1(Object.assign({}, rects, {
        placement: placement
    })) : offset1, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [
        _enumsJs.left,
        _enumsJs.right
    ].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
    } : {
        x: skidding,
        y: distance
    };
}
function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [
        0,
        0
    ] : _options$offset;
    var data = _enumsJs.placements.reduce(function(acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
        return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'offset',
    enabled: true,
    phase: 'main',
    requires: [
        'popperOffsets'
    ],
    fn: offset
};

},{"../utils/getBasePlacement.js":"hArkE","../enums.js":"qxiOM","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"jCAMm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _computeOffsetsJs = require("../utils/computeOffsets.js");
var _computeOffsetsJsDefault = parcelHelpers.interopDefault(_computeOffsetsJs);
function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    // Offsets are the actual position the popper needs to have to be
    // properly positioned near its reference element
    // This is the most basic placement, and will be adjusted by
    // the modifiers in the next step
    state.modifiersData[name] = _computeOffsetsJsDefault.default({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: 'absolute',
        placement: state.placement
    });
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'popperOffsets',
    enabled: true,
    phase: 'read',
    fn: popperOffsets,
    data: {}
};

},{"../utils/computeOffsets.js":"7HSss","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"gAFAP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js");
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getMainAxisFromPlacementJs = require("../utils/getMainAxisFromPlacement.js");
var _getMainAxisFromPlacementJsDefault = parcelHelpers.interopDefault(_getMainAxisFromPlacementJs);
var _getAltAxisJs = require("../utils/getAltAxis.js");
var _getAltAxisJsDefault = parcelHelpers.interopDefault(_getAltAxisJs);
var _withinJs = require("../utils/within.js");
var _getLayoutRectJs = require("../dom-utils/getLayoutRect.js");
var _getLayoutRectJsDefault = parcelHelpers.interopDefault(_getLayoutRectJs);
var _getOffsetParentJs = require("../dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _detectOverflowJs = require("../utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _getVariationJs = require("../utils/getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _getFreshSideObjectJs = require("../utils/getFreshSideObject.js");
var _getFreshSideObjectJsDefault = parcelHelpers.interopDefault(_getFreshSideObjectJs);
var _mathJs = require("../utils/math.js");
function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = _detectOverflowJsDefault.default(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
    });
    var basePlacement = _getBasePlacementJsDefault.default(state.placement);
    var variation = _getVariationJsDefault.default(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = _getMainAxisFromPlacementJsDefault.default(basePlacement);
    var altAxis = _getAltAxisJsDefault.default(mainAxis);
    var popperOffsets = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
    } : Object.assign({
        mainAxis: 0,
        altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
        x: 0,
        y: 0
    };
    if (!popperOffsets) return;
    if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === 'y' ? _enumsJs.top : _enumsJs.left;
        var altSide = mainAxis === 'y' ? _enumsJs.bottom : _enumsJs.right;
        var len = mainAxis === 'y' ? 'height' : 'width';
        var offset = popperOffsets[mainAxis];
        var min = offset + overflow[mainSide];
        var max = offset - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === _enumsJs.start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === _enumsJs.start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds
        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? _getLayoutRectJsDefault.default(arrowElement) : {
            width: 0,
            height: 0
        };
        var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : _getFreshSideObjectJsDefault.default();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)
        var arrowLen = _withinJs.within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && _getOffsetParentJsDefault.default(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset + maxOffset - offsetModifierValue;
        var preventedOffset = _withinJs.within(tether ? _mathJs.min(min, tetherMin) : min, offset, tether ? _mathJs.max(max, tetherMax) : max);
        popperOffsets[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset;
    }
    if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === 'x' ? _enumsJs.top : _enumsJs.left;
        var _altSide = mainAxis === 'x' ? _enumsJs.bottom : _enumsJs.right;
        var _offset = popperOffsets[altAxis];
        var _len = altAxis === 'y' ? 'height' : 'width';
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [
            _enumsJs.top,
            _enumsJs.left
        ].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? _withinJs.withinMaxClamp(_tetherMin, _offset, _tetherMax) : _withinJs.within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'preventOverflow',
    enabled: true,
    phase: 'main',
    fn: preventOverflow,
    requiresIfExists: [
        'offset'
    ]
};

},{"../enums.js":"qxiOM","../utils/getBasePlacement.js":"hArkE","../utils/getMainAxisFromPlacement.js":"4EL78","../utils/getAltAxis.js":"iOHpc","../utils/within.js":"fpOgl","../dom-utils/getLayoutRect.js":"8ol2m","../dom-utils/getOffsetParent.js":"jtCXH","../utils/detectOverflow.js":"bOwkj","../utils/getVariation.js":"lWBoq","../utils/getFreshSideObject.js":"lXEWs","../utils/math.js":"9Zwjh","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"iOHpc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getAltAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
}
exports.default = getAltAxis;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"g1Jyk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "popperGenerator", ()=>popperGenerator
);
parcelHelpers.export(exports, "createPopper", ()=>createPopper
);
parcelHelpers.export(exports, "detectOverflow", ()=>_detectOverflowJsDefault.default
);
var _getCompositeRectJs = require("./dom-utils/getCompositeRect.js");
var _getCompositeRectJsDefault = parcelHelpers.interopDefault(_getCompositeRectJs);
var _getLayoutRectJs = require("./dom-utils/getLayoutRect.js");
var _getLayoutRectJsDefault = parcelHelpers.interopDefault(_getLayoutRectJs);
var _listScrollParentsJs = require("./dom-utils/listScrollParents.js");
var _listScrollParentsJsDefault = parcelHelpers.interopDefault(_listScrollParentsJs);
var _getOffsetParentJs = require("./dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _getComputedStyleJs = require("./dom-utils/getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _orderModifiersJs = require("./utils/orderModifiers.js");
var _orderModifiersJsDefault = parcelHelpers.interopDefault(_orderModifiersJs);
var _debounceJs = require("./utils/debounce.js");
var _debounceJsDefault = parcelHelpers.interopDefault(_debounceJs);
var _validateModifiersJs = require("./utils/validateModifiers.js");
var _validateModifiersJsDefault = parcelHelpers.interopDefault(_validateModifiersJs);
var _uniqueByJs = require("./utils/uniqueBy.js");
var _uniqueByJsDefault = parcelHelpers.interopDefault(_uniqueByJs);
var _getBasePlacementJs = require("./utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _mergeByNameJs = require("./utils/mergeByName.js");
var _mergeByNameJsDefault = parcelHelpers.interopDefault(_mergeByNameJs);
var _detectOverflowJs = require("./utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _instanceOfJs = require("./dom-utils/instanceOf.js");
var _enumsJs = require("./enums.js");
var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
    placement: 'bottom',
    modifiers: [],
    strategy: 'absolute'
};
function areValidElements() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
    return !args.some(function(element) {
        return !(element && typeof element.getBoundingClientRect === 'function');
    });
}
function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) generatorOptions = {};
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper(reference1, popper1, options1) {
        if (options1 === void 0) options1 = defaultOptions;
        var state1 = {
            placement: 'bottom',
            orderedModifiers: [],
            options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
            modifiersData: {},
            elements: {
                reference: reference1,
                popper: popper1
            },
            attributes: {},
            styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
            state: state1,
            setOptions: function setOptions(setOptionsAction) {
                var options = typeof setOptionsAction === 'function' ? setOptionsAction(state1.options) : setOptionsAction;
                cleanupModifierEffects();
                state1.options = Object.assign({}, defaultOptions, state1.options, options);
                state1.scrollParents = {
                    reference: _instanceOfJs.isElement(reference1) ? _listScrollParentsJsDefault.default(reference1) : reference1.contextElement ? _listScrollParentsJsDefault.default(reference1.contextElement) : [],
                    popper: _listScrollParentsJsDefault.default(popper1)
                }; // Orders the modifiers based on their dependencies and `phase`
                // properties
                var orderedModifiers = _orderModifiersJsDefault.default(_mergeByNameJsDefault.default([].concat(defaultModifiers, state1.options.modifiers))); // Strip out disabled modifiers
                state1.orderedModifiers = orderedModifiers.filter(function(m) {
                    return m.enabled;
                }); // Validate the provided modifiers so that the consumer will get warned
                var modifiers = _uniqueByJsDefault.default([].concat(orderedModifiers, state1.options.modifiers), function(_ref) {
                    var name = _ref.name;
                    return name;
                });
                _validateModifiersJsDefault.default(modifiers);
                if (_getBasePlacementJsDefault.default(state1.options.placement) === _enumsJs.auto) {
                    var flipModifier = state1.orderedModifiers.find(function(_ref2) {
                        var name = _ref2.name;
                        return name === 'flip';
                    });
                    if (!flipModifier) console.error([
                        'Popper: "auto" placements require the "flip" modifier be',
                        'present and enabled to work.'
                    ].join(' '));
                }
                var _getComputedStyle = _getComputedStyleJsDefault.default(popper1), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
                // cause bugs with positioning, so we'll warn the consumer
                if ([
                    marginTop,
                    marginRight,
                    marginBottom,
                    marginLeft
                ].some(function(margin) {
                    return parseFloat(margin);
                })) console.warn([
                    'Popper: CSS "margin" styles cannot be used to apply padding',
                    'between the popper and its reference element or boundary.',
                    'To replicate margin, use the `offset` modifier, as well as',
                    'the `padding` option in the `preventOverflow` and `flip`',
                    'modifiers.'
                ].join(' '));
                runModifierEffects();
                return instance.update();
            },
            // Sync update â€“ it will always be executed, even if not necessary. This
            // is useful for low frequency updates where sync behavior simplifies the
            // logic.
            // For high frequency updates (e.g. `resize` and `scroll` events), always
            // prefer the async Popper#update method
            forceUpdate: function forceUpdate() {
                if (isDestroyed) return;
                var _state$elements = state1.elements, reference = _state$elements.reference, popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
                // anymore
                if (!areValidElements(reference, popper)) {
                    console.error(INVALID_ELEMENT_ERROR);
                    return;
                } // Store the reference and popper rects to be read by modifiers
                state1.rects = {
                    reference: _getCompositeRectJsDefault.default(reference, _getOffsetParentJsDefault.default(popper), state1.options.strategy === 'fixed'),
                    popper: _getLayoutRectJsDefault.default(popper)
                }; // Modifiers have the ability to reset the current update cycle. The
                // most common use case for this is the `flip` modifier changing the
                // placement, which then needs to re-run all the modifiers, because the
                // logic was previously ran for the previous placement and is therefore
                // stale/incorrect
                state1.reset = false;
                state1.placement = state1.options.placement; // On each update cycle, the `modifiersData` property for each modifier
                // is filled with the initial data specified by the modifier. This means
                // it doesn't persist and is fresh on each update.
                // To ensure persistent data, use `${name}#persistent`
                state1.orderedModifiers.forEach(function(modifier) {
                    return state1.modifiersData[modifier.name] = Object.assign({}, modifier.data);
                });
                var __debug_loops__ = 0;
                for(var index = 0; index < state1.orderedModifiers.length; index++){
                    __debug_loops__ += 1;
                    if (__debug_loops__ > 100) {
                        console.error(INFINITE_LOOP_ERROR);
                        break;
                    }
                    if (state1.reset === true) {
                        state1.reset = false;
                        index = -1;
                        continue;
                    }
                    var _state$orderedModifie = state1.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
                    if (typeof fn === 'function') state1 = fn({
                        state: state1,
                        options: _options,
                        name: name,
                        instance: instance
                    }) || state1;
                }
            },
            // Async and optimistically optimized update â€“ it will not be executed if
            // not necessary (debounced to run at most once-per-tick)
            update: _debounceJsDefault.default(function() {
                return new Promise(function(resolve) {
                    instance.forceUpdate();
                    resolve(state1);
                });
            }),
            destroy: function destroy() {
                cleanupModifierEffects();
                isDestroyed = true;
            }
        };
        if (!areValidElements(reference1, popper1)) {
            console.error(INVALID_ELEMENT_ERROR);
            return instance;
        }
        instance.setOptions(options1).then(function(state) {
            if (!isDestroyed && options1.onFirstUpdate) options1.onFirstUpdate(state);
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.
        function runModifierEffects() {
            state1.orderedModifiers.forEach(function(_ref3) {
                var name = _ref3.name, _ref3$options = _ref3.options, options = _ref3$options === void 0 ? {} : _ref3$options, effect = _ref3.effect;
                if (typeof effect === 'function') {
                    var cleanupFn = effect({
                        state: state1,
                        name: name,
                        instance: instance,
                        options: options
                    });
                    var noopFn = function noopFn() {};
                    effectCleanupFns.push(cleanupFn || noopFn);
                }
            });
        }
        function cleanupModifierEffects() {
            effectCleanupFns.forEach(function(fn) {
                return fn();
            });
            effectCleanupFns = [];
        }
        return instance;
    };
}
var createPopper = /*#__PURE__*/ popperGenerator(); // eslint-disable-next-line import/no-unused-modules

},{"./dom-utils/getCompositeRect.js":"itWMz","./dom-utils/getLayoutRect.js":"8ol2m","./dom-utils/listScrollParents.js":"4CRHK","./dom-utils/getOffsetParent.js":"jtCXH","./dom-utils/getComputedStyle.js":"cYNQK","./utils/orderModifiers.js":"hUXjz","./utils/debounce.js":"6x6UT","./utils/validateModifiers.js":"gBqCj","./utils/uniqueBy.js":"9oMQk","./utils/getBasePlacement.js":"hArkE","./utils/mergeByName.js":"eNYZ6","./utils/detectOverflow.js":"bOwkj","./dom-utils/instanceOf.js":"1C4Db","./enums.js":"qxiOM","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"itWMz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getBoundingClientRectJs = require("./getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _getNodeScrollJs = require("./getNodeScroll.js");
var _getNodeScrollJsDefault = parcelHelpers.interopDefault(_getNodeScrollJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _instanceOfJs = require("./instanceOf.js");
var _getWindowScrollBarXJs = require("./getWindowScrollBarX.js");
var _getWindowScrollBarXJsDefault = parcelHelpers.interopDefault(_getWindowScrollBarXJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _isScrollParentJs = require("./isScrollParent.js");
var _isScrollParentJsDefault = parcelHelpers.interopDefault(_isScrollParentJs);
var _mathJs = require("../utils/math.js");
function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = _mathJs.round(rect.width) / element.offsetWidth || 1;
    var scaleY = _mathJs.round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) isFixed = false;
    var isOffsetParentAnElement = _instanceOfJs.isHTMLElement(offsetParent);
    var offsetParentIsScaled = _instanceOfJs.isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = _getDocumentElementJsDefault.default(offsetParent);
    var rect = _getBoundingClientRectJsDefault.default(elementOrVirtualElement, offsetParentIsScaled);
    var scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    var offsets = {
        x: 0,
        y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (_getNodeNameJsDefault.default(offsetParent) !== 'body' || _isScrollParentJsDefault.default(documentElement)) scroll = _getNodeScrollJsDefault.default(offsetParent);
        if (_instanceOfJs.isHTMLElement(offsetParent)) {
            offsets = _getBoundingClientRectJsDefault.default(offsetParent, true);
            offsets.x += offsetParent.clientLeft;
            offsets.y += offsetParent.clientTop;
        } else if (documentElement) offsets.x = _getWindowScrollBarXJsDefault.default(documentElement);
    }
    return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
    };
}
exports.default = getCompositeRect;

},{"./getBoundingClientRect.js":"hyXFK","./getNodeScroll.js":"kDmXG","./getNodeName.js":"dO1na","./instanceOf.js":"1C4Db","./getWindowScrollBarX.js":"k8Ha2","./getDocumentElement.js":"dX7bp","./isScrollParent.js":"7nATc","../utils/math.js":"9Zwjh","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"kDmXG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowScrollJs = require("./getWindowScroll.js");
var _getWindowScrollJsDefault = parcelHelpers.interopDefault(_getWindowScrollJs);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _instanceOfJs = require("./instanceOf.js");
var _getHTMLElementScrollJs = require("./getHTMLElementScroll.js");
var _getHTMLElementScrollJsDefault = parcelHelpers.interopDefault(_getHTMLElementScrollJs);
function getNodeScroll(node) {
    if (node === _getWindowJsDefault.default(node) || !_instanceOfJs.isHTMLElement(node)) return _getWindowScrollJsDefault.default(node);
    else return _getHTMLElementScrollJsDefault.default(node);
}
exports.default = getNodeScroll;

},{"./getWindowScroll.js":"8B9D1","./getWindow.js":"kY3PJ","./instanceOf.js":"1C4Db","./getHTMLElementScroll.js":"lLsYN","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"lLsYN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getHTMLElementScroll(element) {
    return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
    };
}
exports.default = getHTMLElementScroll;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"hUXjz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js"); // source: https://stackoverflow.com/questions/49875255
function order(modifiers) {
    var map = new Map();
    var visited = new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
        map.set(modifier.name, modifier);
    }); // On visiting object, check for its dependencies and visit them recursively
    function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
            if (!visited.has(dep)) {
                var depModifier = map.get(dep);
                if (depModifier) sort(depModifier);
            }
        });
        result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) // check for visited object
        sort(modifier);
    });
    return result;
}
function orderModifiers(modifiers) {
    // order based on dependencies
    var orderedModifiers = order(modifiers); // order based on phase
    return _enumsJs.modifierPhases.reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
            return modifier.phase === phase;
        }));
    }, []);
}
exports.default = orderModifiers;

},{"../enums.js":"qxiOM","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"6x6UT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function debounce(fn) {
    var pending;
    return function() {
        if (!pending) pending = new Promise(function(resolve) {
            Promise.resolve().then(function() {
                pending = undefined;
                resolve(fn());
            });
        });
        return pending;
    };
}
exports.default = debounce;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"gBqCj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _formatJs = require("./format.js");
var _formatJsDefault = parcelHelpers.interopDefault(_formatJs);
var _enumsJs = require("../enums.js");
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = [
    'name',
    'enabled',
    'phase',
    'fn',
    'effect',
    'requires',
    'options'
];
function validateModifiers(modifiers) {
    modifiers.forEach(function(modifier) {
        [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
        .filter(function(value, index, self) {
            return self.indexOf(value) === index;
        }).forEach(function(key) {
            switch(key){
                case 'name':
                    if (typeof modifier.name !== 'string') console.error(_formatJsDefault.default(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
                    break;
                case 'enabled':
                    if (typeof modifier.enabled !== 'boolean') console.error(_formatJsDefault.default(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
                    break;
                case 'phase':
                    if (_enumsJs.modifierPhases.indexOf(modifier.phase) < 0) console.error(_formatJsDefault.default(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + _enumsJs.modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
                    break;
                case 'fn':
                    if (typeof modifier.fn !== 'function') console.error(_formatJsDefault.default(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
                    break;
                case 'effect':
                    if (modifier.effect != null && typeof modifier.effect !== 'function') console.error(_formatJsDefault.default(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
                    break;
                case 'requires':
                    if (modifier.requires != null && !Array.isArray(modifier.requires)) console.error(_formatJsDefault.default(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
                    break;
                case 'requiresIfExists':
                    if (!Array.isArray(modifier.requiresIfExists)) console.error(_formatJsDefault.default(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
                    break;
                case 'options':
                case 'data':
                    break;
                default:
                    console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function(s) {
                        return "\"" + s + "\"";
                    }).join(', ') + "; but \"" + key + "\" was provided.");
            }
            modifier.requires && modifier.requires.forEach(function(requirement) {
                if (modifiers.find(function(mod) {
                    return mod.name === requirement;
                }) == null) console.error(_formatJsDefault.default(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
            });
        });
    });
}
exports.default = validateModifiers;

},{"./format.js":"9qXIw","../enums.js":"qxiOM","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"9qXIw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function format(str) {
    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
    return [].concat(args).reduce(function(p, c) {
        return p.replace(/%s/, c);
    }, str);
}
exports.default = format;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"9oMQk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function uniqueBy(arr, fn) {
    var identifiers = new Set();
    return arr.filter(function(item) {
        var identifier = fn(item);
        if (!identifiers.has(identifier)) {
            identifiers.add(identifier);
            return true;
        }
    });
}
exports.default = uniqueBy;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"eNYZ6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function mergeByName(modifiers) {
    var merged1 = modifiers.reduce(function(merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
            options: Object.assign({}, existing.options, current.options),
            data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
    }, {}); // IE11 does not support Object.values
    return Object.keys(merged1).map(function(key) {
        return merged1[key];
    });
}
exports.default = mergeByName;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"dg9kH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createPopper", ()=>createPopper
) // eslint-disable-next-line import/no-unused-modules
;
parcelHelpers.export(exports, "popperGenerator", ()=>_createPopperJs.popperGenerator
);
parcelHelpers.export(exports, "defaultModifiers", ()=>defaultModifiers
);
parcelHelpers.export(exports, "detectOverflow", ()=>_createPopperJs.detectOverflow
);
parcelHelpers.export(exports, "createPopperLite", ()=>_popperLiteJs.createPopper
) // eslint-disable-next-line import/no-unused-modules
;
var _createPopperJs = require("./createPopper.js");
var _eventListenersJs = require("./modifiers/eventListeners.js");
var _eventListenersJsDefault = parcelHelpers.interopDefault(_eventListenersJs);
var _popperOffsetsJs = require("./modifiers/popperOffsets.js");
var _popperOffsetsJsDefault = parcelHelpers.interopDefault(_popperOffsetsJs);
var _computeStylesJs = require("./modifiers/computeStyles.js");
var _computeStylesJsDefault = parcelHelpers.interopDefault(_computeStylesJs);
var _applyStylesJs = require("./modifiers/applyStyles.js");
var _applyStylesJsDefault = parcelHelpers.interopDefault(_applyStylesJs);
var _offsetJs = require("./modifiers/offset.js");
var _offsetJsDefault = parcelHelpers.interopDefault(_offsetJs);
var _flipJs = require("./modifiers/flip.js");
var _flipJsDefault = parcelHelpers.interopDefault(_flipJs);
var _preventOverflowJs = require("./modifiers/preventOverflow.js");
var _preventOverflowJsDefault = parcelHelpers.interopDefault(_preventOverflowJs);
var _arrowJs = require("./modifiers/arrow.js");
var _arrowJsDefault = parcelHelpers.interopDefault(_arrowJs);
var _hideJs = require("./modifiers/hide.js");
var _hideJsDefault = parcelHelpers.interopDefault(_hideJs);
var _popperLiteJs = require("./popper-lite.js");
var _indexJs = require("./modifiers/index.js");
parcelHelpers.exportAll(_indexJs, exports);
var defaultModifiers = [
    _eventListenersJsDefault.default,
    _popperOffsetsJsDefault.default,
    _computeStylesJsDefault.default,
    _applyStylesJsDefault.default,
    _offsetJsDefault.default,
    _flipJsDefault.default,
    _preventOverflowJsDefault.default,
    _arrowJsDefault.default,
    _hideJsDefault.default
];
var createPopper = /*#__PURE__*/ _createPopperJs.popperGenerator({
    defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

},{"./createPopper.js":"g1Jyk","./modifiers/eventListeners.js":"lGj0Q","./modifiers/popperOffsets.js":"jCAMm","./modifiers/computeStyles.js":"3aFNf","./modifiers/applyStyles.js":"cPbqH","./modifiers/offset.js":"4yTnb","./modifiers/flip.js":"bwIX2","./modifiers/preventOverflow.js":"gAFAP","./modifiers/arrow.js":"6eCC1","./modifiers/hide.js":"jeIWi","./popper-lite.js":"bxdRR","./modifiers/index.js":"bSOA6","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"bxdRR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createPopper", ()=>createPopper
);
parcelHelpers.export(exports, "popperGenerator", ()=>_createPopperJs.popperGenerator
);
parcelHelpers.export(exports, "defaultModifiers", ()=>defaultModifiers
);
parcelHelpers.export(exports, "detectOverflow", ()=>_createPopperJs.detectOverflow
);
var _createPopperJs = require("./createPopper.js");
var _eventListenersJs = require("./modifiers/eventListeners.js");
var _eventListenersJsDefault = parcelHelpers.interopDefault(_eventListenersJs);
var _popperOffsetsJs = require("./modifiers/popperOffsets.js");
var _popperOffsetsJsDefault = parcelHelpers.interopDefault(_popperOffsetsJs);
var _computeStylesJs = require("./modifiers/computeStyles.js");
var _computeStylesJsDefault = parcelHelpers.interopDefault(_computeStylesJs);
var _applyStylesJs = require("./modifiers/applyStyles.js");
var _applyStylesJsDefault = parcelHelpers.interopDefault(_applyStylesJs);
var defaultModifiers = [
    _eventListenersJsDefault.default,
    _popperOffsetsJsDefault.default,
    _computeStylesJsDefault.default,
    _applyStylesJsDefault.default
];
var createPopper = /*#__PURE__*/ _createPopperJs.popperGenerator({
    defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

},{"./createPopper.js":"g1Jyk","./modifiers/eventListeners.js":"lGj0Q","./modifiers/popperOffsets.js":"jCAMm","./modifiers/computeStyles.js":"3aFNf","./modifiers/applyStyles.js":"cPbqH","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"ixfcR":[function(require,module,exports) {
//
// Apex line chart
//
'use strict';
var apexCharts = require('apexcharts');
var themeStyles = require('../theme-styles');
function apexLineChart() {
    this.init = function(chartEl) {
        var styles = new themeStyles();
        var colorPalette = [
            styles.colors().theme.primary,
            styles.colors().theme.tertiary,
            styles.colors().theme.secondary,
            styles.colors().theme.warning
        ];
        function init($this) {
            var options = {
                chart: {
                    zoom: {
                        enabled: false
                    },
                    toolbar: {
                        show: false
                    },
                    shadow: {
                        enabled: false
                    }
                },
                colors: colorPalette,
                stroke: {
                    width: 4,
                    curve: 'smooth'
                },
                series: [
                    {
                        name: 'Ongoing',
                        type: 'line',
                        data: [
                            30,
                            50,
                            70,
                            90,
                            80,
                            70,
                            90,
                            120,
                            100,
                            120,
                            140
                        ]
                    },
                    {
                        name: 'Finished',
                        type: 'line',
                        data: [
                            50,
                            70,
                            30,
                            20,
                            10,
                            10,
                            40,
                            100,
                            90,
                            100,
                            120
                        ]
                    }
                ],
                markers: {
                    size: 0
                },
                xaxis: {
                    axisBorder: {
                        show: false
                    },
                    axisTicks: {
                        show: false
                    },
                    categories: [
                        'Jan',
                        'Feb',
                        'Mar',
                        'Apr',
                        'May',
                        'Jun',
                        'Jul',
                        'Aug',
                        'Sep',
                        'Oct',
                        'Nov',
                        'Dec'
                    ],
                    labels: {
                        style: {
                            colors: '#999',
                            fontSize: '13px',
                            fontFamily: '#333',
                            cssClass: 'apexcharts-xaxis-label'
                        }
                    }
                },
                yaxis: {
                    axisBorder: {
                        show: false
                    },
                    axisTicks: {
                        show: false
                    },
                    labels: {
                        style: {
                            colors: '#999',
                            fontSize: '13px',
                            fontFamily: 'inherit',
                            cssClass: 'apexcharts-xaxis-label'
                        }
                    }
                },
                legend: {
                    show: false
                },
                grid: {
                    borderColor: '#f3f3f3',
                    strokeDashArray: 3
                },
                dataLabels: {
                    enabled: false
                },
                tooltip: {
                    shared: true,
                    intersect: false,
                    y: {
                        formatter: function(y) {
                            if (typeof y !== "undefined") return y.toFixed(0) + " orders";
                            return y;
                        }
                    }
                }
            };
            // Get data from data attributes
            var height = $this.dataset.height;
            // Inject dynamic properties
            options.colors = colorPalette;
            options.chart.height = height ? height : 350;
            // Create chart
            new apexCharts($this, options).render();
        }
        if (chartEl) init(chartEl);
    };
}
module.exports = apexLineChart;

},{"apexcharts":"Hm9hE","../theme-styles":"kqb2N"}],"Hm9hE":[function(require,module,exports) {
/*!
 * ApexCharts v3.35.0
 * (c) 2018-2022 ApexCharts
 * Released under the MIT License.
 */ "use strict";
function t(t1, e1) {
    var i1 = Object.keys(t1);
    if (Object.getOwnPropertySymbols) {
        var a1 = Object.getOwnPropertySymbols(t1);
        e1 && (a1 = a1.filter(function(e2) {
            return Object.getOwnPropertyDescriptor(t1, e2).enumerable;
        })), i1.push.apply(i1, a1);
    }
    return i1;
}
function e(e3) {
    for(var i2 = 1; i2 < arguments.length; i2++){
        var a2 = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? t(Object(a2), !0).forEach(function(t2) {
            o(e3, t2, a2[t2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(a2)) : t(Object(a2)).forEach(function(t3) {
            Object.defineProperty(e3, t3, Object.getOwnPropertyDescriptor(a2, t3));
        });
    }
    return e3;
}
function i(t4) {
    return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
        return typeof t5;
    } : function(t6) {
        return t6 && "function" == typeof Symbol && t6.constructor === Symbol && t6 !== Symbol.prototype ? "symbol" : typeof t6;
    })(t4);
}
function a(t7, e4) {
    if (!(t7 instanceof e4)) throw new TypeError("Cannot call a class as a function");
}
function s(t8, e5) {
    for(var i3 = 0; i3 < e5.length; i3++){
        var a3 = e5[i3];
        a3.enumerable = a3.enumerable || !1, a3.configurable = !0, "value" in a3 && (a3.writable = !0), Object.defineProperty(t8, a3.key, a3);
    }
}
function r(t9, e6, i4) {
    return e6 && s(t9.prototype, e6), i4 && s(t9, i4), t9;
}
function o(t10, e7, i5) {
    return e7 in t10 ? Object.defineProperty(t10, e7, {
        value: i5,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t10[e7] = i5, t10;
}
function n(t11, e8) {
    if ("function" != typeof e8 && null !== e8) throw new TypeError("Super expression must either be null or a function");
    t11.prototype = Object.create(e8 && e8.prototype, {
        constructor: {
            value: t11,
            writable: !0,
            configurable: !0
        }
    }), e8 && h(t11, e8);
}
function l(t12) {
    return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(t13) {
        return t13.__proto__ || Object.getPrototypeOf(t13);
    })(t12);
}
function h(t14, e9) {
    return (h = Object.setPrototypeOf || function(t15, e10) {
        return t15.__proto__ = e10, t15;
    })(t14, e9);
}
function c(t16, e11) {
    if (e11 && ("object" == typeof e11 || "function" == typeof e11)) return e11;
    if (void 0 !== e11) throw new TypeError("Derived constructors may only return object or undefined");
    return function(t17) {
        if (void 0 === t17) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t17;
    }(t16);
}
function d(t18) {
    var e12 = function() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0;
        } catch (t) {
            return !1;
        }
    }();
    return function() {
        var i6, a4 = l(t18);
        if (e12) {
            var s1 = l(this).constructor;
            i6 = Reflect.construct(a4, arguments, s1);
        } else i6 = a4.apply(this, arguments);
        return c(this, i6);
    };
}
function g(t19, e13) {
    return function(t20) {
        if (Array.isArray(t20)) return t20;
    }(t19) || function(t21, e14) {
        var i7 = null == t21 ? null : "undefined" != typeof Symbol && t21[Symbol.iterator] || t21["@@iterator"];
        if (null == i7) return;
        var a5, s2, r1 = [], o1 = !0, n1 = !1;
        try {
            for(i7 = i7.call(t21); !(o1 = (a5 = i7.next()).done) && (r1.push(a5.value), !e14 || r1.length !== e14); o1 = !0);
        } catch (t22) {
            n1 = !0, s2 = t22;
        } finally{
            try {
                o1 || null == i7.return || i7.return();
            } finally{
                if (n1) throw s2;
            }
        }
        return r1;
    }(t19, e13) || p(t19, e13) || function() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
}
function u(t23) {
    return function(t24) {
        if (Array.isArray(t24)) return f(t24);
    }(t23) || function(t25) {
        if ("undefined" != typeof Symbol && null != t25[Symbol.iterator] || null != t25["@@iterator"]) return Array.from(t25);
    }(t23) || p(t23) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
}
function p(t26, e15) {
    if (t26) {
        if ("string" == typeof t26) return f(t26, e15);
        var i8 = Object.prototype.toString.call(t26).slice(8, -1);
        return "Object" === i8 && t26.constructor && (i8 = t26.constructor.name), "Map" === i8 || "Set" === i8 ? Array.from(t26) : "Arguments" === i8 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i8) ? f(t26, e15) : void 0;
    }
}
function f(t27, e16) {
    (null == e16 || e16 > t27.length) && (e16 = t27.length);
    for(var i9 = 0, a6 = new Array(e16); i9 < e16; i9++)a6[i9] = t27[i9];
    return a6;
}
var x = function() {
    function t28() {
        a(this, t28);
    }
    return r(t28, [
        {
            key: "shadeRGBColor",
            value: function(t29, e17) {
                var i10 = e17.split(","), a7 = t29 < 0 ? 0 : 255, s3 = t29 < 0 ? -1 * t29 : t29, r2 = parseInt(i10[0].slice(4), 10), o2 = parseInt(i10[1], 10), n2 = parseInt(i10[2], 10);
                return "rgb(" + (Math.round((a7 - r2) * s3) + r2) + "," + (Math.round((a7 - o2) * s3) + o2) + "," + (Math.round((a7 - n2) * s3) + n2) + ")";
            }
        },
        {
            key: "shadeHexColor",
            value: function(t30, e18) {
                var i11 = parseInt(e18.slice(1), 16), a8 = t30 < 0 ? 0 : 255, s4 = t30 < 0 ? -1 * t30 : t30, r3 = i11 >> 16, o3 = i11 >> 8 & 255, n3 = 255 & i11;
                return "#" + (16777216 + 65536 * (Math.round((a8 - r3) * s4) + r3) + 256 * (Math.round((a8 - o3) * s4) + o3) + (Math.round((a8 - n3) * s4) + n3)).toString(16).slice(1);
            }
        },
        {
            key: "shadeColor",
            value: function(e19, i12) {
                return t28.isColorHex(i12) ? this.shadeHexColor(e19, i12) : this.shadeRGBColor(e19, i12);
            }
        }
    ], [
        {
            key: "bind",
            value: function(t31, e20) {
                return function() {
                    return t31.apply(e20, arguments);
                };
            }
        },
        {
            key: "isObject",
            value: function(t32) {
                return t32 && "object" === i(t32) && !Array.isArray(t32) && null != t32;
            }
        },
        {
            key: "is",
            value: function(t33, e21) {
                return Object.prototype.toString.call(e21) === "[object " + t33 + "]";
            }
        },
        {
            key: "listToArray",
            value: function(t34) {
                var e22, i13 = [];
                for(e22 = 0; e22 < t34.length; e22++)i13[e22] = t34[e22];
                return i13;
            }
        },
        {
            key: "extend",
            value: function(t35, e23) {
                var i14 = this;
                "function" != typeof Object.assign && (Object.assign = function(t36) {
                    if (null == t36) throw new TypeError("Cannot convert undefined or null to object");
                    for(var e24 = Object(t36), i15 = 1; i15 < arguments.length; i15++){
                        var a10 = arguments[i15];
                        if (null != a10) for(var s5 in a10)a10.hasOwnProperty(s5) && (e24[s5] = a10[s5]);
                    }
                    return e24;
                });
                var a9 = Object.assign({}, t35);
                return this.isObject(t35) && this.isObject(e23) && Object.keys(e23).forEach(function(s6) {
                    i14.isObject(e23[s6]) && s6 in t35 ? a9[s6] = i14.extend(t35[s6], e23[s6]) : Object.assign(a9, o({}, s6, e23[s6]));
                }), a9;
            }
        },
        {
            key: "extendArray",
            value: function(e25, i16) {
                var a11 = [];
                return e25.map(function(e26) {
                    a11.push(t28.extend(i16, e26));
                }), e25 = a11;
            }
        },
        {
            key: "monthMod",
            value: function(t37) {
                return t37 % 12;
            }
        },
        {
            key: "clone",
            value: function(e27) {
                if (t28.is("Array", e27)) {
                    for(var a12 = [], s7 = 0; s7 < e27.length; s7++)a12[s7] = this.clone(e27[s7]);
                    return a12;
                }
                if (t28.is("Null", e27)) return null;
                if (t28.is("Date", e27)) return e27;
                if ("object" === i(e27)) {
                    var r4 = {};
                    for(var o4 in e27)e27.hasOwnProperty(o4) && (r4[o4] = this.clone(e27[o4]));
                    return r4;
                }
                return e27;
            }
        },
        {
            key: "log10",
            value: function(t38) {
                return Math.log(t38) / Math.LN10;
            }
        },
        {
            key: "roundToBase10",
            value: function(t39) {
                return Math.pow(10, Math.floor(Math.log10(t39)));
            }
        },
        {
            key: "roundToBase",
            value: function(t40, e28) {
                return Math.pow(e28, Math.floor(Math.log(t40) / Math.log(e28)));
            }
        },
        {
            key: "parseNumber",
            value: function(t41) {
                return null === t41 ? t41 : parseFloat(t41);
            }
        },
        {
            key: "randomId",
            value: function() {
                return (Math.random() + 1).toString(36).substring(4);
            }
        },
        {
            key: "noExponents",
            value: function(t42) {
                var e29 = String(t42).split(/[eE]/);
                if (1 === e29.length) return e29[0];
                var i17 = "", a13 = t42 < 0 ? "-" : "", s8 = e29[0].replace(".", ""), r5 = Number(e29[1]) + 1;
                if (r5 < 0) {
                    for(i17 = a13 + "0."; r5++;)i17 += "0";
                    return i17 + s8.replace(/^-/, "");
                }
                for(r5 -= s8.length; r5--;)i17 += "0";
                return s8 + i17;
            }
        },
        {
            key: "getDimensions",
            value: function(t43) {
                var e30 = getComputedStyle(t43, null), i18 = t43.clientHeight, a14 = t43.clientWidth;
                return i18 -= parseFloat(e30.paddingTop) + parseFloat(e30.paddingBottom), [
                    a14 -= parseFloat(e30.paddingLeft) + parseFloat(e30.paddingRight),
                    i18
                ];
            }
        },
        {
            key: "getBoundingClientRect",
            value: function(t44) {
                var e31 = t44.getBoundingClientRect();
                return {
                    top: e31.top,
                    right: e31.right,
                    bottom: e31.bottom,
                    left: e31.left,
                    width: t44.clientWidth,
                    height: t44.clientHeight,
                    x: e31.left,
                    y: e31.top
                };
            }
        },
        {
            key: "getLargestStringFromArr",
            value: function(t45) {
                return t45.reduce(function(t46, e32) {
                    return Array.isArray(e32) && (e32 = e32.reduce(function(t47, e33) {
                        return t47.length > e33.length ? t47 : e33;
                    })), t46.length > e32.length ? t46 : e32;
                }, 0);
            }
        },
        {
            key: "hexToRgba",
            value: function() {
                var t48 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999", e34 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .6;
                "#" !== t48.substring(0, 1) && (t48 = "#999999");
                var i19 = t48.replace("#", "");
                i19 = i19.match(new RegExp("(.{" + i19.length / 3 + "})", "g"));
                for(var a15 = 0; a15 < i19.length; a15++)i19[a15] = parseInt(1 === i19[a15].length ? i19[a15] + i19[a15] : i19[a15], 16);
                return void 0 !== e34 && i19.push(e34), "rgba(" + i19.join(",") + ")";
            }
        },
        {
            key: "getOpacityFromRGBA",
            value: function(t49) {
                return parseFloat(t49.replace(/^.*,(.+)\)/, "$1"));
            }
        },
        {
            key: "rgb2hex",
            value: function(t50) {
                return (t50 = t50.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === t50.length ? "#" + ("0" + parseInt(t50[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t50[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t50[3], 10).toString(16)).slice(-2) : "";
            }
        },
        {
            key: "isColorHex",
            value: function(t51) {
                return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t51);
            }
        },
        {
            key: "getPolygonPos",
            value: function(t52, e35) {
                for(var i20 = [], a16 = 2 * Math.PI / e35, s9 = 0; s9 < e35; s9++){
                    var r6 = {};
                    r6.x = t52 * Math.sin(s9 * a16), r6.y = -t52 * Math.cos(s9 * a16), i20.push(r6);
                }
                return i20;
            }
        },
        {
            key: "polarToCartesian",
            value: function(t53, e36, i21, a17) {
                var s10 = (a17 - 90) * Math.PI / 180;
                return {
                    x: t53 + i21 * Math.cos(s10),
                    y: e36 + i21 * Math.sin(s10)
                };
            }
        },
        {
            key: "escapeString",
            value: function(t54) {
                var e37 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x", i22 = t54.toString().slice();
                return i22 = i22.replace(/[` ~!@#$%^&*()_|+\-=?;:'",.<>{}[\]\\/]/gi, e37);
            }
        },
        {
            key: "negToZero",
            value: function(t55) {
                return t55 < 0 ? 0 : t55;
            }
        },
        {
            key: "moveIndexInArray",
            value: function(t56, e38, i23) {
                if (i23 >= t56.length) for(var a18 = i23 - t56.length + 1; a18--;)t56.push(void 0);
                return t56.splice(i23, 0, t56.splice(e38, 1)[0]), t56;
            }
        },
        {
            key: "extractNumber",
            value: function(t57) {
                return parseFloat(t57.replace(/[^\d.]*/g, ""));
            }
        },
        {
            key: "findAncestor",
            value: function(t58, e39) {
                for(; (t58 = t58.parentElement) && !t58.classList.contains(e39););
                return t58;
            }
        },
        {
            key: "setELstyles",
            value: function(t59, e40) {
                for(var i24 in e40)e40.hasOwnProperty(i24) && (t59.style.key = e40[i24]);
            }
        },
        {
            key: "isNumber",
            value: function(t60) {
                return !isNaN(t60) && parseFloat(Number(t60)) === t60 && !isNaN(parseInt(t60, 10));
            }
        },
        {
            key: "isFloat",
            value: function(t61) {
                return Number(t61) === t61 && t61 % 1 != 0;
            }
        },
        {
            key: "isSafari",
            value: function() {
                return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            }
        },
        {
            key: "isFirefox",
            value: function() {
                return navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
            }
        },
        {
            key: "isIE11",
            value: function() {
                if (-1 !== window.navigator.userAgent.indexOf("MSIE") || window.navigator.appVersion.indexOf("Trident/") > -1) return !0;
            }
        },
        {
            key: "isIE",
            value: function() {
                var t62 = window.navigator.userAgent, e41 = t62.indexOf("MSIE ");
                if (e41 > 0) return parseInt(t62.substring(e41 + 5, t62.indexOf(".", e41)), 10);
                if (t62.indexOf("Trident/") > 0) {
                    var i25 = t62.indexOf("rv:");
                    return parseInt(t62.substring(i25 + 3, t62.indexOf(".", i25)), 10);
                }
                var a19 = t62.indexOf("Edge/");
                return a19 > 0 && parseInt(t62.substring(a19 + 5, t62.indexOf(".", a19)), 10);
            }
        }
    ]), t28;
}(), b = function() {
    function t63(e42) {
        a(this, t63), this.ctx = e42, this.w = e42.w, this.setEasingFunctions();
    }
    return r(t63, [
        {
            key: "setEasingFunctions",
            value: function() {
                var t64;
                if (!this.w.globals.easing) {
                    switch(this.w.config.chart.animations.easing){
                        case "linear":
                            t64 = "-";
                            break;
                        case "easein":
                            t64 = "<";
                            break;
                        case "easeout":
                            t64 = ">";
                            break;
                        case "easeinout":
                            t64 = "<>";
                            break;
                        case "swing":
                            t64 = function(t65) {
                                var e43 = 1.70158;
                                return (t65 -= 1) * t65 * ((e43 + 1) * t65 + e43) + 1;
                            };
                            break;
                        case "bounce":
                            t64 = function(t66) {
                                return t66 < 1 / 2.75 ? 7.5625 * t66 * t66 : t66 < 2 / 2.75 ? 7.5625 * (t66 -= 1.5 / 2.75) * t66 + .75 : t66 < 2.5 / 2.75 ? 7.5625 * (t66 -= 2.25 / 2.75) * t66 + .9375 : 7.5625 * (t66 -= 2.625 / 2.75) * t66 + .984375;
                            };
                            break;
                        case "elastic":
                            t64 = function(t67) {
                                return t67 === !!t67 ? t67 : Math.pow(2, -10 * t67) * Math.sin((t67 - .075) * (2 * Math.PI) / .3) + 1;
                            };
                            break;
                        default:
                            t64 = "<>";
                    }
                    this.w.globals.easing = t64;
                }
            }
        },
        {
            key: "animateLine",
            value: function(t68, e44, i26, a20) {
                t68.attr(e44).animate(a20).attr(i26);
            }
        },
        {
            key: "animateMarker",
            value: function(t69, e45, i27, a21, s11, r7) {
                e45 || (e45 = 0), t69.attr({
                    r: e45,
                    width: e45,
                    height: e45
                }).animate(a21, s11).attr({
                    r: i27,
                    width: i27.width,
                    height: i27.height
                }).afterAll(function() {
                    r7();
                });
            }
        },
        {
            key: "animateCircle",
            value: function(t70, e46, i28, a22, s12) {
                t70.attr({
                    r: e46.r,
                    cx: e46.cx,
                    cy: e46.cy
                }).animate(a22, s12).attr({
                    r: i28.r,
                    cx: i28.cx,
                    cy: i28.cy
                });
            }
        },
        {
            key: "animateRect",
            value: function(t71, e47, i29, a23, s13) {
                t71.attr(e47).animate(a23).attr(i29).afterAll(function() {
                    return s13();
                });
            }
        },
        {
            key: "animatePathsGradually",
            value: function(t72) {
                var e48 = t72.el, i30 = t72.realIndex, a24 = t72.j, s14 = t72.fill, r8 = t72.pathFrom, o5 = t72.pathTo, n4 = t72.speed, l1 = t72.delay, h1 = this.w, c1 = 0;
                h1.config.chart.animations.animateGradually.enabled && (c1 = h1.config.chart.animations.animateGradually.delay), h1.config.chart.animations.dynamicAnimation.enabled && h1.globals.dataChanged && "bar" !== h1.config.chart.type && (c1 = 0), this.morphSVG(e48, i30, a24, "line" !== h1.config.chart.type || h1.globals.comboCharts ? s14 : "stroke", r8, o5, n4, l1 * c1);
            }
        },
        {
            key: "showDelayedElements",
            value: function() {
                this.w.globals.delayedElements.forEach(function(t73) {
                    t73.el.classList.remove("apexcharts-element-hidden");
                });
            }
        },
        {
            key: "animationCompleted",
            value: function(t74) {
                var e49 = this.w;
                e49.globals.animationEnded || (e49.globals.animationEnded = !0, this.showDelayedElements(), "function" == typeof e49.config.chart.events.animationEnd && e49.config.chart.events.animationEnd(this.ctx, {
                    el: t74,
                    w: e49
                }));
            }
        },
        {
            key: "morphSVG",
            value: function(t75, e50, i31, a25, s15, r9, o6, n5) {
                var l2 = this, h2 = this.w;
                s15 || (s15 = t75.attr("pathFrom")), r9 || (r9 = t75.attr("pathTo"));
                var c2 = function(t) {
                    return "radar" === h2.config.chart.type && (o6 = 1), "M 0 ".concat(h2.globals.gridHeight);
                };
                (!s15 || s15.indexOf("undefined") > -1 || s15.indexOf("NaN") > -1) && (s15 = c2()), (!r9 || r9.indexOf("undefined") > -1 || r9.indexOf("NaN") > -1) && (r9 = c2()), h2.globals.shouldAnimate || (o6 = 1), t75.plot(s15).animate(1, h2.globals.easing, n5).plot(s15).animate(o6, h2.globals.easing, n5).plot(r9).afterAll(function() {
                    x.isNumber(i31) ? i31 === h2.globals.series[h2.globals.maxValsInArrayIndex].length - 2 && h2.globals.shouldAnimate && l2.animationCompleted(t75) : "none" !== a25 && h2.globals.shouldAnimate && (!h2.globals.comboCharts && e50 === h2.globals.series.length - 1 || h2.globals.comboCharts) && l2.animationCompleted(t75), l2.showDelayedElements();
                });
            }
        }
    ]), t63;
}(), v = function() {
    function t76(e51) {
        a(this, t76), this.ctx = e51, this.w = e51.w;
    }
    return r(t76, [
        {
            key: "getDefaultFilter",
            value: function(t77, e52) {
                var i32 = this.w;
                t77.unfilter(!0), (new window.SVG.Filter).size("120%", "180%", "-5%", "-40%"), "none" !== i32.config.states.normal.filter ? this.applyFilter(t77, e52, i32.config.states.normal.filter.type, i32.config.states.normal.filter.value) : i32.config.chart.dropShadow.enabled && this.dropShadow(t77, i32.config.chart.dropShadow, e52);
            }
        },
        {
            key: "addNormalFilter",
            value: function(t78, e53) {
                var i33 = this.w;
                i33.config.chart.dropShadow.enabled && !t78.node.classList.contains("apexcharts-marker") && this.dropShadow(t78, i33.config.chart.dropShadow, e53);
            }
        },
        {
            key: "addLightenFilter",
            value: function(t79, e54, i34) {
                var a26 = this, s16 = this.w, r10 = i34.intensity;
                t79.unfilter(!0);
                new window.SVG.Filter;
                t79.filter(function(t80) {
                    var i35 = s16.config.chart.dropShadow;
                    (i35.enabled ? a26.addShadow(t80, e54, i35) : t80).componentTransfer({
                        rgb: {
                            type: "linear",
                            slope: 1.5,
                            intercept: r10
                        }
                    });
                }), t79.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t79.filterer.node);
            }
        },
        {
            key: "addDarkenFilter",
            value: function(t81, e55, i36) {
                var a27 = this, s17 = this.w, r11 = i36.intensity;
                t81.unfilter(!0);
                new window.SVG.Filter;
                t81.filter(function(t82) {
                    var i37 = s17.config.chart.dropShadow;
                    (i37.enabled ? a27.addShadow(t82, e55, i37) : t82).componentTransfer({
                        rgb: {
                            type: "linear",
                            slope: r11
                        }
                    });
                }), t81.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t81.filterer.node);
            }
        },
        {
            key: "applyFilter",
            value: function(t83, e56, i38) {
                var a28 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5;
                switch(i38){
                    case "none":
                        this.addNormalFilter(t83, e56);
                        break;
                    case "lighten":
                        this.addLightenFilter(t83, e56, {
                            intensity: a28
                        });
                        break;
                    case "darken":
                        this.addDarkenFilter(t83, e56, {
                            intensity: a28
                        });
                }
            }
        },
        {
            key: "addShadow",
            value: function(t84, e57, i39) {
                var a29 = i39.blur, s18 = i39.top, r12 = i39.left, o7 = i39.color, n6 = i39.opacity, l3 = t84.flood(Array.isArray(o7) ? o7[e57] : o7, n6).composite(t84.sourceAlpha, "in").offset(r12, s18).gaussianBlur(a29).merge(t84.source);
                return t84.blend(t84.source, l3);
            }
        },
        {
            key: "dropShadow",
            value: function(t85, e58) {
                var i40 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, a30 = e58.top, s19 = e58.left, r13 = e58.blur, o8 = e58.color, n7 = e58.opacity, l4 = e58.noUserSpaceOnUse, h3 = this.w;
                return t85.unfilter(!0), x.isIE() && "radialBar" === h3.config.chart.type || (o8 = Array.isArray(o8) ? o8[i40] : o8, t85.filter(function(t86) {
                    var e59 = null;
                    e59 = x.isSafari() || x.isFirefox() || x.isIE() ? t86.flood(o8, n7).composite(t86.sourceAlpha, "in").offset(s19, a30).gaussianBlur(r13) : t86.flood(o8, n7).composite(t86.sourceAlpha, "in").offset(s19, a30).gaussianBlur(r13).merge(t86.source), t86.blend(t86.source, e59);
                }), l4 || t85.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t85.filterer.node)), t85;
            }
        },
        {
            key: "setSelectionFilter",
            value: function(t87, e60, i41) {
                var a31 = this.w;
                if (void 0 !== a31.globals.selectedDataPoints[e60] && a31.globals.selectedDataPoints[e60].indexOf(i41) > -1) {
                    t87.node.setAttribute("selected", !0);
                    var s20 = a31.config.states.active.filter;
                    "none" !== s20 && this.applyFilter(t87, e60, s20.type, s20.value);
                }
            }
        },
        {
            key: "_scaleFilterSize",
            value: function(t88) {
                !function(e61) {
                    for(var i42 in e61)e61.hasOwnProperty(i42) && t88.setAttribute(i42, e61[i42]);
                }({
                    width: "200%",
                    height: "200%",
                    x: "-50%",
                    y: "-50%"
                });
            }
        }
    ]), t76;
}(), m = function() {
    function t89(e62) {
        a(this, t89), this.ctx = e62, this.w = e62.w;
    }
    return r(t89, [
        {
            key: "drawLine",
            value: function(t90, e63, i43, a32) {
                var s21 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8", r14 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, o9 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, n8 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "butt", l5 = this.w, h4 = l5.globals.dom.Paper.line().attr({
                    x1: t90,
                    y1: e63,
                    x2: i43,
                    y2: a32,
                    stroke: s21,
                    "stroke-dasharray": r14,
                    "stroke-width": o9,
                    "stroke-linecap": n8
                });
                return h4;
            }
        },
        {
            key: "drawRect",
            value: function() {
                var t91 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e64 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i44 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, a33 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s22 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, r15 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe", o10 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1, n9 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, l6 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null, h5 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, c3 = this.w, d1 = c3.globals.dom.Paper.rect();
                return d1.attr({
                    x: t91,
                    y: e64,
                    width: i44 > 0 ? i44 : 0,
                    height: a33 > 0 ? a33 : 0,
                    rx: s22,
                    ry: s22,
                    opacity: o10,
                    "stroke-width": null !== n9 ? n9 : 0,
                    stroke: null !== l6 ? l6 : "none",
                    "stroke-dasharray": h5
                }), d1.node.setAttribute("fill", r15), d1;
            }
        },
        {
            key: "drawPolygon",
            value: function(t92) {
                var e65 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1", i45 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, a34 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none", s23 = this.w, r16 = s23.globals.dom.Paper.polygon(t92).attr({
                    fill: a34,
                    stroke: e65,
                    "stroke-width": i45
                });
                return r16;
            }
        },
        {
            key: "drawCircle",
            value: function(t93) {
                var e66 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i46 = this.w;
                t93 < 0 && (t93 = 0);
                var a35 = i46.globals.dom.Paper.circle(2 * t93);
                return null !== e66 && a35.attr(e66), a35;
            }
        },
        {
            key: "drawPath",
            value: function(t94) {
                var e67 = t94.d, i47 = void 0 === e67 ? "" : e67, a36 = t94.stroke, s24 = void 0 === a36 ? "#a8a8a8" : a36, r17 = t94.strokeWidth, o11 = void 0 === r17 ? 1 : r17, n10 = t94.fill, l7 = t94.fillOpacity, h6 = void 0 === l7 ? 1 : l7, c4 = t94.strokeOpacity, d2 = void 0 === c4 ? 1 : c4, g1 = t94.classes, u1 = t94.strokeLinecap, p1 = void 0 === u1 ? null : u1, f1 = t94.strokeDashArray, x1 = void 0 === f1 ? 0 : f1, b1 = this.w;
                return null === p1 && (p1 = b1.config.stroke.lineCap), (i47.indexOf("undefined") > -1 || i47.indexOf("NaN") > -1) && (i47 = "M 0 ".concat(b1.globals.gridHeight)), b1.globals.dom.Paper.path(i47).attr({
                    fill: n10,
                    "fill-opacity": h6,
                    stroke: s24,
                    "stroke-opacity": d2,
                    "stroke-linecap": p1,
                    "stroke-width": o11,
                    "stroke-dasharray": x1,
                    class: g1
                });
            }
        },
        {
            key: "group",
            value: function() {
                var t95 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e68 = this.w, i48 = e68.globals.dom.Paper.group();
                return null !== t95 && i48.attr(t95), i48;
            }
        },
        {
            key: "move",
            value: function(t96, e69) {
                var i49 = [
                    "M",
                    t96,
                    e69
                ].join(" ");
                return i49;
            }
        },
        {
            key: "line",
            value: function(t97, e70) {
                var i50 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a37 = null;
                return null === i50 ? a37 = [
                    "L",
                    t97,
                    e70
                ].join(" ") : "H" === i50 ? a37 = [
                    "H",
                    t97
                ].join(" ") : "V" === i50 && (a37 = [
                    "V",
                    e70
                ].join(" ")), a37;
            }
        },
        {
            key: "curve",
            value: function(t98, e71, i51, a38, s25, r18) {
                var o12 = [
                    "C",
                    t98,
                    e71,
                    i51,
                    a38,
                    s25,
                    r18
                ].join(" ");
                return o12;
            }
        },
        {
            key: "quadraticCurve",
            value: function(t99, e72, i52, a39) {
                return [
                    "Q",
                    t99,
                    e72,
                    i52,
                    a39
                ].join(" ");
            }
        },
        {
            key: "arc",
            value: function(t100, e73, i53, a40, s26, r19, o13) {
                var n11 = arguments.length > 7 && void 0 !== arguments[7] && arguments[7], l8 = "A";
                n11 && (l8 = "a");
                var h7 = [
                    l8,
                    t100,
                    e73,
                    i53,
                    a40,
                    s26,
                    r19,
                    o13
                ].join(" ");
                return h7;
            }
        },
        {
            key: "renderPaths",
            value: function(t101) {
                var i54, a41 = t101.j, s27 = t101.realIndex, r20 = t101.pathFrom, o14 = t101.pathTo, n12 = t101.stroke, l9 = t101.strokeWidth, h8 = t101.strokeLinecap, c5 = t101.fill, d3 = t101.animationDelay, g2 = t101.initialSpeed, u2 = t101.dataChangeSpeed, p2 = t101.className, f2 = t101.shouldClipToGrid, x2 = void 0 === f2 || f2, m1 = t101.bindEventsOnPaths, y1 = void 0 === m1 || m1, w1 = t101.drawShadow, k1 = void 0 === w1 || w1, A1 = this.w, S1 = new v(this.ctx), C1 = new b(this.ctx), L1 = this.w.config.chart.animations.enabled, P1 = L1 && this.w.config.chart.animations.dynamicAnimation.enabled, T1 = !!(L1 && !A1.globals.resized || P1 && A1.globals.dataChanged && A1.globals.shouldAnimate);
                T1 ? i54 = r20 : (i54 = o14, A1.globals.animationEnded = !0);
                var M1 = A1.config.stroke.dashArray, I1 = 0;
                I1 = Array.isArray(M1) ? M1[s27] : A1.config.stroke.dashArray;
                var z1 = this.drawPath({
                    d: i54,
                    stroke: n12,
                    strokeWidth: l9,
                    fill: c5,
                    fillOpacity: 1,
                    classes: p2,
                    strokeLinecap: h8,
                    strokeDashArray: I1
                });
                if (z1.attr("index", s27), x2 && z1.attr({
                    "clip-path": "url(#gridRectMask".concat(A1.globals.cuid, ")")
                }), "none" !== A1.config.states.normal.filter.type) S1.getDefaultFilter(z1, s27);
                else if (A1.config.chart.dropShadow.enabled && k1 && (!A1.config.chart.dropShadow.enabledOnSeries || A1.config.chart.dropShadow.enabledOnSeries && -1 !== A1.config.chart.dropShadow.enabledOnSeries.indexOf(s27))) {
                    var X1 = A1.config.chart.dropShadow;
                    S1.dropShadow(z1, X1, s27);
                }
                y1 && (z1.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, z1)), z1.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, z1)), z1.node.addEventListener("mousedown", this.pathMouseDown.bind(this, z1))), z1.attr({
                    pathTo: o14,
                    pathFrom: r20
                });
                var E1 = {
                    el: z1,
                    j: a41,
                    realIndex: s27,
                    pathFrom: r20,
                    pathTo: o14,
                    fill: c5,
                    strokeWidth: l9,
                    delay: d3
                };
                return !L1 || A1.globals.resized || A1.globals.dataChanged ? !A1.globals.resized && A1.globals.dataChanged || C1.showDelayedElements() : C1.animatePathsGradually(e(e({}, E1), {}, {
                    speed: g2
                })), A1.globals.dataChanged && P1 && T1 && C1.animatePathsGradually(e(e({}, E1), {}, {
                    speed: u2
                })), z1;
            }
        },
        {
            key: "drawPattern",
            value: function(t102, e74, i55) {
                var a42 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8", s28 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, r21 = this.w, o15 = r21.globals.dom.Paper.pattern(e74, i55, function(r22) {
                    "horizontalLines" === t102 ? r22.line(0, 0, i55, 0).stroke({
                        color: a42,
                        width: s28 + 1
                    }) : "verticalLines" === t102 ? r22.line(0, 0, 0, e74).stroke({
                        color: a42,
                        width: s28 + 1
                    }) : "slantedLines" === t102 ? r22.line(0, 0, e74, i55).stroke({
                        color: a42,
                        width: s28
                    }) : "squares" === t102 ? r22.rect(e74, i55).fill("none").stroke({
                        color: a42,
                        width: s28
                    }) : "circles" === t102 && r22.circle(e74).fill("none").stroke({
                        color: a42,
                        width: s28
                    });
                });
                return o15;
            }
        },
        {
            key: "drawGradient",
            value: function(t103, e75, i56, a43, s29) {
                var r23, o16 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, n13 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, l10 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, h9 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, c6 = this.w;
                e75.length < 9 && 0 === e75.indexOf("#") && (e75 = x.hexToRgba(e75, a43)), i56.length < 9 && 0 === i56.indexOf("#") && (i56 = x.hexToRgba(i56, s29));
                var d4 = 0, g3 = 1, u3 = 1, p3 = null;
                null !== n13 && (d4 = void 0 !== n13[0] ? n13[0] / 100 : 0, g3 = void 0 !== n13[1] ? n13[1] / 100 : 1, u3 = void 0 !== n13[2] ? n13[2] / 100 : 1, p3 = void 0 !== n13[3] ? n13[3] / 100 : null);
                var f3 = !("donut" !== c6.config.chart.type && "pie" !== c6.config.chart.type && "polarArea" !== c6.config.chart.type && "bubble" !== c6.config.chart.type);
                if (r23 = null === l10 || 0 === l10.length ? c6.globals.dom.Paper.gradient(f3 ? "radial" : "linear", function(t104) {
                    t104.at(d4, e75, a43), t104.at(g3, i56, s29), t104.at(u3, i56, s29), null !== p3 && t104.at(p3, e75, a43);
                }) : c6.globals.dom.Paper.gradient(f3 ? "radial" : "linear", function(t105) {
                    (Array.isArray(l10[h9]) ? l10[h9] : l10).forEach(function(e76) {
                        t105.at(e76.offset / 100, e76.color, e76.opacity);
                    });
                }), f3) {
                    var b2 = c6.globals.gridWidth / 2, v1 = c6.globals.gridHeight / 2;
                    "bubble" !== c6.config.chart.type ? r23.attr({
                        gradientUnits: "userSpaceOnUse",
                        cx: b2,
                        cy: v1,
                        r: o16
                    }) : r23.attr({
                        cx: .5,
                        cy: .5,
                        r: .8,
                        fx: .2,
                        fy: .2
                    });
                } else "vertical" === t103 ? r23.from(0, 0).to(0, 1) : "diagonal" === t103 ? r23.from(0, 0).to(1, 1) : "horizontal" === t103 ? r23.from(0, 1).to(1, 1) : "diagonal2" === t103 && r23.from(1, 0).to(0, 1);
                return r23;
            }
        },
        {
            key: "drawText",
            value: function(t106) {
                var e77, i57 = t106.x, a44 = t106.y, s30 = t106.text, r24 = t106.textAnchor, o17 = t106.fontSize, n14 = t106.fontFamily, l11 = t106.fontWeight, h10 = t106.foreColor, c7 = t106.opacity, d5 = t106.cssClass, g4 = void 0 === d5 ? "" : d5, u4 = t106.isPlainText, p4 = void 0 === u4 || u4, f4 = this.w;
                return void 0 === s30 && (s30 = ""), r24 || (r24 = "start"), h10 && h10.length || (h10 = f4.config.chart.foreColor), n14 = n14 || f4.config.chart.fontFamily, l11 = l11 || "regular", (e77 = Array.isArray(s30) ? f4.globals.dom.Paper.text(function(t107) {
                    for(var e78 = 0; e78 < s30.length; e78++)0 === e78 ? t107.tspan(s30[e78]) : t107.tspan(s30[e78]).newLine();
                }) : p4 ? f4.globals.dom.Paper.plain(s30) : f4.globals.dom.Paper.text(function(t108) {
                    return t108.tspan(s30);
                })).attr({
                    x: i57,
                    y: a44,
                    "text-anchor": r24,
                    "dominant-baseline": "auto",
                    "font-size": o17,
                    "font-family": n14,
                    "font-weight": l11,
                    fill: h10,
                    class: "apexcharts-text " + g4
                }), e77.node.style.fontFamily = n14, e77.node.style.opacity = c7, e77;
            }
        },
        {
            key: "drawMarker",
            value: function(t109, e79, i58) {
                t109 = t109 || 0;
                var a45 = i58.pSize || 0, s31 = null;
                if ("square" === i58.shape || "rect" === i58.shape) {
                    var r25 = void 0 === i58.pRadius ? a45 / 2 : i58.pRadius;
                    null !== e79 && a45 || (a45 = 0, r25 = 0);
                    var o18 = 1.2 * a45 + r25, n15 = this.drawRect(o18, o18, o18, o18, r25);
                    n15.attr({
                        x: t109 - o18 / 2,
                        y: e79 - o18 / 2,
                        cx: t109,
                        cy: e79,
                        class: i58.class ? i58.class : "",
                        fill: i58.pointFillColor,
                        "fill-opacity": i58.pointFillOpacity ? i58.pointFillOpacity : 1,
                        stroke: i58.pointStrokeColor,
                        "stroke-width": i58.pointStrokeWidth ? i58.pointStrokeWidth : 0,
                        "stroke-opacity": i58.pointStrokeOpacity ? i58.pointStrokeOpacity : 1
                    }), s31 = n15;
                } else "circle" !== i58.shape && i58.shape || (x.isNumber(e79) || (a45 = 0, e79 = 0), s31 = this.drawCircle(a45, {
                    cx: t109,
                    cy: e79,
                    class: i58.class ? i58.class : "",
                    stroke: i58.pointStrokeColor,
                    fill: i58.pointFillColor,
                    "fill-opacity": i58.pointFillOpacity ? i58.pointFillOpacity : 1,
                    "stroke-width": i58.pointStrokeWidth ? i58.pointStrokeWidth : 0,
                    "stroke-opacity": i58.pointStrokeOpacity ? i58.pointStrokeOpacity : 1
                }));
                return s31;
            }
        },
        {
            key: "pathMouseEnter",
            value: function(t110, e80) {
                var i59 = this.w, a46 = new v(this.ctx), s32 = parseInt(t110.node.getAttribute("index"), 10), r26 = parseInt(t110.node.getAttribute("j"), 10);
                if ("function" == typeof i59.config.chart.events.dataPointMouseEnter && i59.config.chart.events.dataPointMouseEnter(e80, this.ctx, {
                    seriesIndex: s32,
                    dataPointIndex: r26,
                    w: i59
                }), this.ctx.events.fireEvent("dataPointMouseEnter", [
                    e80,
                    this.ctx,
                    {
                        seriesIndex: s32,
                        dataPointIndex: r26,
                        w: i59
                    }
                ]), ("none" === i59.config.states.active.filter.type || "true" !== t110.node.getAttribute("selected")) && "none" !== i59.config.states.hover.filter.type && !i59.globals.isTouchDevice) {
                    var o19 = i59.config.states.hover.filter;
                    a46.applyFilter(t110, s32, o19.type, o19.value);
                }
            }
        },
        {
            key: "pathMouseLeave",
            value: function(t111, e81) {
                var i60 = this.w, a47 = new v(this.ctx), s33 = parseInt(t111.node.getAttribute("index"), 10), r27 = parseInt(t111.node.getAttribute("j"), 10);
                "function" == typeof i60.config.chart.events.dataPointMouseLeave && i60.config.chart.events.dataPointMouseLeave(e81, this.ctx, {
                    seriesIndex: s33,
                    dataPointIndex: r27,
                    w: i60
                }), this.ctx.events.fireEvent("dataPointMouseLeave", [
                    e81,
                    this.ctx,
                    {
                        seriesIndex: s33,
                        dataPointIndex: r27,
                        w: i60
                    }
                ]), "none" !== i60.config.states.active.filter.type && "true" === t111.node.getAttribute("selected") || "none" !== i60.config.states.hover.filter.type && a47.getDefaultFilter(t111, s33);
            }
        },
        {
            key: "pathMouseDown",
            value: function(t112, e82) {
                var i61 = this.w, a48 = new v(this.ctx), s34 = parseInt(t112.node.getAttribute("index"), 10), r28 = parseInt(t112.node.getAttribute("j"), 10), o20 = "false";
                if ("true" === t112.node.getAttribute("selected")) {
                    if (t112.node.setAttribute("selected", "false"), i61.globals.selectedDataPoints[s34].indexOf(r28) > -1) {
                        var n16 = i61.globals.selectedDataPoints[s34].indexOf(r28);
                        i61.globals.selectedDataPoints[s34].splice(n16, 1);
                    }
                } else {
                    if (!i61.config.states.active.allowMultipleDataPointsSelection && i61.globals.selectedDataPoints.length > 0) {
                        i61.globals.selectedDataPoints = [];
                        var l12 = i61.globals.dom.Paper.select(".apexcharts-series path").members, h11 = i61.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members, c8 = function(t113) {
                            Array.prototype.forEach.call(t113, function(t114) {
                                t114.node.setAttribute("selected", "false"), a48.getDefaultFilter(t114, s34);
                            });
                        };
                        c8(l12), c8(h11);
                    }
                    t112.node.setAttribute("selected", "true"), o20 = "true", void 0 === i61.globals.selectedDataPoints[s34] && (i61.globals.selectedDataPoints[s34] = []), i61.globals.selectedDataPoints[s34].push(r28);
                }
                if ("true" === o20) {
                    var d6 = i61.config.states.active.filter;
                    "none" !== d6 && a48.applyFilter(t112, s34, d6.type, d6.value);
                } else "none" !== i61.config.states.active.filter.type && a48.getDefaultFilter(t112, s34);
                "function" == typeof i61.config.chart.events.dataPointSelection && i61.config.chart.events.dataPointSelection(e82, this.ctx, {
                    selectedDataPoints: i61.globals.selectedDataPoints,
                    seriesIndex: s34,
                    dataPointIndex: r28,
                    w: i61
                }), e82 && this.ctx.events.fireEvent("dataPointSelection", [
                    e82,
                    this.ctx,
                    {
                        selectedDataPoints: i61.globals.selectedDataPoints,
                        seriesIndex: s34,
                        dataPointIndex: r28,
                        w: i61
                    }
                ]);
            }
        },
        {
            key: "rotateAroundCenter",
            value: function(t115) {
                var e83 = {};
                return t115 && "function" == typeof t115.getBBox && (e83 = t115.getBBox()), {
                    x: e83.x + e83.width / 2,
                    y: e83.y + e83.height / 2
                };
            }
        },
        {
            key: "getTextRects",
            value: function(t116, e84, i62, a49) {
                var s35 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], r29 = this.w, o21 = this.drawText({
                    x: -200,
                    y: -200,
                    text: t116,
                    textAnchor: "start",
                    fontSize: e84,
                    fontFamily: i62,
                    foreColor: "#fff",
                    opacity: 0
                });
                a49 && o21.attr("transform", a49), r29.globals.dom.Paper.add(o21);
                var n17 = o21.bbox();
                return s35 || (n17 = o21.node.getBoundingClientRect()), o21.remove(), {
                    width: n17.width,
                    height: n17.height
                };
            }
        },
        {
            key: "placeTextWithEllipsis",
            value: function(t117, e85, i63) {
                if ("function" == typeof t117.getComputedTextLength && (t117.textContent = e85, e85.length > 0 && t117.getComputedTextLength() >= i63 / 1.1)) {
                    for(var a50 = e85.length - 3; a50 > 0; a50 -= 3)if (t117.getSubStringLength(0, a50) <= i63 / 1.1) return void (t117.textContent = e85.substring(0, a50) + "...");
                    t117.textContent = ".";
                }
            }
        }
    ], [
        {
            key: "setAttrs",
            value: function(t118, e86) {
                for(var i64 in e86)e86.hasOwnProperty(i64) && t118.setAttribute(i64, e86[i64]);
            }
        }
    ]), t89;
}(), y = function() {
    function t119(e87) {
        a(this, t119), this.ctx = e87, this.w = e87.w;
    }
    return r(t119, [
        {
            key: "getStackedSeriesTotals",
            value: function() {
                var t120 = this.w, e88 = [];
                if (0 === t120.globals.series.length) return e88;
                for(var i65 = 0; i65 < t120.globals.series[t120.globals.maxValsInArrayIndex].length; i65++){
                    for(var a51 = 0, s36 = 0; s36 < t120.globals.series.length; s36++)void 0 !== t120.globals.series[s36][i65] && (a51 += t120.globals.series[s36][i65]);
                    e88.push(a51);
                }
                return t120.globals.stackedSeriesTotals = e88, e88;
            }
        },
        {
            key: "getSeriesTotalByIndex",
            value: function() {
                var t121 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                return null === t121 ? this.w.config.series.reduce(function(t122, e89) {
                    return t122 + e89;
                }, 0) : this.w.globals.series[t121].reduce(function(t123, e90) {
                    return t123 + e90;
                }, 0);
            }
        },
        {
            key: "isSeriesNull",
            value: function() {
                var t124 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                return 0 === (null === t124 ? this.w.config.series.filter(function(t125) {
                    return null !== t125;
                }) : this.w.config.series[t124].data.filter(function(t126) {
                    return null !== t126;
                })).length;
            }
        },
        {
            key: "seriesHaveSameValues",
            value: function(t127) {
                return this.w.globals.series[t127].every(function(t128, e, i66) {
                    return t128 === i66[0];
                });
            }
        },
        {
            key: "getCategoryLabels",
            value: function(t129) {
                var e91 = this.w, i67 = t129.slice();
                return e91.config.xaxis.convertedCatToNumeric && (i67 = t129.map(function(t130, i) {
                    return e91.config.xaxis.labels.formatter(t130 - e91.globals.minX + 1);
                })), i67;
            }
        },
        {
            key: "getLargestSeries",
            value: function() {
                var t131 = this.w;
                t131.globals.maxValsInArrayIndex = t131.globals.series.map(function(t132) {
                    return t132.length;
                }).indexOf(Math.max.apply(Math, t131.globals.series.map(function(t133) {
                    return t133.length;
                })));
            }
        },
        {
            key: "getLargestMarkerSize",
            value: function() {
                var t134 = this.w, e92 = 0;
                return t134.globals.markers.size.forEach(function(t135) {
                    e92 = Math.max(e92, t135);
                }), t134.config.markers.discrete && t134.config.markers.discrete.length && t134.config.markers.discrete.forEach(function(t136) {
                    e92 = Math.max(e92, t136.size);
                }), e92 > 0 && (e92 += t134.config.markers.hover.sizeOffset + 1), t134.globals.markers.largestSize = e92, e92;
            }
        },
        {
            key: "getSeriesTotals",
            value: function() {
                var t137 = this.w;
                t137.globals.seriesTotals = t137.globals.series.map(function(t138, e) {
                    var i68 = 0;
                    if (Array.isArray(t138)) for(var a52 = 0; a52 < t138.length; a52++)i68 += t138[a52];
                    else i68 += t138;
                    return i68;
                });
            }
        },
        {
            key: "getSeriesTotalsXRange",
            value: function(t139, e93) {
                var i69 = this.w;
                return i69.globals.series.map(function(a53, s37) {
                    for(var r30 = 0, o22 = 0; o22 < a53.length; o22++)i69.globals.seriesX[s37][o22] > t139 && i69.globals.seriesX[s37][o22] < e93 && (r30 += a53[o22]);
                    return r30;
                });
            }
        },
        {
            key: "getPercentSeries",
            value: function() {
                var t140 = this.w;
                t140.globals.seriesPercent = t140.globals.series.map(function(e94, i) {
                    var a54 = [];
                    if (Array.isArray(e94)) for(var s38 = 0; s38 < e94.length; s38++){
                        var r31 = t140.globals.stackedSeriesTotals[s38], o23 = 0;
                        r31 && (o23 = 100 * e94[s38] / r31), a54.push(o23);
                    }
                    else {
                        var n18 = 100 * e94 / t140.globals.seriesTotals.reduce(function(t141, e95) {
                            return t141 + e95;
                        }, 0);
                        a54.push(n18);
                    }
                    return a54;
                });
            }
        },
        {
            key: "getCalculatedRatios",
            value: function() {
                var t142, e96, i70, a55, s39 = this.w.globals, r32 = [], o24 = 0, n19 = [], l13 = .1, h12 = 0;
                if (s39.yRange = [], s39.isMultipleYAxis) for(var c9 = 0; c9 < s39.minYArr.length; c9++)s39.yRange.push(Math.abs(s39.minYArr[c9] - s39.maxYArr[c9])), n19.push(0);
                else s39.yRange.push(Math.abs(s39.minY - s39.maxY));
                s39.xRange = Math.abs(s39.maxX - s39.minX), s39.zRange = Math.abs(s39.maxZ - s39.minZ);
                for(var d7 = 0; d7 < s39.yRange.length; d7++)r32.push(s39.yRange[d7] / s39.gridHeight);
                if (e96 = s39.xRange / s39.gridWidth, i70 = Math.abs(s39.initialMaxX - s39.initialMinX) / s39.gridWidth, t142 = s39.yRange / s39.gridWidth, a55 = s39.xRange / s39.gridHeight, (o24 = s39.zRange / s39.gridHeight * 16) || (o24 = 1), s39.minY !== Number.MIN_VALUE && 0 !== Math.abs(s39.minY) && (s39.hasNegs = !0), s39.isMultipleYAxis) {
                    n19 = [];
                    for(var g5 = 0; g5 < r32.length; g5++)n19.push(-s39.minYArr[g5] / r32[g5]);
                } else n19.push(-s39.minY / r32[0]), s39.minY !== Number.MIN_VALUE && 0 !== Math.abs(s39.minY) && (l13 = -s39.minY / t142, h12 = s39.minX / e96);
                return {
                    yRatio: r32,
                    invertedYRatio: t142,
                    zRatio: o24,
                    xRatio: e96,
                    initialXRatio: i70,
                    invertedXRatio: a55,
                    baseLineInvertedY: l13,
                    baseLineY: n19,
                    baseLineX: h12
                };
            }
        },
        {
            key: "getLogSeries",
            value: function(t143) {
                var e97 = this, i71 = this.w;
                return i71.globals.seriesLog = t143.map(function(t144, a56) {
                    return i71.config.yaxis[a56] && i71.config.yaxis[a56].logarithmic ? t144.map(function(t145) {
                        return null === t145 ? null : e97.getLogVal(i71.config.yaxis[a56].logBase, t145, a56);
                    }) : t144;
                }), i71.globals.invalidLogScale ? t143 : i71.globals.seriesLog;
            }
        },
        {
            key: "getBaseLog",
            value: function(t146, e98) {
                return Math.log(e98) / Math.log(t146);
            }
        },
        {
            key: "getLogVal",
            value: function(t147, e99, i72) {
                if (0 === e99) return 0;
                var a57 = this.w, s40 = 0 === a57.globals.minYArr[i72] ? -1 : this.getBaseLog(t147, a57.globals.minYArr[i72]), r33 = (0 === a57.globals.maxYArr[i72] ? 0 : this.getBaseLog(t147, a57.globals.maxYArr[i72])) - s40;
                return e99 < 1 ? e99 / r33 : (this.getBaseLog(t147, e99) - s40) / r33;
            }
        },
        {
            key: "getLogYRatios",
            value: function(t148) {
                var e100 = this, i73 = this.w, a58 = this.w.globals;
                return a58.yLogRatio = t148.slice(), a58.logYRange = a58.yRange.map(function(t149, s41) {
                    if (i73.config.yaxis[s41] && e100.w.config.yaxis[s41].logarithmic) {
                        var r34, o25 = -Number.MAX_VALUE, n20 = Number.MIN_VALUE;
                        return a58.seriesLog.forEach(function(t150, e101) {
                            t150.forEach(function(t151) {
                                i73.config.yaxis[e101] && i73.config.yaxis[e101].logarithmic && (o25 = Math.max(t151, o25), n20 = Math.min(t151, n20));
                            });
                        }), r34 = Math.pow(a58.yRange[s41], Math.abs(n20 - o25) / a58.yRange[s41]), a58.yLogRatio[s41] = r34 / a58.gridHeight, r34;
                    }
                }), a58.invalidLogScale ? t148.slice() : a58.yLogRatio;
            }
        }
    ], [
        {
            key: "checkComboSeries",
            value: function(t152) {
                var e102 = !1, i74 = 0, a59 = 0;
                return t152.length && void 0 !== t152[0].type && t152.forEach(function(t153) {
                    "bar" !== t153.type && "column" !== t153.type && "candlestick" !== t153.type && "boxPlot" !== t153.type || i74++, void 0 !== t153.type && a59++;
                }), a59 > 0 && (e102 = !0), {
                    comboBarCount: i74,
                    comboCharts: e102
                };
            }
        },
        {
            key: "extendArrayProps",
            value: function(t154, e103, i75) {
                return e103.yaxis && (e103 = t154.extendYAxis(e103, i75)), e103.annotations && (e103.annotations.yaxis && (e103 = t154.extendYAxisAnnotations(e103)), e103.annotations.xaxis && (e103 = t154.extendXAxisAnnotations(e103)), e103.annotations.points && (e103 = t154.extendPointAnnotations(e103))), e103;
            }
        }
    ]), t119;
}(), w = function() {
    function t155(e104) {
        a(this, t155), this.w = e104.w, this.annoCtx = e104;
    }
    return r(t155, [
        {
            key: "setOrientations",
            value: function(t156) {
                var e105 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i76 = this.w;
                if ("vertical" === t156.label.orientation) {
                    var a60 = null !== e105 ? e105 : 0, s42 = i76.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a60, "']"));
                    if (null !== s42) {
                        var r35 = s42.getBoundingClientRect();
                        s42.setAttribute("x", parseFloat(s42.getAttribute("x")) - r35.height + 4), "top" === t156.label.position ? s42.setAttribute("y", parseFloat(s42.getAttribute("y")) + r35.width) : s42.setAttribute("y", parseFloat(s42.getAttribute("y")) - r35.width);
                        var o26 = this.annoCtx.graphics.rotateAroundCenter(s42), n21 = o26.x, l14 = o26.y;
                        s42.setAttribute("transform", "rotate(-90 ".concat(n21, " ").concat(l14, ")"));
                    }
                }
            }
        },
        {
            key: "addBackgroundToAnno",
            value: function(t157, e106) {
                var i77 = this.w;
                if (!t157 || void 0 === e106.label.text || void 0 !== e106.label.text && !String(e106.label.text).trim()) return null;
                var a61 = i77.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), s43 = t157.getBoundingClientRect(), r36 = e106.label.style.padding.left, o27 = e106.label.style.padding.right, n22 = e106.label.style.padding.top, l15 = e106.label.style.padding.bottom;
                "vertical" === e106.label.orientation && (n22 = e106.label.style.padding.left, l15 = e106.label.style.padding.right, r36 = e106.label.style.padding.top, o27 = e106.label.style.padding.bottom);
                var h13 = s43.left - a61.left - r36, c10 = s43.top - a61.top - n22, d8 = this.annoCtx.graphics.drawRect(h13 - i77.globals.barPadForNumericAxis, c10, s43.width + r36 + o27, s43.height + n22 + l15, e106.label.borderRadius, e106.label.style.background, 1, e106.label.borderWidth, e106.label.borderColor, 0);
                return e106.id && d8.node.classList.add(e106.id), d8;
            }
        },
        {
            key: "annotationsBackground",
            value: function() {
                var t158 = this, e107 = this.w, i78 = function(i79, a62, s44) {
                    var r37 = e107.globals.dom.baseEl.querySelector(".apexcharts-".concat(s44, "-annotations .apexcharts-").concat(s44, "-annotation-label[rel='").concat(a62, "']"));
                    if (r37) {
                        var o28 = r37.parentNode, n23 = t158.addBackgroundToAnno(r37, i79);
                        n23 && (o28.insertBefore(n23.node, r37), i79.label.mouseEnter && n23.node.addEventListener("mouseenter", i79.label.mouseEnter.bind(t158, i79)), i79.label.mouseLeave && n23.node.addEventListener("mouseleave", i79.label.mouseLeave.bind(t158, i79)));
                    }
                };
                e107.config.annotations.xaxis.map(function(t159, e108) {
                    i78(t159, e108, "xaxis");
                }), e107.config.annotations.yaxis.map(function(t160, e109) {
                    i78(t160, e109, "yaxis");
                }), e107.config.annotations.points.map(function(t161, e110) {
                    i78(t161, e110, "point");
                });
            }
        },
        {
            key: "getY1Y2",
            value: function(t162, e111) {
                var i80, a63 = "y1" === t162 ? e111.y : e111.y2, s45 = this.w;
                if (this.annoCtx.invertAxis) {
                    var r38 = s45.globals.labels.indexOf(a63);
                    s45.config.xaxis.convertedCatToNumeric && (r38 = s45.globals.categoryLabels.indexOf(a63));
                    var o29 = s45.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (r38 + 1) + ")");
                    o29 && (i80 = parseFloat(o29.getAttribute("y")));
                } else {
                    var n24;
                    if (s45.config.yaxis[e111.yAxisIndex].logarithmic) n24 = (a63 = new y(this.annoCtx.ctx).getLogVal(a63, e111.yAxisIndex)) / s45.globals.yLogRatio[e111.yAxisIndex];
                    else n24 = (a63 - s45.globals.minYArr[e111.yAxisIndex]) / (s45.globals.yRange[e111.yAxisIndex] / s45.globals.gridHeight);
                    i80 = s45.globals.gridHeight - n24, s45.config.yaxis[e111.yAxisIndex] && s45.config.yaxis[e111.yAxisIndex].reversed && (i80 = n24);
                }
                return i80;
            }
        },
        {
            key: "getX1X2",
            value: function(t163, e112) {
                var i81 = this.w, a64 = this.annoCtx.invertAxis ? i81.globals.minY : i81.globals.minX, s46 = this.annoCtx.invertAxis ? i81.globals.maxY : i81.globals.maxX, r39 = this.annoCtx.invertAxis ? i81.globals.yRange[0] : i81.globals.xRange, o30 = (e112.x - a64) / (r39 / i81.globals.gridWidth);
                this.annoCtx.inversedReversedAxis && (o30 = (s46 - e112.x) / (r39 / i81.globals.gridWidth)), "category" !== i81.config.xaxis.type && !i81.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i81.globals.dataFormatXNumeric || (o30 = this.getStringX(e112.x));
                var n25 = (e112.x2 - a64) / (r39 / i81.globals.gridWidth);
                return this.annoCtx.inversedReversedAxis && (n25 = (s46 - e112.x2) / (r39 / i81.globals.gridWidth)), "category" !== i81.config.xaxis.type && !i81.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i81.globals.dataFormatXNumeric || (n25 = this.getStringX(e112.x2)), "x1" === t163 ? o30 : n25;
            }
        },
        {
            key: "getStringX",
            value: function(t164) {
                var e113 = this.w, i82 = t164;
                e113.config.xaxis.convertedCatToNumeric && e113.globals.categoryLabels.length && (t164 = e113.globals.categoryLabels.indexOf(t164) + 1);
                var a65 = e113.globals.labels.indexOf(t164), s47 = e113.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (a65 + 1) + ")");
                return s47 && (i82 = parseFloat(s47.getAttribute("x"))), i82;
            }
        }
    ]), t155;
}(), k = function() {
    function t165(e114) {
        a(this, t165), this.w = e114.w, this.annoCtx = e114, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new w(this.annoCtx);
    }
    return r(t165, [
        {
            key: "addXaxisAnnotation",
            value: function(t166, e115, i83) {
                var a66, s48 = this.w, r40 = this.helpers.getX1X2("x1", t166), o31 = t166.label.text, n26 = t166.strokeDashArray;
                if (x.isNumber(r40)) {
                    if (null === t166.x2 || void 0 === t166.x2) {
                        var l16 = this.annoCtx.graphics.drawLine(r40 + t166.offsetX, 0 + t166.offsetY, r40 + t166.offsetX, s48.globals.gridHeight + t166.offsetY, t166.borderColor, n26, t166.borderWidth);
                        e115.appendChild(l16.node), t166.id && l16.node.classList.add(t166.id);
                    } else {
                        if ((a66 = this.helpers.getX1X2("x2", t166)) < r40) {
                            var h14 = r40;
                            r40 = a66, a66 = h14;
                        }
                        var c11 = this.annoCtx.graphics.drawRect(r40 + t166.offsetX, 0 + t166.offsetY, a66 - r40, s48.globals.gridHeight + t166.offsetY, 0, t166.fillColor, t166.opacity, 1, t166.borderColor, n26);
                        c11.node.classList.add("apexcharts-annotation-rect"), c11.attr("clip-path", "url(#gridRectMask".concat(s48.globals.cuid, ")")), e115.appendChild(c11.node), t166.id && c11.node.classList.add(t166.id);
                    }
                    var d9 = "top" === t166.label.position ? 4 : s48.globals.gridHeight, g6 = this.annoCtx.graphics.getTextRects(o31, parseFloat(t166.label.style.fontSize)), u5 = this.annoCtx.graphics.drawText({
                        x: r40 + t166.label.offsetX,
                        y: d9 + t166.label.offsetY - ("vertical" === t166.label.orientation ? "top" === t166.label.position ? g6.width / 2 - 12 : -g6.width / 2 : 0),
                        text: o31,
                        textAnchor: t166.label.textAnchor,
                        fontSize: t166.label.style.fontSize,
                        fontFamily: t166.label.style.fontFamily,
                        fontWeight: t166.label.style.fontWeight,
                        foreColor: t166.label.style.color,
                        cssClass: "apexcharts-xaxis-annotation-label ".concat(t166.label.style.cssClass, " ").concat(t166.id ? t166.id : "")
                    });
                    u5.attr({
                        rel: i83
                    }), e115.appendChild(u5.node), this.annoCtx.helpers.setOrientations(t166, i83);
                }
            }
        },
        {
            key: "drawXAxisAnnotations",
            value: function() {
                var t167 = this, e116 = this.w, i84 = this.annoCtx.graphics.group({
                    class: "apexcharts-xaxis-annotations"
                });
                return e116.config.annotations.xaxis.map(function(e117, a67) {
                    t167.addXaxisAnnotation(e117, i84.node, a67);
                }), i84;
            }
        }
    ]), t165;
}(), A = function() {
    function t168(e118) {
        a(this, t168), this.w = e118.w, this.annoCtx = e118, this.helpers = new w(this.annoCtx);
    }
    return r(t168, [
        {
            key: "addYaxisAnnotation",
            value: function(t169, e119, i85) {
                var a68, s49 = this.w, r41 = t169.strokeDashArray, o32 = this.helpers.getY1Y2("y1", t169), n27 = t169.label.text;
                if (null === t169.y2 || void 0 === t169.y2) {
                    var l17 = this.annoCtx.graphics.drawLine(0 + t169.offsetX, o32 + t169.offsetY, this._getYAxisAnnotationWidth(t169), o32 + t169.offsetY, t169.borderColor, r41, t169.borderWidth);
                    e119.appendChild(l17.node), t169.id && l17.node.classList.add(t169.id);
                } else {
                    if ((a68 = this.helpers.getY1Y2("y2", t169)) > o32) {
                        var h15 = o32;
                        o32 = a68, a68 = h15;
                    }
                    var c12 = this.annoCtx.graphics.drawRect(0 + t169.offsetX, a68 + t169.offsetY, this._getYAxisAnnotationWidth(t169), o32 - a68, 0, t169.fillColor, t169.opacity, 1, t169.borderColor, r41);
                    c12.node.classList.add("apexcharts-annotation-rect"), c12.attr("clip-path", "url(#gridRectMask".concat(s49.globals.cuid, ")")), e119.appendChild(c12.node), t169.id && c12.node.classList.add(t169.id);
                }
                var d10 = "right" === t169.label.position ? s49.globals.gridWidth : 0, g7 = this.annoCtx.graphics.drawText({
                    x: d10 + t169.label.offsetX,
                    y: (null != a68 ? a68 : o32) + t169.label.offsetY - 3,
                    text: n27,
                    textAnchor: t169.label.textAnchor,
                    fontSize: t169.label.style.fontSize,
                    fontFamily: t169.label.style.fontFamily,
                    fontWeight: t169.label.style.fontWeight,
                    foreColor: t169.label.style.color,
                    cssClass: "apexcharts-yaxis-annotation-label ".concat(t169.label.style.cssClass, " ").concat(t169.id ? t169.id : "")
                });
                g7.attr({
                    rel: i85
                }), e119.appendChild(g7.node);
            }
        },
        {
            key: "_getYAxisAnnotationWidth",
            value: function(t170) {
                var e120 = this.w;
                e120.globals.gridWidth;
                return (t170.width.indexOf("%") > -1 ? e120.globals.gridWidth * parseInt(t170.width, 10) / 100 : parseInt(t170.width, 10)) + t170.offsetX;
            }
        },
        {
            key: "drawYAxisAnnotations",
            value: function() {
                var t171 = this, e121 = this.w, i86 = this.annoCtx.graphics.group({
                    class: "apexcharts-yaxis-annotations"
                });
                return e121.config.annotations.yaxis.map(function(e122, a69) {
                    t171.addYaxisAnnotation(e122, i86.node, a69);
                }), i86;
            }
        }
    ]), t168;
}(), S = function() {
    function t172(e123) {
        a(this, t172), this.w = e123.w, this.annoCtx = e123, this.helpers = new w(this.annoCtx);
    }
    return r(t172, [
        {
            key: "addPointAnnotation",
            value: function(t173, e124, i87) {
                this.w;
                var a70 = this.helpers.getX1X2("x1", t173), s50 = this.helpers.getY1Y2("y1", t173);
                if (x.isNumber(a70)) {
                    var r42 = {
                        pSize: t173.marker.size,
                        pointStrokeWidth: t173.marker.strokeWidth,
                        pointFillColor: t173.marker.fillColor,
                        pointStrokeColor: t173.marker.strokeColor,
                        shape: t173.marker.shape,
                        pRadius: t173.marker.radius,
                        class: "apexcharts-point-annotation-marker ".concat(t173.marker.cssClass, " ").concat(t173.id ? t173.id : "")
                    }, o33 = this.annoCtx.graphics.drawMarker(a70 + t173.marker.offsetX, s50 + t173.marker.offsetY, r42);
                    e124.appendChild(o33.node);
                    var n28 = t173.label.text ? t173.label.text : "", l18 = this.annoCtx.graphics.drawText({
                        x: a70 + t173.label.offsetX,
                        y: s50 + t173.label.offsetY - t173.marker.size - parseFloat(t173.label.style.fontSize) / 1.6,
                        text: n28,
                        textAnchor: t173.label.textAnchor,
                        fontSize: t173.label.style.fontSize,
                        fontFamily: t173.label.style.fontFamily,
                        fontWeight: t173.label.style.fontWeight,
                        foreColor: t173.label.style.color,
                        cssClass: "apexcharts-point-annotation-label ".concat(t173.label.style.cssClass, " ").concat(t173.id ? t173.id : "")
                    });
                    if (l18.attr({
                        rel: i87
                    }), e124.appendChild(l18.node), t173.customSVG.SVG) {
                        var h16 = this.annoCtx.graphics.group({
                            class: "apexcharts-point-annotations-custom-svg " + t173.customSVG.cssClass
                        });
                        h16.attr({
                            transform: "translate(".concat(a70 + t173.customSVG.offsetX, ", ").concat(s50 + t173.customSVG.offsetY, ")")
                        }), h16.node.innerHTML = t173.customSVG.SVG, e124.appendChild(h16.node);
                    }
                    if (t173.image.path) {
                        var c13 = t173.image.width ? t173.image.width : 20, d11 = t173.image.height ? t173.image.height : 20;
                        o33 = this.annoCtx.addImage({
                            x: a70 + t173.image.offsetX - c13 / 2,
                            y: s50 + t173.image.offsetY - d11 / 2,
                            width: c13,
                            height: d11,
                            path: t173.image.path,
                            appendTo: ".apexcharts-point-annotations"
                        });
                    }
                    t173.mouseEnter && o33.node.addEventListener("mouseenter", t173.mouseEnter.bind(this, t173)), t173.mouseLeave && o33.node.addEventListener("mouseleave", t173.mouseLeave.bind(this, t173));
                }
            }
        },
        {
            key: "drawPointAnnotations",
            value: function() {
                var t174 = this, e125 = this.w, i88 = this.annoCtx.graphics.group({
                    class: "apexcharts-point-annotations"
                });
                return e125.config.annotations.points.map(function(e126, a71) {
                    t174.addPointAnnotation(e126, i88.node, a71);
                }), i88;
            }
        }
    ]), t172;
}();
var C = {
    name: "en",
    options: {
        months: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
        ],
        shortMonths: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
        ],
        days: [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
        ],
        shortDays: [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
        ],
        toolbar: {
            exportToSVG: "Download SVG",
            exportToPNG: "Download PNG",
            exportToCSV: "Download CSV",
            menu: "Menu",
            selection: "Selection",
            selectionZoom: "Selection Zoom",
            zoomIn: "Zoom In",
            zoomOut: "Zoom Out",
            pan: "Panning",
            reset: "Reset Zoom"
        }
    }
}, L = function() {
    function t175() {
        a(this, t175), this.yAxis = {
            show: !0,
            showAlways: !1,
            showForNullSeries: !0,
            seriesName: void 0,
            opposite: !1,
            reversed: !1,
            logarithmic: !1,
            logBase: 10,
            tickAmount: void 0,
            forceNiceScale: !1,
            max: void 0,
            min: void 0,
            floating: !1,
            decimalsInFloat: void 0,
            labels: {
                show: !0,
                minWidth: 0,
                maxWidth: 160,
                offsetX: 0,
                offsetY: 0,
                align: void 0,
                rotate: 0,
                padding: 20,
                style: {
                    colors: [],
                    fontSize: "11px",
                    fontWeight: 400,
                    fontFamily: void 0,
                    cssClass: ""
                },
                formatter: void 0
            },
            axisBorder: {
                show: !1,
                color: "#e0e0e0",
                width: 1,
                offsetX: 0,
                offsetY: 0
            },
            axisTicks: {
                show: !1,
                color: "#e0e0e0",
                width: 6,
                offsetX: 0,
                offsetY: 0
            },
            title: {
                text: void 0,
                rotate: -90,
                offsetY: 0,
                offsetX: 0,
                style: {
                    color: void 0,
                    fontSize: "11px",
                    fontWeight: 900,
                    fontFamily: void 0,
                    cssClass: ""
                }
            },
            tooltip: {
                enabled: !1,
                offsetX: 0
            },
            crosshairs: {
                show: !0,
                position: "front",
                stroke: {
                    color: "#b6b6b6",
                    width: 1,
                    dashArray: 0
                }
            }
        }, this.pointAnnotation = {
            id: void 0,
            x: 0,
            y: null,
            yAxisIndex: 0,
            seriesIndex: 0,
            mouseEnter: void 0,
            mouseLeave: void 0,
            marker: {
                size: 4,
                fillColor: "#fff",
                strokeWidth: 2,
                strokeColor: "#333",
                shape: "circle",
                offsetX: 0,
                offsetY: 0,
                radius: 2,
                cssClass: ""
            },
            label: {
                borderColor: "#c2c2c2",
                borderWidth: 1,
                borderRadius: 2,
                text: void 0,
                textAnchor: "middle",
                offsetX: 0,
                offsetY: 0,
                mouseEnter: void 0,
                mouseLeave: void 0,
                style: {
                    background: "#fff",
                    color: void 0,
                    fontSize: "11px",
                    fontFamily: void 0,
                    fontWeight: 400,
                    cssClass: "",
                    padding: {
                        left: 5,
                        right: 5,
                        top: 2,
                        bottom: 2
                    }
                }
            },
            customSVG: {
                SVG: void 0,
                cssClass: void 0,
                offsetX: 0,
                offsetY: 0
            },
            image: {
                path: void 0,
                width: 20,
                height: 20,
                offsetX: 0,
                offsetY: 0
            }
        }, this.yAxisAnnotation = {
            id: void 0,
            y: 0,
            y2: null,
            strokeDashArray: 1,
            fillColor: "#c2c2c2",
            borderColor: "#c2c2c2",
            borderWidth: 1,
            opacity: .3,
            offsetX: 0,
            offsetY: 0,
            width: "100%",
            yAxisIndex: 0,
            label: {
                borderColor: "#c2c2c2",
                borderWidth: 1,
                borderRadius: 2,
                text: void 0,
                textAnchor: "end",
                position: "right",
                offsetX: 0,
                offsetY: -3,
                mouseEnter: void 0,
                mouseLeave: void 0,
                style: {
                    background: "#fff",
                    color: void 0,
                    fontSize: "11px",
                    fontFamily: void 0,
                    fontWeight: 400,
                    cssClass: "",
                    padding: {
                        left: 5,
                        right: 5,
                        top: 2,
                        bottom: 2
                    }
                }
            }
        }, this.xAxisAnnotation = {
            id: void 0,
            x: 0,
            x2: null,
            strokeDashArray: 1,
            fillColor: "#c2c2c2",
            borderColor: "#c2c2c2",
            borderWidth: 1,
            opacity: .3,
            offsetX: 0,
            offsetY: 0,
            label: {
                borderColor: "#c2c2c2",
                borderWidth: 1,
                borderRadius: 2,
                text: void 0,
                textAnchor: "middle",
                orientation: "vertical",
                position: "top",
                offsetX: 0,
                offsetY: 0,
                mouseEnter: void 0,
                mouseLeave: void 0,
                style: {
                    background: "#fff",
                    color: void 0,
                    fontSize: "11px",
                    fontFamily: void 0,
                    fontWeight: 400,
                    cssClass: "",
                    padding: {
                        left: 5,
                        right: 5,
                        top: 2,
                        bottom: 2
                    }
                }
            }
        }, this.text = {
            x: 0,
            y: 0,
            text: "",
            textAnchor: "start",
            foreColor: void 0,
            fontSize: "13px",
            fontFamily: void 0,
            fontWeight: 400,
            appendTo: ".apexcharts-annotations",
            backgroundColor: "transparent",
            borderColor: "#c2c2c2",
            borderRadius: 0,
            borderWidth: 0,
            paddingLeft: 4,
            paddingRight: 4,
            paddingTop: 2,
            paddingBottom: 2
        };
    }
    return r(t175, [
        {
            key: "init",
            value: function() {
                return {
                    annotations: {
                        position: "front",
                        yaxis: [
                            this.yAxisAnnotation
                        ],
                        xaxis: [
                            this.xAxisAnnotation
                        ],
                        points: [
                            this.pointAnnotation
                        ],
                        texts: [],
                        images: [],
                        shapes: []
                    },
                    chart: {
                        animations: {
                            enabled: !0,
                            easing: "easeinout",
                            speed: 800,
                            animateGradually: {
                                delay: 150,
                                enabled: !0
                            },
                            dynamicAnimation: {
                                enabled: !0,
                                speed: 350
                            }
                        },
                        background: "transparent",
                        locales: [
                            C
                        ],
                        defaultLocale: "en",
                        dropShadow: {
                            enabled: !1,
                            enabledOnSeries: void 0,
                            top: 2,
                            left: 2,
                            blur: 4,
                            color: "#000",
                            opacity: .35
                        },
                        events: {
                            animationEnd: void 0,
                            beforeMount: void 0,
                            mounted: void 0,
                            updated: void 0,
                            click: void 0,
                            mouseMove: void 0,
                            mouseLeave: void 0,
                            legendClick: void 0,
                            markerClick: void 0,
                            selection: void 0,
                            dataPointSelection: void 0,
                            dataPointMouseEnter: void 0,
                            dataPointMouseLeave: void 0,
                            beforeZoom: void 0,
                            beforeResetZoom: void 0,
                            zoomed: void 0,
                            scrolled: void 0,
                            brushScrolled: void 0
                        },
                        foreColor: "#373d3f",
                        fontFamily: "Helvetica, Arial, sans-serif",
                        height: "auto",
                        parentHeightOffset: 15,
                        redrawOnParentResize: !0,
                        redrawOnWindowResize: !0,
                        id: void 0,
                        group: void 0,
                        offsetX: 0,
                        offsetY: 0,
                        selection: {
                            enabled: !1,
                            type: "x",
                            fill: {
                                color: "#24292e",
                                opacity: .1
                            },
                            stroke: {
                                width: 1,
                                color: "#24292e",
                                opacity: .4,
                                dashArray: 3
                            },
                            xaxis: {
                                min: void 0,
                                max: void 0
                            },
                            yaxis: {
                                min: void 0,
                                max: void 0
                            }
                        },
                        sparkline: {
                            enabled: !1
                        },
                        brush: {
                            enabled: !1,
                            autoScaleYaxis: !0,
                            target: void 0
                        },
                        stacked: !1,
                        stackType: "normal",
                        toolbar: {
                            show: !0,
                            offsetX: 0,
                            offsetY: 0,
                            tools: {
                                download: !0,
                                selection: !0,
                                zoom: !0,
                                zoomin: !0,
                                zoomout: !0,
                                pan: !0,
                                reset: !0,
                                customIcons: []
                            },
                            export: {
                                csv: {
                                    filename: void 0,
                                    columnDelimiter: ",",
                                    headerCategory: "category",
                                    headerValue: "value",
                                    dateFormatter: function(t176) {
                                        return new Date(t176).toDateString();
                                    }
                                },
                                png: {
                                    filename: void 0
                                },
                                svg: {
                                    filename: void 0
                                }
                            },
                            autoSelected: "zoom"
                        },
                        type: "line",
                        width: "100%",
                        zoom: {
                            enabled: !0,
                            type: "x",
                            autoScaleYaxis: !1,
                            zoomedArea: {
                                fill: {
                                    color: "#90CAF9",
                                    opacity: .4
                                },
                                stroke: {
                                    color: "#0D47A1",
                                    opacity: .4,
                                    width: 1
                                }
                            }
                        }
                    },
                    plotOptions: {
                        area: {
                            fillTo: "origin"
                        },
                        bar: {
                            horizontal: !1,
                            columnWidth: "70%",
                            barHeight: "70%",
                            distributed: !1,
                            borderRadius: 0,
                            rangeBarOverlap: !0,
                            rangeBarGroupRows: !1,
                            colors: {
                                ranges: [],
                                backgroundBarColors: [],
                                backgroundBarOpacity: 1,
                                backgroundBarRadius: 0
                            },
                            dataLabels: {
                                position: "top",
                                maxItems: 100,
                                hideOverflowingLabels: !0,
                                orientation: "horizontal"
                            }
                        },
                        bubble: {
                            minBubbleRadius: void 0,
                            maxBubbleRadius: void 0
                        },
                        candlestick: {
                            colors: {
                                upward: "#00B746",
                                downward: "#EF403C"
                            },
                            wick: {
                                useFillColor: !0
                            }
                        },
                        boxPlot: {
                            colors: {
                                upper: "#00E396",
                                lower: "#008FFB"
                            }
                        },
                        heatmap: {
                            radius: 2,
                            enableShades: !0,
                            shadeIntensity: .5,
                            reverseNegativeShade: !1,
                            distributed: !1,
                            useFillColorAsStroke: !1,
                            colorScale: {
                                inverse: !1,
                                ranges: [],
                                min: void 0,
                                max: void 0
                            }
                        },
                        treemap: {
                            enableShades: !0,
                            shadeIntensity: .5,
                            distributed: !1,
                            reverseNegativeShade: !1,
                            useFillColorAsStroke: !1,
                            colorScale: {
                                inverse: !1,
                                ranges: [],
                                min: void 0,
                                max: void 0
                            }
                        },
                        radialBar: {
                            inverseOrder: !1,
                            startAngle: 0,
                            endAngle: 360,
                            offsetX: 0,
                            offsetY: 0,
                            hollow: {
                                margin: 5,
                                size: "50%",
                                background: "transparent",
                                image: void 0,
                                imageWidth: 150,
                                imageHeight: 150,
                                imageOffsetX: 0,
                                imageOffsetY: 0,
                                imageClipped: !0,
                                position: "front",
                                dropShadow: {
                                    enabled: !1,
                                    top: 0,
                                    left: 0,
                                    blur: 3,
                                    color: "#000",
                                    opacity: .5
                                }
                            },
                            track: {
                                show: !0,
                                startAngle: void 0,
                                endAngle: void 0,
                                background: "#f2f2f2",
                                strokeWidth: "97%",
                                opacity: 1,
                                margin: 5,
                                dropShadow: {
                                    enabled: !1,
                                    top: 0,
                                    left: 0,
                                    blur: 3,
                                    color: "#000",
                                    opacity: .5
                                }
                            },
                            dataLabels: {
                                show: !0,
                                name: {
                                    show: !0,
                                    fontSize: "16px",
                                    fontFamily: void 0,
                                    fontWeight: 600,
                                    color: void 0,
                                    offsetY: 0,
                                    formatter: function(t177) {
                                        return t177;
                                    }
                                },
                                value: {
                                    show: !0,
                                    fontSize: "14px",
                                    fontFamily: void 0,
                                    fontWeight: 400,
                                    color: void 0,
                                    offsetY: 16,
                                    formatter: function(t178) {
                                        return t178 + "%";
                                    }
                                },
                                total: {
                                    show: !1,
                                    label: "Total",
                                    fontSize: "16px",
                                    fontWeight: 600,
                                    fontFamily: void 0,
                                    color: void 0,
                                    formatter: function(t179) {
                                        return t179.globals.seriesTotals.reduce(function(t180, e127) {
                                            return t180 + e127;
                                        }, 0) / t179.globals.series.length + "%";
                                    }
                                }
                            }
                        },
                        pie: {
                            customScale: 1,
                            offsetX: 0,
                            offsetY: 0,
                            startAngle: 0,
                            endAngle: 360,
                            expandOnClick: !0,
                            dataLabels: {
                                offset: 0,
                                minAngleToShowLabel: 10
                            },
                            donut: {
                                size: "65%",
                                background: "transparent",
                                labels: {
                                    show: !1,
                                    name: {
                                        show: !0,
                                        fontSize: "16px",
                                        fontFamily: void 0,
                                        fontWeight: 600,
                                        color: void 0,
                                        offsetY: -10,
                                        formatter: function(t181) {
                                            return t181;
                                        }
                                    },
                                    value: {
                                        show: !0,
                                        fontSize: "20px",
                                        fontFamily: void 0,
                                        fontWeight: 400,
                                        color: void 0,
                                        offsetY: 10,
                                        formatter: function(t182) {
                                            return t182;
                                        }
                                    },
                                    total: {
                                        show: !1,
                                        showAlways: !1,
                                        label: "Total",
                                        fontSize: "16px",
                                        fontWeight: 400,
                                        fontFamily: void 0,
                                        color: void 0,
                                        formatter: function(t183) {
                                            return t183.globals.seriesTotals.reduce(function(t184, e128) {
                                                return t184 + e128;
                                            }, 0);
                                        }
                                    }
                                }
                            }
                        },
                        polarArea: {
                            rings: {
                                strokeWidth: 1,
                                strokeColor: "#e8e8e8"
                            },
                            spokes: {
                                strokeWidth: 1,
                                connectorColors: "#e8e8e8"
                            }
                        },
                        radar: {
                            size: void 0,
                            offsetX: 0,
                            offsetY: 0,
                            polygons: {
                                strokeWidth: 1,
                                strokeColors: "#e8e8e8",
                                connectorColors: "#e8e8e8",
                                fill: {
                                    colors: void 0
                                }
                            }
                        }
                    },
                    colors: void 0,
                    dataLabels: {
                        enabled: !0,
                        enabledOnSeries: void 0,
                        formatter: function(t185) {
                            return null !== t185 ? t185 : "";
                        },
                        textAnchor: "middle",
                        distributed: !1,
                        offsetX: 0,
                        offsetY: 0,
                        style: {
                            fontSize: "12px",
                            fontFamily: void 0,
                            fontWeight: 600,
                            colors: void 0
                        },
                        background: {
                            enabled: !0,
                            foreColor: "#fff",
                            borderRadius: 2,
                            padding: 4,
                            opacity: .9,
                            borderWidth: 1,
                            borderColor: "#fff",
                            dropShadow: {
                                enabled: !1,
                                top: 1,
                                left: 1,
                                blur: 1,
                                color: "#000",
                                opacity: .45
                            }
                        },
                        dropShadow: {
                            enabled: !1,
                            top: 1,
                            left: 1,
                            blur: 1,
                            color: "#000",
                            opacity: .45
                        }
                    },
                    fill: {
                        type: "solid",
                        colors: void 0,
                        opacity: .85,
                        gradient: {
                            shade: "dark",
                            type: "horizontal",
                            shadeIntensity: .5,
                            gradientToColors: void 0,
                            inverseColors: !0,
                            opacityFrom: 1,
                            opacityTo: 1,
                            stops: [
                                0,
                                50,
                                100
                            ],
                            colorStops: []
                        },
                        image: {
                            src: [],
                            width: void 0,
                            height: void 0
                        },
                        pattern: {
                            style: "squares",
                            width: 6,
                            height: 6,
                            strokeWidth: 2
                        }
                    },
                    forecastDataPoints: {
                        count: 0,
                        fillOpacity: .5,
                        strokeWidth: void 0,
                        dashArray: 4
                    },
                    grid: {
                        show: !0,
                        borderColor: "#e0e0e0",
                        strokeDashArray: 0,
                        position: "back",
                        xaxis: {
                            lines: {
                                show: !1
                            }
                        },
                        yaxis: {
                            lines: {
                                show: !0
                            }
                        },
                        row: {
                            colors: void 0,
                            opacity: .5
                        },
                        column: {
                            colors: void 0,
                            opacity: .5
                        },
                        padding: {
                            top: 0,
                            right: 10,
                            bottom: 0,
                            left: 12
                        }
                    },
                    labels: [],
                    legend: {
                        show: !0,
                        showForSingleSeries: !1,
                        showForNullSeries: !0,
                        showForZeroSeries: !0,
                        floating: !1,
                        position: "bottom",
                        horizontalAlign: "center",
                        inverseOrder: !1,
                        fontSize: "12px",
                        fontFamily: void 0,
                        fontWeight: 400,
                        width: void 0,
                        height: void 0,
                        formatter: void 0,
                        tooltipHoverFormatter: void 0,
                        offsetX: -20,
                        offsetY: 4,
                        customLegendItems: [],
                        labels: {
                            colors: void 0,
                            useSeriesColors: !1
                        },
                        markers: {
                            width: 12,
                            height: 12,
                            strokeWidth: 0,
                            fillColors: void 0,
                            strokeColor: "#fff",
                            radius: 12,
                            customHTML: void 0,
                            offsetX: 0,
                            offsetY: 0,
                            onClick: void 0
                        },
                        itemMargin: {
                            horizontal: 5,
                            vertical: 2
                        },
                        onItemClick: {
                            toggleDataSeries: !0
                        },
                        onItemHover: {
                            highlightDataSeries: !0
                        }
                    },
                    markers: {
                        discrete: [],
                        size: 0,
                        colors: void 0,
                        strokeColors: "#fff",
                        strokeWidth: 2,
                        strokeOpacity: .9,
                        strokeDashArray: 0,
                        fillOpacity: 1,
                        shape: "circle",
                        width: 8,
                        height: 8,
                        radius: 2,
                        offsetX: 0,
                        offsetY: 0,
                        onClick: void 0,
                        onDblClick: void 0,
                        showNullDataPoints: !0,
                        hover: {
                            size: void 0,
                            sizeOffset: 3
                        }
                    },
                    noData: {
                        text: void 0,
                        align: "center",
                        verticalAlign: "middle",
                        offsetX: 0,
                        offsetY: 0,
                        style: {
                            color: void 0,
                            fontSize: "14px",
                            fontFamily: void 0
                        }
                    },
                    responsive: [],
                    series: void 0,
                    states: {
                        normal: {
                            filter: {
                                type: "none",
                                value: 0
                            }
                        },
                        hover: {
                            filter: {
                                type: "lighten",
                                value: .1
                            }
                        },
                        active: {
                            allowMultipleDataPointsSelection: !1,
                            filter: {
                                type: "darken",
                                value: .5
                            }
                        }
                    },
                    title: {
                        text: void 0,
                        align: "left",
                        margin: 5,
                        offsetX: 0,
                        offsetY: 0,
                        floating: !1,
                        style: {
                            fontSize: "14px",
                            fontWeight: 900,
                            fontFamily: void 0,
                            color: void 0
                        }
                    },
                    subtitle: {
                        text: void 0,
                        align: "left",
                        margin: 5,
                        offsetX: 0,
                        offsetY: 30,
                        floating: !1,
                        style: {
                            fontSize: "12px",
                            fontWeight: 400,
                            fontFamily: void 0,
                            color: void 0
                        }
                    },
                    stroke: {
                        show: !0,
                        curve: "smooth",
                        lineCap: "butt",
                        width: 2,
                        colors: void 0,
                        dashArray: 0
                    },
                    tooltip: {
                        enabled: !0,
                        enabledOnSeries: void 0,
                        shared: !0,
                        followCursor: !1,
                        intersect: !1,
                        inverseOrder: !1,
                        custom: void 0,
                        fillSeriesColor: !1,
                        theme: "light",
                        cssClass: "",
                        style: {
                            fontSize: "12px",
                            fontFamily: void 0
                        },
                        onDatasetHover: {
                            highlightDataSeries: !1
                        },
                        x: {
                            show: !0,
                            format: "dd MMM",
                            formatter: void 0
                        },
                        y: {
                            formatter: void 0,
                            title: {
                                formatter: function(t186) {
                                    return t186 ? t186 + ": " : "";
                                }
                            }
                        },
                        z: {
                            formatter: void 0,
                            title: "Size: "
                        },
                        marker: {
                            show: !0,
                            fillColors: void 0
                        },
                        items: {
                            display: "flex"
                        },
                        fixed: {
                            enabled: !1,
                            position: "topRight",
                            offsetX: 0,
                            offsetY: 0
                        }
                    },
                    xaxis: {
                        type: "category",
                        categories: [],
                        convertedCatToNumeric: !1,
                        offsetX: 0,
                        offsetY: 0,
                        overwriteCategories: void 0,
                        labels: {
                            show: !0,
                            rotate: -45,
                            rotateAlways: !1,
                            hideOverlappingLabels: !0,
                            trim: !1,
                            minHeight: void 0,
                            maxHeight: 120,
                            showDuplicates: !0,
                            style: {
                                colors: [],
                                fontSize: "12px",
                                fontWeight: 400,
                                fontFamily: void 0,
                                cssClass: ""
                            },
                            offsetX: 0,
                            offsetY: 0,
                            format: void 0,
                            formatter: void 0,
                            datetimeUTC: !0,
                            datetimeFormatter: {
                                year: "yyyy",
                                month: "MMM 'yy",
                                day: "dd MMM",
                                hour: "HH:mm",
                                minute: "HH:mm:ss",
                                second: "HH:mm:ss"
                            },
                            group: {
                                groups: [],
                                style: {
                                    colors: [],
                                    fontSize: "12px",
                                    fontWeight: 400,
                                    fontFamily: void 0,
                                    cssClass: ""
                                }
                            }
                        },
                        axisBorder: {
                            show: !0,
                            color: "#e0e0e0",
                            width: "100%",
                            height: 1,
                            offsetX: 0,
                            offsetY: 0
                        },
                        axisTicks: {
                            show: !0,
                            color: "#e0e0e0",
                            height: 6,
                            offsetX: 0,
                            offsetY: 0
                        },
                        tickAmount: void 0,
                        tickPlacement: "on",
                        min: void 0,
                        max: void 0,
                        range: void 0,
                        floating: !1,
                        decimalsInFloat: void 0,
                        position: "bottom",
                        title: {
                            text: void 0,
                            offsetX: 0,
                            offsetY: 0,
                            style: {
                                color: void 0,
                                fontSize: "12px",
                                fontWeight: 900,
                                fontFamily: void 0,
                                cssClass: ""
                            }
                        },
                        crosshairs: {
                            show: !0,
                            width: 1,
                            position: "back",
                            opacity: .9,
                            stroke: {
                                color: "#b6b6b6",
                                width: 1,
                                dashArray: 3
                            },
                            fill: {
                                type: "solid",
                                color: "#B1B9C4",
                                gradient: {
                                    colorFrom: "#D8E3F0",
                                    colorTo: "#BED1E6",
                                    stops: [
                                        0,
                                        100
                                    ],
                                    opacityFrom: .4,
                                    opacityTo: .5
                                }
                            },
                            dropShadow: {
                                enabled: !1,
                                left: 0,
                                top: 0,
                                blur: 1,
                                opacity: .4
                            }
                        },
                        tooltip: {
                            enabled: !0,
                            offsetY: 0,
                            formatter: void 0,
                            style: {
                                fontSize: "12px",
                                fontFamily: void 0
                            }
                        }
                    },
                    yaxis: this.yAxis,
                    theme: {
                        mode: "light",
                        palette: "palette1",
                        monochrome: {
                            enabled: !1,
                            color: "#008FFB",
                            shadeTo: "light",
                            shadeIntensity: .65
                        }
                    }
                };
            }
        }
    ]), t175;
}(), P = function() {
    function t187(e129) {
        a(this, t187), this.ctx = e129, this.w = e129.w, this.graphics = new m(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new w(this), this.xAxisAnnotations = new k(this), this.yAxisAnnotations = new A(this), this.pointsAnnotations = new S(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
    }
    return r(t187, [
        {
            key: "drawAxesAnnotations",
            value: function() {
                var t188 = this.w;
                if (t188.globals.axisCharts) {
                    for(var e130 = this.yAxisAnnotations.drawYAxisAnnotations(), i89 = this.xAxisAnnotations.drawXAxisAnnotations(), a72 = this.pointsAnnotations.drawPointAnnotations(), s51 = t188.config.chart.animations.enabled, r43 = [
                        e130,
                        i89,
                        a72
                    ], o34 = [
                        i89.node,
                        e130.node,
                        a72.node
                    ], n29 = 0; n29 < 3; n29++)t188.globals.dom.elGraphical.add(r43[n29]), !s51 || t188.globals.resized || t188.globals.dataChanged || "scatter" !== t188.config.chart.type && "bubble" !== t188.config.chart.type && t188.globals.dataPoints > 1 && o34[n29].classList.add("apexcharts-element-hidden"), t188.globals.delayedElements.push({
                        el: o34[n29],
                        index: 0
                    });
                    this.helpers.annotationsBackground();
                }
            }
        },
        {
            key: "drawImageAnnos",
            value: function() {
                var t189 = this;
                this.w.config.annotations.images.map(function(e131, i90) {
                    t189.addImage(e131, i90);
                });
            }
        },
        {
            key: "drawTextAnnos",
            value: function() {
                var t190 = this;
                this.w.config.annotations.texts.map(function(e132, i91) {
                    t190.addText(e132, i91);
                });
            }
        },
        {
            key: "addXaxisAnnotation",
            value: function(t191, e133, i92) {
                this.xAxisAnnotations.addXaxisAnnotation(t191, e133, i92);
            }
        },
        {
            key: "addYaxisAnnotation",
            value: function(t192, e134, i93) {
                this.yAxisAnnotations.addYaxisAnnotation(t192, e134, i93);
            }
        },
        {
            key: "addPointAnnotation",
            value: function(t193, e135, i94) {
                this.pointsAnnotations.addPointAnnotation(t193, e135, i94);
            }
        },
        {
            key: "addText",
            value: function(t194, e) {
                var i95 = t194.x, a73 = t194.y, s52 = t194.text, r44 = t194.textAnchor, o35 = t194.foreColor, n30 = t194.fontSize, l19 = t194.fontFamily, h17 = t194.fontWeight, c14 = t194.cssClass, d12 = t194.backgroundColor, g8 = t194.borderWidth, u6 = t194.strokeDashArray, p5 = t194.borderRadius, f5 = t194.borderColor, x3 = t194.appendTo, b3 = void 0 === x3 ? ".apexcharts-annotations" : x3, v2 = t194.paddingLeft, m2 = void 0 === v2 ? 4 : v2, y2 = t194.paddingRight, w2 = void 0 === y2 ? 4 : y2, k2 = t194.paddingBottom, A2 = void 0 === k2 ? 2 : k2, S2 = t194.paddingTop, C2 = void 0 === S2 ? 2 : S2, L2 = this.w, P2 = this.graphics.drawText({
                    x: i95,
                    y: a73,
                    text: s52,
                    textAnchor: r44 || "start",
                    fontSize: n30 || "12px",
                    fontWeight: h17 || "regular",
                    fontFamily: l19 || L2.config.chart.fontFamily,
                    foreColor: o35 || L2.config.chart.foreColor,
                    cssClass: c14
                }), T2 = L2.globals.dom.baseEl.querySelector(b3);
                T2 && T2.appendChild(P2.node);
                var M2 = P2.bbox();
                if (s52) {
                    var I2 = this.graphics.drawRect(M2.x - m2, M2.y - C2, M2.width + m2 + w2, M2.height + A2 + C2, p5, d12 || "transparent", 1, g8, f5, u6);
                    T2.insertBefore(I2.node, P2.node);
                }
            }
        },
        {
            key: "addImage",
            value: function(t195, e) {
                var i96 = this.w, a74 = t195.path, s53 = t195.x, r45 = void 0 === s53 ? 0 : s53, o36 = t195.y, n31 = void 0 === o36 ? 0 : o36, l20 = t195.width, h18 = void 0 === l20 ? 20 : l20, c15 = t195.height, d13 = void 0 === c15 ? 20 : c15, g9 = t195.appendTo, u7 = void 0 === g9 ? ".apexcharts-annotations" : g9, p6 = i96.globals.dom.Paper.image(a74);
                p6.size(h18, d13).move(r45, n31);
                var f6 = i96.globals.dom.baseEl.querySelector(u7);
                return f6 && f6.appendChild(p6.node), p6;
            }
        },
        {
            key: "addXaxisAnnotationExternal",
            value: function(t196, e136, i97) {
                return this.addAnnotationExternal({
                    params: t196,
                    pushToMemory: e136,
                    context: i97,
                    type: "xaxis",
                    contextMethod: i97.addXaxisAnnotation
                }), i97;
            }
        },
        {
            key: "addYaxisAnnotationExternal",
            value: function(t197, e137, i98) {
                return this.addAnnotationExternal({
                    params: t197,
                    pushToMemory: e137,
                    context: i98,
                    type: "yaxis",
                    contextMethod: i98.addYaxisAnnotation
                }), i98;
            }
        },
        {
            key: "addPointAnnotationExternal",
            value: function(t198, e138, i99) {
                return void 0 === this.invertAxis && (this.invertAxis = i99.w.globals.isBarHorizontal), this.addAnnotationExternal({
                    params: t198,
                    pushToMemory: e138,
                    context: i99,
                    type: "point",
                    contextMethod: i99.addPointAnnotation
                }), i99;
            }
        },
        {
            key: "addAnnotationExternal",
            value: function(t199) {
                var e139 = t199.params, i100 = t199.pushToMemory, a75 = t199.context, s54 = t199.type, r46 = t199.contextMethod, o37 = a75, n32 = o37.w, l21 = n32.globals.dom.baseEl.querySelector(".apexcharts-".concat(s54, "-annotations")), h19 = l21.childNodes.length + 1, c16 = new L, d14 = Object.assign({}, "xaxis" === s54 ? c16.xAxisAnnotation : "yaxis" === s54 ? c16.yAxisAnnotation : c16.pointAnnotation), g10 = x.extend(d14, e139);
                switch(s54){
                    case "xaxis":
                        this.addXaxisAnnotation(g10, l21, h19);
                        break;
                    case "yaxis":
                        this.addYaxisAnnotation(g10, l21, h19);
                        break;
                    case "point":
                        this.addPointAnnotation(g10, l21, h19);
                }
                var u8 = n32.globals.dom.baseEl.querySelector(".apexcharts-".concat(s54, "-annotations .apexcharts-").concat(s54, "-annotation-label[rel='").concat(h19, "']")), p7 = this.helpers.addBackgroundToAnno(u8, g10);
                return p7 && l21.insertBefore(p7.node, u8), i100 && n32.globals.memory.methodsToExec.push({
                    context: o37,
                    id: g10.id ? g10.id : x.randomId(),
                    method: r46,
                    label: "addAnnotation",
                    params: e139
                }), a75;
            }
        },
        {
            key: "clearAnnotations",
            value: function(t200) {
                var e140 = t200.w, i101 = e140.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
                e140.globals.memory.methodsToExec.map(function(t201, i102) {
                    "addText" !== t201.label && "addAnnotation" !== t201.label || e140.globals.memory.methodsToExec.splice(i102, 1);
                }), i101 = x.listToArray(i101), Array.prototype.forEach.call(i101, function(t202) {
                    for(; t202.firstChild;)t202.removeChild(t202.firstChild);
                });
            }
        },
        {
            key: "removeAnnotation",
            value: function(t203, e141) {
                var i103 = t203.w, a76 = i103.globals.dom.baseEl.querySelectorAll(".".concat(e141));
                a76 && (i103.globals.memory.methodsToExec.map(function(t204, a77) {
                    t204.id === e141 && i103.globals.memory.methodsToExec.splice(a77, 1);
                }), Array.prototype.forEach.call(a76, function(t205) {
                    t205.parentElement.removeChild(t205);
                }));
            }
        }
    ]), t187;
}(), T = function() {
    function t206(e142) {
        a(this, t206), this.ctx = e142, this.w = e142.w, this.opts = null, this.seriesIndex = 0;
    }
    return r(t206, [
        {
            key: "clippedImgArea",
            value: function(t207) {
                var e143 = this.w, i104 = e143.config, a78 = parseInt(e143.globals.gridWidth, 10), s55 = parseInt(e143.globals.gridHeight, 10), r47 = a78 > s55 ? a78 : s55, o38 = t207.image, n33 = 0, l22 = 0;
                void 0 === t207.width && void 0 === t207.height ? void 0 !== i104.fill.image.width && void 0 !== i104.fill.image.height ? (n33 = i104.fill.image.width + 1, l22 = i104.fill.image.height) : (n33 = r47 + 1, l22 = r47) : (n33 = t207.width, l22 = t207.height);
                var h20 = document.createElementNS(e143.globals.SVGNS, "pattern");
                m.setAttrs(h20, {
                    id: t207.patternID,
                    patternUnits: t207.patternUnits ? t207.patternUnits : "userSpaceOnUse",
                    width: n33 + "px",
                    height: l22 + "px"
                });
                var c17 = document.createElementNS(e143.globals.SVGNS, "image");
                h20.appendChild(c17), c17.setAttributeNS(window.SVG.xlink, "href", o38), m.setAttrs(c17, {
                    x: 0,
                    y: 0,
                    preserveAspectRatio: "none",
                    width: n33 + "px",
                    height: l22 + "px"
                }), c17.style.opacity = t207.opacity, e143.globals.dom.elDefs.node.appendChild(h20);
            }
        },
        {
            key: "getSeriesIndex",
            value: function(t208) {
                var e144 = this.w;
                return ("bar" === e144.config.chart.type || "rangeBar" === e144.config.chart.type) && e144.config.plotOptions.bar.distributed || "heatmap" === e144.config.chart.type || "treemap" === e144.config.chart.type ? this.seriesIndex = t208.seriesNumber : this.seriesIndex = t208.seriesNumber % e144.globals.series.length, this.seriesIndex;
            }
        },
        {
            key: "fillPath",
            value: function(t209) {
                var e145 = this.w;
                this.opts = t209;
                var i105, a79, s56, r48 = this.w.config;
                this.seriesIndex = this.getSeriesIndex(t209);
                var o39 = this.getFillColors()[this.seriesIndex];
                void 0 !== e145.globals.seriesColors[this.seriesIndex] && (o39 = e145.globals.seriesColors[this.seriesIndex]), "function" == typeof o39 && (o39 = o39({
                    seriesIndex: this.seriesIndex,
                    dataPointIndex: t209.dataPointIndex,
                    value: t209.value,
                    w: e145
                }));
                var n34 = this.getFillType(this.seriesIndex), l23 = Array.isArray(r48.fill.opacity) ? r48.fill.opacity[this.seriesIndex] : r48.fill.opacity;
                t209.color && (o39 = t209.color);
                var h21 = o39;
                if (-1 === o39.indexOf("rgb") ? o39.length < 9 && (h21 = x.hexToRgba(o39, l23)) : o39.indexOf("rgba") > -1 && (l23 = x.getOpacityFromRGBA(o39)), t209.opacity && (l23 = t209.opacity), "pattern" === n34 && (a79 = this.handlePatternFill(a79, o39, l23, h21)), "gradient" === n34 && (s56 = this.handleGradientFill(o39, l23, this.seriesIndex)), "image" === n34) {
                    var c18 = r48.fill.image.src, d15 = t209.patternID ? t209.patternID : "";
                    this.clippedImgArea({
                        opacity: l23,
                        image: Array.isArray(c18) ? t209.seriesNumber < c18.length ? c18[t209.seriesNumber] : c18[0] : c18,
                        width: t209.width ? t209.width : void 0,
                        height: t209.height ? t209.height : void 0,
                        patternUnits: t209.patternUnits,
                        patternID: "pattern".concat(e145.globals.cuid).concat(t209.seriesNumber + 1).concat(d15)
                    }), i105 = "url(#pattern".concat(e145.globals.cuid).concat(t209.seriesNumber + 1).concat(d15, ")");
                } else i105 = "gradient" === n34 ? s56 : "pattern" === n34 ? a79 : h21;
                return t209.solid && (i105 = h21), i105;
            }
        },
        {
            key: "getFillType",
            value: function(t210) {
                var e146 = this.w;
                return Array.isArray(e146.config.fill.type) ? e146.config.fill.type[t210] : e146.config.fill.type;
            }
        },
        {
            key: "getFillColors",
            value: function() {
                var t211 = this.w, e147 = t211.config, i106 = this.opts, a80 = [];
                return t211.globals.comboCharts ? "line" === t211.config.series[this.seriesIndex].type ? Array.isArray(t211.globals.stroke.colors) ? a80 = t211.globals.stroke.colors : a80.push(t211.globals.stroke.colors) : Array.isArray(t211.globals.fill.colors) ? a80 = t211.globals.fill.colors : a80.push(t211.globals.fill.colors) : "line" === e147.chart.type ? Array.isArray(t211.globals.stroke.colors) ? a80 = t211.globals.stroke.colors : a80.push(t211.globals.stroke.colors) : Array.isArray(t211.globals.fill.colors) ? a80 = t211.globals.fill.colors : a80.push(t211.globals.fill.colors), void 0 !== i106.fillColors && (a80 = [], Array.isArray(i106.fillColors) ? a80 = i106.fillColors.slice() : a80.push(i106.fillColors)), a80;
            }
        },
        {
            key: "handlePatternFill",
            value: function(t212, e148, i107, a81) {
                var s57 = this.w.config, r49 = this.opts, o40 = new m(this.ctx), n35 = void 0 === s57.fill.pattern.strokeWidth ? Array.isArray(s57.stroke.width) ? s57.stroke.width[this.seriesIndex] : s57.stroke.width : Array.isArray(s57.fill.pattern.strokeWidth) ? s57.fill.pattern.strokeWidth[this.seriesIndex] : s57.fill.pattern.strokeWidth, l24 = e148;
                Array.isArray(s57.fill.pattern.style) ? t212 = void 0 !== s57.fill.pattern.style[r49.seriesNumber] ? o40.drawPattern(s57.fill.pattern.style[r49.seriesNumber], s57.fill.pattern.width, s57.fill.pattern.height, l24, n35, i107) : a81 : t212 = o40.drawPattern(s57.fill.pattern.style, s57.fill.pattern.width, s57.fill.pattern.height, l24, n35, i107);
                return t212;
            }
        },
        {
            key: "handleGradientFill",
            value: function(t213, e149, i108) {
                var a82, s58 = this.w.config, r50 = this.opts, o41 = new m(this.ctx), n36 = new x, l25 = s58.fill.gradient.type, h22 = t213, c19 = void 0 === s58.fill.gradient.opacityFrom ? e149 : Array.isArray(s58.fill.gradient.opacityFrom) ? s58.fill.gradient.opacityFrom[i108] : s58.fill.gradient.opacityFrom;
                h22.indexOf("rgba") > -1 && (c19 = x.getOpacityFromRGBA(h22));
                var d16 = void 0 === s58.fill.gradient.opacityTo ? e149 : Array.isArray(s58.fill.gradient.opacityTo) ? s58.fill.gradient.opacityTo[i108] : s58.fill.gradient.opacityTo;
                if (void 0 === s58.fill.gradient.gradientToColors || 0 === s58.fill.gradient.gradientToColors.length) a82 = "dark" === s58.fill.gradient.shade ? n36.shadeColor(-1 * parseFloat(s58.fill.gradient.shadeIntensity), t213.indexOf("rgb") > -1 ? x.rgb2hex(t213) : t213) : n36.shadeColor(parseFloat(s58.fill.gradient.shadeIntensity), t213.indexOf("rgb") > -1 ? x.rgb2hex(t213) : t213);
                else if (s58.fill.gradient.gradientToColors[r50.seriesNumber]) {
                    var g11 = s58.fill.gradient.gradientToColors[r50.seriesNumber];
                    a82 = g11, g11.indexOf("rgba") > -1 && (d16 = x.getOpacityFromRGBA(g11));
                } else a82 = t213;
                if (s58.fill.gradient.inverseColors) {
                    var u9 = h22;
                    h22 = a82, a82 = u9;
                }
                return h22.indexOf("rgb") > -1 && (h22 = x.rgb2hex(h22)), a82.indexOf("rgb") > -1 && (a82 = x.rgb2hex(a82)), o41.drawGradient(l25, h22, a82, c19, d16, r50.size, s58.fill.gradient.stops, s58.fill.gradient.colorStops, i108);
            }
        }
    ]), t206;
}(), M = function() {
    function t214(e150, i) {
        a(this, t214), this.ctx = e150, this.w = e150.w;
    }
    return r(t214, [
        {
            key: "setGlobalMarkerSize",
            value: function() {
                var t215 = this.w;
                if (t215.globals.markers.size = Array.isArray(t215.config.markers.size) ? t215.config.markers.size : [
                    t215.config.markers.size
                ], t215.globals.markers.size.length > 0) {
                    if (t215.globals.markers.size.length < t215.globals.series.length + 1) for(var e151 = 0; e151 <= t215.globals.series.length; e151++)void 0 === t215.globals.markers.size[e151] && t215.globals.markers.size.push(t215.globals.markers.size[0]);
                } else t215.globals.markers.size = t215.config.series.map(function(e) {
                    return t215.config.markers.size;
                });
            }
        },
        {
            key: "plotChartMarkers",
            value: function(t216, e152, i109, a83) {
                var s59, r51 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o42 = this.w, n37 = e152, l26 = t216, h23 = null, c20 = new m(this.ctx), d17 = o42.config.markers.discrete && o42.config.markers.discrete.length;
                if ((o42.globals.markers.size[e152] > 0 || r51 || d17) && (h23 = c20.group({
                    class: r51 || d17 ? "" : "apexcharts-series-markers"
                })).attr("clip-path", "url(#gridRectMarkerMask".concat(o42.globals.cuid, ")")), Array.isArray(l26.x)) for(var g12 = 0; g12 < l26.x.length; g12++){
                    var u10 = i109;
                    1 === i109 && 0 === g12 && (u10 = 0), 1 === i109 && 1 === g12 && (u10 = 1);
                    var p8 = "apexcharts-marker";
                    "line" !== o42.config.chart.type && "area" !== o42.config.chart.type || o42.globals.comboCharts || o42.config.tooltip.intersect || (p8 += " no-pointer-events");
                    var f7 = Array.isArray(o42.config.markers.size) ? o42.globals.markers.size[e152] > 0 : o42.config.markers.size > 0;
                    if (f7 || r51 || d17) {
                        x.isNumber(l26.y[g12]) ? p8 += " w".concat(x.randomId()) : p8 = "apexcharts-nullpoint";
                        var b4 = this.getMarkerConfig({
                            cssClass: p8,
                            seriesIndex: e152,
                            dataPointIndex: u10
                        });
                        o42.config.series[n37].data[u10] && (o42.config.series[n37].data[u10].fillColor && (b4.pointFillColor = o42.config.series[n37].data[u10].fillColor), o42.config.series[n37].data[u10].strokeColor && (b4.pointStrokeColor = o42.config.series[n37].data[u10].strokeColor)), a83 && (b4.pSize = a83), (s59 = c20.drawMarker(l26.x[g12], l26.y[g12], b4)).attr("rel", u10), s59.attr("j", u10), s59.attr("index", e152), s59.node.setAttribute("default-marker-size", b4.pSize);
                        var y3 = new v(this.ctx);
                        y3.setSelectionFilter(s59, e152, u10), this.addEvents(s59), h23 && h23.add(s59);
                    } else void 0 === o42.globals.pointsArray[e152] && (o42.globals.pointsArray[e152] = []), o42.globals.pointsArray[e152].push([
                        l26.x[g12],
                        l26.y[g12]
                    ]);
                }
                return h23;
            }
        },
        {
            key: "getMarkerConfig",
            value: function(t217) {
                var e153 = t217.cssClass, i110 = t217.seriesIndex, a84 = t217.dataPointIndex, s60 = void 0 === a84 ? null : a84, r52 = t217.finishRadius, o43 = void 0 === r52 ? null : r52, n38 = this.w, l27 = this.getMarkerStyle(i110), h24 = n38.globals.markers.size[i110], c21 = n38.config.markers;
                return null !== s60 && c21.discrete.length && c21.discrete.map(function(t218) {
                    t218.seriesIndex === i110 && t218.dataPointIndex === s60 && (l27.pointStrokeColor = t218.strokeColor, l27.pointFillColor = t218.fillColor, h24 = t218.size, l27.pointShape = t218.shape);
                }), {
                    pSize: null === o43 ? h24 : o43,
                    pRadius: c21.radius,
                    width: Array.isArray(c21.width) ? c21.width[i110] : c21.width,
                    height: Array.isArray(c21.height) ? c21.height[i110] : c21.height,
                    pointStrokeWidth: Array.isArray(c21.strokeWidth) ? c21.strokeWidth[i110] : c21.strokeWidth,
                    pointStrokeColor: l27.pointStrokeColor,
                    pointFillColor: l27.pointFillColor,
                    shape: l27.pointShape || (Array.isArray(c21.shape) ? c21.shape[i110] : c21.shape),
                    class: e153,
                    pointStrokeOpacity: Array.isArray(c21.strokeOpacity) ? c21.strokeOpacity[i110] : c21.strokeOpacity,
                    pointStrokeDashArray: Array.isArray(c21.strokeDashArray) ? c21.strokeDashArray[i110] : c21.strokeDashArray,
                    pointFillOpacity: Array.isArray(c21.fillOpacity) ? c21.fillOpacity[i110] : c21.fillOpacity,
                    seriesIndex: i110
                };
            }
        },
        {
            key: "addEvents",
            value: function(t219) {
                var e154 = this.w, i111 = new m(this.ctx);
                t219.node.addEventListener("mouseenter", i111.pathMouseEnter.bind(this.ctx, t219)), t219.node.addEventListener("mouseleave", i111.pathMouseLeave.bind(this.ctx, t219)), t219.node.addEventListener("mousedown", i111.pathMouseDown.bind(this.ctx, t219)), t219.node.addEventListener("click", e154.config.markers.onClick), t219.node.addEventListener("dblclick", e154.config.markers.onDblClick), t219.node.addEventListener("touchstart", i111.pathMouseDown.bind(this.ctx, t219), {
                    passive: !0
                });
            }
        },
        {
            key: "getMarkerStyle",
            value: function(t220) {
                var e155 = this.w, i112 = e155.globals.markers.colors, a85 = e155.config.markers.strokeColor || e155.config.markers.strokeColors;
                return {
                    pointStrokeColor: Array.isArray(a85) ? a85[t220] : a85,
                    pointFillColor: Array.isArray(i112) ? i112[t220] : i112
                };
            }
        }
    ]), t214;
}(), I = function() {
    function t221(e156) {
        a(this, t221), this.ctx = e156, this.w = e156.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
    }
    return r(t221, [
        {
            key: "draw",
            value: function(t, e157, i113) {
                var a86 = this.w, s61 = new m(this.ctx), r53 = i113.realIndex, o44 = i113.pointsPos, n39 = i113.zRatio, l28 = i113.elParent, h25 = s61.group({
                    class: "apexcharts-series-markers apexcharts-series-".concat(a86.config.chart.type)
                });
                if (h25.attr("clip-path", "url(#gridRectMarkerMask".concat(a86.globals.cuid, ")")), Array.isArray(o44.x)) for(var c22 = 0; c22 < o44.x.length; c22++){
                    var d18 = e157 + 1, g13 = !0;
                    0 === e157 && 0 === c22 && (d18 = 0), 0 === e157 && 1 === c22 && (d18 = 1);
                    var u11 = 0, p9 = a86.globals.markers.size[r53];
                    if (n39 !== 1 / 0) {
                        p9 = a86.globals.seriesZ[r53][d18] / n39;
                        var f8 = a86.config.plotOptions.bubble;
                        f8.minBubbleRadius && p9 < f8.minBubbleRadius && (p9 = f8.minBubbleRadius), f8.maxBubbleRadius && p9 > f8.maxBubbleRadius && (p9 = f8.maxBubbleRadius);
                    }
                    a86.config.chart.animations.enabled || (u11 = p9);
                    var x4 = o44.x[c22], b5 = o44.y[c22];
                    if (u11 = u11 || 0, null !== b5 && void 0 !== a86.globals.series[r53][d18] || (g13 = !1), g13) {
                        var v3 = this.drawPoint(x4, b5, u11, p9, r53, d18, e157);
                        h25.add(v3);
                    }
                    l28.add(h25);
                }
            }
        },
        {
            key: "drawPoint",
            value: function(t222, e158, i114, a87, s62, r54, o45) {
                var n40 = this.w, l29 = s62, h26 = new b(this.ctx), c23 = new v(this.ctx), d19 = new T(this.ctx), g14 = new M(this.ctx), u12 = new m(this.ctx), p10 = g14.getMarkerConfig({
                    cssClass: "apexcharts-marker",
                    seriesIndex: l29,
                    dataPointIndex: r54,
                    finishRadius: "bubble" === n40.config.chart.type || n40.globals.comboCharts && n40.config.series[s62] && "bubble" === n40.config.series[s62].type ? a87 : null
                });
                a87 = p10.pSize;
                var f9, x5 = d19.fillPath({
                    seriesNumber: s62,
                    dataPointIndex: r54,
                    color: p10.pointFillColor,
                    patternUnits: "objectBoundingBox",
                    value: n40.globals.series[s62][o45]
                });
                if ("circle" === p10.shape ? f9 = u12.drawCircle(i114) : "square" !== p10.shape && "rect" !== p10.shape || (f9 = u12.drawRect(0, 0, p10.width - p10.pointStrokeWidth / 2, p10.height - p10.pointStrokeWidth / 2, p10.pRadius)), n40.config.series[l29].data[r54] && n40.config.series[l29].data[r54].fillColor && (x5 = n40.config.series[l29].data[r54].fillColor), f9.attr({
                    x: t222 - p10.width / 2 - p10.pointStrokeWidth / 2,
                    y: e158 - p10.height / 2 - p10.pointStrokeWidth / 2,
                    cx: t222,
                    cy: e158,
                    fill: x5,
                    "fill-opacity": p10.pointFillOpacity,
                    stroke: p10.pointStrokeColor,
                    r: a87,
                    "stroke-width": p10.pointStrokeWidth,
                    "stroke-dasharray": p10.pointStrokeDashArray,
                    "stroke-opacity": p10.pointStrokeOpacity
                }), n40.config.chart.dropShadow.enabled) {
                    var y4 = n40.config.chart.dropShadow;
                    c23.dropShadow(f9, y4, s62);
                }
                if (!this.initialAnim || n40.globals.dataChanged || n40.globals.resized) n40.globals.animationEnded = !0;
                else {
                    var w3 = n40.config.chart.animations.speed;
                    h26.animateMarker(f9, 0, "circle" === p10.shape ? a87 : {
                        width: p10.width,
                        height: p10.height
                    }, w3, n40.globals.easing, function() {
                        window.setTimeout(function() {
                            h26.animationCompleted(f9);
                        }, 100);
                    });
                }
                if (n40.globals.dataChanged && "circle" === p10.shape) {
                    if (this.dynamicAnim) {
                        var k3, A3, S3, C3, L3 = n40.config.chart.animations.dynamicAnimation.speed;
                        null != (C3 = n40.globals.previousPaths[s62] && n40.globals.previousPaths[s62][o45]) && (k3 = C3.x, A3 = C3.y, S3 = void 0 !== C3.r ? C3.r : a87);
                        for(var P3 = 0; P3 < n40.globals.collapsedSeries.length; P3++)n40.globals.collapsedSeries[P3].index === s62 && (L3 = 1, a87 = 0);
                        0 === t222 && 0 === e158 && (a87 = 0), h26.animateCircle(f9, {
                            cx: k3,
                            cy: A3,
                            r: S3
                        }, {
                            cx: t222,
                            cy: e158,
                            r: a87
                        }, L3, n40.globals.easing);
                    } else f9.attr({
                        r: a87
                    });
                }
                return f9.attr({
                    rel: r54,
                    j: r54,
                    index: s62,
                    "default-marker-size": a87
                }), c23.setSelectionFilter(f9, s62, r54), g14.addEvents(f9), f9.node.classList.add("apexcharts-marker"), f9;
            }
        },
        {
            key: "centerTextInBubble",
            value: function(t223) {
                var e159 = this.w;
                return {
                    y: t223 += parseInt(e159.config.dataLabels.style.fontSize, 10) / 4
                };
            }
        }
    ]), t221;
}(), z = function() {
    function t224(e160) {
        a(this, t224), this.ctx = e160, this.w = e160.w;
    }
    return r(t224, [
        {
            key: "dataLabelsCorrection",
            value: function(t225, e161, i115, a88, s63, r55, o46) {
                var n41 = this.w, l30 = !1, h27 = new m(this.ctx).getTextRects(i115, o46), c24 = h27.width, d20 = h27.height;
                e161 < 0 && (e161 = 0), e161 > n41.globals.gridHeight + d20 && (e161 = n41.globals.gridHeight + d20 / 2), void 0 === n41.globals.dataLabelsRects[a88] && (n41.globals.dataLabelsRects[a88] = []), n41.globals.dataLabelsRects[a88].push({
                    x: t225,
                    y: e161,
                    width: c24,
                    height: d20
                });
                var g15 = n41.globals.dataLabelsRects[a88].length - 2, u13 = void 0 !== n41.globals.lastDrawnDataLabelsIndexes[a88] ? n41.globals.lastDrawnDataLabelsIndexes[a88][n41.globals.lastDrawnDataLabelsIndexes[a88].length - 1] : 0;
                if (void 0 !== n41.globals.dataLabelsRects[a88][g15]) {
                    var p11 = n41.globals.dataLabelsRects[a88][u13];
                    (t225 > p11.x + p11.width + 2 || e161 > p11.y + p11.height + 2 || t225 + c24 < p11.x) && (l30 = !0);
                }
                return (0 === s63 || r55) && (l30 = !0), {
                    x: t225,
                    y: e161,
                    textRects: h27,
                    drawnextLabel: l30
                };
            }
        },
        {
            key: "drawDataLabel",
            value: function(t226, e162, i116) {
                var a89 = this, s64 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 2, r56 = this.w, o47 = new m(this.ctx), n42 = r56.config.dataLabels, l31 = 0, h28 = 0, c25 = i116, d21 = null;
                if (!n42.enabled || !Array.isArray(t226.x)) return d21;
                d21 = o47.group({
                    class: "apexcharts-data-labels"
                });
                for(var g16 = 0; g16 < t226.x.length; g16++)if (l31 = t226.x[g16] + n42.offsetX, h28 = t226.y[g16] + n42.offsetY + s64, !isNaN(l31)) {
                    1 === i116 && 0 === g16 && (c25 = 0), 1 === i116 && 1 === g16 && (c25 = 1);
                    var u14 = r56.globals.series[e162][c25], p12 = "", f10 = function(t227) {
                        return r56.config.dataLabels.formatter(t227, {
                            ctx: a89.ctx,
                            seriesIndex: e162,
                            dataPointIndex: c25,
                            w: r56
                        });
                    };
                    if ("bubble" === r56.config.chart.type) {
                        p12 = f10(u14 = r56.globals.seriesZ[e162][c25]), h28 = t226.y[g16];
                        var x6 = new I(this.ctx), b6 = x6.centerTextInBubble(h28, e162, c25);
                        h28 = b6.y;
                    } else void 0 !== u14 && (p12 = f10(u14));
                    this.plotDataLabelsText({
                        x: l31,
                        y: h28,
                        text: p12,
                        i: e162,
                        j: c25,
                        parent: d21,
                        offsetCorrection: !0,
                        dataLabelsConfig: r56.config.dataLabels
                    });
                }
                return d21;
            }
        },
        {
            key: "plotDataLabelsText",
            value: function(t228) {
                var e163 = this.w, i117 = new m(this.ctx), a90 = t228.x, s65 = t228.y, r57 = t228.i, o48 = t228.j, n43 = t228.text, l32 = t228.textAnchor, h29 = t228.fontSize, c26 = t228.parent, d22 = t228.dataLabelsConfig, g17 = t228.color, u15 = t228.alwaysDrawDataLabel, p13 = t228.offsetCorrection;
                if (!(Array.isArray(e163.config.dataLabels.enabledOnSeries) && e163.config.dataLabels.enabledOnSeries.indexOf(r57) < 0)) {
                    var f11 = {
                        x: a90,
                        y: s65,
                        drawnextLabel: !0,
                        textRects: null
                    };
                    p13 && (f11 = this.dataLabelsCorrection(a90, s65, n43, r57, o48, u15, parseInt(d22.style.fontSize, 10))), e163.globals.zoomed || (a90 = f11.x, s65 = f11.y), f11.textRects && (a90 < -10 - f11.textRects.width || a90 > e163.globals.gridWidth + f11.textRects.width + 10) && (n43 = "");
                    var x7 = e163.globals.dataLabels.style.colors[r57];
                    (("bar" === e163.config.chart.type || "rangeBar" === e163.config.chart.type) && e163.config.plotOptions.bar.distributed || e163.config.dataLabels.distributed) && (x7 = e163.globals.dataLabels.style.colors[o48]), "function" == typeof x7 && (x7 = x7({
                        series: e163.globals.series,
                        seriesIndex: r57,
                        dataPointIndex: o48,
                        w: e163
                    })), g17 && (x7 = g17);
                    var b7 = d22.offsetX, y5 = d22.offsetY;
                    if ("bar" !== e163.config.chart.type && "rangeBar" !== e163.config.chart.type || (b7 = 0, y5 = 0), f11.drawnextLabel) {
                        var w4 = i117.drawText({
                            width: 100,
                            height: parseInt(d22.style.fontSize, 10),
                            x: a90 + b7,
                            y: s65 + y5,
                            foreColor: x7,
                            textAnchor: l32 || d22.textAnchor,
                            text: n43,
                            fontSize: h29 || d22.style.fontSize,
                            fontFamily: d22.style.fontFamily,
                            fontWeight: d22.style.fontWeight || "normal"
                        });
                        if (w4.attr({
                            class: "apexcharts-datalabel",
                            cx: a90,
                            cy: s65
                        }), d22.dropShadow.enabled) {
                            var k4 = d22.dropShadow;
                            new v(this.ctx).dropShadow(w4, k4);
                        }
                        c26.add(w4), void 0 === e163.globals.lastDrawnDataLabelsIndexes[r57] && (e163.globals.lastDrawnDataLabelsIndexes[r57] = []), e163.globals.lastDrawnDataLabelsIndexes[r57].push(o48);
                    }
                }
            }
        },
        {
            key: "addBackgroundToDataLabel",
            value: function(t, e164) {
                var i118 = this.w, a91 = i118.config.dataLabels.background, s66 = a91.padding, r58 = a91.padding / 2, o49 = e164.width, n44 = e164.height, l33 = new m(this.ctx).drawRect(e164.x - s66, e164.y - r58 / 2, o49 + 2 * s66, n44 + r58, a91.borderRadius, "transparent" === i118.config.chart.background ? "#fff" : i118.config.chart.background, a91.opacity, a91.borderWidth, a91.borderColor);
                a91.dropShadow.enabled && new v(this.ctx).dropShadow(l33, a91.dropShadow);
                return l33;
            }
        },
        {
            key: "dataLabelsBackground",
            value: function() {
                var t229 = this.w;
                if ("bubble" !== t229.config.chart.type) for(var e165 = t229.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i119 = 0; i119 < e165.length; i119++){
                    var a92 = e165[i119], s67 = a92.getBBox(), r59 = null;
                    if (s67.width && s67.height && (r59 = this.addBackgroundToDataLabel(a92, s67)), r59) {
                        a92.parentNode.insertBefore(r59.node, a92);
                        var o50 = a92.getAttribute("fill");
                        t229.config.chart.animations.enabled && !t229.globals.resized && !t229.globals.dataChanged ? r59.animate().attr({
                            fill: o50
                        }) : r59.attr({
                            fill: o50
                        }), a92.setAttribute("fill", t229.config.dataLabels.background.foreColor);
                    }
                }
            }
        },
        {
            key: "bringForward",
            value: function() {
                for(var t230 = this.w, e166 = t230.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i120 = t230.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), a93 = 0; a93 < e166.length; a93++)i120 && i120.insertBefore(e166[a93], i120.nextSibling);
            }
        }
    ]), t224;
}(), X = function() {
    function t231(e167) {
        a(this, t231), this.w = e167.w, this.barCtx = e167;
    }
    return r(t231, [
        {
            key: "handleBarDataLabels",
            value: function(t232) {
                var e168 = t232.x, i121 = t232.y, a94 = t232.y1, s68 = t232.y2, r60 = t232.i, o51 = t232.j, n45 = t232.realIndex, l34 = t232.series, h30 = t232.barHeight, c27 = t232.barWidth, d23 = t232.barYPosition, g18 = t232.visibleSeries, u16 = t232.renderedPath, p14 = this.w, f12 = new m(this.barCtx.ctx), x8 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[n45] : this.barCtx.strokeWidth, b8 = e168 + parseFloat(c27 * g18), v4 = i121 + parseFloat(h30 * g18);
                p14.globals.isXNumeric && !p14.globals.isBarHorizontal && (b8 = e168 + parseFloat(c27 * (g18 + 1)), v4 = i121 + parseFloat(h30 * (g18 + 1)) - x8);
                var y6 = e168, w5 = i121, k5 = {}, A4 = p14.config.dataLabels, S4 = this.barCtx.barOptions.dataLabels;
                void 0 !== d23 && this.barCtx.isRangeBar && (v4 = d23, w5 = d23);
                var C4 = A4.offsetX, L4 = A4.offsetY, P4 = {
                    width: 0,
                    height: 0
                };
                if (p14.config.dataLabels.enabled) {
                    var T3 = this.barCtx.series[r60][o51];
                    P4 = f12.getTextRects(p14.globals.yLabelFormatters[0](T3), parseFloat(A4.style.fontSize));
                }
                var M3 = {
                    x: e168,
                    y: i121,
                    i: r60,
                    j: o51,
                    renderedPath: u16,
                    bcx: b8,
                    bcy: v4,
                    barHeight: h30,
                    barWidth: c27,
                    textRects: P4,
                    strokeWidth: x8,
                    dataLabelsX: y6,
                    dataLabelsY: w5,
                    barDataLabelsConfig: S4,
                    offX: C4,
                    offY: L4
                };
                return k5 = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(M3) : this.calculateColumnsDataLabelsPosition(M3), u16.attr({
                    cy: k5.bcy,
                    cx: k5.bcx,
                    j: o51,
                    val: l34[r60][o51],
                    barHeight: h30,
                    barWidth: c27
                }), this.drawCalculatedDataLabels({
                    x: k5.dataLabelsX,
                    y: k5.dataLabelsY,
                    val: this.barCtx.isRangeBar ? [
                        a94,
                        s68
                    ] : l34[r60][o51],
                    i: n45,
                    j: o51,
                    barWidth: c27,
                    barHeight: h30,
                    textRects: P4,
                    dataLabelsConfig: A4
                });
            }
        },
        {
            key: "calculateColumnsDataLabelsPosition",
            value: function(t233) {
                var e169, i122 = this.w, a95 = t233.i, s69 = t233.j, r61 = t233.y, o52 = t233.bcx, n46 = t233.barWidth, l35 = t233.barHeight, h31 = t233.textRects, c28 = t233.dataLabelsY, d24 = t233.barDataLabelsConfig, g19 = t233.strokeWidth, u17 = t233.offX, p15 = t233.offY;
                l35 = Math.abs(l35);
                var f13 = "vertical" === i122.config.plotOptions.bar.dataLabels.orientation;
                o52 -= g19 / 2;
                var x9 = i122.globals.gridWidth / i122.globals.dataPoints;
                if (e169 = i122.globals.isXNumeric ? o52 - n46 / 2 + u17 : o52 - x9 + n46 / 2 + u17, f13) e169 = e169 + h31.height / 2 - g19 / 2 - 2;
                var b9 = this.barCtx.series[a95][s69] < 0, v5 = r61;
                switch(this.barCtx.isReversed && (v5 = r61 - l35 + (b9 ? 2 * l35 : 0), r61 -= l35), d24.position){
                    case "center":
                        c28 = f13 ? b9 ? v5 + l35 / 2 + p15 : v5 + l35 / 2 - p15 : b9 ? v5 - l35 / 2 + h31.height / 2 + p15 : v5 + l35 / 2 + h31.height / 2 - p15;
                        break;
                    case "bottom":
                        c28 = f13 ? b9 ? v5 + l35 + p15 : v5 + l35 - p15 : b9 ? v5 - l35 + h31.height + g19 + p15 : v5 + l35 - h31.height / 2 + g19 - p15;
                        break;
                    case "top":
                        c28 = f13 ? b9 ? v5 + p15 : v5 - p15 : b9 ? v5 - h31.height / 2 - p15 : v5 + h31.height + p15;
                }
                return i122.config.chart.stacked || (c28 < 0 ? c28 = 0 + g19 : c28 + h31.height / 3 > i122.globals.gridHeight && (c28 = i122.globals.gridHeight - g19)), {
                    bcx: o52,
                    bcy: r61,
                    dataLabelsX: e169,
                    dataLabelsY: c28
                };
            }
        },
        {
            key: "calculateBarsDataLabelsPosition",
            value: function(t234) {
                var e170 = this.w, i123 = t234.x, a96 = t234.i, s70 = t234.j, r62 = t234.bcy, o53 = t234.barHeight, n47 = t234.barWidth, l36 = t234.textRects, h32 = t234.dataLabelsX, c29 = t234.strokeWidth, d25 = t234.barDataLabelsConfig, g20 = t234.offX, u18 = t234.offY, p16 = e170.globals.gridHeight / e170.globals.dataPoints;
                n47 = Math.abs(n47);
                var f14 = r62 - (this.barCtx.isRangeBar ? 0 : p16) + o53 / 2 + l36.height / 2 + u18 - 3, x10 = this.barCtx.series[a96][s70] < 0, b10 = i123;
                switch(this.barCtx.isReversed && (b10 = i123 + n47 - (x10 ? 2 * n47 : 0), i123 = e170.globals.gridWidth - n47), d25.position){
                    case "center":
                        h32 = x10 ? b10 + n47 / 2 - g20 : Math.max(l36.width / 2, b10 - n47 / 2) + g20;
                        break;
                    case "bottom":
                        h32 = x10 ? b10 + n47 - c29 - Math.round(l36.width / 2) - g20 : b10 - n47 + c29 + Math.round(l36.width / 2) + g20;
                        break;
                    case "top":
                        h32 = x10 ? b10 - c29 + Math.round(l36.width / 2) - g20 : b10 - c29 - Math.round(l36.width / 2) + g20;
                }
                return e170.config.chart.stacked || (h32 < 0 ? h32 = h32 + l36.width + c29 : h32 + l36.width / 2 > e170.globals.gridWidth && (h32 = e170.globals.gridWidth - l36.width - c29)), {
                    bcx: i123,
                    bcy: r62,
                    dataLabelsX: h32,
                    dataLabelsY: f14
                };
            }
        },
        {
            key: "drawCalculatedDataLabels",
            value: function(t235) {
                var i124 = t235.x, a97 = t235.y, s71 = t235.val, r63 = t235.i, o54 = t235.j, n48 = t235.textRects, l37 = t235.barHeight, h33 = t235.barWidth, c30 = t235.dataLabelsConfig, d26 = this.w, g21 = "rotate(0)";
                "vertical" === d26.config.plotOptions.bar.dataLabels.orientation && (g21 = "rotate(-90, ".concat(i124, ", ").concat(a97, ")"));
                var u19 = new z(this.barCtx.ctx), p17 = new m(this.barCtx.ctx), f15 = c30.formatter, x11 = null, b11 = d26.globals.collapsedSeriesIndices.indexOf(r63) > -1;
                if (c30.enabled && !b11) {
                    x11 = p17.group({
                        class: "apexcharts-data-labels",
                        transform: g21
                    });
                    var v6 = "";
                    void 0 !== s71 && (v6 = f15(s71, {
                        seriesIndex: r63,
                        dataPointIndex: o54,
                        w: d26
                    }));
                    var y7 = d26.globals.series[r63][o54] < 0, w6 = d26.config.plotOptions.bar.dataLabels.position;
                    if ("vertical" === d26.config.plotOptions.bar.dataLabels.orientation && ("top" === w6 && (c30.textAnchor = y7 ? "end" : "start"), "center" === w6 && (c30.textAnchor = "middle"), "bottom" === w6 && (c30.textAnchor = y7 ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels) h33 < p17.getTextRects(v6, parseFloat(c30.style.fontSize)).width && (v6 = "");
                    d26.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? n48.width / 1.6 > Math.abs(h33) && (v6 = "") : n48.height / 1.6 > Math.abs(l37) && (v6 = ""));
                    var k6 = e({}, c30);
                    this.barCtx.isHorizontal && s71 < 0 && ("start" === c30.textAnchor ? k6.textAnchor = "end" : "end" === c30.textAnchor && (k6.textAnchor = "start")), u19.plotDataLabelsText({
                        x: i124,
                        y: a97,
                        text: v6,
                        i: r63,
                        j: o54,
                        parent: x11,
                        dataLabelsConfig: k6,
                        alwaysDrawDataLabel: !0,
                        offsetCorrection: !0
                    });
                }
                return x11;
            }
        }
    ]), t231;
}(), E = function() {
    function t236(e171) {
        a(this, t236), this.ctx = e171, this.w = e171.w, this.legendInactiveClass = "legend-mouseover-inactive";
    }
    return r(t236, [
        {
            key: "getAllSeriesEls",
            value: function() {
                return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
            }
        },
        {
            key: "getSeriesByName",
            value: function(t237) {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(x.escapeString(t237), "']"));
            }
        },
        {
            key: "isSeriesHidden",
            value: function(t238) {
                var e172 = this.getSeriesByName(t238), i125 = parseInt(e172.getAttribute("data:realIndex"), 10);
                return {
                    isHidden: e172.classList.contains("apexcharts-series-collapsed"),
                    realIndex: i125
                };
            }
        },
        {
            key: "addCollapsedClassToSeries",
            value: function(t239, e173) {
                var i126 = this.w;
                function a98(i127) {
                    for(var a99 = 0; a99 < i127.length; a99++)i127[a99].index === e173 && t239.node.classList.add("apexcharts-series-collapsed");
                }
                a98(i126.globals.collapsedSeries), a98(i126.globals.ancillaryCollapsedSeries);
            }
        },
        {
            key: "toggleSeries",
            value: function(t240) {
                var e174 = this.isSeriesHidden(t240);
                return this.ctx.legend.legendHelpers.toggleDataSeries(e174.realIndex, e174.isHidden), e174.isHidden;
            }
        },
        {
            key: "showSeries",
            value: function(t241) {
                var e175 = this.isSeriesHidden(t241);
                e175.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e175.realIndex, !0);
            }
        },
        {
            key: "hideSeries",
            value: function(t242) {
                var e176 = this.isSeriesHidden(t242);
                e176.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e176.realIndex, !1);
            }
        },
        {
            key: "resetSeries",
            value: function() {
                var t243 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e177 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i128 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a100 = this.w, s72 = x.clone(a100.globals.initialSeries);
                a100.globals.previousPaths = [], i128 ? (a100.globals.collapsedSeries = [], a100.globals.ancillaryCollapsedSeries = [], a100.globals.collapsedSeriesIndices = [], a100.globals.ancillaryCollapsedSeriesIndices = []) : s72 = this.emptyCollapsedSeries(s72), a100.config.series = s72, t243 && (e177 && (a100.globals.zoomed = !1, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(s72, a100.config.chart.animations.dynamicAnimation.enabled));
            }
        },
        {
            key: "emptyCollapsedSeries",
            value: function(t244) {
                for(var e178 = this.w, i129 = 0; i129 < t244.length; i129++)e178.globals.collapsedSeriesIndices.indexOf(i129) > -1 && (t244[i129].data = []);
                return t244;
            }
        },
        {
            key: "toggleSeriesOnHover",
            value: function(t245, e179) {
                var i130 = this.w;
                e179 || (e179 = t245.target);
                var a101 = i130.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");
                if ("mousemove" === t245.type) {
                    var s73 = parseInt(e179.getAttribute("rel"), 10) - 1, r64 = null, o55 = null;
                    i130.globals.axisCharts || "radialBar" === i130.config.chart.type ? i130.globals.axisCharts ? (r64 = i130.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(s73, "']")), o55 = i130.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(s73, "']"))) : r64 = i130.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s73 + 1, "']")) : r64 = i130.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s73 + 1, "'] path"));
                    for(var n49 = 0; n49 < a101.length; n49++)a101[n49].classList.add(this.legendInactiveClass);
                    null !== r64 && (i130.globals.axisCharts || r64.parentNode.classList.remove(this.legendInactiveClass), r64.classList.remove(this.legendInactiveClass), null !== o55 && o55.classList.remove(this.legendInactiveClass));
                } else if ("mouseout" === t245.type) for(var l38 = 0; l38 < a101.length; l38++)a101[l38].classList.remove(this.legendInactiveClass);
            }
        },
        {
            key: "highlightRangeInSeries",
            value: function(t246, e180) {
                var i131 = this, a102 = this.w, s74 = a102.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"), r65 = function(t247) {
                    for(var e181 = 0; e181 < s74.length; e181++)s74[e181].classList[t247](i131.legendInactiveClass);
                };
                if ("mousemove" === t246.type) {
                    var o56 = parseInt(e180.getAttribute("rel"), 10) - 1;
                    r65("add"), function(t248) {
                        for(var e182 = 0; e182 < s74.length; e182++){
                            var a103 = parseInt(s74[e182].getAttribute("val"), 10);
                            a103 >= t248.from && a103 <= t248.to && s74[e182].classList.remove(i131.legendInactiveClass);
                        }
                    }(a102.config.plotOptions.heatmap.colorScale.ranges[o56]);
                } else "mouseout" === t246.type && r65("remove");
            }
        },
        {
            key: "getActiveConfigSeriesIndex",
            value: function() {
                var t249 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], e183 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "asc", i132 = this.w, a104 = 0;
                if (i132.config.series.length > 1) {
                    for(var s75 = i132.config.series.map(function(e184, a105) {
                        var s77 = !1;
                        return t249 && (s77 = "bar" === i132.config.series[a105].type || "column" === i132.config.series[a105].type), e184.data && e184.data.length > 0 && !s77 ? a105 : -1;
                    }), r66 = "asc" === e183 ? 0 : s75.length - 1; "asc" === e183 ? r66 < s75.length : r66 >= 0; "asc" === e183 ? r66++ : r66--)if (-1 !== s75[r66]) {
                        a104 = s75[r66];
                        break;
                    }
                }
                return a104;
            }
        },
        {
            key: "getPreviousPaths",
            value: function() {
                var t250 = this.w;
                function e185(e186, i134, a107) {
                    for(var s79 = e186[i134].childNodes, r67 = {
                        type: a107,
                        paths: [],
                        realIndex: e186[i134].getAttribute("data:realIndex")
                    }, o57 = 0; o57 < s79.length; o57++)if (s79[o57].hasAttribute("pathTo")) {
                        var n50 = s79[o57].getAttribute("pathTo");
                        r67.paths.push({
                            d: n50
                        });
                    }
                    t250.globals.previousPaths.push(r67);
                }
                t250.globals.previousPaths = [];
                [
                    "line",
                    "area",
                    "bar",
                    "rangebar",
                    "candlestick",
                    "radar"
                ].forEach(function(i135) {
                    for(var a108, s80 = (a108 = i135, t250.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(a108, "-series .apexcharts-series"))), r68 = 0; r68 < s80.length; r68++)e185(s80, r68, i135);
                }), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
                var i133 = t250.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t250.config.chart.type, " .apexcharts-series"));
                if (i133.length > 0) for(var a106 = function(e187) {
                    for(var i136 = t250.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t250.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(e187, "'] rect")), a109 = [], s81 = function(t251) {
                        var e188 = function(e189) {
                            return i136[t251].getAttribute(e189);
                        }, s82 = {
                            x: parseFloat(e188("x")),
                            y: parseFloat(e188("y")),
                            width: parseFloat(e188("width")),
                            height: parseFloat(e188("height"))
                        };
                        a109.push({
                            rect: s82,
                            color: i136[t251].getAttribute("color")
                        });
                    }, r69 = 0; r69 < i136.length; r69++)s81(r69);
                    t250.globals.previousPaths.push(a109);
                }, s78 = 0; s78 < i133.length; s78++)a106(s78);
                t250.globals.axisCharts || (t250.globals.previousPaths = t250.globals.series);
            }
        },
        {
            key: "handlePrevBubbleScatterPaths",
            value: function(t252) {
                var e190 = this.w, i137 = e190.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t252, "-series .apexcharts-series"));
                if (i137.length > 0) for(var a110 = 0; a110 < i137.length; a110++){
                    for(var s83 = e190.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t252, "-series .apexcharts-series[data\\:realIndex='").concat(a110, "'] circle")), r70 = [], o58 = 0; o58 < s83.length; o58++)r70.push({
                        x: s83[o58].getAttribute("cx"),
                        y: s83[o58].getAttribute("cy"),
                        r: s83[o58].getAttribute("r")
                    });
                    e190.globals.previousPaths.push(r70);
                }
            }
        },
        {
            key: "clearPreviousPaths",
            value: function() {
                var t253 = this.w;
                t253.globals.previousPaths = [], t253.globals.allSeriesCollapsed = !1;
            }
        },
        {
            key: "handleNoData",
            value: function() {
                var t254 = this.w, e191 = t254.config.noData, i138 = new m(this.ctx), a111 = t254.globals.svgWidth / 2, s84 = t254.globals.svgHeight / 2, r71 = "middle";
                if (t254.globals.noData = !0, t254.globals.animationEnded = !0, "left" === e191.align ? (a111 = 10, r71 = "start") : "right" === e191.align && (a111 = t254.globals.svgWidth - 10, r71 = "end"), "top" === e191.verticalAlign ? s84 = 50 : "bottom" === e191.verticalAlign && (s84 = t254.globals.svgHeight - 50), a111 += e191.offsetX, s84 = s84 + parseInt(e191.style.fontSize, 10) + 2 + e191.offsetY, void 0 !== e191.text && "" !== e191.text) {
                    var o59 = i138.drawText({
                        x: a111,
                        y: s84,
                        text: e191.text,
                        textAnchor: r71,
                        fontSize: e191.style.fontSize,
                        fontFamily: e191.style.fontFamily,
                        foreColor: e191.style.color,
                        opacity: 1,
                        class: "apexcharts-text-nodata"
                    });
                    t254.globals.dom.Paper.add(o59);
                }
            }
        },
        {
            key: "setNullSeriesToZeroValues",
            value: function(t255) {
                for(var e192 = this.w, i139 = 0; i139 < t255.length; i139++)if (0 === t255[i139].length) for(var a112 = 0; a112 < t255[e192.globals.maxValsInArrayIndex].length; a112++)t255[i139].push(0);
                return t255;
            }
        },
        {
            key: "hasAllSeriesEqualX",
            value: function() {
                for(var t256 = !0, e193 = this.w, i140 = this.filteredSeriesX(), a113 = 0; a113 < i140.length - 1; a113++)if (i140[a113][0] !== i140[a113 + 1][0]) {
                    t256 = !1;
                    break;
                }
                return e193.globals.allSeriesHasEqualX = t256, t256;
            }
        },
        {
            key: "filteredSeriesX",
            value: function() {
                var t257 = this.w.globals.seriesX.map(function(t258) {
                    return t258.length > 0 ? t258 : [];
                });
                return t257;
            }
        }
    ]), t236;
}(), Y = function() {
    function t259(e194) {
        a(this, t259), this.w = e194.w, this.barCtx = e194;
    }
    return r(t259, [
        {
            key: "initVariables",
            value: function(t260) {
                var e195 = this.w;
                this.barCtx.series = t260, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
                for(var i141 = 0; i141 < t260.length; i141++)if (t260[i141].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t260[i141].length), e195.globals.isXNumeric) for(var a114 = 0; a114 < t260[i141].length; a114++)e195.globals.seriesX[i141][a114] > e195.globals.minX && e195.globals.seriesX[i141][a114] < e195.globals.maxX && this.barCtx.visibleItems++;
                else this.barCtx.visibleItems = e195.globals.dataPoints;
                0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], this.barCtx.radiusOnSeriesNumber = t260.length - 1, e195.globals.comboCharts || this.checkZeroSeries({
                    series: t260
                });
            }
        },
        {
            key: "initialPositions",
            value: function() {
                var t261, e196, i142, a115, s85, r72, o60, n51, l39 = this.w, h34 = l39.globals.dataPoints;
                this.barCtx.isRangeBar && (h34 = l39.globals.labels.length);
                var c31 = this.barCtx.seriesLen;
                if (l39.config.plotOptions.bar.rangeBarGroupRows && (c31 = 1), this.barCtx.isHorizontal) s85 = (i142 = l39.globals.gridHeight / h34) / c31, l39.globals.isXNumeric && (s85 = (i142 = l39.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), s85 = s85 * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, n51 = this.barCtx.baseLineInvertedY + l39.globals.padHorizontal + (this.barCtx.isReversed ? l39.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), e196 = (i142 - s85 * this.barCtx.seriesLen) / 2;
                else {
                    if (a115 = l39.globals.gridWidth / this.barCtx.visibleItems, l39.config.xaxis.convertedCatToNumeric && (a115 = l39.globals.gridWidth / l39.globals.dataPoints), r72 = a115 / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, l39.globals.isXNumeric) {
                        var d27 = this.barCtx.xRatio;
                        l39.config.xaxis.convertedCatToNumeric && (d27 = this.barCtx.initialXRatio), l39.globals.minXDiff && .5 !== l39.globals.minXDiff && l39.globals.minXDiff / d27 > 0 && (a115 = l39.globals.minXDiff / d27), (r72 = a115 / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (r72 = 1);
                    }
                    o60 = l39.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? l39.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0), t261 = l39.globals.padHorizontal + (a115 - r72 * this.barCtx.seriesLen) / 2;
                }
                return {
                    x: t261,
                    y: e196,
                    yDivision: i142,
                    xDivision: a115,
                    barHeight: s85,
                    barWidth: r72,
                    zeroH: o60,
                    zeroW: n51
                };
            }
        },
        {
            key: "getPathFillColor",
            value: function(t262, e197, i143, a116) {
                var s86 = this.w, r73 = new T(this.barCtx.ctx), o61 = null, n52 = this.barCtx.barOptions.distributed ? i143 : e197;
                this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(a117) {
                    t262[e197][i143] >= a117.from && t262[e197][i143] <= a117.to && (o61 = a117.color);
                });
                return s86.config.series[e197].data[i143] && s86.config.series[e197].data[i143].fillColor && (o61 = s86.config.series[e197].data[i143].fillColor), r73.fillPath({
                    seriesNumber: this.barCtx.barOptions.distributed ? n52 : a116,
                    dataPointIndex: i143,
                    color: o61,
                    value: t262[e197][i143]
                });
            }
        },
        {
            key: "getStrokeWidth",
            value: function(t263, e198, i144) {
                var a118 = 0, s87 = this.w;
                return void 0 === this.barCtx.series[t263][e198] || null === this.barCtx.series[t263][e198] ? this.barCtx.isNullValue = !0 : this.barCtx.isNullValue = !1, s87.config.stroke.show && (this.barCtx.isNullValue || (a118 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i144] : this.barCtx.strokeWidth)), a118;
            }
        },
        {
            key: "barBackground",
            value: function(t264) {
                var e199 = t264.j, i145 = t264.i, a119 = t264.x1, s88 = t264.x2, r74 = t264.y1, o62 = t264.y2, n53 = t264.elSeries, l40 = this.w, h35 = new m(this.barCtx.ctx), c32 = new E(this.barCtx.ctx).getActiveConfigSeriesIndex();
                if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && c32 === i145) {
                    e199 >= this.barCtx.barOptions.colors.backgroundBarColors.length && (e199 %= this.barCtx.barOptions.colors.backgroundBarColors.length);
                    var d28 = this.barCtx.barOptions.colors.backgroundBarColors[e199], g22 = h35.drawRect(void 0 !== a119 ? a119 : 0, void 0 !== r74 ? r74 : 0, void 0 !== s88 ? s88 : l40.globals.gridWidth, void 0 !== o62 ? o62 : l40.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, d28, this.barCtx.barOptions.colors.backgroundBarOpacity);
                    n53.add(g22), g22.node.classList.add("apexcharts-backgroundBar");
                }
            }
        },
        {
            key: "getColumnPaths",
            value: function(t265) {
                var e200 = t265.barWidth, i146 = t265.barXPosition, a120 = t265.yRatio, s89 = t265.y1, r75 = t265.y2, o63 = t265.strokeWidth, n54 = t265.series, l41 = t265.realIndex, h36 = t265.i, c33 = t265.j, d29 = t265.w, g23 = new m(this.barCtx.ctx);
                (o63 = Array.isArray(o63) ? o63[l41] : o63) || (o63 = 0);
                var u20 = {
                    barWidth: e200,
                    strokeWidth: o63,
                    yRatio: a120,
                    barXPosition: i146,
                    y1: s89,
                    y2: r75
                }, p18 = this.getRoundedBars(d29, u20, n54, h36, c33), f16 = i146, x12 = i146 + e200, b12 = g23.move(f16, s89), v7 = g23.move(f16, s89), y8 = g23.line(x12 - o63, s89);
                return d29.globals.previousPaths.length > 0 && (v7 = this.barCtx.getPreviousPath(l41, c33, !1)), b12 = b12 + g23.line(f16, p18.y2) + p18.pathWithRadius + g23.line(x12 - o63, p18.y2) + y8 + y8 + "z", v7 = v7 + g23.line(f16, s89) + y8 + y8 + y8 + y8 + y8 + g23.line(f16, s89), d29.config.chart.stacked && (this.barCtx.yArrj.push(p18.y2), this.barCtx.yArrjF.push(Math.abs(s89 - p18.y2)), this.barCtx.yArrjVal.push(this.barCtx.series[h36][c33])), {
                    pathTo: b12,
                    pathFrom: v7
                };
            }
        },
        {
            key: "getBarpaths",
            value: function(t266) {
                var e201 = t266.barYPosition, i147 = t266.barHeight, a121 = t266.x1, s90 = t266.x2, r76 = t266.strokeWidth, o64 = t266.series, n55 = t266.realIndex, l42 = t266.i, h37 = t266.j, c34 = t266.w, d30 = new m(this.barCtx.ctx);
                (r76 = Array.isArray(r76) ? r76[n55] : r76) || (r76 = 0);
                var g24 = {
                    barHeight: i147,
                    strokeWidth: r76,
                    barYPosition: e201,
                    x2: s90,
                    x1: a121
                }, u21 = this.getRoundedBars(c34, g24, o64, l42, h37), p19 = d30.move(a121, e201), f17 = d30.move(a121, e201);
                c34.globals.previousPaths.length > 0 && (f17 = this.barCtx.getPreviousPath(n55, h37, !1));
                var x13 = e201, b13 = e201 + i147, v8 = d30.line(a121, b13 - r76);
                return p19 = p19 + d30.line(u21.x2, x13) + u21.pathWithRadius + d30.line(u21.x2, b13 - r76) + v8 + v8 + "z", f17 = f17 + d30.line(a121, x13) + v8 + v8 + v8 + v8 + v8 + d30.line(a121, x13), c34.config.chart.stacked && (this.barCtx.xArrj.push(u21.x2), this.barCtx.xArrjF.push(Math.abs(a121 - u21.x2)), this.barCtx.xArrjVal.push(this.barCtx.series[l42][h37])), {
                    pathTo: p19,
                    pathFrom: f17
                };
            }
        },
        {
            key: "getRoundedBars",
            value: function(t267, e202, i148, a122, s91) {
                var r77 = new m(this.barCtx.ctx), o65 = 0, n56 = t267.config.plotOptions.bar.borderRadius, l43 = Array.isArray(n56);
                l43 ? o65 = n56[a122 > n56.length - 1 ? n56.length - 1 : a122] : o65 = n56;
                if (t267.config.chart.stacked && i148.length > 1 && a122 !== this.barCtx.radiusOnSeriesNumber && !l43 && (o65 = 0), this.barCtx.isHorizontal) {
                    var h38 = "", c35 = e202.x2;
                    if (Math.abs(e202.x1 - e202.x2) < o65 && (o65 = Math.abs(e202.x1 - e202.x2)), void 0 !== i148[a122][s91] || null !== i148[a122][s91]) {
                        var d31 = this.barCtx.isReversed ? i148[a122][s91] > 0 : i148[a122][s91] < 0;
                        d31 && (o65 *= -1), c35 -= o65, h38 = r77.quadraticCurve(c35 + o65, e202.barYPosition, c35 + o65, e202.barYPosition + (d31 ? -1 * o65 : o65)) + r77.line(c35 + o65, e202.barYPosition + e202.barHeight - e202.strokeWidth - (d31 ? -1 * o65 : o65)) + r77.quadraticCurve(c35 + o65, e202.barYPosition + e202.barHeight - e202.strokeWidth, c35, e202.barYPosition + e202.barHeight - e202.strokeWidth);
                    }
                    return {
                        pathWithRadius: h38,
                        x2: c35
                    };
                }
                var g25 = "", u22 = e202.y2;
                if (Math.abs(e202.y1 - e202.y2) < o65 && (o65 = Math.abs(e202.y1 - e202.y2)), void 0 !== i148[a122][s91] || null !== i148[a122][s91]) {
                    var p20 = i148[a122][s91] < 0;
                    p20 && (o65 *= -1), u22 += o65, g25 = r77.quadraticCurve(e202.barXPosition, u22 - o65, e202.barXPosition + (p20 ? -1 * o65 : o65), u22 - o65) + r77.line(e202.barXPosition + e202.barWidth - e202.strokeWidth - (p20 ? -1 * o65 : o65), u22 - o65) + r77.quadraticCurve(e202.barXPosition + e202.barWidth - e202.strokeWidth, u22 - o65, e202.barXPosition + e202.barWidth - e202.strokeWidth, u22);
                }
                return {
                    pathWithRadius: g25,
                    y2: u22
                };
            }
        },
        {
            key: "checkZeroSeries",
            value: function(t268) {
                for(var e203 = t268.series, i149 = this.w, a123 = 0; a123 < e203.length; a123++){
                    for(var s92 = 0, r78 = 0; r78 < e203[i149.globals.maxValsInArrayIndex].length; r78++)s92 += e203[a123][r78];
                    0 === s92 && this.barCtx.zeroSerieses.push(a123);
                }
                for(var o66 = e203.length - 1; o66 >= 0; o66--)this.barCtx.zeroSerieses.indexOf(o66) > -1 && o66 === this.radiusOnSeriesNumber && (this.barCtx.radiusOnSeriesNumber -= 1);
                for(var n57 = e203.length - 1; n57 >= 0; n57--)i149.globals.collapsedSeriesIndices.indexOf(this.barCtx.radiusOnSeriesNumber) > -1 && (this.barCtx.radiusOnSeriesNumber -= 1);
            }
        },
        {
            key: "getXForValue",
            value: function(t269, e204) {
                var i150 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a124 = i150 ? e204 : null;
                return null != t269 && (a124 = e204 + t269 / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? t269 / this.barCtx.invertedYRatio : 0)), a124;
            }
        },
        {
            key: "getYForValue",
            value: function(t270, e205) {
                var i151 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a125 = i151 ? e205 : null;
                return null != t270 && (a125 = e205 - t270 / this.barCtx.yRatio[this.barCtx.yaxisIndex] + 2 * (this.barCtx.isReversed ? t270 / this.barCtx.yRatio[this.barCtx.yaxisIndex] : 0)), a125;
            }
        },
        {
            key: "getGoalValues",
            value: function(t271, e206, i152, a126, s93) {
                var r79 = this, n58 = this.w, l44 = [];
                return n58.globals.seriesGoals[a126] && n58.globals.seriesGoals[a126][s93] && Array.isArray(n58.globals.seriesGoals[a126][s93]) && n58.globals.seriesGoals[a126][s93].forEach(function(a127) {
                    var s94;
                    l44.push((o(s94 = {}, t271, "x" === t271 ? r79.getXForValue(a127.value, e206, !1) : r79.getYForValue(a127.value, i152, !1)), o(s94, "attrs", a127), s94));
                }), l44;
            }
        },
        {
            key: "drawGoalLine",
            value: function(t272) {
                var e207 = t272.barXPosition, i153 = t272.barYPosition, a128 = t272.goalX, s95 = t272.goalY, r80 = t272.barWidth, o67 = t272.barHeight, n59 = new m(this.barCtx.ctx), l45 = n59.group({
                    className: "apexcharts-bar-goals-groups"
                }), h39 = null;
                return this.barCtx.isHorizontal ? Array.isArray(a128) && a128.forEach(function(t273) {
                    var e208 = void 0 !== t273.attrs.strokeHeight ? t273.attrs.strokeHeight : o67 / 2, a129 = i153 + e208 + o67 / 2;
                    h39 = n59.drawLine(t273.x, a129 - 2 * e208, t273.x, a129, t273.attrs.strokeColor ? t273.attrs.strokeColor : void 0, t273.attrs.strokeDashArray, t273.attrs.strokeWidth ? t273.attrs.strokeWidth : 2, t273.attrs.strokeLineCap), l45.add(h39);
                }) : Array.isArray(s95) && s95.forEach(function(t274) {
                    var i154 = void 0 !== t274.attrs.strokeWidth ? t274.attrs.strokeWidth : r80 / 2, a130 = e207 + i154 + r80 / 2;
                    h39 = n59.drawLine(a130 - 2 * i154, t274.y, a130, t274.y, t274.attrs.strokeColor ? t274.attrs.strokeColor : void 0, t274.attrs.strokeDashArray, t274.attrs.strokeHeight ? t274.attrs.strokeHeight : 2, t274.attrs.strokeLineCap), l45.add(h39);
                }), l45;
            }
        }
    ]), t259;
}(), F = function() {
    function t275(e209, i155) {
        a(this, t275), this.ctx = e209, this.w = e209.w;
        var s96 = this.w;
        this.barOptions = s96.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = s96.config.stroke.width, this.isNullValue = !1, this.isRangeBar = s96.globals.seriesRangeBar.length && this.isHorizontal, this.xyRatios = i155, null !== this.xyRatios && (this.xRatio = i155.xRatio, this.initialXRatio = i155.initialXRatio, this.yRatio = i155.yRatio, this.invertedXRatio = i155.invertedXRatio, this.invertedYRatio = i155.invertedYRatio, this.baseLineY = i155.baseLineY, this.baseLineInvertedY = i155.baseLineInvertedY), this.yaxisIndex = 0, this.seriesLen = 0, this.barHelpers = new Y(this);
    }
    return r(t275, [
        {
            key: "draw",
            value: function(t276, i156) {
                var a131 = this.w, s97 = new m(this.ctx), r81 = new y(this.ctx, a131);
                t276 = r81.getLogSeries(t276), this.series = t276, this.yRatio = r81.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t276);
                var o68 = s97.group({
                    class: "apexcharts-bar-series apexcharts-plot-series"
                });
                a131.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.");
                for(var n60 = 0, l46 = 0; n60 < t276.length; n60++, l46++){
                    var h40, c36, d32, g26, u23 = void 0, p21 = void 0, f18 = [], b14 = [], v9 = a131.globals.comboCharts ? i156[n60] : n60, w7 = s97.group({
                        class: "apexcharts-series",
                        rel: n60 + 1,
                        seriesName: x.escapeString(a131.globals.seriesNames[v9]),
                        "data:realIndex": v9
                    });
                    this.ctx.series.addCollapsedClassToSeries(w7, v9), t276[n60].length > 0 && (this.visibleI = this.visibleI + 1);
                    var k7 = 0, A5 = 0;
                    this.yRatio.length > 1 && (this.yaxisIndex = v9), this.isReversed = a131.config.yaxis[this.yaxisIndex] && a131.config.yaxis[this.yaxisIndex].reversed;
                    var S5 = this.barHelpers.initialPositions();
                    p21 = S5.y, k7 = S5.barHeight, c36 = S5.yDivision, g26 = S5.zeroW, u23 = S5.x, A5 = S5.barWidth, h40 = S5.xDivision, d32 = S5.zeroH, this.horizontal || b14.push(u23 + A5 / 2);
                    for(var C5 = s97.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": v9
                    }), L5 = s97.group({
                        class: "apexcharts-bar-goals-markers",
                        style: "pointer-events: none"
                    }), P5 = 0; P5 < a131.globals.dataPoints; P5++){
                        var T4 = this.barHelpers.getStrokeWidth(n60, P5, v9), M4 = null, I3 = {
                            indexes: {
                                i: n60,
                                j: P5,
                                realIndex: v9,
                                bc: l46
                            },
                            x: u23,
                            y: p21,
                            strokeWidth: T4,
                            elSeries: w7
                        };
                        this.isHorizontal ? (M4 = this.drawBarPaths(e(e({}, I3), {}, {
                            barHeight: k7,
                            zeroW: g26,
                            yDivision: c36
                        })), A5 = this.series[n60][P5] / this.invertedYRatio) : (M4 = this.drawColumnPaths(e(e({}, I3), {}, {
                            xDivision: h40,
                            barWidth: A5,
                            zeroH: d32
                        })), k7 = this.series[n60][P5] / this.yRatio[this.yaxisIndex]);
                        var z2 = this.barHelpers.drawGoalLine({
                            barXPosition: M4.barXPosition,
                            barYPosition: M4.barYPosition,
                            goalX: M4.goalX,
                            goalY: M4.goalY,
                            barHeight: k7,
                            barWidth: A5
                        });
                        z2 && L5.add(z2), p21 = M4.y, u23 = M4.x, P5 > 0 && b14.push(u23 + A5 / 2), f18.push(p21);
                        var X2 = this.barHelpers.getPathFillColor(t276, n60, P5, v9);
                        this.renderSeries({
                            realIndex: v9,
                            pathFill: X2,
                            j: P5,
                            i: n60,
                            pathFrom: M4.pathFrom,
                            pathTo: M4.pathTo,
                            strokeWidth: T4,
                            elSeries: w7,
                            x: u23,
                            y: p21,
                            series: t276,
                            barHeight: k7,
                            barWidth: A5,
                            elDataLabelsWrap: C5,
                            elGoalsMarkers: L5,
                            visibleSeries: this.visibleI,
                            type: "bar"
                        });
                    }
                    a131.globals.seriesXvalues[v9] = b14, a131.globals.seriesYvalues[v9] = f18, o68.add(w7);
                }
                return o68;
            }
        },
        {
            key: "renderSeries",
            value: function(t277) {
                var e210 = t277.realIndex, i157 = t277.pathFill, a132 = t277.lineFill, s98 = t277.j, r82 = t277.i, o69 = t277.pathFrom, n61 = t277.pathTo, l47 = t277.strokeWidth, h41 = t277.elSeries, c37 = t277.x, d33 = t277.y, g27 = t277.y1, u24 = t277.y2, p22 = t277.series, f19 = t277.barHeight, x14 = t277.barWidth, b15 = t277.barYPosition, y9 = t277.elDataLabelsWrap, w8 = t277.elGoalsMarkers, k8 = t277.visibleSeries, A6 = t277.type, S6 = this.w, C6 = new m(this.ctx);
                a132 || (a132 = this.barOptions.distributed ? S6.globals.stroke.colors[s98] : S6.globals.stroke.colors[e210]), S6.config.series[r82].data[s98] && S6.config.series[r82].data[s98].strokeColor && (a132 = S6.config.series[r82].data[s98].strokeColor), this.isNullValue && (i157 = "none");
                var L6 = s98 / S6.config.chart.animations.animateGradually.delay * (S6.config.chart.animations.speed / S6.globals.dataPoints) / 2.4, P6 = C6.renderPaths({
                    i: r82,
                    j: s98,
                    realIndex: e210,
                    pathFrom: o69,
                    pathTo: n61,
                    stroke: a132,
                    strokeWidth: l47,
                    strokeLineCap: S6.config.stroke.lineCap,
                    fill: i157,
                    animationDelay: L6,
                    initialSpeed: S6.config.chart.animations.speed,
                    dataChangeSpeed: S6.config.chart.animations.dynamicAnimation.speed,
                    className: "apexcharts-".concat(A6, "-area")
                });
                P6.attr("clip-path", "url(#gridRectMask".concat(S6.globals.cuid, ")"));
                var T5 = S6.config.forecastDataPoints;
                T5.count > 0 && s98 >= S6.globals.dataPoints - T5.count && (P6.node.setAttribute("stroke-dasharray", T5.dashArray), P6.node.setAttribute("stroke-width", T5.strokeWidth), P6.node.setAttribute("fill-opacity", T5.fillOpacity)), void 0 !== g27 && void 0 !== u24 && (P6.attr("data-range-y1", g27), P6.attr("data-range-y2", u24)), new v(this.ctx).setSelectionFilter(P6, e210, s98), h41.add(P6);
                var M5 = new X(this).handleBarDataLabels({
                    x: c37,
                    y: d33,
                    y1: g27,
                    y2: u24,
                    i: r82,
                    j: s98,
                    series: p22,
                    realIndex: e210,
                    barHeight: f19,
                    barWidth: x14,
                    barYPosition: b15,
                    renderedPath: P6,
                    visibleSeries: k8
                });
                return null !== M5 && y9.add(M5), h41.add(y9), w8 && h41.add(w8), h41;
            }
        },
        {
            key: "drawBarPaths",
            value: function(t278) {
                var e211 = t278.indexes, i158 = t278.barHeight, a133 = t278.strokeWidth, s99 = t278.zeroW, r83 = t278.x, o70 = t278.y, n62 = t278.yDivision, l48 = t278.elSeries, h42 = this.w, c38 = e211.i, d34 = e211.j;
                h42.globals.isXNumeric && (o70 = (h42.globals.seriesX[c38][d34] - h42.globals.minX) / this.invertedXRatio - i158);
                var g28 = o70 + i158 * this.visibleI;
                r83 = this.barHelpers.getXForValue(this.series[c38][d34], s99);
                var u25 = this.barHelpers.getBarpaths({
                    barYPosition: g28,
                    barHeight: i158,
                    x1: s99,
                    x2: r83,
                    strokeWidth: a133,
                    series: this.series,
                    realIndex: e211.realIndex,
                    i: c38,
                    j: d34,
                    w: h42
                });
                return h42.globals.isXNumeric || (o70 += n62), this.barHelpers.barBackground({
                    j: d34,
                    i: c38,
                    y1: g28 - i158 * this.visibleI,
                    y2: i158 * this.seriesLen,
                    elSeries: l48
                }), {
                    pathTo: u25.pathTo,
                    pathFrom: u25.pathFrom,
                    x: r83,
                    y: o70,
                    goalX: this.barHelpers.getGoalValues("x", s99, null, c38, d34),
                    barYPosition: g28
                };
            }
        },
        {
            key: "drawColumnPaths",
            value: function(t279) {
                var e212 = t279.indexes, i159 = t279.x, a134 = t279.y, s100 = t279.xDivision, r84 = t279.barWidth, o71 = t279.zeroH, n63 = t279.strokeWidth, l49 = t279.elSeries, h43 = this.w, c39 = e212.realIndex, d35 = e212.i, g29 = e212.j, u26 = e212.bc;
                if (h43.globals.isXNumeric) {
                    var p23 = c39;
                    h43.globals.seriesX[c39].length || (p23 = h43.globals.maxValsInArrayIndex), i159 = (h43.globals.seriesX[p23][g29] - h43.globals.minX) / this.xRatio - r84 * this.seriesLen / 2;
                }
                var f20 = i159 + r84 * this.visibleI;
                a134 = this.barHelpers.getYForValue(this.series[d35][g29], o71);
                var x15 = this.barHelpers.getColumnPaths({
                    barXPosition: f20,
                    barWidth: r84,
                    y1: o71,
                    y2: a134,
                    strokeWidth: n63,
                    series: this.series,
                    realIndex: e212.realIndex,
                    i: d35,
                    j: g29,
                    w: h43
                });
                return h43.globals.isXNumeric || (i159 += s100), this.barHelpers.barBackground({
                    bc: u26,
                    j: g29,
                    i: d35,
                    x1: f20 - n63 / 2 - r84 * this.visibleI,
                    x2: r84 * this.seriesLen + n63 / 2,
                    elSeries: l49
                }), {
                    pathTo: x15.pathTo,
                    pathFrom: x15.pathFrom,
                    x: i159,
                    y: a134,
                    goalY: this.barHelpers.getGoalValues("y", null, o71, d35, g29),
                    barXPosition: f20
                };
            }
        },
        {
            key: "getPreviousPath",
            value: function(t280, e213) {
                for(var i160, a135 = this.w, s101 = 0; s101 < a135.globals.previousPaths.length; s101++){
                    var r85 = a135.globals.previousPaths[s101];
                    r85.paths && r85.paths.length > 0 && parseInt(r85.realIndex, 10) === parseInt(t280, 10) && void 0 !== a135.globals.previousPaths[s101].paths[e213] && (i160 = a135.globals.previousPaths[s101].paths[e213].d);
                }
                return i160;
            }
        }
    ]), t275;
}(), R = function() {
    function t281(e214) {
        a(this, t281), this.ctx = e214, this.w = e214.w, this.months31 = [
            1,
            3,
            5,
            7,
            8,
            10,
            12
        ], this.months30 = [
            2,
            4,
            6,
            9,
            11
        ], this.daysCntOfYear = [
            0,
            31,
            59,
            90,
            120,
            151,
            181,
            212,
            243,
            273,
            304,
            334
        ];
    }
    return r(t281, [
        {
            key: "isValidDate",
            value: function(t282) {
                return !isNaN(this.parseDate(t282));
            }
        },
        {
            key: "getTimeStamp",
            value: function(t283) {
                return Date.parse(t283) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t283).toISOString().substr(0, 25)).getTime() : new Date(t283).getTime() : t283;
            }
        },
        {
            key: "getDate",
            value: function(t284) {
                return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t284).toUTCString()) : new Date(t284);
            }
        },
        {
            key: "parseDate",
            value: function(t285) {
                var e215 = Date.parse(t285);
                if (!isNaN(e215)) return this.getTimeStamp(t285);
                var i161 = Date.parse(t285.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
                return i161 = this.getTimeStamp(i161);
            }
        },
        {
            key: "parseDateWithTimezone",
            value: function(t286) {
                return Date.parse(t286.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
            }
        },
        {
            key: "formatDate",
            value: function(t287, e216) {
                var i162 = this.w.globals.locale, a136 = this.w.config.xaxis.labels.datetimeUTC, s102 = [
                    "\0"
                ].concat(u(i162.months)), r86 = [
                    "\x01"
                ].concat(u(i162.shortMonths)), o72 = [
                    "\x02"
                ].concat(u(i162.days)), n64 = [
                    "\x03"
                ].concat(u(i162.shortDays));
                function l50(t288, e217) {
                    var i163 = t288 + "";
                    for(e217 = e217 || 2; i163.length < e217;)i163 = "0" + i163;
                    return i163;
                }
                var h44 = a136 ? t287.getUTCFullYear() : t287.getFullYear();
                e216 = (e216 = (e216 = e216.replace(/(^|[^\\])yyyy+/g, "$1" + h44)).replace(/(^|[^\\])yy/g, "$1" + h44.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + h44);
                var c40 = (a136 ? t287.getUTCMonth() : t287.getMonth()) + 1;
                e216 = (e216 = (e216 = (e216 = e216.replace(/(^|[^\\])MMMM+/g, "$1" + s102[0])).replace(/(^|[^\\])MMM/g, "$1" + r86[0])).replace(/(^|[^\\])MM/g, "$1" + l50(c40))).replace(/(^|[^\\])M/g, "$1" + c40);
                var d36 = a136 ? t287.getUTCDate() : t287.getDate();
                e216 = (e216 = (e216 = (e216 = e216.replace(/(^|[^\\])dddd+/g, "$1" + o72[0])).replace(/(^|[^\\])ddd/g, "$1" + n64[0])).replace(/(^|[^\\])dd/g, "$1" + l50(d36))).replace(/(^|[^\\])d/g, "$1" + d36);
                var g30 = a136 ? t287.getUTCHours() : t287.getHours(), p24 = g30 > 12 ? g30 - 12 : 0 === g30 ? 12 : g30;
                e216 = (e216 = (e216 = (e216 = e216.replace(/(^|[^\\])HH+/g, "$1" + l50(g30))).replace(/(^|[^\\])H/g, "$1" + g30)).replace(/(^|[^\\])hh+/g, "$1" + l50(p24))).replace(/(^|[^\\])h/g, "$1" + p24);
                var f21 = a136 ? t287.getUTCMinutes() : t287.getMinutes();
                e216 = (e216 = e216.replace(/(^|[^\\])mm+/g, "$1" + l50(f21))).replace(/(^|[^\\])m/g, "$1" + f21);
                var x16 = a136 ? t287.getUTCSeconds() : t287.getSeconds();
                e216 = (e216 = e216.replace(/(^|[^\\])ss+/g, "$1" + l50(x16))).replace(/(^|[^\\])s/g, "$1" + x16);
                var b16 = a136 ? t287.getUTCMilliseconds() : t287.getMilliseconds();
                e216 = e216.replace(/(^|[^\\])fff+/g, "$1" + l50(b16, 3)), b16 = Math.round(b16 / 10), e216 = e216.replace(/(^|[^\\])ff/g, "$1" + l50(b16)), b16 = Math.round(b16 / 10);
                var v10 = g30 < 12 ? "AM" : "PM";
                e216 = (e216 = (e216 = e216.replace(/(^|[^\\])f/g, "$1" + b16)).replace(/(^|[^\\])TT+/g, "$1" + v10)).replace(/(^|[^\\])T/g, "$1" + v10.charAt(0));
                var m3 = v10.toLowerCase();
                e216 = (e216 = e216.replace(/(^|[^\\])tt+/g, "$1" + m3)).replace(/(^|[^\\])t/g, "$1" + m3.charAt(0));
                var y10 = -t287.getTimezoneOffset(), w9 = a136 || !y10 ? "Z" : y10 > 0 ? "+" : "-";
                if (!a136) {
                    var k9 = (y10 = Math.abs(y10)) % 60;
                    w9 += l50(Math.floor(y10 / 60)) + ":" + l50(k9);
                }
                e216 = e216.replace(/(^|[^\\])K/g, "$1" + w9);
                var A7 = (a136 ? t287.getUTCDay() : t287.getDay()) + 1;
                return e216 = (e216 = (e216 = (e216 = (e216 = e216.replace(new RegExp(o72[0], "g"), o72[A7])).replace(new RegExp(n64[0], "g"), n64[A7])).replace(new RegExp(s102[0], "g"), s102[c40])).replace(new RegExp(r86[0], "g"), r86[c40])).replace(/\\(.)/g, "$1");
            }
        },
        {
            key: "getTimeUnitsfromTimestamp",
            value: function(t289, e218, i) {
                var a137 = this.w;
                void 0 !== a137.config.xaxis.min && (t289 = a137.config.xaxis.min), void 0 !== a137.config.xaxis.max && (e218 = a137.config.xaxis.max);
                var s103 = this.getDate(t289), r87 = this.getDate(e218), o73 = this.formatDate(s103, "yyyy MM dd HH mm ss fff").split(" "), n65 = this.formatDate(r87, "yyyy MM dd HH mm ss fff").split(" ");
                return {
                    minMillisecond: parseInt(o73[6], 10),
                    maxMillisecond: parseInt(n65[6], 10),
                    minSecond: parseInt(o73[5], 10),
                    maxSecond: parseInt(n65[5], 10),
                    minMinute: parseInt(o73[4], 10),
                    maxMinute: parseInt(n65[4], 10),
                    minHour: parseInt(o73[3], 10),
                    maxHour: parseInt(n65[3], 10),
                    minDate: parseInt(o73[2], 10),
                    maxDate: parseInt(n65[2], 10),
                    minMonth: parseInt(o73[1], 10) - 1,
                    maxMonth: parseInt(n65[1], 10) - 1,
                    minYear: parseInt(o73[0], 10),
                    maxYear: parseInt(n65[0], 10)
                };
            }
        },
        {
            key: "isLeapYear",
            value: function(t290) {
                return t290 % 4 == 0 && t290 % 100 != 0 || t290 % 400 == 0;
            }
        },
        {
            key: "calculcateLastDaysOfMonth",
            value: function(t291, e219, i164) {
                return this.determineDaysOfMonths(t291, e219) - i164;
            }
        },
        {
            key: "determineDaysOfYear",
            value: function(t292) {
                var e220 = 365;
                return this.isLeapYear(t292) && (e220 = 366), e220;
            }
        },
        {
            key: "determineRemainingDaysOfYear",
            value: function(t, e221, i165) {
                var a138 = this.daysCntOfYear[e221] + i165;
                return e221 > 1 && this.isLeapYear() && a138++, a138;
            }
        },
        {
            key: "determineDaysOfMonths",
            value: function(t293, e222) {
                var i166 = 30;
                switch(t293 = x.monthMod(t293), !0){
                    case this.months30.indexOf(t293) > -1:
                        2 === t293 && (i166 = this.isLeapYear(e222) ? 29 : 28);
                        break;
                    case this.months31.indexOf(t293) > -1:
                    default:
                        i166 = 31;
                }
                return i166;
            }
        }
    ]), t281;
}(), H = function(t294) {
    n(s104, F);
    var i167 = d(s104);
    function s104() {
        return a(this, s104), i167.apply(this, arguments);
    }
    return r(s104, [
        {
            key: "draw",
            value: function(t295, i168) {
                var a139 = this.w, s105 = new m(this.ctx);
                this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t295, this.seriesRangeStart = a139.globals.seriesRangeStart, this.seriesRangeEnd = a139.globals.seriesRangeEnd, this.barHelpers.initVariables(t295);
                for(var r88 = s105.group({
                    class: "apexcharts-rangebar-series apexcharts-plot-series"
                }), o74 = 0; o74 < t295.length; o74++){
                    var n66, l51, h45, c41 = void 0, d37 = void 0, g31 = void 0, u27 = a139.globals.comboCharts ? i168[o74] : o74, p25 = s105.group({
                        class: "apexcharts-series",
                        seriesName: x.escapeString(a139.globals.seriesNames[u27]),
                        rel: o74 + 1,
                        "data:realIndex": u27
                    });
                    this.ctx.series.addCollapsedClassToSeries(p25, u27), t295[o74].length > 0 && (this.visibleI = this.visibleI + 1);
                    var f22 = 0, b17 = 0;
                    this.yRatio.length > 1 && (this.yaxisIndex = u27);
                    var v11 = this.barHelpers.initialPositions();
                    d37 = v11.y, h45 = v11.zeroW, c41 = v11.x, b17 = v11.barWidth, n66 = v11.xDivision, l51 = v11.zeroH;
                    for(var y11 = s105.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": u27
                    }), w10 = s105.group({
                        class: "apexcharts-rangebar-goals-markers",
                        style: "pointer-events: none"
                    }), k10 = 0; k10 < a139.globals.dataPoints; k10++){
                        var A8 = this.barHelpers.getStrokeWidth(o74, k10, u27), S7 = this.seriesRangeStart[o74][k10], C7 = this.seriesRangeEnd[o74][k10], L7 = null, P7 = null, T6 = {
                            x: c41,
                            y: d37,
                            strokeWidth: A8,
                            elSeries: p25
                        };
                        if (g31 = v11.yDivision, f22 = v11.barHeight, this.isHorizontal) {
                            P7 = d37 + f22 * this.visibleI;
                            var M6 = this.seriesLen;
                            a139.config.plotOptions.bar.rangeBarGroupRows && (M6 = 1);
                            var I4 = (g31 - f22 * M6) / 2;
                            if (void 0 === a139.config.series[o74].data[k10]) break;
                            if (a139.config.series[o74].data[k10].x) {
                                var z3 = this.detectOverlappingBars({
                                    i: o74,
                                    j: k10,
                                    barYPosition: P7,
                                    srty: I4,
                                    barHeight: f22,
                                    yDivision: g31,
                                    initPositions: v11
                                });
                                f22 = z3.barHeight, P7 = z3.barYPosition;
                            }
                            b17 = (L7 = this.drawRangeBarPaths(e({
                                indexes: {
                                    i: o74,
                                    j: k10,
                                    realIndex: u27
                                },
                                barHeight: f22,
                                barYPosition: P7,
                                zeroW: h45,
                                yDivision: g31,
                                y1: S7,
                                y2: C7
                            }, T6))).barWidth;
                        } else f22 = (L7 = this.drawRangeColumnPaths(e({
                            indexes: {
                                i: o74,
                                j: k10,
                                realIndex: u27
                            },
                            zeroH: l51,
                            barWidth: b17,
                            xDivision: n66
                        }, T6))).barHeight;
                        var X3 = this.barHelpers.drawGoalLine({
                            barXPosition: L7.barXPosition,
                            barYPosition: P7,
                            goalX: L7.goalX,
                            goalY: L7.goalY,
                            barHeight: f22,
                            barWidth: b17
                        });
                        X3 && w10.add(X3), d37 = L7.y, c41 = L7.x;
                        var E2 = this.barHelpers.getPathFillColor(t295, o74, k10, u27), Y1 = a139.globals.stroke.colors[u27];
                        this.renderSeries({
                            realIndex: u27,
                            pathFill: E2,
                            lineFill: Y1,
                            j: k10,
                            i: o74,
                            x: c41,
                            y: d37,
                            y1: S7,
                            y2: C7,
                            pathFrom: L7.pathFrom,
                            pathTo: L7.pathTo,
                            strokeWidth: A8,
                            elSeries: p25,
                            series: t295,
                            barHeight: f22,
                            barYPosition: P7,
                            barWidth: b17,
                            elDataLabelsWrap: y11,
                            elGoalsMarkers: w10,
                            visibleSeries: this.visibleI,
                            type: "rangebar"
                        });
                    }
                    r88.add(p25);
                }
                return r88;
            }
        },
        {
            key: "detectOverlappingBars",
            value: function(t296) {
                var e223 = t296.i, i169 = t296.j, a140 = t296.barYPosition, s106 = t296.srty, r89 = t296.barHeight, o75 = t296.yDivision, n67 = t296.initPositions, l52 = this.w, h46 = [], c42 = l52.config.series[e223].data[i169].rangeName, d38 = l52.config.series[e223].data[i169].x, g32 = l52.globals.labels.indexOf(d38), u28 = l52.globals.seriesRangeBar[e223].findIndex(function(t297) {
                    return t297.x === d38 && t297.overlaps.length > 0;
                });
                return a140 = l52.config.plotOptions.bar.rangeBarGroupRows ? s106 + o75 * g32 : s106 + r89 * this.visibleI + o75 * g32, u28 > -1 && !l52.config.plotOptions.bar.rangeBarOverlap && (h46 = l52.globals.seriesRangeBar[e223][u28].overlaps).indexOf(c42) > -1 && (a140 = (r89 = n67.barHeight / h46.length) * this.visibleI + o75 * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + r89 * (this.visibleI + h46.indexOf(c42)) + o75 * g32), {
                    barYPosition: a140,
                    barHeight: r89
                };
            }
        },
        {
            key: "drawRangeColumnPaths",
            value: function(t298) {
                var e224 = t298.indexes, i170 = t298.x;
                t298.strokeWidth;
                var a141 = t298.xDivision, s107 = t298.barWidth, r90 = t298.zeroH, o76 = this.w, n68 = e224.i, l53 = e224.j, h47 = this.yRatio[this.yaxisIndex], c43 = e224.realIndex, d39 = this.getRangeValue(c43, l53), g33 = Math.min(d39.start, d39.end), u29 = Math.max(d39.start, d39.end);
                o76.globals.isXNumeric && (i170 = (o76.globals.seriesX[n68][l53] - o76.globals.minX) / this.xRatio - s107 / 2);
                var p26 = i170 + s107 * this.visibleI;
                void 0 === this.series[n68][l53] || null === this.series[n68][l53] ? g33 = r90 : (g33 = r90 - g33 / h47, u29 = r90 - u29 / h47);
                var f23 = Math.abs(u29 - g33), x17 = this.barHelpers.getColumnPaths({
                    barXPosition: p26,
                    barWidth: s107,
                    y1: g33,
                    y2: u29,
                    strokeWidth: this.strokeWidth,
                    series: this.seriesRangeEnd,
                    realIndex: e224.realIndex,
                    i: c43,
                    j: l53,
                    w: o76
                });
                return o76.globals.isXNumeric || (i170 += a141), {
                    pathTo: x17.pathTo,
                    pathFrom: x17.pathFrom,
                    barHeight: f23,
                    x: i170,
                    y: u29,
                    goalY: this.barHelpers.getGoalValues("y", null, r90, n68, l53),
                    barXPosition: p26
                };
            }
        },
        {
            key: "drawRangeBarPaths",
            value: function(t299) {
                var e225 = t299.indexes, i171 = t299.y, a142 = t299.y1, s108 = t299.y2, r91 = t299.yDivision, o77 = t299.barHeight, n69 = t299.barYPosition, l54 = t299.zeroW, h48 = this.w, c44 = l54 + a142 / this.invertedYRatio, d40 = l54 + s108 / this.invertedYRatio, g34 = Math.abs(d40 - c44), u30 = this.barHelpers.getBarpaths({
                    barYPosition: n69,
                    barHeight: o77,
                    x1: c44,
                    x2: d40,
                    strokeWidth: this.strokeWidth,
                    series: this.seriesRangeEnd,
                    i: e225.realIndex,
                    realIndex: e225.realIndex,
                    j: e225.j,
                    w: h48
                });
                return h48.globals.isXNumeric || (i171 += r91), {
                    pathTo: u30.pathTo,
                    pathFrom: u30.pathFrom,
                    barWidth: g34,
                    x: d40,
                    goalX: this.barHelpers.getGoalValues("x", l54, null, e225.realIndex, e225.j),
                    y: i171
                };
            }
        },
        {
            key: "getRangeValue",
            value: function(t300, e226) {
                var i172 = this.w;
                return {
                    start: i172.globals.seriesRangeStart[t300][e226],
                    end: i172.globals.seriesRangeEnd[t300][e226]
                };
            }
        },
        {
            key: "getTooltipValues",
            value: function(t301) {
                var e227 = t301.ctx, i173 = t301.seriesIndex, a143 = t301.dataPointIndex, s109 = t301.y1, r92 = t301.y2, o78 = t301.w, n70 = o78.globals.seriesRangeStart[i173][a143], l55 = o78.globals.seriesRangeEnd[i173][a143], h49 = o78.globals.labels[a143], c45 = o78.config.series[i173].name ? o78.config.series[i173].name : "", d41 = o78.config.tooltip.y.formatter, g35 = o78.config.tooltip.y.title.formatter, u31 = {
                    w: o78,
                    seriesIndex: i173,
                    dataPointIndex: a143,
                    start: n70,
                    end: l55
                };
                "function" == typeof g35 && (c45 = g35(c45, u31)), Number.isFinite(s109) && Number.isFinite(r92) && (n70 = s109, l55 = r92, o78.config.series[i173].data[a143].x && (h49 = o78.config.series[i173].data[a143].x + ":"), "function" == typeof d41 && (h49 = d41(h49, u31)));
                var p27 = "", f24 = "", x18 = o78.globals.colors[i173];
                if (void 0 === o78.config.tooltip.x.formatter) {
                    if ("datetime" === o78.config.xaxis.type) {
                        var b18 = new R(e227);
                        p27 = b18.formatDate(b18.getDate(n70), o78.config.tooltip.x.format), f24 = b18.formatDate(b18.getDate(l55), o78.config.tooltip.x.format);
                    } else p27 = n70, f24 = l55;
                } else p27 = o78.config.tooltip.x.formatter(n70), f24 = o78.config.tooltip.x.formatter(l55);
                return {
                    start: n70,
                    end: l55,
                    startVal: p27,
                    endVal: f24,
                    ylabel: h49,
                    color: x18,
                    seriesName: c45
                };
            }
        },
        {
            key: "buildCustomTooltipHTML",
            value: function(t302) {
                var e228 = t302.color, i174 = t302.seriesName;
                return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + e228 + '">' + (i174 || "") + '</span></div><div> <span class="category">' + t302.ylabel + ' </span> <span class="value start-value">' + t302.start + '</span> <span class="separator">-</span> <span class="value end-value">' + t302.end + "</span></div></div>";
            }
        }
    ]), s104;
}(), D = function() {
    function t303(e229) {
        a(this, t303), this.opts = e229;
    }
    return r(t303, [
        {
            key: "line",
            value: function() {
                return {
                    chart: {
                        animations: {
                            easing: "swing"
                        }
                    },
                    dataLabels: {
                        enabled: !1
                    },
                    stroke: {
                        width: 5,
                        curve: "straight"
                    },
                    markers: {
                        size: 0,
                        hover: {
                            sizeOffset: 6
                        }
                    },
                    xaxis: {
                        crosshairs: {
                            width: 1
                        }
                    }
                };
            }
        },
        {
            key: "sparkline",
            value: function(t304) {
                this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0;
                return x.extend(t304, {
                    grid: {
                        show: !1,
                        padding: {
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: 0
                        }
                    },
                    legend: {
                        show: !1
                    },
                    xaxis: {
                        labels: {
                            show: !1
                        },
                        tooltip: {
                            enabled: !1
                        },
                        axisBorder: {
                            show: !1
                        },
                        axisTicks: {
                            show: !1
                        }
                    },
                    chart: {
                        toolbar: {
                            show: !1
                        },
                        zoom: {
                            enabled: !1
                        }
                    },
                    dataLabels: {
                        enabled: !1
                    }
                });
            }
        },
        {
            key: "bar",
            value: function() {
                return {
                    chart: {
                        stacked: !1,
                        animations: {
                            easing: "swing"
                        }
                    },
                    plotOptions: {
                        bar: {
                            dataLabels: {
                                position: "center"
                            }
                        }
                    },
                    dataLabels: {
                        style: {
                            colors: [
                                "#fff"
                            ]
                        },
                        background: {
                            enabled: !1
                        }
                    },
                    stroke: {
                        width: 0,
                        lineCap: "round"
                    },
                    fill: {
                        opacity: .85
                    },
                    legend: {
                        markers: {
                            shape: "square",
                            radius: 2,
                            size: 8
                        }
                    },
                    tooltip: {
                        shared: !1,
                        intersect: !0
                    },
                    xaxis: {
                        tooltip: {
                            enabled: !1
                        },
                        tickPlacement: "between",
                        crosshairs: {
                            width: "barWidth",
                            position: "back",
                            fill: {
                                type: "gradient"
                            },
                            dropShadow: {
                                enabled: !1
                            },
                            stroke: {
                                width: 0
                            }
                        }
                    }
                };
            }
        },
        {
            key: "candlestick",
            value: function() {
                var t305 = this;
                return {
                    stroke: {
                        width: 1,
                        colors: [
                            "#333"
                        ]
                    },
                    fill: {
                        opacity: 1
                    },
                    dataLabels: {
                        enabled: !1
                    },
                    tooltip: {
                        shared: !0,
                        custom: function(e230) {
                            var i175 = e230.seriesIndex, a144 = e230.dataPointIndex, s110 = e230.w;
                            return t305._getBoxTooltip(s110, i175, a144, [
                                "Open",
                                "High",
                                "",
                                "Low",
                                "Close"
                            ], "candlestick");
                        }
                    },
                    states: {
                        active: {
                            filter: {
                                type: "none"
                            }
                        }
                    },
                    xaxis: {
                        crosshairs: {
                            width: 1
                        }
                    }
                };
            }
        },
        {
            key: "boxPlot",
            value: function() {
                var t306 = this;
                return {
                    chart: {
                        animations: {
                            dynamicAnimation: {
                                enabled: !1
                            }
                        }
                    },
                    stroke: {
                        width: 1,
                        colors: [
                            "#24292e"
                        ]
                    },
                    dataLabels: {
                        enabled: !1
                    },
                    tooltip: {
                        shared: !0,
                        custom: function(e231) {
                            var i176 = e231.seriesIndex, a145 = e231.dataPointIndex, s111 = e231.w;
                            return t306._getBoxTooltip(s111, i176, a145, [
                                "Minimum",
                                "Q1",
                                "Median",
                                "Q3",
                                "Maximum"
                            ], "boxPlot");
                        }
                    },
                    markers: {
                        size: 5,
                        strokeWidth: 1,
                        strokeColors: "#111"
                    },
                    xaxis: {
                        crosshairs: {
                            width: 1
                        }
                    }
                };
            }
        },
        {
            key: "rangeBar",
            value: function() {
                return {
                    stroke: {
                        width: 0,
                        lineCap: "square"
                    },
                    plotOptions: {
                        bar: {
                            borderRadius: 0,
                            dataLabels: {
                                position: "center"
                            }
                        }
                    },
                    dataLabels: {
                        enabled: !1,
                        formatter: function(t, e232) {
                            e232.ctx;
                            var i177 = e232.seriesIndex, a146 = e232.dataPointIndex, s112 = e232.w, r93 = s112.globals.seriesRangeStart[i177][a146];
                            return s112.globals.seriesRangeEnd[i177][a146] - r93;
                        },
                        background: {
                            enabled: !1
                        },
                        style: {
                            colors: [
                                "#fff"
                            ]
                        }
                    },
                    tooltip: {
                        shared: !1,
                        followCursor: !0,
                        custom: function(t307) {
                            return t307.w.config.plotOptions && t307.w.config.plotOptions.bar && t307.w.config.plotOptions.bar.horizontal ? function(t308) {
                                var e233 = new H(t308.ctx, null), i178 = e233.getTooltipValues(t308), a147 = i178.color, s113 = i178.seriesName, r94 = i178.ylabel, o79 = i178.startVal, n71 = i178.endVal;
                                return e233.buildCustomTooltipHTML({
                                    color: a147,
                                    seriesName: s113,
                                    ylabel: r94,
                                    start: o79,
                                    end: n71
                                });
                            }(t307) : function(t309) {
                                var e234 = new H(t309.ctx, null), i179 = e234.getTooltipValues(t309), a148 = i179.color, s114 = i179.seriesName, r95 = i179.ylabel, o80 = i179.start, n72 = i179.end;
                                return e234.buildCustomTooltipHTML({
                                    color: a148,
                                    seriesName: s114,
                                    ylabel: r95,
                                    start: o80,
                                    end: n72
                                });
                            }(t307);
                        }
                    },
                    xaxis: {
                        tickPlacement: "between",
                        tooltip: {
                            enabled: !1
                        },
                        crosshairs: {
                            stroke: {
                                width: 0
                            }
                        }
                    }
                };
            }
        },
        {
            key: "area",
            value: function() {
                return {
                    stroke: {
                        width: 4
                    },
                    fill: {
                        type: "gradient",
                        gradient: {
                            inverseColors: !1,
                            shade: "light",
                            type: "vertical",
                            opacityFrom: .65,
                            opacityTo: .5,
                            stops: [
                                0,
                                100,
                                100
                            ]
                        }
                    },
                    markers: {
                        size: 0,
                        hover: {
                            sizeOffset: 6
                        }
                    },
                    tooltip: {
                        followCursor: !1
                    }
                };
            }
        },
        {
            key: "brush",
            value: function(t310) {
                return x.extend(t310, {
                    chart: {
                        toolbar: {
                            autoSelected: "selection",
                            show: !1
                        },
                        zoom: {
                            enabled: !1
                        }
                    },
                    dataLabels: {
                        enabled: !1
                    },
                    stroke: {
                        width: 1
                    },
                    tooltip: {
                        enabled: !1
                    },
                    xaxis: {
                        tooltip: {
                            enabled: !1
                        }
                    }
                });
            }
        },
        {
            key: "stacked100",
            value: function(t311) {
                t311.dataLabels = t311.dataLabels || {}, t311.dataLabels.formatter = t311.dataLabels.formatter || void 0;
                var e235 = t311.dataLabels.formatter;
                return t311.yaxis.forEach(function(e, i180) {
                    t311.yaxis[i180].min = 0, t311.yaxis[i180].max = 100;
                }), "bar" === t311.chart.type && (t311.dataLabels.formatter = e235 || function(t312) {
                    return "number" == typeof t312 && t312 ? t312.toFixed(0) + "%" : t312;
                }), t311;
            }
        },
        {
            key: "convertCatToNumeric",
            value: function(t313) {
                return t313.xaxis.convertedCatToNumeric = !0, t313;
            }
        },
        {
            key: "convertCatToNumericXaxis",
            value: function(t314, e, i181) {
                t314.xaxis.type = "numeric", t314.xaxis.labels = t314.xaxis.labels || {}, t314.xaxis.labels.formatter = t314.xaxis.labels.formatter || function(t315) {
                    return x.isNumber(t315) ? Math.floor(t315) : t315;
                };
                var a149 = t314.xaxis.labels.formatter, s115 = t314.xaxis.categories && t314.xaxis.categories.length ? t314.xaxis.categories : t314.labels;
                return i181 && i181.length && (s115 = i181.map(function(t316) {
                    return Array.isArray(t316) ? t316 : String(t316);
                })), s115 && s115.length && (t314.xaxis.labels.formatter = function(t317) {
                    return x.isNumber(t317) ? a149(s115[Math.floor(t317) - 1]) : a149(t317);
                }), t314.xaxis.categories = [], t314.labels = [], t314.xaxis.tickAmount = t314.xaxis.tickAmount || "dataPoints", t314;
            }
        },
        {
            key: "bubble",
            value: function() {
                return {
                    dataLabels: {
                        style: {
                            colors: [
                                "#fff"
                            ]
                        }
                    },
                    tooltip: {
                        shared: !1,
                        intersect: !0
                    },
                    xaxis: {
                        crosshairs: {
                            width: 0
                        }
                    },
                    fill: {
                        type: "solid",
                        gradient: {
                            shade: "light",
                            inverse: !0,
                            shadeIntensity: .55,
                            opacityFrom: .4,
                            opacityTo: .8
                        }
                    }
                };
            }
        },
        {
            key: "scatter",
            value: function() {
                return {
                    dataLabels: {
                        enabled: !1
                    },
                    tooltip: {
                        shared: !1,
                        intersect: !0
                    },
                    markers: {
                        size: 6,
                        strokeWidth: 1,
                        hover: {
                            sizeOffset: 2
                        }
                    }
                };
            }
        },
        {
            key: "heatmap",
            value: function() {
                return {
                    chart: {
                        stacked: !1
                    },
                    fill: {
                        opacity: 1
                    },
                    dataLabels: {
                        style: {
                            colors: [
                                "#fff"
                            ]
                        }
                    },
                    stroke: {
                        colors: [
                            "#fff"
                        ]
                    },
                    tooltip: {
                        followCursor: !0,
                        marker: {
                            show: !1
                        },
                        x: {
                            show: !1
                        }
                    },
                    legend: {
                        position: "top",
                        markers: {
                            shape: "square",
                            size: 10,
                            offsetY: 2
                        }
                    },
                    grid: {
                        padding: {
                            right: 20
                        }
                    }
                };
            }
        },
        {
            key: "treemap",
            value: function() {
                return {
                    chart: {
                        zoom: {
                            enabled: !1
                        }
                    },
                    dataLabels: {
                        style: {
                            fontSize: 14,
                            fontWeight: 600,
                            colors: [
                                "#fff"
                            ]
                        }
                    },
                    stroke: {
                        show: !0,
                        width: 2,
                        colors: [
                            "#fff"
                        ]
                    },
                    legend: {
                        show: !1
                    },
                    fill: {
                        gradient: {
                            stops: [
                                0,
                                100
                            ]
                        }
                    },
                    tooltip: {
                        followCursor: !0,
                        x: {
                            show: !1
                        }
                    },
                    grid: {
                        padding: {
                            left: 0,
                            right: 0
                        }
                    },
                    xaxis: {
                        crosshairs: {
                            show: !1
                        },
                        tooltip: {
                            enabled: !1
                        }
                    }
                };
            }
        },
        {
            key: "pie",
            value: function() {
                return {
                    chart: {
                        toolbar: {
                            show: !1
                        }
                    },
                    plotOptions: {
                        pie: {
                            donut: {
                                labels: {
                                    show: !1
                                }
                            }
                        }
                    },
                    dataLabels: {
                        formatter: function(t318) {
                            return t318.toFixed(1) + "%";
                        },
                        style: {
                            colors: [
                                "#fff"
                            ]
                        },
                        background: {
                            enabled: !1
                        },
                        dropShadow: {
                            enabled: !0
                        }
                    },
                    stroke: {
                        colors: [
                            "#fff"
                        ]
                    },
                    fill: {
                        opacity: 1,
                        gradient: {
                            shade: "light",
                            stops: [
                                0,
                                100
                            ]
                        }
                    },
                    tooltip: {
                        theme: "dark",
                        fillSeriesColor: !0
                    },
                    legend: {
                        position: "right"
                    }
                };
            }
        },
        {
            key: "donut",
            value: function() {
                return {
                    chart: {
                        toolbar: {
                            show: !1
                        }
                    },
                    dataLabels: {
                        formatter: function(t319) {
                            return t319.toFixed(1) + "%";
                        },
                        style: {
                            colors: [
                                "#fff"
                            ]
                        },
                        background: {
                            enabled: !1
                        },
                        dropShadow: {
                            enabled: !0
                        }
                    },
                    stroke: {
                        colors: [
                            "#fff"
                        ]
                    },
                    fill: {
                        opacity: 1,
                        gradient: {
                            shade: "light",
                            shadeIntensity: .35,
                            stops: [
                                80,
                                100
                            ],
                            opacityFrom: 1,
                            opacityTo: 1
                        }
                    },
                    tooltip: {
                        theme: "dark",
                        fillSeriesColor: !0
                    },
                    legend: {
                        position: "right"
                    }
                };
            }
        },
        {
            key: "polarArea",
            value: function() {
                return this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6, {
                    chart: {
                        toolbar: {
                            show: !1
                        }
                    },
                    dataLabels: {
                        formatter: function(t320) {
                            return t320.toFixed(1) + "%";
                        },
                        enabled: !1
                    },
                    stroke: {
                        show: !0,
                        width: 2
                    },
                    fill: {
                        opacity: .7
                    },
                    tooltip: {
                        theme: "dark",
                        fillSeriesColor: !0
                    },
                    legend: {
                        position: "right"
                    }
                };
            }
        },
        {
            key: "radar",
            value: function() {
                return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, {
                    dataLabels: {
                        enabled: !1,
                        style: {
                            fontSize: "11px"
                        }
                    },
                    stroke: {
                        width: 2
                    },
                    markers: {
                        size: 3,
                        strokeWidth: 1,
                        strokeOpacity: 1
                    },
                    fill: {
                        opacity: .2
                    },
                    tooltip: {
                        shared: !1,
                        intersect: !0,
                        followCursor: !0
                    },
                    grid: {
                        show: !1
                    },
                    xaxis: {
                        labels: {
                            formatter: function(t321) {
                                return t321;
                            },
                            style: {
                                colors: [
                                    "#a8a8a8"
                                ],
                                fontSize: "11px"
                            }
                        },
                        tooltip: {
                            enabled: !1
                        },
                        crosshairs: {
                            show: !1
                        }
                    }
                };
            }
        },
        {
            key: "radialBar",
            value: function() {
                return {
                    chart: {
                        animations: {
                            dynamicAnimation: {
                                enabled: !0,
                                speed: 800
                            }
                        },
                        toolbar: {
                            show: !1
                        }
                    },
                    fill: {
                        gradient: {
                            shade: "dark",
                            shadeIntensity: .4,
                            inverseColors: !1,
                            type: "diagonal2",
                            opacityFrom: 1,
                            opacityTo: 1,
                            stops: [
                                70,
                                98,
                                100
                            ]
                        }
                    },
                    legend: {
                        show: !1,
                        position: "right"
                    },
                    tooltip: {
                        enabled: !1,
                        fillSeriesColor: !0
                    }
                };
            }
        },
        {
            key: "_getBoxTooltip",
            value: function(t322, e236, i182, a150, s116) {
                var r96 = t322.globals.seriesCandleO[e236][i182], o81 = t322.globals.seriesCandleH[e236][i182], n73 = t322.globals.seriesCandleM[e236][i182], l56 = t322.globals.seriesCandleL[e236][i182], h50 = t322.globals.seriesCandleC[e236][i182];
                return t322.config.series[e236].type && t322.config.series[e236].type !== s116 ? '<div class="apexcharts-custom-tooltip">\n          '.concat(t322.config.series[e236].name ? t322.config.series[e236].name : "series-" + (e236 + 1), ": <strong>").concat(t322.globals.series[e236][i182], "</strong>\n        </div>") : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t322.config.chart.type, '">') + "<div>".concat(a150[0], ': <span class="value">') + r96 + "</span></div>" + "<div>".concat(a150[1], ': <span class="value">') + o81 + "</span></div>" + (n73 ? "<div>".concat(a150[2], ': <span class="value">') + n73 + "</span></div>" : "") + "<div>".concat(a150[3], ': <span class="value">') + l56 + "</span></div>" + "<div>".concat(a150[4], ': <span class="value">') + h50 + "</span></div></div>";
            }
        }
    ]), t303;
}(), N = function() {
    function t323(e237) {
        a(this, t323), this.opts = e237;
    }
    return r(t323, [
        {
            key: "init",
            value: function(t324) {
                var e238 = t324.responsiveOverride, a151 = this.opts, s117 = new L, r97 = new D(a151);
                this.chartType = a151.chart.type, "histogram" === this.chartType && (a151.chart.type = "bar", a151 = x.extend({
                    plotOptions: {
                        bar: {
                            columnWidth: "99.99%"
                        }
                    }
                }, a151)), a151 = this.extendYAxis(a151), a151 = this.extendAnnotations(a151);
                var o82 = s117.init(), n74 = {};
                if (a151 && "object" === i(a151)) {
                    var l57 = {};
                    l57 = -1 !== [
                        "line",
                        "area",
                        "bar",
                        "candlestick",
                        "boxPlot",
                        "rangeBar",
                        "histogram",
                        "bubble",
                        "scatter",
                        "heatmap",
                        "treemap",
                        "pie",
                        "polarArea",
                        "donut",
                        "radar",
                        "radialBar"
                    ].indexOf(a151.chart.type) ? r97[a151.chart.type]() : r97.line(), a151.chart.brush && a151.chart.brush.enabled && (l57 = r97.brush(l57)), a151.chart.stacked && "100%" === a151.chart.stackType && (a151 = r97.stacked100(a151)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(a151), a151.xaxis = a151.xaxis || window.Apex.xaxis || {}, e238 || (a151.xaxis.convertedCatToNumeric = !1), ((a151 = this.checkForCatToNumericXAxis(this.chartType, l57, a151)).chart.sparkline && a151.chart.sparkline.enabled || window.Apex.chart && window.Apex.chart.sparkline && window.Apex.chart.sparkline.enabled) && (l57 = r97.sparkline(l57)), n74 = x.extend(o82, l57);
                }
                var h51 = x.extend(n74, window.Apex);
                return o82 = x.extend(h51, a151), o82 = this.handleUserInputErrors(o82);
            }
        },
        {
            key: "checkForCatToNumericXAxis",
            value: function(t325, e239, i183) {
                var a152 = new D(i183), s118 = ("bar" === t325 || "boxPlot" === t325) && i183.plotOptions && i183.plotOptions.bar && i183.plotOptions.bar.horizontal, r98 = "pie" === t325 || "polarArea" === t325 || "donut" === t325 || "radar" === t325 || "radialBar" === t325 || "heatmap" === t325, o83 = "datetime" !== i183.xaxis.type && "numeric" !== i183.xaxis.type, n75 = i183.xaxis.tickPlacement ? i183.xaxis.tickPlacement : e239.xaxis && e239.xaxis.tickPlacement;
                return s118 || r98 || !o83 || "between" === n75 || (i183 = a152.convertCatToNumeric(i183)), i183;
            }
        },
        {
            key: "extendYAxis",
            value: function(t326, e240) {
                var i184 = new L;
                (void 0 === t326.yaxis || !t326.yaxis || Array.isArray(t326.yaxis) && 0 === t326.yaxis.length) && (t326.yaxis = {}), t326.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t326.yaxis = x.extend(t326.yaxis, window.Apex.yaxis)), t326.yaxis.constructor !== Array ? t326.yaxis = [
                    x.extend(i184.yAxis, t326.yaxis)
                ] : t326.yaxis = x.extendArray(t326.yaxis, i184.yAxis);
                var a153 = !1;
                t326.yaxis.forEach(function(t327) {
                    t327.logarithmic && (a153 = !0);
                });
                var s119 = t326.series;
                return e240 && !s119 && (s119 = e240.config.series), a153 && s119.length !== t326.yaxis.length && s119.length && (t326.yaxis = s119.map(function(e241, a154) {
                    if (e241.name || (s119[a154].name = "series-".concat(a154 + 1)), t326.yaxis[a154]) return t326.yaxis[a154].seriesName = s119[a154].name, t326.yaxis[a154];
                    var r99 = x.extend(i184.yAxis, t326.yaxis[0]);
                    return r99.show = !1, r99;
                })), a153 && s119.length > 1 && s119.length !== t326.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes. Please make sure to equalize both."), t326;
            }
        },
        {
            key: "extendAnnotations",
            value: function(t328) {
                return void 0 === t328.annotations && (t328.annotations = {}, t328.annotations.yaxis = [], t328.annotations.xaxis = [], t328.annotations.points = []), t328 = this.extendYAxisAnnotations(t328), t328 = this.extendXAxisAnnotations(t328), t328 = this.extendPointAnnotations(t328);
            }
        },
        {
            key: "extendYAxisAnnotations",
            value: function(t329) {
                var e242 = new L;
                return t329.annotations.yaxis = x.extendArray(void 0 !== t329.annotations.yaxis ? t329.annotations.yaxis : [], e242.yAxisAnnotation), t329;
            }
        },
        {
            key: "extendXAxisAnnotations",
            value: function(t330) {
                var e243 = new L;
                return t330.annotations.xaxis = x.extendArray(void 0 !== t330.annotations.xaxis ? t330.annotations.xaxis : [], e243.xAxisAnnotation), t330;
            }
        },
        {
            key: "extendPointAnnotations",
            value: function(t331) {
                var e244 = new L;
                return t331.annotations.points = x.extendArray(void 0 !== t331.annotations.points ? t331.annotations.points : [], e244.pointAnnotation), t331;
            }
        },
        {
            key: "checkForDarkTheme",
            value: function(t332) {
                t332.theme && "dark" === t332.theme.mode && (t332.tooltip || (t332.tooltip = {}), "light" !== t332.tooltip.theme && (t332.tooltip.theme = "dark"), t332.chart.foreColor || (t332.chart.foreColor = "#f6f7f8"), t332.chart.background || (t332.chart.background = "#424242"), t332.theme.palette || (t332.theme.palette = "palette4"));
            }
        },
        {
            key: "handleUserInputErrors",
            value: function(t333) {
                var e245 = t333;
                if (e245.tooltip.shared && e245.tooltip.intersect) throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
                if ("bar" === e245.chart.type && e245.plotOptions.bar.horizontal) {
                    if (e245.yaxis.length > 1) throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
                    e245.yaxis[0].reversed && (e245.yaxis[0].opposite = !0), e245.xaxis.tooltip.enabled = !1, e245.yaxis[0].tooltip.enabled = !1, e245.chart.zoom.enabled = !1;
                }
                return "bar" !== e245.chart.type && "rangeBar" !== e245.chart.type || e245.tooltip.shared && "barWidth" === e245.xaxis.crosshairs.width && e245.series.length > 1 && (e245.xaxis.crosshairs.width = "tickWidth"), "candlestick" !== e245.chart.type && "boxPlot" !== e245.chart.type || e245.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(e245.chart.type, " chart is not supported.")), e245.yaxis[0].reversed = !1), e245;
            }
        }
    ]), t323;
}(), O = function() {
    function t334() {
        a(this, t334);
    }
    return r(t334, [
        {
            key: "initGlobalVars",
            value: function(t335) {
                t335.series = [], t335.seriesCandleO = [], t335.seriesCandleH = [], t335.seriesCandleM = [], t335.seriesCandleL = [], t335.seriesCandleC = [], t335.seriesRangeStart = [], t335.seriesRangeEnd = [], t335.seriesRangeBar = [], t335.seriesPercent = [], t335.seriesGoals = [], t335.seriesX = [], t335.seriesZ = [], t335.seriesNames = [], t335.seriesTotals = [], t335.seriesLog = [], t335.seriesColors = [], t335.stackedSeriesTotals = [], t335.seriesXvalues = [], t335.seriesYvalues = [], t335.labels = [], t335.hasGroups = !1, t335.groups = [], t335.categoryLabels = [], t335.timescaleLabels = [], t335.noLabelsProvided = !1, t335.resizeTimer = null, t335.selectionResizeTimer = null, t335.delayedElements = [], t335.pointsArray = [], t335.dataLabelsRects = [], t335.isXNumeric = !1, t335.xaxisLabelsCount = 0, t335.skipLastTimelinelabel = !1, t335.skipFirstTimelinelabel = !1, t335.isDataXYZ = !1, t335.isMultiLineX = !1, t335.isMultipleYAxis = !1, t335.maxY = -Number.MAX_VALUE, t335.minY = Number.MIN_VALUE, t335.minYArr = [], t335.maxYArr = [], t335.maxX = -Number.MAX_VALUE, t335.minX = Number.MAX_VALUE, t335.initialMaxX = -Number.MAX_VALUE, t335.initialMinX = Number.MAX_VALUE, t335.maxDate = 0, t335.minDate = Number.MAX_VALUE, t335.minZ = Number.MAX_VALUE, t335.maxZ = -Number.MAX_VALUE, t335.minXDiff = Number.MAX_VALUE, t335.yAxisScale = [], t335.xAxisScale = null, t335.xAxisTicksPositions = [], t335.yLabelsCoords = [], t335.yTitleCoords = [], t335.barPadForNumericAxis = 0, t335.padHorizontal = 0, t335.xRange = 0, t335.yRange = [], t335.zRange = 0, t335.dataPoints = 0, t335.xTickAmount = 0;
            }
        },
        {
            key: "globalVars",
            value: function(t336) {
                return {
                    chartID: null,
                    cuid: null,
                    events: {
                        beforeMount: [],
                        mounted: [],
                        updated: [],
                        clicked: [],
                        selection: [],
                        dataPointSelection: [],
                        zoomed: [],
                        scrolled: []
                    },
                    colors: [],
                    clientX: null,
                    clientY: null,
                    fill: {
                        colors: []
                    },
                    stroke: {
                        colors: []
                    },
                    dataLabels: {
                        style: {
                            colors: []
                        }
                    },
                    radarPolygons: {
                        fill: {
                            colors: []
                        }
                    },
                    markers: {
                        colors: [],
                        size: t336.markers.size,
                        largestSize: 0
                    },
                    animationEnded: !1,
                    isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints,
                    isDirty: !1,
                    isExecCalled: !1,
                    initialConfig: null,
                    initialSeries: [],
                    lastXAxis: [],
                    lastYAxis: [],
                    columnSeries: null,
                    labels: [],
                    timescaleLabels: [],
                    noLabelsProvided: !1,
                    allSeriesCollapsed: !1,
                    collapsedSeries: [],
                    collapsedSeriesIndices: [],
                    ancillaryCollapsedSeries: [],
                    ancillaryCollapsedSeriesIndices: [],
                    risingSeries: [],
                    dataFormatXNumeric: !1,
                    capturedSeriesIndex: -1,
                    capturedDataPointIndex: -1,
                    selectedDataPoints: [],
                    goldenPadding: 35,
                    invalidLogScale: !1,
                    ignoreYAxisIndexes: [],
                    yAxisSameScaleIndices: [],
                    maxValsInArrayIndex: 0,
                    radialSize: 0,
                    selection: void 0,
                    zoomEnabled: "zoom" === t336.chart.toolbar.autoSelected && t336.chart.toolbar.tools.zoom && t336.chart.zoom.enabled,
                    panEnabled: "pan" === t336.chart.toolbar.autoSelected && t336.chart.toolbar.tools.pan,
                    selectionEnabled: "selection" === t336.chart.toolbar.autoSelected && t336.chart.toolbar.tools.selection,
                    yaxis: null,
                    mousedown: !1,
                    lastClientPosition: {},
                    visibleXRange: void 0,
                    yValueDecimal: 0,
                    total: 0,
                    SVGNS: "http://www.w3.org/2000/svg",
                    svgWidth: 0,
                    svgHeight: 0,
                    noData: !1,
                    locale: {},
                    dom: {},
                    memory: {
                        methodsToExec: []
                    },
                    shouldAnimate: !0,
                    skipLastTimelinelabel: !1,
                    skipFirstTimelinelabel: !1,
                    delayedElements: [],
                    axisCharts: !0,
                    isDataXYZ: !1,
                    resized: !1,
                    resizeTimer: null,
                    comboCharts: !1,
                    dataChanged: !1,
                    previousPaths: [],
                    allSeriesHasEqualX: !0,
                    pointsArray: [],
                    dataLabelsRects: [],
                    lastDrawnDataLabelsIndexes: [],
                    hasNullValues: !1,
                    easing: null,
                    zoomed: !1,
                    gridWidth: 0,
                    gridHeight: 0,
                    rotateXLabels: !1,
                    defaultLabels: !1,
                    xLabelFormatter: void 0,
                    yLabelFormatters: [],
                    xaxisTooltipFormatter: void 0,
                    ttKeyFormatter: void 0,
                    ttVal: void 0,
                    ttZFormatter: void 0,
                    LINE_HEIGHT_RATIO: 1.618,
                    xAxisLabelsHeight: 0,
                    xAxisGroupLabelsHeight: 0,
                    xAxisLabelsWidth: 0,
                    yAxisLabelsWidth: 0,
                    scaleX: 1,
                    scaleY: 1,
                    translateX: 0,
                    translateY: 0,
                    translateYAxisX: [],
                    yAxisWidths: [],
                    translateXAxisY: 0,
                    translateXAxisX: 0,
                    tooltip: null
                };
            }
        },
        {
            key: "init",
            value: function(t337) {
                var e246 = this.globalVars(t337);
                return this.initGlobalVars(e246), e246.initialConfig = x.extend({}, t337), e246.initialSeries = x.clone(t337.series), e246.lastXAxis = x.clone(e246.initialConfig.xaxis), e246.lastYAxis = x.clone(e246.initialConfig.yaxis), e246;
            }
        }
    ]), t334;
}(), W = function() {
    function t338(e247) {
        a(this, t338), this.opts = e247;
    }
    return r(t338, [
        {
            key: "init",
            value: function() {
                var t339 = new N(this.opts).init({
                    responsiveOverride: !1
                });
                return {
                    config: t339,
                    globals: (new O).init(t339)
                };
            }
        }
    ]), t338;
}(), B = function() {
    function t340(e248) {
        a(this, t340), this.ctx = e248, this.w = e248.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new y(this.ctx);
    }
    return r(t340, [
        {
            key: "isMultiFormat",
            value: function() {
                return this.isFormatXY() || this.isFormat2DArray();
            }
        },
        {
            key: "isFormatXY",
            value: function() {
                var t341 = this.w.config.series.slice(), e249 = new E(this.ctx);
                if (this.activeSeriesIndex = e249.getActiveConfigSeriesIndex(), void 0 !== t341[this.activeSeriesIndex].data && t341[this.activeSeriesIndex].data.length > 0 && null !== t341[this.activeSeriesIndex].data[0] && void 0 !== t341[this.activeSeriesIndex].data[0].x && null !== t341[this.activeSeriesIndex].data[0]) return !0;
            }
        },
        {
            key: "isFormat2DArray",
            value: function() {
                var t342 = this.w.config.series.slice(), e250 = new E(this.ctx);
                if (this.activeSeriesIndex = e250.getActiveConfigSeriesIndex(), void 0 !== t342[this.activeSeriesIndex].data && t342[this.activeSeriesIndex].data.length > 0 && void 0 !== t342[this.activeSeriesIndex].data[0] && null !== t342[this.activeSeriesIndex].data[0] && t342[this.activeSeriesIndex].data[0].constructor === Array) return !0;
            }
        },
        {
            key: "handleFormat2DArray",
            value: function(t343, e251) {
                for(var i185 = this.w.config, a155 = this.w.globals, s120 = "boxPlot" === i185.chart.type || "boxPlot" === i185.series[e251].type, r100 = 0; r100 < t343[e251].data.length; r100++)if (void 0 !== t343[e251].data[r100][1] && (Array.isArray(t343[e251].data[r100][1]) && 4 === t343[e251].data[r100][1].length && !s120 ? this.twoDSeries.push(x.parseNumber(t343[e251].data[r100][1][3])) : t343[e251].data[r100].length >= 5 ? this.twoDSeries.push(x.parseNumber(t343[e251].data[r100][4])) : this.twoDSeries.push(x.parseNumber(t343[e251].data[r100][1])), a155.dataFormatXNumeric = !0), "datetime" === i185.xaxis.type) {
                    var o84 = new Date(t343[e251].data[r100][0]);
                    o84 = new Date(o84).getTime(), this.twoDSeriesX.push(o84);
                } else this.twoDSeriesX.push(t343[e251].data[r100][0]);
                for(var n76 = 0; n76 < t343[e251].data.length; n76++)void 0 !== t343[e251].data[n76][2] && (this.threeDSeries.push(t343[e251].data[n76][2]), a155.isDataXYZ = !0);
            }
        },
        {
            key: "handleFormatXY",
            value: function(t344, e252) {
                var i186 = this.w.config, a156 = this.w.globals, s121 = new R(this.ctx), r101 = e252;
                a156.collapsedSeriesIndices.indexOf(e252) > -1 && (r101 = this.activeSeriesIndex);
                for(var o85 = 0; o85 < t344[e252].data.length; o85++)void 0 !== t344[e252].data[o85].y && (Array.isArray(t344[e252].data[o85].y) ? this.twoDSeries.push(x.parseNumber(t344[e252].data[o85].y[t344[e252].data[o85].y.length - 1])) : this.twoDSeries.push(x.parseNumber(t344[e252].data[o85].y))), void 0 !== t344[e252].data[o85].goals && Array.isArray(t344[e252].data[o85].goals) ? (void 0 === this.seriesGoals[e252] && (this.seriesGoals[e252] = []), this.seriesGoals[e252].push(t344[e252].data[o85].goals)) : (void 0 === this.seriesGoals[e252] && (this.seriesGoals[e252] = []), this.seriesGoals[e252].push(null));
                for(var n77 = 0; n77 < t344[r101].data.length; n77++){
                    var l58 = "string" == typeof t344[r101].data[n77].x, h52 = Array.isArray(t344[r101].data[n77].x), c46 = !h52 && !!s121.isValidDate(t344[r101].data[n77].x.toString());
                    if (l58 || c46) {
                        if (l58 || i186.xaxis.convertedCatToNumeric) {
                            var d42 = a156.isBarHorizontal && a156.isRangeData;
                            "datetime" !== i186.xaxis.type || d42 ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t344[r101].data[n77].x)) : this.twoDSeriesX.push(s121.parseDate(t344[r101].data[n77].x));
                        } else "datetime" === i186.xaxis.type ? this.twoDSeriesX.push(s121.parseDate(t344[r101].data[n77].x.toString())) : (a156.dataFormatXNumeric = !0, a156.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(t344[r101].data[n77].x)));
                    } else h52 ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t344[r101].data[n77].x)) : (a156.isXNumeric = !0, a156.dataFormatXNumeric = !0, this.twoDSeriesX.push(t344[r101].data[n77].x));
                }
                if (t344[e252].data[0] && void 0 !== t344[e252].data[0].z) {
                    for(var g36 = 0; g36 < t344[e252].data.length; g36++)this.threeDSeries.push(t344[e252].data[g36].z);
                    a156.isDataXYZ = !0;
                }
            }
        },
        {
            key: "handleRangeData",
            value: function(t345, e253) {
                var i187 = this.w.globals, a157 = {};
                return this.isFormat2DArray() ? a157 = this.handleRangeDataFormat("array", t345, e253) : this.isFormatXY() && (a157 = this.handleRangeDataFormat("xy", t345, e253)), i187.seriesRangeStart.push(a157.start), i187.seriesRangeEnd.push(a157.end), i187.seriesRangeBar.push(a157.rangeUniques), i187.seriesRangeBar.forEach(function(t346, e254) {
                    t346 && t346.forEach(function(t347, e255) {
                        t347.y.forEach(function(e256, i188) {
                            for(var a158 = 0; a158 < t347.y.length; a158++)if (i188 !== a158) {
                                var s122 = e256.y1, r102 = e256.y2, o86 = t347.y[a158].y1;
                                s122 <= t347.y[a158].y2 && o86 <= r102 && (t347.overlaps.indexOf(e256.rangeName) < 0 && t347.overlaps.push(e256.rangeName), t347.overlaps.indexOf(t347.y[a158].rangeName) < 0 && t347.overlaps.push(t347.y[a158].rangeName));
                            }
                        });
                    });
                }), a157;
            }
        },
        {
            key: "handleCandleStickBoxData",
            value: function(t348, e257) {
                var i189 = this.w.globals, a159 = {};
                return this.isFormat2DArray() ? a159 = this.handleCandleStickBoxDataFormat("array", t348, e257) : this.isFormatXY() && (a159 = this.handleCandleStickBoxDataFormat("xy", t348, e257)), i189.seriesCandleO[e257] = a159.o, i189.seriesCandleH[e257] = a159.h, i189.seriesCandleM[e257] = a159.m, i189.seriesCandleL[e257] = a159.l, i189.seriesCandleC[e257] = a159.c, a159;
            }
        },
        {
            key: "handleRangeDataFormat",
            value: function(t349, e258, i190) {
                var a160 = [], s123 = [], r103 = e258[i190].data.filter(function(t350, e259, i191) {
                    return e259 === i191.findIndex(function(e260) {
                        return e260.x === t350.x;
                    });
                }).map(function(t351, e) {
                    return {
                        x: t351.x,
                        overlaps: [],
                        y: []
                    };
                }), o87 = "Please provide [Start, End] values in valid format. Read more https://apexcharts.com/docs/series/#rangecharts", n78 = new E(this.ctx).getActiveConfigSeriesIndex();
                if ("array" === t349) {
                    if (2 !== e258[n78].data[0][1].length) throw new Error(o87);
                    for(var l59 = 0; l59 < e258[i190].data.length; l59++)a160.push(e258[i190].data[l59][1][0]), s123.push(e258[i190].data[l59][1][1]);
                } else if ("xy" === t349) {
                    if (2 !== e258[n78].data[0].y.length) throw new Error(o87);
                    for(var h53 = function(t352) {
                        var o88 = x.randomId(), n79 = e258[i190].data[t352].x, l60 = {
                            y1: e258[i190].data[t352].y[0],
                            y2: e258[i190].data[t352].y[1],
                            rangeName: o88
                        };
                        e258[i190].data[t352].rangeName = o88;
                        var h55 = r103.findIndex(function(t353) {
                            return t353.x === n79;
                        });
                        r103[h55].y.push(l60), a160.push(l60.y1), s123.push(l60.y2);
                    }, c47 = 0; c47 < e258[i190].data.length; c47++)h53(c47);
                }
                return {
                    start: a160,
                    end: s123,
                    rangeUniques: r103
                };
            }
        },
        {
            key: "handleCandleStickBoxDataFormat",
            value: function(t354, e261, i192) {
                var a161 = this.w, s124 = "boxPlot" === a161.config.chart.type || "boxPlot" === a161.config.series[i192].type, r104 = [], o89 = [], n80 = [], l61 = [], h56 = [];
                if ("array" === t354) {
                    if (s124 && 6 === e261[i192].data[0].length || !s124 && 5 === e261[i192].data[0].length) for(var c48 = 0; c48 < e261[i192].data.length; c48++)r104.push(e261[i192].data[c48][1]), o89.push(e261[i192].data[c48][2]), s124 ? (n80.push(e261[i192].data[c48][3]), l61.push(e261[i192].data[c48][4]), h56.push(e261[i192].data[c48][5])) : (l61.push(e261[i192].data[c48][3]), h56.push(e261[i192].data[c48][4]));
                    else for(var d43 = 0; d43 < e261[i192].data.length; d43++)Array.isArray(e261[i192].data[d43][1]) && (r104.push(e261[i192].data[d43][1][0]), o89.push(e261[i192].data[d43][1][1]), s124 ? (n80.push(e261[i192].data[d43][1][2]), l61.push(e261[i192].data[d43][1][3]), h56.push(e261[i192].data[d43][1][4])) : (l61.push(e261[i192].data[d43][1][2]), h56.push(e261[i192].data[d43][1][3])));
                } else if ("xy" === t354) for(var g37 = 0; g37 < e261[i192].data.length; g37++)Array.isArray(e261[i192].data[g37].y) && (r104.push(e261[i192].data[g37].y[0]), o89.push(e261[i192].data[g37].y[1]), s124 ? (n80.push(e261[i192].data[g37].y[2]), l61.push(e261[i192].data[g37].y[3]), h56.push(e261[i192].data[g37].y[4])) : (l61.push(e261[i192].data[g37].y[2]), h56.push(e261[i192].data[g37].y[3])));
                return {
                    o: r104,
                    h: o89,
                    m: n80,
                    l: l61,
                    c: h56
                };
            }
        },
        {
            key: "parseDataAxisCharts",
            value: function(t355) {
                var e262 = this, i193 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx, a162 = this.w.config, s125 = this.w.globals, r105 = new R(i193), o90 = a162.labels.length > 0 ? a162.labels.slice() : a162.xaxis.categories.slice();
                s125.isRangeBar = "rangeBar" === a162.chart.type && s125.isBarHorizontal, s125.hasGroups = "category" === a162.xaxis.type && void 0 !== a162.xaxis.group && void 0 !== a162.xaxis.group.groups && a162.xaxis.group.groups.length > 0, s125.hasGroups && (s125.groups = a162.xaxis.group.groups);
                for(var n81 = function() {
                    for(var t356 = 0; t356 < o90.length; t356++)if ("string" == typeof o90[t356]) {
                        if (!r105.isValidDate(o90[t356])) throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
                        e262.twoDSeriesX.push(r105.parseDate(o90[t356]));
                    } else e262.twoDSeriesX.push(o90[t356]);
                }, l62 = 0; l62 < t355.length; l62++){
                    if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t355[l62].data) return void console.error("It is a possibility that you may have not included 'data' property in series.");
                    if ("rangeBar" !== a162.chart.type && "rangeArea" !== a162.chart.type && "rangeBar" !== t355[l62].type && "rangeArea" !== t355[l62].type || (s125.isRangeData = !0, this.handleRangeData(t355, l62)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(t355, l62) : this.isFormatXY() && this.handleFormatXY(t355, l62), "candlestick" !== a162.chart.type && "candlestick" !== t355[l62].type && "boxPlot" !== a162.chart.type && "boxPlot" !== t355[l62].type || this.handleCandleStickBoxData(t355, l62), s125.series.push(this.twoDSeries), s125.labels.push(this.twoDSeriesX), s125.seriesX.push(this.twoDSeriesX), s125.seriesGoals = this.seriesGoals, l62 !== this.activeSeriesIndex || this.fallbackToCategory || (s125.isXNumeric = !0);
                    else {
                        "datetime" === a162.xaxis.type ? (s125.isXNumeric = !0, n81(), s125.seriesX.push(this.twoDSeriesX)) : "numeric" === a162.xaxis.type && (s125.isXNumeric = !0, o90.length > 0 && (this.twoDSeriesX = o90, s125.seriesX.push(this.twoDSeriesX))), s125.labels.push(this.twoDSeriesX);
                        var h57 = t355[l62].data.map(function(t357) {
                            return x.parseNumber(t357);
                        });
                        s125.series.push(h57);
                    }
                    s125.seriesZ.push(this.threeDSeries), void 0 !== t355[l62].name ? s125.seriesNames.push(t355[l62].name) : s125.seriesNames.push("series-" + parseInt(l62 + 1, 10)), void 0 !== t355[l62].color ? s125.seriesColors.push(t355[l62].color) : s125.seriesColors.push(void 0);
                }
                return this.w;
            }
        },
        {
            key: "parseDataNonAxisCharts",
            value: function(t358) {
                var e263 = this.w.globals, i194 = this.w.config;
                e263.series = t358.slice(), e263.seriesNames = i194.labels.slice();
                for(var a163 = 0; a163 < e263.series.length; a163++)void 0 === e263.seriesNames[a163] && e263.seriesNames.push("series-" + (a163 + 1));
                return this.w;
            }
        },
        {
            key: "handleExternalLabelsData",
            value: function(t359) {
                var e264 = this.w.config, i195 = this.w.globals;
                if (e264.xaxis.categories.length > 0) i195.labels = e264.xaxis.categories;
                else if (e264.labels.length > 0) i195.labels = e264.labels.slice();
                else if (this.fallbackToCategory) {
                    if (i195.labels = i195.labels[0], i195.seriesRangeBar.length && (i195.seriesRangeBar.map(function(t360) {
                        t360.forEach(function(t361) {
                            i195.labels.indexOf(t361.x) < 0 && t361.x && i195.labels.push(t361.x);
                        });
                    }), i195.labels = i195.labels.filter(function(t362, e265, i196) {
                        return i196.indexOf(t362) === e265;
                    })), e264.xaxis.convertedCatToNumeric) new D(e264).convertCatToNumericXaxis(e264, this.ctx, i195.seriesX[0]), this._generateExternalLabels(t359);
                } else this._generateExternalLabels(t359);
            }
        },
        {
            key: "_generateExternalLabels",
            value: function(t363) {
                var e266 = this.w.globals, i197 = this.w.config, a164 = [];
                if (e266.axisCharts) {
                    if (e266.series.length > 0) {
                        if (this.isFormatXY()) for(var s126 = i197.series.map(function(t364, e267) {
                            return t364.data.filter(function(t365, e268, i198) {
                                return i198.findIndex(function(e269) {
                                    return e269.x === t365.x;
                                }) === e268;
                            });
                        }), r106 = s126.reduce(function(t366, e270, i199, a165) {
                            return a165[t366].length > e270.length ? t366 : i199;
                        }, 0), o91 = 0; o91 < s126[r106].length; o91++)a164.push(o91 + 1);
                        else for(var n82 = 0; n82 < e266.series[e266.maxValsInArrayIndex].length; n82++)a164.push(n82 + 1);
                    }
                    e266.seriesX = [];
                    for(var l63 = 0; l63 < t363.length; l63++)e266.seriesX.push(a164);
                    e266.isXNumeric = !0;
                }
                if (0 === a164.length) {
                    a164 = e266.axisCharts ? [] : e266.series.map(function(t, e271) {
                        return e271 + 1;
                    });
                    for(var h58 = 0; h58 < t363.length; h58++)e266.seriesX.push(a164);
                }
                e266.labels = a164, i197.xaxis.convertedCatToNumeric && (e266.categoryLabels = a164.map(function(t367) {
                    return i197.xaxis.labels.formatter(t367);
                })), e266.noLabelsProvided = !0;
            }
        },
        {
            key: "parseData",
            value: function(t368) {
                var e272 = this.w, i200 = e272.config, a166 = e272.globals;
                if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a166.axisCharts ? this.parseDataAxisCharts(t368) : this.parseDataNonAxisCharts(t368), this.coreUtils.getLargestSeries(), "bar" === i200.chart.type && i200.chart.stacked) {
                    var s127 = new E(this.ctx);
                    a166.series = s127.setNullSeriesToZeroValues(a166.series);
                }
                this.coreUtils.getSeriesTotals(), a166.axisCharts && this.coreUtils.getStackedSeriesTotals(), this.coreUtils.getPercentSeries(), a166.dataFormatXNumeric || a166.isXNumeric && ("numeric" !== i200.xaxis.type || 0 !== i200.labels.length || 0 !== i200.xaxis.categories.length) || this.handleExternalLabelsData(t368);
                for(var r107 = this.coreUtils.getCategoryLabels(a166.labels), o92 = 0; o92 < r107.length; o92++)if (Array.isArray(r107[o92])) {
                    a166.isMultiLineX = !0;
                    break;
                }
            }
        },
        {
            key: "excludeCollapsedSeriesInYAxis",
            value: function() {
                var t369 = this, e273 = this.w;
                e273.globals.ignoreYAxisIndexes = e273.globals.collapsedSeries.map(function(i201, a) {
                    if (t369.w.globals.isMultipleYAxis && !e273.config.chart.stacked) return i201.index;
                });
            }
        }
    ]), t340;
}(), V = function() {
    function t370(e274) {
        a(this, t370), this.ctx = e274, this.w = e274.w, this.tooltipKeyFormat = "dd MMM";
    }
    return r(t370, [
        {
            key: "xLabelFormat",
            value: function(t371, e275, i202, a167) {
                var s128 = this.w;
                if ("datetime" === s128.config.xaxis.type && void 0 === s128.config.xaxis.labels.formatter && void 0 === s128.config.tooltip.x.formatter) {
                    var r108 = new R(this.ctx);
                    return r108.formatDate(r108.getDate(e275), s128.config.tooltip.x.format);
                }
                return t371(e275, i202, a167);
            }
        },
        {
            key: "defaultGeneralFormatter",
            value: function(t372) {
                return Array.isArray(t372) ? t372.map(function(t373) {
                    return t373;
                }) : t372;
            }
        },
        {
            key: "defaultYFormatter",
            value: function(t374, e276, i203) {
                var a168 = this.w;
                return x.isNumber(t374) && (t374 = 0 !== a168.globals.yValueDecimal ? t374.toFixed(void 0 !== e276.decimalsInFloat ? e276.decimalsInFloat : a168.globals.yValueDecimal) : a168.globals.maxYArr[i203] - a168.globals.minYArr[i203] < 5 ? t374.toFixed(1) : t374.toFixed(0)), t374;
            }
        },
        {
            key: "setLabelFormatters",
            value: function() {
                var t375 = this, e277 = this.w;
                return e277.globals.xaxisTooltipFormatter = function(e278) {
                    return t375.defaultGeneralFormatter(e278);
                }, e277.globals.ttKeyFormatter = function(e279) {
                    return t375.defaultGeneralFormatter(e279);
                }, e277.globals.ttZFormatter = function(t376) {
                    return t376;
                }, e277.globals.legendFormatter = function(e280) {
                    return t375.defaultGeneralFormatter(e280);
                }, void 0 !== e277.config.xaxis.labels.formatter ? e277.globals.xLabelFormatter = e277.config.xaxis.labels.formatter : e277.globals.xLabelFormatter = function(t377) {
                    if (x.isNumber(t377)) {
                        if (!e277.config.xaxis.convertedCatToNumeric && "numeric" === e277.config.xaxis.type) {
                            if (x.isNumber(e277.config.xaxis.decimalsInFloat)) return t377.toFixed(e277.config.xaxis.decimalsInFloat);
                            var i204 = e277.globals.maxX - e277.globals.minX;
                            return i204 > 0 && i204 < 100 ? t377.toFixed(1) : t377.toFixed(0);
                        }
                        if (e277.globals.isBarHorizontal) {
                            if (e277.globals.maxY - e277.globals.minYArr < 4) return t377.toFixed(1);
                        }
                        return t377.toFixed(0);
                    }
                    return t377;
                }, "function" == typeof e277.config.tooltip.x.formatter ? e277.globals.ttKeyFormatter = e277.config.tooltip.x.formatter : e277.globals.ttKeyFormatter = e277.globals.xLabelFormatter, "function" == typeof e277.config.xaxis.tooltip.formatter && (e277.globals.xaxisTooltipFormatter = e277.config.xaxis.tooltip.formatter), (Array.isArray(e277.config.tooltip.y) || void 0 !== e277.config.tooltip.y.formatter) && (e277.globals.ttVal = e277.config.tooltip.y), void 0 !== e277.config.tooltip.z.formatter && (e277.globals.ttZFormatter = e277.config.tooltip.z.formatter), void 0 !== e277.config.legend.formatter && (e277.globals.legendFormatter = e277.config.legend.formatter), e277.config.yaxis.forEach(function(i205, a169) {
                    void 0 !== i205.labels.formatter ? e277.globals.yLabelFormatters[a169] = i205.labels.formatter : e277.globals.yLabelFormatters[a169] = function(s129) {
                        return e277.globals.xyCharts ? Array.isArray(s129) ? s129.map(function(e281) {
                            return t375.defaultYFormatter(e281, i205, a169);
                        }) : t375.defaultYFormatter(s129, i205, a169) : s129;
                    };
                }), e277.globals;
            }
        },
        {
            key: "heatmapLabelFormatters",
            value: function() {
                var t378 = this.w;
                if ("heatmap" === t378.config.chart.type) {
                    t378.globals.yAxisScale[0].result = t378.globals.seriesNames.slice();
                    var e282 = t378.globals.seriesNames.reduce(function(t379, e284) {
                        return t379.length > e284.length ? t379 : e284;
                    }, 0);
                    t378.globals.yAxisScale[0].niceMax = e282, t378.globals.yAxisScale[0].niceMin = e282;
                }
            }
        }
    ]), t370;
}(), G = function() {
    function t380(e285) {
        a(this, t380), this.ctx = e285, this.w = e285.w;
    }
    return r(t380, [
        {
            key: "getLabel",
            value: function(t381, e286, i206, a170) {
                var s130 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [], r109 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px", o93 = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6], n83 = this.w, l64 = void 0 === t381[a170] ? "" : t381[a170], h59 = l64, c49 = n83.globals.xLabelFormatter, d44 = n83.config.xaxis.labels.formatter, g38 = !1, u32 = new V(this.ctx), p28 = l64;
                o93 && (h59 = u32.xLabelFormat(c49, l64, p28, {
                    i: a170,
                    dateFormatter: new R(this.ctx).formatDate,
                    w: n83
                }), void 0 !== d44 && (h59 = d44(l64, t381[a170], {
                    i: a170,
                    dateFormatter: new R(this.ctx).formatDate,
                    w: n83
                })));
                var f25 = function(t382) {
                    var i207 = null;
                    return e286.forEach(function(t383) {
                        "month" === t383.unit ? i207 = "year" : "day" === t383.unit ? i207 = "month" : "hour" === t383.unit ? i207 = "day" : "minute" === t383.unit && (i207 = "hour");
                    }), i207 === t382;
                };
                e286.length > 0 ? (g38 = f25(e286[a170].unit), i206 = e286[a170].position, h59 = e286[a170].value) : "datetime" === n83.config.xaxis.type && void 0 === d44 && (h59 = ""), void 0 === h59 && (h59 = ""), h59 = Array.isArray(h59) ? h59 : h59.toString();
                var x19 = new m(this.ctx), b19 = {};
                b19 = n83.globals.rotateXLabels && o93 ? x19.getTextRects(h59, parseInt(r109, 10), null, "rotate(".concat(n83.config.xaxis.labels.rotate, " 0 0)"), !1) : x19.getTextRects(h59, parseInt(r109, 10));
                var v12 = !n83.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
                return !Array.isArray(h59) && (0 === h59.indexOf("NaN") || 0 === h59.toLowerCase().indexOf("invalid") || h59.toLowerCase().indexOf("infinity") >= 0 || s130.indexOf(h59) >= 0 && v12) && (h59 = ""), {
                    x: i206,
                    text: h59,
                    textRect: b19,
                    isBold: g38
                };
            }
        },
        {
            key: "checkLabelBasedOnTickamount",
            value: function(t384, e287, i208) {
                var a171 = this.w, s131 = a171.config.xaxis.tickAmount;
                return "dataPoints" === s131 && (s131 = Math.round(a171.globals.gridWidth / 120)), s131 > i208 || t384 % Math.round(i208 / (s131 + 1)) == 0 || (e287.text = ""), e287;
            }
        },
        {
            key: "checkForOverflowingLabels",
            value: function(t385, e288, i209, a172, s132) {
                var r110 = this.w;
                if (0 === t385 && r110.globals.skipFirstTimelinelabel && (e288.text = ""), t385 === i209 - 1 && r110.globals.skipLastTimelinelabel && (e288.text = ""), r110.config.xaxis.labels.hideOverlappingLabels && a172.length > 0) {
                    var o94 = s132[s132.length - 1];
                    e288.x < o94.textRect.width / (r110.globals.rotateXLabels ? Math.abs(r110.config.xaxis.labels.rotate) / 12 : 1.01) + o94.x && (e288.text = "");
                }
                return e288;
            }
        },
        {
            key: "checkForReversedLabels",
            value: function(t386, e289) {
                var i210 = this.w;
                return i210.config.yaxis[t386] && i210.config.yaxis[t386].reversed && e289.reverse(), e289;
            }
        },
        {
            key: "isYAxisHidden",
            value: function(t387) {
                var e290 = this.w, i211 = new y(this.ctx);
                return !e290.config.yaxis[t387].show || !e290.config.yaxis[t387].showForNullSeries && i211.isSeriesNull(t387) && -1 === e290.globals.collapsedSeriesIndices.indexOf(t387);
            }
        },
        {
            key: "getYAxisForeColor",
            value: function(t388, e291) {
                var i212 = this.w;
                return Array.isArray(t388) && i212.globals.yAxisScale[e291] && this.ctx.theme.pushExtraColors(t388, i212.globals.yAxisScale[e291].result.length, !1), t388;
            }
        },
        {
            key: "drawYAxisTicks",
            value: function(t389, e292, i213, a173, s133, r111, o95) {
                var n84 = this.w, l65 = new m(this.ctx), h60 = n84.globals.translateY;
                if (a173.show && e292 > 0) {
                    !0 === n84.config.yaxis[s133].opposite && (t389 += a173.width);
                    for(var c50 = e292; c50 >= 0; c50--){
                        var d45 = h60 + e292 / 10 + n84.config.yaxis[s133].labels.offsetY - 1;
                        n84.globals.isBarHorizontal && (d45 = r111 * c50), "heatmap" === n84.config.chart.type && (d45 += r111 / 2);
                        var g39 = l65.drawLine(t389 + i213.offsetX - a173.width + a173.offsetX, d45 + a173.offsetY, t389 + i213.offsetX + a173.offsetX, d45 + a173.offsetY, a173.color);
                        o95.add(g39), h60 += r111;
                    }
                }
            }
        }
    ]), t380;
}(), j = function() {
    function t390(e293) {
        a(this, t390), this.ctx = e293, this.w = e293.w;
    }
    return r(t390, [
        {
            key: "scaleSvgNode",
            value: function(t391, e294) {
                var i214 = parseFloat(t391.getAttributeNS(null, "width")), a174 = parseFloat(t391.getAttributeNS(null, "height"));
                t391.setAttributeNS(null, "width", i214 * e294), t391.setAttributeNS(null, "height", a174 * e294), t391.setAttributeNS(null, "viewBox", "0 0 " + i214 + " " + a174);
            }
        },
        {
            key: "fixSvgStringForIe11",
            value: function(t392) {
                if (!x.isIE11()) return t392.replace(/&nbsp;/g, "&#160;");
                var e295 = 0, i215 = t392.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, function(t393) {
                    return 2 === ++e295 ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"' : t393;
                });
                return i215 = (i215 = i215.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1");
            }
        },
        {
            key: "getSvgString",
            value: function(t394) {
                var e296 = this.w.globals.dom.Paper.svg();
                if (1 !== t394) {
                    var i216 = this.w.globals.dom.Paper.node.cloneNode(!0);
                    this.scaleSvgNode(i216, t394), e296 = (new XMLSerializer).serializeToString(i216);
                }
                return this.fixSvgStringForIe11(e296);
            }
        },
        {
            key: "cleanup",
            value: function() {
                var t395 = this.w, e297 = t395.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"), i217 = t395.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"), a175 = t395.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
                Array.prototype.forEach.call(a175, function(t396) {
                    t396.setAttribute("width", 0);
                }), e297 && e297[0] && (e297[0].setAttribute("x", -500), e297[0].setAttribute("x1", -500), e297[0].setAttribute("x2", -500)), i217 && i217[0] && (i217[0].setAttribute("y", -100), i217[0].setAttribute("y1", -100), i217[0].setAttribute("y2", -100));
            }
        },
        {
            key: "svgUrl",
            value: function() {
                this.cleanup();
                var t397 = this.getSvgString(), e298 = new Blob([
                    t397
                ], {
                    type: "image/svg+xml;charset=utf-8"
                });
                return URL.createObjectURL(e298);
            }
        },
        {
            key: "dataURI",
            value: function(t398) {
                var e299 = this;
                return new Promise(function(i218) {
                    var a176 = e299.w, s134 = t398 ? t398.scale || t398.width / a176.globals.svgWidth : 1;
                    e299.cleanup();
                    var r112 = document.createElement("canvas");
                    r112.width = a176.globals.svgWidth * s134, r112.height = parseInt(a176.globals.dom.elWrap.style.height, 10) * s134;
                    var o96 = "transparent" === a176.config.chart.background ? "#fff" : a176.config.chart.background, n85 = r112.getContext("2d");
                    n85.fillStyle = o96, n85.fillRect(0, 0, r112.width * s134, r112.height * s134);
                    var l66 = e299.getSvgString(s134);
                    if (window.canvg && x.isIE11()) {
                        var h61 = window.canvg.Canvg.fromString(n85, l66, {
                            ignoreClear: !0,
                            ignoreDimensions: !0
                        });
                        h61.start();
                        var c51 = r112.msToBlob();
                        h61.stop(), i218({
                            blob: c51
                        });
                    } else {
                        var d46 = "data:image/svg+xml," + encodeURIComponent(l66), g40 = new Image;
                        g40.crossOrigin = "anonymous", g40.onload = function() {
                            if (n85.drawImage(g40, 0, 0), r112.msToBlob) {
                                var t399 = r112.msToBlob();
                                i218({
                                    blob: t399
                                });
                            } else {
                                var e300 = r112.toDataURL("image/png");
                                i218({
                                    imgURI: e300
                                });
                            }
                        }, g40.src = d46;
                    }
                });
            }
        },
        {
            key: "exportToSVG",
            value: function() {
                this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, ".svg");
            }
        },
        {
            key: "exportToPng",
            value: function() {
                var t400 = this;
                this.dataURI().then(function(e301) {
                    var i219 = e301.imgURI, a177 = e301.blob;
                    a177 ? navigator.msSaveOrOpenBlob(a177, t400.w.globals.chartID + ".png") : t400.triggerDownload(i219, t400.w.config.chart.toolbar.export.png.filename, ".png");
                });
            }
        },
        {
            key: "exportToCSV",
            value: function(t401) {
                var e302 = this, i220 = t401.series, a178 = t401.columnDelimiter, s135 = t401.lineDelimiter, r113 = void 0 === s135 ? "\n" : s135, o97 = this.w, n86 = [], l67 = [], h62 = "", c52 = new B(this.ctx), d47 = new G(this.ctx), g41 = function(t402) {
                    var i221 = "";
                    if (o97.globals.axisCharts) {
                        if ("category" === o97.config.xaxis.type || o97.config.xaxis.convertedCatToNumeric) {
                            if (o97.globals.isBarHorizontal) {
                                var s136 = o97.globals.yLabelFormatters[0], r114 = new E(e302.ctx).getActiveConfigSeriesIndex();
                                i221 = s136(o97.globals.labels[t402], {
                                    seriesIndex: r114,
                                    dataPointIndex: t402,
                                    w: o97
                                });
                            } else i221 = d47.getLabel(o97.globals.labels, o97.globals.timescaleLabels, 0, t402).text;
                        }
                        "datetime" === o97.config.xaxis.type && (o97.config.xaxis.categories.length ? i221 = o97.config.xaxis.categories[t402] : o97.config.labels.length && (i221 = o97.config.labels[t402]));
                    } else i221 = o97.config.labels[t402];
                    return Array.isArray(i221) && (i221 = i221.join(" ")), x.isNumber(i221) ? i221 : i221.split(a178).join("");
                };
                n86.push(o97.config.chart.toolbar.export.csv.headerCategory), i220.map(function(t403, e303) {
                    var i222 = t403.name ? t403.name : "series-".concat(e303);
                    o97.globals.axisCharts && n86.push(i222.split(a178).join("") ? i222.split(a178).join("") : "series-".concat(e303));
                }), o97.globals.axisCharts || (n86.push(o97.config.chart.toolbar.export.csv.headerValue), l67.push(n86.join(a178))), i220.map(function(t404, e304) {
                    o97.globals.axisCharts ? function(t405, e305) {
                        if (n86.length && 0 === e305 && l67.push(n86.join(a178)), t405.data && t405.data.length) for(var s137 = 0; s137 < t405.data.length; s137++){
                            n86 = [];
                            var r115 = g41(s137);
                            if (r115 || (c52.isFormatXY() ? r115 = i220[e305].data[s137].x : c52.isFormat2DArray() && (r115 = i220[e305].data[s137] ? i220[e305].data[s137][0] : "")), 0 === e305) {
                                n86.push((d48 = r115, "datetime" === o97.config.xaxis.type && String(d48).length >= 10 ? o97.config.chart.toolbar.export.csv.dateFormatter(r115) : x.isNumber(r115) ? r115 : r115.split(a178).join("")));
                                for(var h63 = 0; h63 < o97.globals.series.length; h63++)n86.push(o97.globals.series[h63][s137]);
                            }
                            ("candlestick" === o97.config.chart.type || t405.type && "candlestick" === t405.type) && (n86.pop(), n86.push(o97.globals.seriesCandleO[e305][s137]), n86.push(o97.globals.seriesCandleH[e305][s137]), n86.push(o97.globals.seriesCandleL[e305][s137]), n86.push(o97.globals.seriesCandleC[e305][s137])), ("boxPlot" === o97.config.chart.type || t405.type && "boxPlot" === t405.type) && (n86.pop(), n86.push(o97.globals.seriesCandleO[e305][s137]), n86.push(o97.globals.seriesCandleH[e305][s137]), n86.push(o97.globals.seriesCandleM[e305][s137]), n86.push(o97.globals.seriesCandleL[e305][s137]), n86.push(o97.globals.seriesCandleC[e305][s137])), "rangeBar" === o97.config.chart.type && (n86.pop(), n86.push(o97.globals.seriesRangeStart[e305][s137]), n86.push(o97.globals.seriesRangeEnd[e305][s137])), n86.length && l67.push(n86.join(a178));
                        }
                        var d48;
                    }(t404, e304) : ((n86 = []).push(o97.globals.labels[e304].split(a178).join("")), n86.push(o97.globals.series[e304]), l67.push(n86.join(a178)));
                }), h62 += l67.join(r113), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\ufeff" + h62), o97.config.chart.toolbar.export.csv.filename, ".csv");
            }
        },
        {
            key: "triggerDownload",
            value: function(t406, e306, i223) {
                var a179 = document.createElement("a");
                a179.href = t406, a179.download = (e306 || this.w.globals.chartID) + i223, document.body.appendChild(a179), a179.click(), document.body.removeChild(a179);
            }
        }
    ]), t390;
}(), _ = function() {
    function t407(e307) {
        a(this, t407), this.ctx = e307, this.w = e307.w;
        var i224 = this.w;
        this.axesUtils = new G(e307), this.xaxisLabels = i224.globals.labels.slice(), i224.globals.timescaleLabels.length > 0 && !i224.globals.isBarHorizontal && (this.xaxisLabels = i224.globals.timescaleLabels.slice()), i224.config.xaxis.overwriteCategories && (this.xaxisLabels = i224.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], "top" === i224.config.xaxis.position ? this.offY = 0 : this.offY = i224.globals.gridHeight + 1, this.offY = this.offY + i224.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = "bar" === i224.config.chart.type && i224.config.plotOptions.bar.horizontal, this.xaxisFontSize = i224.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = i224.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i224.config.xaxis.labels.style.colors, this.xaxisBorderWidth = i224.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = i224.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = i224.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = i224.config.xaxis.axisBorder.height, this.yaxis = i224.config.yaxis[0];
    }
    return r(t407, [
        {
            key: "drawXaxis",
            value: function() {
                var t408 = this.w, e308 = new m(this.ctx), i225 = e308.group({
                    class: "apexcharts-xaxis",
                    transform: "translate(".concat(t408.config.xaxis.offsetX, ", ").concat(t408.config.xaxis.offsetY, ")")
                }), a180 = e308.group({
                    class: "apexcharts-xaxis-texts-g",
                    transform: "translate(".concat(t408.globals.translateXAxisX, ", ").concat(t408.globals.translateXAxisY, ")")
                });
                i225.add(a180);
                for(var s138 = [], r116 = 0; r116 < this.xaxisLabels.length; r116++)s138.push(this.xaxisLabels[r116]);
                if (this.drawXAxisLabelAndGroup(!0, e308, a180, s138, t408.globals.isXNumeric, function(t, e309) {
                    return e309;
                }), t408.globals.hasGroups) {
                    var o98 = t408.globals.groups;
                    s138 = [];
                    for(var n87 = 0; n87 < o98.length; n87++)s138.push(o98[n87].title);
                    var l68 = {};
                    t408.config.xaxis.group.style && (l68.xaxisFontSize = t408.config.xaxis.group.style.fontSize, l68.xaxisFontFamily = t408.config.xaxis.group.style.fontFamily, l68.xaxisForeColors = t408.config.xaxis.group.style.colors, l68.fontWeight = t408.config.xaxis.group.style.fontWeight, l68.cssClass = t408.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(!1, e308, a180, s138, !1, function(t409, e310) {
                        return o98[t409].cols * e310;
                    }, l68);
                }
                if (void 0 !== t408.config.xaxis.title.text) {
                    var h64 = e308.group({
                        class: "apexcharts-xaxis-title"
                    }), c53 = e308.drawText({
                        x: t408.globals.gridWidth / 2 + t408.config.xaxis.title.offsetX,
                        y: this.offY + parseFloat(this.xaxisFontSize) + t408.globals.xAxisLabelsHeight + t408.config.xaxis.title.offsetY,
                        text: t408.config.xaxis.title.text,
                        textAnchor: "middle",
                        fontSize: t408.config.xaxis.title.style.fontSize,
                        fontFamily: t408.config.xaxis.title.style.fontFamily,
                        fontWeight: t408.config.xaxis.title.style.fontWeight,
                        foreColor: t408.config.xaxis.title.style.color,
                        cssClass: "apexcharts-xaxis-title-text " + t408.config.xaxis.title.style.cssClass
                    });
                    h64.add(c53), i225.add(h64);
                }
                if (t408.config.xaxis.axisBorder.show) {
                    var d49 = t408.globals.barPadForNumericAxis, g42 = e308.drawLine(t408.globals.padHorizontal + t408.config.xaxis.axisBorder.offsetX - d49, this.offY, this.xaxisBorderWidth + d49, this.offY, t408.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
                    i225.add(g42);
                }
                return i225;
            }
        },
        {
            key: "drawXAxisLabelAndGroup",
            value: function(t410, e311, i226, a181, s139, r117) {
                var o99, n88 = this, l69 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : {}, h65 = [], c54 = [], d50 = this.w, g43 = l69.xaxisFontSize || this.xaxisFontSize, u33 = l69.xaxisFontFamily || this.xaxisFontFamily, p29 = l69.xaxisForeColors || this.xaxisForeColors, f26 = l69.fontWeight || d50.config.xaxis.labels.style.fontWeight, x20 = l69.cssClass || d50.config.xaxis.labels.style.cssClass, b20 = d50.globals.padHorizontal, v13 = a181.length, m4 = "category" === d50.config.xaxis.type ? d50.globals.dataPoints : v13;
                if (s139) {
                    var y12 = m4 > 1 ? m4 - 1 : m4;
                    o99 = d50.globals.gridWidth / y12, b20 = b20 + r117(0, o99) / 2 + d50.config.xaxis.labels.offsetX;
                } else o99 = d50.globals.gridWidth / m4, b20 = b20 + r117(0, o99) + d50.config.xaxis.labels.offsetX;
                for(var w11 = function(s140) {
                    var l70 = b20 - r117(s140, o99) / 2 + d50.config.xaxis.labels.offsetX;
                    0 === s140 && 1 === v13 && o99 / 2 === b20 && 1 === m4 && (l70 = d50.globals.gridWidth / 2);
                    var y13 = n88.axesUtils.getLabel(a181, d50.globals.timescaleLabels, l70, s140, h65, g43, t410), w12 = 28;
                    d50.globals.rotateXLabels && t410 && (w12 = 22), t410 || (w12 = w12 + parseFloat(g43) + (d50.globals.xAxisLabelsHeight - d50.globals.xAxisGroupLabelsHeight) + (d50.globals.rotateXLabels ? 10 : 0)), y13 = void 0 !== d50.config.xaxis.tickAmount && "dataPoints" !== d50.config.xaxis.tickAmount && "datetime" !== d50.config.xaxis.type ? n88.axesUtils.checkLabelBasedOnTickamount(s140, y13, v13) : n88.axesUtils.checkForOverflowingLabels(s140, y13, v13, h65, c54);
                    if (t410 && y13.text && d50.globals.xaxisLabelsCount++, d50.config.xaxis.labels.show) {
                        var k12 = e311.drawText({
                            x: y13.x,
                            y: n88.offY + d50.config.xaxis.labels.offsetY + w12 - ("top" === d50.config.xaxis.position ? d50.globals.xAxisHeight + d50.config.xaxis.axisTicks.height - 2 : 0),
                            text: y13.text,
                            textAnchor: "middle",
                            fontWeight: y13.isBold ? 600 : f26,
                            fontSize: g43,
                            fontFamily: u33,
                            foreColor: Array.isArray(p29) ? t410 && d50.config.xaxis.convertedCatToNumeric ? p29[d50.globals.minX + s140 - 1] : p29[s140] : p29,
                            isPlainText: !1,
                            cssClass: (t410 ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + x20
                        });
                        if (i226.add(k12), t410) {
                            var A9 = document.createElementNS(d50.globals.SVGNS, "title");
                            A9.textContent = Array.isArray(y13.text) ? y13.text.join(" ") : y13.text, k12.node.appendChild(A9), "" !== y13.text && (h65.push(y13.text), c54.push(y13));
                        }
                    }
                    s140 < v13 - 1 && (b20 += r117(s140 + 1, o99));
                }, k11 = 0; k11 <= v13 - 1; k11++)w11(k11);
            }
        },
        {
            key: "drawXaxisInversed",
            value: function(t411) {
                var e312, i227, a182 = this, s141 = this.w, r118 = new m(this.ctx), o100 = s141.config.yaxis[0].opposite ? s141.globals.translateYAxisX[t411] : 0, n89 = r118.group({
                    class: "apexcharts-yaxis apexcharts-xaxis-inversed",
                    rel: t411
                }), l71 = r118.group({
                    class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g",
                    transform: "translate(" + o100 + ", 0)"
                });
                n89.add(l71);
                var h66 = [];
                if (s141.config.yaxis[t411].show) for(var c55 = 0; c55 < this.xaxisLabels.length; c55++)h66.push(this.xaxisLabels[c55]);
                e312 = s141.globals.gridHeight / h66.length, i227 = -e312 / 2.2;
                var d51 = s141.globals.yLabelFormatters[0], g44 = s141.config.yaxis[0].labels;
                if (g44.show) for(var u34 = function(o101) {
                    var n90 = void 0 === h66[o101] ? "" : h66[o101];
                    n90 = d51(n90, {
                        seriesIndex: t411,
                        dataPointIndex: o101,
                        w: s141
                    });
                    var c56 = a182.axesUtils.getYAxisForeColor(g44.style.colors, t411), u35 = 0;
                    Array.isArray(n90) && (u35 = n90.length / 2 * parseInt(g44.style.fontSize, 10));
                    var p31 = r118.drawText({
                        x: g44.offsetX - 15,
                        y: i227 + e312 + g44.offsetY - u35,
                        text: n90,
                        textAnchor: a182.yaxis.opposite ? "start" : "end",
                        foreColor: Array.isArray(c56) ? c56[o101] : c56,
                        fontSize: g44.style.fontSize,
                        fontFamily: g44.style.fontFamily,
                        fontWeight: g44.style.fontWeight,
                        isPlainText: !1,
                        cssClass: "apexcharts-yaxis-label " + g44.style.cssClass
                    });
                    l71.add(p31);
                    var f28 = document.createElementNS(s141.globals.SVGNS, "title");
                    if (f28.textContent = Array.isArray(n90) ? n90.join(" ") : n90, p31.node.appendChild(f28), 0 !== s141.config.yaxis[t411].labels.rotate) {
                        var x22 = r118.rotateAroundCenter(p31.node);
                        p31.node.setAttribute("transform", "rotate(".concat(s141.config.yaxis[t411].labels.rotate, " 0 ").concat(x22.y, ")"));
                    }
                    i227 += e312;
                }, p30 = 0; p30 <= h66.length - 1; p30++)u34(p30);
                if (void 0 !== s141.config.yaxis[0].title.text) {
                    var f27 = r118.group({
                        class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed",
                        transform: "translate(" + o100 + ", 0)"
                    }), x21 = r118.drawText({
                        x: 0,
                        y: s141.globals.gridHeight / 2,
                        text: s141.config.yaxis[0].title.text,
                        textAnchor: "middle",
                        foreColor: s141.config.yaxis[0].title.style.color,
                        fontSize: s141.config.yaxis[0].title.style.fontSize,
                        fontWeight: s141.config.yaxis[0].title.style.fontWeight,
                        fontFamily: s141.config.yaxis[0].title.style.fontFamily,
                        cssClass: "apexcharts-yaxis-title-text " + s141.config.yaxis[0].title.style.cssClass
                    });
                    f27.add(x21), n89.add(f27);
                }
                var b21 = 0;
                this.isCategoryBarHorizontal && s141.config.yaxis[0].opposite && (b21 = s141.globals.gridWidth);
                var v14 = s141.config.xaxis.axisBorder;
                if (v14.show) {
                    var y14 = r118.drawLine(s141.globals.padHorizontal + v14.offsetX + b21, 1 + v14.offsetY, s141.globals.padHorizontal + v14.offsetX + b21, s141.globals.gridHeight + v14.offsetY, v14.color, 0);
                    n89.add(y14);
                }
                return s141.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(b21, h66.length, s141.config.yaxis[0].axisBorder, s141.config.yaxis[0].axisTicks, 0, e312, n89), n89;
            }
        },
        {
            key: "drawXaxisTicks",
            value: function(t412, e313, i228) {
                var a183 = this.w, s142 = t412;
                if (!(t412 < 0 || t412 - 2 > a183.globals.gridWidth)) {
                    var r119 = this.offY + a183.config.xaxis.axisTicks.offsetY;
                    if (e313 = e313 + r119 + a183.config.xaxis.axisTicks.height, "top" === a183.config.xaxis.position && (e313 = r119 - a183.config.xaxis.axisTicks.height), a183.config.xaxis.axisTicks.show) {
                        var o102 = new m(this.ctx).drawLine(t412 + a183.config.xaxis.axisTicks.offsetX, r119 + a183.config.xaxis.offsetY, s142 + a183.config.xaxis.axisTicks.offsetX, e313 + a183.config.xaxis.offsetY, a183.config.xaxis.axisTicks.color);
                        i228.add(o102), o102.node.classList.add("apexcharts-xaxis-tick");
                    }
                }
            }
        },
        {
            key: "getXAxisTicksPositions",
            value: function() {
                var t413 = this.w, e314 = [], i229 = this.xaxisLabels.length, a184 = t413.globals.padHorizontal;
                if (t413.globals.timescaleLabels.length > 0) for(var s143 = 0; s143 < i229; s143++)a184 = this.xaxisLabels[s143].position, e314.push(a184);
                else for(var r120 = i229, o103 = 0; o103 < r120; o103++){
                    var n91 = r120;
                    t413.globals.isXNumeric && "bar" !== t413.config.chart.type && (n91 -= 1), a184 += t413.globals.gridWidth / n91, e314.push(a184);
                }
                return e314;
            }
        },
        {
            key: "xAxisLabelCorrections",
            value: function() {
                var t414 = this.w, e315 = new m(this.ctx), i230 = t414.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), a185 = t414.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"), s144 = t414.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), r121 = t414.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
                if (t414.globals.rotateXLabels || t414.config.xaxis.labels.rotateAlways) for(var o104 = 0; o104 < a185.length; o104++){
                    var n92 = e315.rotateAroundCenter(a185[o104]);
                    n92.y = n92.y - 1, n92.x = n92.x + 1, a185[o104].setAttribute("transform", "rotate(".concat(t414.config.xaxis.labels.rotate, " ").concat(n92.x, " ").concat(n92.y, ")")), a185[o104].setAttribute("text-anchor", "end");
                    i230.setAttribute("transform", "translate(0, ".concat(-10, ")"));
                    var l72 = a185[o104].childNodes;
                    t414.config.xaxis.labels.trim && Array.prototype.forEach.call(l72, function(i231) {
                        e315.placeTextWithEllipsis(i231, i231.textContent, t414.globals.xAxisLabelsHeight - ("bottom" === t414.config.legend.position ? 20 : 10));
                    });
                }
                else !function() {
                    for(var i232 = t414.globals.gridWidth / (t414.globals.labels.length + 1), s145 = 0; s145 < a185.length; s145++){
                        var r122 = a185[s145].childNodes;
                        t414.config.xaxis.labels.trim && "datetime" !== t414.config.xaxis.type && Array.prototype.forEach.call(r122, function(t415) {
                            e315.placeTextWithEllipsis(t415, t415.textContent, i232);
                        });
                    }
                }();
                if (s144.length > 0) {
                    var h67 = s144[s144.length - 1].getBBox(), c57 = s144[0].getBBox();
                    h67.x < -20 && s144[s144.length - 1].parentNode.removeChild(s144[s144.length - 1]), c57.x + c57.width > t414.globals.gridWidth && !t414.globals.isBarHorizontal && s144[0].parentNode.removeChild(s144[0]);
                    for(var d52 = 0; d52 < r121.length; d52++)e315.placeTextWithEllipsis(r121[d52], r121[d52].textContent, t414.config.yaxis[0].labels.maxWidth - 2 * parseFloat(t414.config.yaxis[0].title.style.fontSize) - 20);
                }
            }
        }
    ]), t407;
}(), U = function() {
    function t416(e316) {
        a(this, t416), this.ctx = e316, this.w = e316.w;
        var i233 = this.w;
        this.xaxisLabels = i233.globals.labels.slice(), this.axesUtils = new G(e316), this.isRangeBar = i233.globals.seriesRangeBar.length, i233.globals.timescaleLabels.length > 0 && (this.xaxisLabels = i233.globals.timescaleLabels.slice());
    }
    return r(t416, [
        {
            key: "drawGridArea",
            value: function() {
                var t417 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e317 = this.w, i234 = new m(this.ctx);
                null === t417 && (t417 = i234.group({
                    class: "apexcharts-grid"
                }));
                var a186 = i234.drawLine(e317.globals.padHorizontal, 1, e317.globals.padHorizontal, e317.globals.gridHeight, "transparent"), s146 = i234.drawLine(e317.globals.padHorizontal, e317.globals.gridHeight, e317.globals.gridWidth, e317.globals.gridHeight, "transparent");
                return t417.add(s146), t417.add(a186), t417;
            }
        },
        {
            key: "drawGrid",
            value: function() {
                var t418 = null;
                return this.w.globals.axisCharts && (t418 = this.renderGrid(), this.drawGridArea(t418.el)), t418;
            }
        },
        {
            key: "createGridMask",
            value: function() {
                var t419 = this.w, e318 = t419.globals, i235 = new m(this.ctx), a187 = Array.isArray(t419.config.stroke.width) ? 0 : t419.config.stroke.width;
                if (Array.isArray(t419.config.stroke.width)) {
                    var s147 = 0;
                    t419.config.stroke.width.forEach(function(t420) {
                        s147 = Math.max(s147, t420);
                    }), a187 = s147;
                }
                e318.dom.elGridRectMask = document.createElementNS(e318.SVGNS, "clipPath"), e318.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(e318.cuid)), e318.dom.elGridRectMarkerMask = document.createElementNS(e318.SVGNS, "clipPath"), e318.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(e318.cuid)), e318.dom.elForecastMask = document.createElementNS(e318.SVGNS, "clipPath"), e318.dom.elForecastMask.setAttribute("id", "forecastMask".concat(e318.cuid)), e318.dom.elNonForecastMask = document.createElementNS(e318.SVGNS, "clipPath"), e318.dom.elNonForecastMask.setAttribute("id", "nonForecastMask".concat(e318.cuid));
                var r123 = t419.config.chart.type, o105 = 0, n93 = 0;
                ("bar" === r123 || "rangeBar" === r123 || "candlestick" === r123 || "boxPlot" === r123 || t419.globals.comboBarCount > 0) && t419.globals.isXNumeric && !t419.globals.isBarHorizontal && (o105 = t419.config.grid.padding.left, n93 = t419.config.grid.padding.right, e318.barPadForNumericAxis > o105 && (o105 = e318.barPadForNumericAxis, n93 = e318.barPadForNumericAxis)), e318.dom.elGridRect = i235.drawRect(-a187 / 2 - o105 - 2, -a187 / 2, e318.gridWidth + a187 + n93 + o105 + 4, e318.gridHeight + a187, 0, "#fff");
                var l73 = t419.globals.markers.largestSize + 1;
                e318.dom.elGridRectMarker = i235.drawRect(2 * -l73, 2 * -l73, e318.gridWidth + 4 * l73, e318.gridHeight + 4 * l73, 0, "#fff"), e318.dom.elGridRectMask.appendChild(e318.dom.elGridRect.node), e318.dom.elGridRectMarkerMask.appendChild(e318.dom.elGridRectMarker.node);
                var h68 = e318.dom.baseEl.querySelector("defs");
                h68.appendChild(e318.dom.elGridRectMask), h68.appendChild(e318.dom.elForecastMask), h68.appendChild(e318.dom.elNonForecastMask), h68.appendChild(e318.dom.elGridRectMarkerMask);
            }
        },
        {
            key: "_drawGridLines",
            value: function(t421) {
                var e319 = t421.i, i236 = t421.x1, a188 = t421.y1, s148 = t421.x2, r124 = t421.y2, o106 = t421.xCount, n94 = t421.parent, l74 = this.w;
                if (!(0 === e319 && l74.globals.skipFirstTimelinelabel || e319 === o106 - 1 && l74.globals.skipLastTimelinelabel && !l74.config.xaxis.labels.formatter || "radar" === l74.config.chart.type)) {
                    l74.config.grid.xaxis.lines.show && this._drawGridLine({
                        x1: i236,
                        y1: a188,
                        x2: s148,
                        y2: r124,
                        parent: n94
                    });
                    var h69 = 0;
                    if (l74.globals.hasGroups && (void 0 === l74.config.xaxis.tickAmount || "dataPoints" === l74.config.xaxis.tickAmount) && "between" === l74.config.xaxis.tickPlacement) {
                        var c58 = l74.globals.groups;
                        if (c58) {
                            for(var d53 = 0, g45 = 0; d53 < e319 && g45 < c58.length; g45++)d53 += c58[g45].cols;
                            d53 === e319 && (h69 = .6 * l74.globals.xAxisLabelsHeight);
                        }
                    }
                    new _(this.ctx).drawXaxisTicks(i236, h69, this.elg);
                }
            }
        },
        {
            key: "_drawGridLine",
            value: function(t422) {
                var e320 = t422.x1, i237 = t422.y1, a189 = t422.x2, s149 = t422.y2, r125 = t422.parent, o107 = this.w, n95 = r125.node.classList.contains("apexcharts-gridlines-horizontal"), l75 = o107.config.grid.strokeDashArray, h70 = o107.globals.barPadForNumericAxis, c59 = new m(this).drawLine(e320 - (n95 ? h70 : 0), i237, a189 + (n95 ? h70 : 0), s149, o107.config.grid.borderColor, l75);
                c59.node.classList.add("apexcharts-gridline"), r125.add(c59);
            }
        },
        {
            key: "_drawGridBandRect",
            value: function(t423) {
                var e321 = t423.c, i238 = t423.x1, a190 = t423.y1, s150 = t423.x2, r126 = t423.y2, o108 = t423.type, n96 = this.w, l76 = new m(this.ctx), h71 = n96.globals.barPadForNumericAxis;
                if ("column" !== o108 || "datetime" !== n96.config.xaxis.type) {
                    var c60 = n96.config.grid[o108].colors[e321], d54 = l76.drawRect(i238 - ("row" === o108 ? h71 : 0), a190, s150 + ("row" === o108 ? 2 * h71 : 0), r126, 0, c60, n96.config.grid[o108].opacity);
                    this.elg.add(d54), d54.attr("clip-path", "url(#gridRectMask".concat(n96.globals.cuid, ")")), d54.node.classList.add("apexcharts-grid-".concat(o108));
                }
            }
        },
        {
            key: "_drawXYLines",
            value: function(t424) {
                var e322 = this, i239 = t424.xCount, a191 = t424.tickAmount, s151 = this.w;
                if (s151.config.grid.xaxis.lines.show || s151.config.xaxis.axisTicks.show) {
                    var r127, o109 = s151.globals.padHorizontal, n97 = s151.globals.gridHeight;
                    s151.globals.timescaleLabels.length ? function(t425) {
                        for(var a192 = t425.xC, s152 = t425.x1, r129 = t425.y1, o111 = t425.x2, n99 = t425.y2, l78 = 0; l78 < a192; l78++)s152 = e322.xaxisLabels[l78].position, o111 = e322.xaxisLabels[l78].position, e322._drawGridLines({
                            i: l78,
                            x1: s152,
                            y1: r129,
                            x2: o111,
                            y2: n99,
                            xCount: i239,
                            parent: e322.elgridLinesV
                        });
                    }({
                        xC: i239,
                        x1: o109,
                        y1: 0,
                        x2: r127,
                        y2: n97
                    }) : (s151.globals.isXNumeric && (i239 = s151.globals.xAxisScale.result.length), s151.config.xaxis.convertedCatToNumeric && (i239 = s151.globals.xaxisLabelsCount), function(t426) {
                        var a193 = t426.xC, r130 = t426.x1, o112 = t426.y1, n100 = t426.x2, l79 = t426.y2;
                        if (void 0 !== s151.config.xaxis.tickAmount && "dataPoints" !== s151.config.xaxis.tickAmount) s151.globals.dom.baseEl.querySelectorAll(".apexcharts-text.apexcharts-xaxis-label tspan:not(:empty)").forEach(function(t427, a194) {
                            var s153 = t427.getBBox();
                            e322._drawGridLines({
                                i: a194,
                                x1: s153.x + s153.width / 2,
                                y1: o112,
                                x2: s153.x + s153.width / 2,
                                y2: l79,
                                xCount: i239,
                                parent: e322.elgridLinesV
                            });
                        });
                        else for(var h73 = 0; h73 < a193 + (s151.globals.isXNumeric ? 0 : 1); h73++)0 === h73 && 1 === a193 && 1 === s151.globals.dataPoints && (n100 = r130 = s151.globals.gridWidth / 2), e322._drawGridLines({
                            i: h73,
                            x1: r130,
                            y1: o112,
                            x2: n100,
                            y2: l79,
                            xCount: i239,
                            parent: e322.elgridLinesV
                        }), n100 = r130 += s151.globals.gridWidth / (s151.globals.isXNumeric ? a193 - 1 : a193);
                    }({
                        xC: i239,
                        x1: o109,
                        y1: 0,
                        x2: r127,
                        y2: n97
                    }));
                }
                if (s151.config.grid.yaxis.lines.show) {
                    var l77 = 0, h72 = 0, c61 = s151.globals.gridWidth, d55 = a191 + 1;
                    this.isRangeBar && (d55 = s151.globals.labels.length);
                    for(var g46 = 0; g46 < d55 + (this.isRangeBar ? 1 : 0); g46++)this._drawGridLine({
                        x1: 0,
                        y1: l77,
                        x2: c61,
                        y2: h72,
                        parent: this.elgridLinesH
                    }), h72 = l77 += s151.globals.gridHeight / (this.isRangeBar ? d55 : a191);
                }
            }
        },
        {
            key: "_drawInvertedXYLines",
            value: function(t428) {
                var e323 = t428.xCount, i240 = this.w;
                if (i240.config.grid.xaxis.lines.show || i240.config.xaxis.axisTicks.show) for(var a195, s154 = i240.globals.padHorizontal, r131 = i240.globals.gridHeight, o113 = 0; o113 < e323 + 1; o113++)i240.config.grid.xaxis.lines.show && this._drawGridLine({
                    x1: s154,
                    y1: 0,
                    x2: a195,
                    y2: r131,
                    parent: this.elgridLinesV
                }), new _(this.ctx).drawXaxisTicks(s154, 0, this.elg), a195 = s154 = s154 + i240.globals.gridWidth / e323 + .3;
                if (i240.config.grid.yaxis.lines.show) for(var n101 = 0, l80 = 0, h74 = i240.globals.gridWidth, c62 = 0; c62 < i240.globals.dataPoints + 1; c62++)this._drawGridLine({
                    x1: 0,
                    y1: n101,
                    x2: h74,
                    y2: l80,
                    parent: this.elgridLinesH
                }), l80 = n101 += i240.globals.gridHeight / i240.globals.dataPoints;
            }
        },
        {
            key: "renderGrid",
            value: function() {
                var t429 = this.w, e324 = new m(this.ctx);
                this.elg = e324.group({
                    class: "apexcharts-grid"
                }), this.elgridLinesH = e324.group({
                    class: "apexcharts-gridlines-horizontal"
                }), this.elgridLinesV = e324.group({
                    class: "apexcharts-gridlines-vertical"
                }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t429.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide());
                for(var i241, a196 = t429.globals.yAxisScale.length ? t429.globals.yAxisScale[0].result.length - 1 : 5, s155 = 0; s155 < t429.globals.series.length && (void 0 !== t429.globals.yAxisScale[s155] && (a196 = t429.globals.yAxisScale[s155].result.length - 1), !(a196 > 2)); s155++);
                return !t429.globals.isBarHorizontal || this.isRangeBar ? (i241 = this.xaxisLabels.length, this.isRangeBar && (a196 = t429.globals.labels.length, t429.config.xaxis.tickAmount && t429.config.xaxis.labels.formatter && (i241 = t429.config.xaxis.tickAmount)), this._drawXYLines({
                    xCount: i241,
                    tickAmount: a196
                })) : (i241 = a196, a196 = t429.globals.xTickAmount, this._drawInvertedXYLines({
                    xCount: i241,
                    tickAmount: a196
                })), this.drawGridBands(i241, a196), {
                    el: this.elg,
                    xAxisTickWidth: t429.globals.gridWidth / i241
                };
            }
        },
        {
            key: "drawGridBands",
            value: function(t430, e325) {
                var i242 = this.w;
                if (void 0 !== i242.config.grid.row.colors && i242.config.grid.row.colors.length > 0) for(var a197 = 0, s156 = i242.globals.gridHeight / e325, r132 = i242.globals.gridWidth, o114 = 0, n102 = 0; o114 < e325; o114++, n102++)n102 >= i242.config.grid.row.colors.length && (n102 = 0), this._drawGridBandRect({
                    c: n102,
                    x1: 0,
                    y1: a197,
                    x2: r132,
                    y2: s156,
                    type: "row"
                }), a197 += i242.globals.gridHeight / e325;
                if (void 0 !== i242.config.grid.column.colors && i242.config.grid.column.colors.length > 0) for(var l81 = i242.globals.isBarHorizontal || "category" !== i242.config.xaxis.type && !i242.config.xaxis.convertedCatToNumeric ? t430 : t430 - 1, h75 = i242.globals.padHorizontal, c63 = i242.globals.padHorizontal + i242.globals.gridWidth / l81, d56 = i242.globals.gridHeight, g47 = 0, u36 = 0; g47 < t430; g47++, u36++)u36 >= i242.config.grid.column.colors.length && (u36 = 0), this._drawGridBandRect({
                    c: u36,
                    x1: h75,
                    y1: 0,
                    x2: c63,
                    y2: d56,
                    type: "column"
                }), h75 += i242.globals.gridWidth / l81;
            }
        }
    ]), t416;
}(), q = function() {
    function t431(e326) {
        a(this, t431), this.ctx = e326, this.w = e326.w;
    }
    return r(t431, [
        {
            key: "niceScale",
            value: function(t432, e327) {
                var i243 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10, a198 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s157 = arguments.length > 4 ? arguments[4] : void 0, r133 = this.w, o115 = Math.abs(e327 - t432);
                if ("dataPoints" === (i243 = this._adjustTicksForSmallRange(i243, a198, o115)) && (i243 = r133.globals.dataPoints - 1), t432 === Number.MIN_VALUE && 0 === e327 || !x.isNumber(t432) && !x.isNumber(e327) || t432 === Number.MIN_VALUE && e327 === -Number.MAX_VALUE) {
                    t432 = 0, e327 = i243;
                    var n103 = this.linearScale(t432, e327, i243);
                    return n103;
                }
                t432 > e327 ? (console.warn("axis.min cannot be greater than axis.max"), e327 = t432 + .1) : t432 === e327 && (t432 = 0 === t432 ? 0 : t432 - .5, e327 = 0 === e327 ? 2 : e327 + .5);
                var l82 = [];
                o115 < 1 && s157 && ("candlestick" === r133.config.chart.type || "candlestick" === r133.config.series[a198].type || "boxPlot" === r133.config.chart.type || "boxPlot" === r133.config.series[a198].type || r133.globals.isRangeData) && (e327 *= 1.01);
                var h76 = i243 + 1;
                h76 < 2 ? h76 = 2 : h76 > 2 && (h76 -= 2);
                var c64 = o115 / h76, d57 = Math.floor(x.log10(c64)), g48 = Math.pow(10, d57), u37 = Math.round(c64 / g48);
                u37 < 1 && (u37 = 1);
                var p32 = u37 * g48, f29 = p32 * Math.floor(t432 / p32), b22 = p32 * Math.ceil(e327 / p32), v15 = f29;
                if (s157 && o115 > 2) {
                    for(; l82.push(v15), !((v15 += p32) > b22););
                    return {
                        result: l82,
                        niceMin: l82[0],
                        niceMax: l82[l82.length - 1]
                    };
                }
                var m5 = t432;
                (l82 = []).push(m5);
                for(var y15 = Math.abs(e327 - t432) / i243, w13 = 0; w13 <= i243; w13++)m5 += y15, l82.push(m5);
                return l82[l82.length - 2] >= e327 && l82.pop(), {
                    result: l82,
                    niceMin: l82[0],
                    niceMax: l82[l82.length - 1]
                };
            }
        },
        {
            key: "linearScale",
            value: function(t433, e328) {
                var i244 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10, a199 = arguments.length > 3 ? arguments[3] : void 0, s158 = Math.abs(e328 - t433);
                "dataPoints" === (i244 = this._adjustTicksForSmallRange(i244, a199, s158)) && (i244 = this.w.globals.dataPoints - 1);
                var r134 = s158 / i244;
                i244 === Number.MAX_VALUE && (i244 = 10, r134 = 1);
                for(var o116 = [], n104 = t433; i244 >= 0;)o116.push(n104), n104 += r134, i244 -= 1;
                return {
                    result: o116,
                    niceMin: o116[0],
                    niceMax: o116[o116.length - 1]
                };
            }
        },
        {
            key: "logarithmicScale",
            value: function(t434, e329, i245) {
                for(var a200 = [], s159 = Math.ceil(Math.log(e329) / Math.log(i245)) + 1, r135 = 0; r135 < s159; r135++)a200.push(Math.pow(i245, r135));
                return 0 === t434 && a200.unshift(t434), {
                    result: a200,
                    niceMin: a200[0],
                    niceMax: a200[a200.length - 1]
                };
            }
        },
        {
            key: "_adjustTicksForSmallRange",
            value: function(t435, e330, i246) {
                var a201 = t435;
                if (void 0 !== e330 && this.w.config.yaxis[e330].labels.formatter && void 0 === this.w.config.yaxis[e330].tickAmount) {
                    var s160 = this.w.config.yaxis[e330].labels.formatter(1);
                    x.isNumber(Number(s160)) && !x.isFloat(s160) && (a201 = Math.ceil(i246));
                }
                return a201 < t435 ? a201 : t435;
            }
        },
        {
            key: "setYScaleForIndex",
            value: function(t436, e331, i247) {
                var a202 = this.w.globals, s161 = this.w.config, r136 = a202.isBarHorizontal ? s161.xaxis : s161.yaxis[t436];
                void 0 === a202.yAxisScale[t436] && (a202.yAxisScale[t436] = []);
                var o117 = Math.abs(i247 - e331);
                if (r136.logarithmic && o117 <= 5 && (a202.invalidLogScale = !0), r136.logarithmic && o117 > 5) a202.allSeriesCollapsed = !1, a202.yAxisScale[t436] = this.logarithmicScale(e331, i247, r136.logBase);
                else if (i247 !== -Number.MAX_VALUE && x.isNumber(i247)) {
                    if (a202.allSeriesCollapsed = !1, void 0 === r136.min && void 0 === r136.max || r136.forceNiceScale) {
                        var n105 = void 0 === s161.yaxis[t436].max && void 0 === s161.yaxis[t436].min || s161.yaxis[t436].forceNiceScale;
                        a202.yAxisScale[t436] = this.niceScale(e331, i247, r136.tickAmount ? r136.tickAmount : o117 < 5 && o117 > 1 ? o117 + 1 : 5, t436, n105);
                    } else a202.yAxisScale[t436] = this.linearScale(e331, i247, r136.tickAmount, t436);
                } else a202.yAxisScale[t436] = this.linearScale(0, 5, 5);
            }
        },
        {
            key: "setXScale",
            value: function(t437, e332) {
                var i248 = this.w, a203 = i248.globals, s162 = i248.config.xaxis, r137 = Math.abs(e332 - t437);
                return e332 !== -Number.MAX_VALUE && x.isNumber(e332) ? a203.xAxisScale = this.linearScale(t437, e332, s162.tickAmount ? s162.tickAmount : r137 < 5 && r137 > 1 ? r137 + 1 : 5, 0) : a203.xAxisScale = this.linearScale(0, 5, 5), a203.xAxisScale;
            }
        },
        {
            key: "setMultipleYScales",
            value: function() {
                var t438 = this, e333 = this.w.globals, i249 = this.w.config, a204 = e333.minYArr.concat([]), s163 = e333.maxYArr.concat([]), r138 = [];
                i249.yaxis.forEach(function(e334, o118) {
                    var n106 = o118;
                    i249.series.forEach(function(t439, i250) {
                        t439.name === e334.seriesName && (n106 = i250, o118 !== i250 ? r138.push({
                            index: i250,
                            similarIndex: o118,
                            alreadyExists: !0
                        }) : r138.push({
                            index: i250
                        }));
                    });
                    var l83 = a204[n106], h77 = s163[n106];
                    t438.setYScaleForIndex(o118, l83, h77);
                }), this.sameScaleInMultipleAxes(a204, s163, r138);
            }
        },
        {
            key: "sameScaleInMultipleAxes",
            value: function(t440, e335, i251) {
                var a205 = this, s164 = this.w.config, r139 = this.w.globals, o119 = [];
                i251.forEach(function(t441) {
                    t441.alreadyExists && (void 0 === o119[t441.index] && (o119[t441.index] = []), o119[t441.index].push(t441.index), o119[t441.index].push(t441.similarIndex));
                }), r139.yAxisSameScaleIndices = o119, o119.forEach(function(t442, e336) {
                    o119.forEach(function(i252, a206) {
                        var s165, r140;
                        e336 !== a206 && (s165 = t442, r140 = i252, s165.filter(function(t443) {
                            return -1 !== r140.indexOf(t443);
                        })).length > 0 && (o119[e336] = o119[e336].concat(o119[a206]));
                    });
                });
                var n107 = o119.map(function(t444) {
                    return t444.filter(function(e337, i253) {
                        return t444.indexOf(e337) === i253;
                    });
                }).map(function(t445) {
                    return t445.sort();
                });
                o119 = o119.filter(function(t446) {
                    return !!t446;
                });
                var l84 = n107.slice(), h78 = l84.map(function(t447) {
                    return JSON.stringify(t447);
                });
                l84 = l84.filter(function(t448, e338) {
                    return h78.indexOf(JSON.stringify(t448)) === e338;
                });
                var c65 = [], d58 = [];
                t440.forEach(function(t449, i254) {
                    l84.forEach(function(a207, s166) {
                        a207.indexOf(i254) > -1 && (void 0 === c65[s166] && (c65[s166] = [], d58[s166] = []), c65[s166].push({
                            key: i254,
                            value: t449
                        }), d58[s166].push({
                            key: i254,
                            value: e335[i254]
                        }));
                    });
                });
                var g49 = Array.apply(null, Array(l84.length)).map(Number.prototype.valueOf, Number.MIN_VALUE), u38 = Array.apply(null, Array(l84.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
                c65.forEach(function(t450, e339) {
                    t450.forEach(function(t451, i) {
                        g49[e339] = Math.min(t451.value, g49[e339]);
                    });
                }), d58.forEach(function(t452, e340) {
                    t452.forEach(function(t453, i) {
                        u38[e340] = Math.max(t453.value, u38[e340]);
                    });
                }), t440.forEach(function(t454, e341) {
                    d58.forEach(function(t455, i255) {
                        var o120 = g49[i255], n108 = u38[i255];
                        s164.chart.stacked && (n108 = 0, t455.forEach(function(t456, e342) {
                            t456.value !== -Number.MAX_VALUE && (n108 += t456.value), o120 !== Number.MIN_VALUE && (o120 += c65[i255][e342].value);
                        })), t455.forEach(function(i, l85) {
                            t455[l85].key === e341 && (void 0 !== s164.yaxis[e341].min && (o120 = "function" == typeof s164.yaxis[e341].min ? s164.yaxis[e341].min(r139.minY) : s164.yaxis[e341].min), void 0 !== s164.yaxis[e341].max && (n108 = "function" == typeof s164.yaxis[e341].max ? s164.yaxis[e341].max(r139.maxY) : s164.yaxis[e341].max), a205.setYScaleForIndex(e341, o120, n108));
                        });
                    });
                });
            }
        },
        {
            key: "autoScaleY",
            value: function(t457, e343, i256) {
                t457 || (t457 = this);
                var a208 = t457.w;
                if (a208.globals.isMultipleYAxis || a208.globals.collapsedSeries.length) return console.warn("autoScaleYaxis is not supported in a multi-yaxis chart."), e343;
                var s167 = a208.globals.seriesX[0], r141 = a208.config.chart.stacked;
                return e343.forEach(function(t458, o121) {
                    for(var n109 = 0, l86 = 0; l86 < s167.length; l86++)if (s167[l86] >= i256.xaxis.min) {
                        n109 = l86;
                        break;
                    }
                    var h79, c66, d59 = a208.globals.minYArr[o121], g50 = a208.globals.maxYArr[o121], u39 = a208.globals.stackedSeriesTotals;
                    a208.globals.series.forEach(function(o122, l87) {
                        var p33 = o122[n109];
                        r141 ? (p33 = u39[n109], h79 = c66 = p33, u39.forEach(function(t459, e344) {
                            s167[e344] <= i256.xaxis.max && s167[e344] >= i256.xaxis.min && (t459 > c66 && null !== t459 && (c66 = t459), o122[e344] < h79 && null !== o122[e344] && (h79 = o122[e344]));
                        })) : (h79 = c66 = p33, o122.forEach(function(t460, e345) {
                            if (s167[e345] <= i256.xaxis.max && s167[e345] >= i256.xaxis.min) {
                                var r142 = t460, o123 = t460;
                                a208.globals.series.forEach(function(i257, a) {
                                    null !== t460 && (r142 = Math.min(i257[e345], r142), o123 = Math.max(i257[e345], o123));
                                }), o123 > c66 && null !== o123 && (c66 = o123), r142 < h79 && null !== r142 && (h79 = r142);
                            }
                        })), void 0 === h79 && void 0 === c66 && (h79 = d59, c66 = g50), (c66 *= c66 < 0 ? .9 : 1.1) < 0 && c66 < g50 && (c66 = g50), (h79 *= h79 < 0 ? 1.1 : .9) < 0 && h79 > d59 && (h79 = d59), e343.length > 1 ? (e343[l87].min = void 0 === t458.min ? h79 : t458.min, e343[l87].max = void 0 === t458.max ? c66 : t458.max) : (e343[0].min = void 0 === t458.min ? h79 : t458.min, e343[0].max = void 0 === t458.max ? c66 : t458.max);
                    });
                }), e343;
            }
        }
    ]), t431;
}(), Z = function() {
    function t461(e346) {
        a(this, t461), this.ctx = e346, this.w = e346.w, this.scales = new q(e346);
    }
    return r(t461, [
        {
            key: "init",
            value: function() {
                this.setYRange(), this.setXRange(), this.setZRange();
            }
        },
        {
            key: "getMinYMaxY",
            value: function(t462) {
                var e347 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE, i258 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE, a209 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s168 = this.w.config, r143 = this.w.globals, o124 = -Number.MAX_VALUE, n110 = Number.MIN_VALUE;
                null === a209 && (a209 = t462 + 1);
                var l88 = r143.series, h80 = l88, c67 = l88;
                "candlestick" === s168.chart.type ? (h80 = r143.seriesCandleL, c67 = r143.seriesCandleH) : "boxPlot" === s168.chart.type ? (h80 = r143.seriesCandleO, c67 = r143.seriesCandleC) : r143.isRangeData && (h80 = r143.seriesRangeStart, c67 = r143.seriesRangeEnd);
                for(var d60 = t462; d60 < a209; d60++){
                    r143.dataPoints = Math.max(r143.dataPoints, l88[d60].length), r143.categoryLabels.length && (r143.dataPoints = r143.categoryLabels.filter(function(t463) {
                        return void 0 !== t463;
                    }).length);
                    for(var g51 = 0; g51 < r143.series[d60].length; g51++){
                        var u40 = l88[d60][g51];
                        null !== u40 && x.isNumber(u40) ? (void 0 !== c67[d60][g51] && (o124 = Math.max(o124, c67[d60][g51]), e347 = Math.min(e347, c67[d60][g51])), void 0 !== h80[d60][g51] && (e347 = Math.min(e347, h80[d60][g51]), i258 = Math.max(i258, h80[d60][g51])), "candlestick" !== this.w.config.chart.type && "boxPlot" !== this.w.config.chart.type || (void 0 !== r143.seriesCandleC[d60][g51] && (o124 = Math.max(o124, r143.seriesCandleO[d60][g51]), o124 = Math.max(o124, r143.seriesCandleH[d60][g51]), o124 = Math.max(o124, r143.seriesCandleL[d60][g51]), o124 = Math.max(o124, r143.seriesCandleC[d60][g51]), "boxPlot" === this.w.config.chart.type && (o124 = Math.max(o124, r143.seriesCandleM[d60][g51]))), !s168.series[d60].type || "candlestick" === s168.series[d60].type && "boxPlot" === s168.series[d60].type || (o124 = Math.max(o124, r143.series[d60][g51]), e347 = Math.min(e347, r143.series[d60][g51])), i258 = o124), r143.seriesGoals[d60] && r143.seriesGoals[d60][g51] && Array.isArray(r143.seriesGoals[d60][g51]) && r143.seriesGoals[d60][g51].forEach(function(t464) {
                            n110 !== Number.MIN_VALUE && (n110 = Math.min(n110, t464.value), e347 = n110), o124 = Math.max(o124, t464.value), i258 = o124;
                        }), x.isFloat(u40) && (u40 = x.noExponents(u40), r143.yValueDecimal = Math.max(r143.yValueDecimal, u40.toString().split(".")[1].length)), n110 > h80[d60][g51] && h80[d60][g51] < 0 && (n110 = h80[d60][g51])) : r143.hasNullValues = !0;
                    }
                }
                return "rangeBar" === s168.chart.type && r143.seriesRangeStart.length && r143.isBarHorizontal && (n110 = e347), "bar" === s168.chart.type && (n110 < 0 && o124 < 0 && (o124 = 0), n110 === Number.MIN_VALUE && (n110 = 0)), {
                    minY: n110,
                    maxY: o124,
                    lowestY: e347,
                    highestY: i258
                };
            }
        },
        {
            key: "setYRange",
            value: function() {
                var t465 = this.w.globals, e348 = this.w.config;
                t465.maxY = -Number.MAX_VALUE, t465.minY = Number.MIN_VALUE;
                var i259 = Number.MAX_VALUE;
                if (t465.isMultipleYAxis) for(var a210 = 0; a210 < t465.series.length; a210++){
                    var s169 = this.getMinYMaxY(a210, i259, null, a210 + 1);
                    t465.minYArr.push(s169.minY), t465.maxYArr.push(s169.maxY), i259 = s169.lowestY;
                }
                var r144 = this.getMinYMaxY(0, i259, null, t465.series.length);
                if (t465.minY = r144.minY, t465.maxY = r144.maxY, i259 = r144.lowestY, e348.chart.stacked && this._setStackedMinMax(), ("line" === e348.chart.type || "area" === e348.chart.type || "candlestick" === e348.chart.type || "boxPlot" === e348.chart.type || "rangeBar" === e348.chart.type && !t465.isBarHorizontal) && t465.minY === Number.MIN_VALUE && i259 !== -Number.MAX_VALUE && i259 !== t465.maxY) {
                    var o125 = t465.maxY - i259;
                    (i259 >= 0 && i259 <= 10 || void 0 !== e348.yaxis[0].min || void 0 !== e348.yaxis[0].max) && (o125 = 0), t465.minY = i259 - 5 * o125 / 100, i259 > 0 && t465.minY < 0 && (t465.minY = 0), t465.maxY = t465.maxY + 5 * o125 / 100;
                }
                if (e348.yaxis.forEach(function(e349, i260) {
                    void 0 !== e349.max && ("number" == typeof e349.max ? t465.maxYArr[i260] = e349.max : "function" == typeof e349.max && (t465.maxYArr[i260] = e349.max(t465.isMultipleYAxis ? t465.maxYArr[i260] : t465.maxY)), t465.maxY = t465.maxYArr[i260]), void 0 !== e349.min && ("number" == typeof e349.min ? t465.minYArr[i260] = e349.min : "function" == typeof e349.min && (t465.minYArr[i260] = e349.min(t465.isMultipleYAxis ? t465.minYArr[i260] === Number.MIN_VALUE ? 0 : t465.minYArr[i260] : t465.minY)), t465.minY = t465.minYArr[i260]);
                }), t465.isBarHorizontal) [
                    "min",
                    "max"
                ].forEach(function(i261) {
                    void 0 !== e348.xaxis[i261] && "number" == typeof e348.xaxis[i261] && ("min" === i261 ? t465.minY = e348.xaxis[i261] : t465.maxY = e348.xaxis[i261]);
                });
                return t465.isMultipleYAxis ? (this.scales.setMultipleYScales(), t465.minY = i259, t465.yAxisScale.forEach(function(e350, i262) {
                    t465.minYArr[i262] = e350.niceMin, t465.maxYArr[i262] = e350.niceMax;
                })) : (this.scales.setYScaleForIndex(0, t465.minY, t465.maxY), t465.minY = t465.yAxisScale[0].niceMin, t465.maxY = t465.yAxisScale[0].niceMax, t465.minYArr[0] = t465.yAxisScale[0].niceMin, t465.maxYArr[0] = t465.yAxisScale[0].niceMax), {
                    minY: t465.minY,
                    maxY: t465.maxY,
                    minYArr: t465.minYArr,
                    maxYArr: t465.maxYArr,
                    yAxisScale: t465.yAxisScale
                };
            }
        },
        {
            key: "setXRange",
            value: function() {
                var t466 = this.w.globals, e351 = this.w.config, i263 = "numeric" === e351.xaxis.type || "datetime" === e351.xaxis.type || "category" === e351.xaxis.type && !t466.noLabelsProvided || t466.noLabelsProvided || t466.isXNumeric;
                if (t466.isXNumeric && function() {
                    for(var e352 = 0; e352 < t466.series.length; e352++)if (t466.labels[e352]) for(var i264 = 0; i264 < t466.labels[e352].length; i264++)null !== t466.labels[e352][i264] && x.isNumber(t466.labels[e352][i264]) && (t466.maxX = Math.max(t466.maxX, t466.labels[e352][i264]), t466.initialMaxX = Math.max(t466.maxX, t466.labels[e352][i264]), t466.minX = Math.min(t466.minX, t466.labels[e352][i264]), t466.initialMinX = Math.min(t466.minX, t466.labels[e352][i264]));
                }(), t466.noLabelsProvided && 0 === e351.xaxis.categories.length && (t466.maxX = t466.labels[t466.labels.length - 1], t466.initialMaxX = t466.labels[t466.labels.length - 1], t466.minX = 1, t466.initialMinX = 1), t466.isXNumeric || t466.noLabelsProvided || t466.dataFormatXNumeric) {
                    var a211;
                    if (void 0 === e351.xaxis.tickAmount ? (a211 = Math.round(t466.svgWidth / 150), "numeric" === e351.xaxis.type && t466.dataPoints < 30 && (a211 = t466.dataPoints - 1), a211 > t466.dataPoints && 0 !== t466.dataPoints && (a211 = t466.dataPoints - 1)) : "dataPoints" === e351.xaxis.tickAmount ? (t466.series.length > 1 && (a211 = t466.series[t466.maxValsInArrayIndex].length - 1), t466.isXNumeric && (a211 = t466.maxX - t466.minX - 1)) : a211 = e351.xaxis.tickAmount, t466.xTickAmount = a211, void 0 !== e351.xaxis.max && "number" == typeof e351.xaxis.max && (t466.maxX = e351.xaxis.max), void 0 !== e351.xaxis.min && "number" == typeof e351.xaxis.min && (t466.minX = e351.xaxis.min), void 0 !== e351.xaxis.range && (t466.minX = t466.maxX - e351.xaxis.range), t466.minX !== Number.MAX_VALUE && t466.maxX !== -Number.MAX_VALUE) {
                        if (e351.xaxis.convertedCatToNumeric && !t466.dataFormatXNumeric) {
                            for(var s170 = [], r145 = t466.minX - 1; r145 < t466.maxX; r145++)s170.push(r145 + 1);
                            t466.xAxisScale = {
                                result: s170,
                                niceMin: s170[0],
                                niceMax: s170[s170.length - 1]
                            };
                        } else t466.xAxisScale = this.scales.setXScale(t466.minX, t466.maxX);
                    } else t466.xAxisScale = this.scales.linearScale(1, a211, a211), t466.noLabelsProvided && t466.labels.length > 0 && (t466.xAxisScale = this.scales.linearScale(1, t466.labels.length, a211 - 1), t466.seriesX = t466.labels.slice());
                    i263 && (t466.labels = t466.xAxisScale.result.slice());
                }
                return t466.isBarHorizontal && t466.labels.length && (t466.xTickAmount = t466.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), {
                    minX: t466.minX,
                    maxX: t466.maxX
                };
            }
        },
        {
            key: "setZRange",
            value: function() {
                var t467 = this.w.globals;
                if (t467.isDataXYZ) {
                    for(var e353 = 0; e353 < t467.series.length; e353++)if (void 0 !== t467.seriesZ[e353]) for(var i265 = 0; i265 < t467.seriesZ[e353].length; i265++)null !== t467.seriesZ[e353][i265] && x.isNumber(t467.seriesZ[e353][i265]) && (t467.maxZ = Math.max(t467.maxZ, t467.seriesZ[e353][i265]), t467.minZ = Math.min(t467.minZ, t467.seriesZ[e353][i265]));
                }
            }
        },
        {
            key: "_handleSingleDataPoint",
            value: function() {
                var t468 = this.w.globals, e354 = this.w.config;
                if (t468.minX === t468.maxX) {
                    var i266 = new R(this.ctx);
                    if ("datetime" === e354.xaxis.type) {
                        var a212 = i266.getDate(t468.minX);
                        e354.xaxis.labels.datetimeUTC ? a212.setUTCDate(a212.getUTCDate() - 2) : a212.setDate(a212.getDate() - 2), t468.minX = new Date(a212).getTime();
                        var s171 = i266.getDate(t468.maxX);
                        e354.xaxis.labels.datetimeUTC ? s171.setUTCDate(s171.getUTCDate() + 2) : s171.setDate(s171.getDate() + 2), t468.maxX = new Date(s171).getTime();
                    } else ("numeric" === e354.xaxis.type || "category" === e354.xaxis.type && !t468.noLabelsProvided) && (t468.minX = t468.minX - 2, t468.initialMinX = t468.minX, t468.maxX = t468.maxX + 2, t468.initialMaxX = t468.maxX);
                }
            }
        },
        {
            key: "_getMinXDiff",
            value: function() {
                var t469 = this.w.globals;
                t469.isXNumeric && t469.seriesX.forEach(function(e355, i267) {
                    1 === e355.length && e355.push(t469.seriesX[t469.maxValsInArrayIndex][t469.seriesX[t469.maxValsInArrayIndex].length - 1]);
                    var a213 = e355.slice();
                    a213.sort(function(t470, e356) {
                        return t470 - e356;
                    }), a213.forEach(function(e357, i268) {
                        if (i268 > 0) {
                            var s172 = e357 - a213[i268 - 1];
                            s172 > 0 && (t469.minXDiff = Math.min(s172, t469.minXDiff));
                        }
                    }), 1 !== t469.dataPoints && t469.minXDiff !== Number.MAX_VALUE || (t469.minXDiff = .5);
                });
            }
        },
        {
            key: "_setStackedMinMax",
            value: function() {
                var t471 = this.w.globals, e358 = [], i269 = [];
                if (t471.series.length) for(var a214 = 0; a214 < t471.series[t471.maxValsInArrayIndex].length; a214++)for(var s173 = 0, r146 = 0, o126 = 0; o126 < t471.series.length; o126++)null !== t471.series[o126][a214] && x.isNumber(t471.series[o126][a214]) && (t471.series[o126][a214] > 0 ? s173 = s173 + parseFloat(t471.series[o126][a214]) + 1e-4 : r146 += parseFloat(t471.series[o126][a214])), o126 === t471.series.length - 1 && (e358.push(s173), i269.push(r146));
                for(var n111 = 0; n111 < e358.length; n111++)t471.maxY = Math.max(t471.maxY, e358[n111]), t471.minY = Math.min(t471.minY, i269[n111]);
            }
        }
    ]), t461;
}(), $ = function() {
    function t472(e359) {
        a(this, t472), this.ctx = e359, this.w = e359.w;
        var i270 = this.w;
        this.xaxisFontSize = i270.config.xaxis.labels.style.fontSize, this.axisFontFamily = i270.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i270.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = "bar" === i270.config.chart.type && i270.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, "bottom" === i270.config.xaxis.position && (this.xAxisoffX = i270.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new G(e359);
    }
    return r(t472, [
        {
            key: "drawYaxis",
            value: function(t473) {
                var e360 = this, i271 = this.w, a215 = new m(this.ctx), s174 = i271.config.yaxis[t473].labels.style, r147 = s174.fontSize, o127 = s174.fontFamily, n112 = s174.fontWeight, l89 = a215.group({
                    class: "apexcharts-yaxis",
                    rel: t473,
                    transform: "translate(" + i271.globals.translateYAxisX[t473] + ", 0)"
                });
                if (this.axesUtils.isYAxisHidden(t473)) return l89;
                var h81 = a215.group({
                    class: "apexcharts-yaxis-texts-g"
                });
                l89.add(h81);
                var c68 = i271.globals.yAxisScale[t473].result.length - 1, d61 = i271.globals.gridHeight / c68, g52 = i271.globals.translateY, u41 = i271.globals.yLabelFormatters[t473], p34 = i271.globals.yAxisScale[t473].result.slice();
                p34 = this.axesUtils.checkForReversedLabels(t473, p34);
                var f30 = "";
                if (i271.config.yaxis[t473].labels.show) for(var x23 = function(l90) {
                    var x24 = p34[l90];
                    x24 = u41(x24, l90, i271);
                    var b24 = i271.config.yaxis[t473].labels.padding;
                    i271.config.yaxis[t473].opposite && 0 !== i271.config.yaxis.length && (b24 *= -1);
                    var v17 = e360.axesUtils.getYAxisForeColor(s174.colors, t473), m6 = a215.drawText({
                        x: b24,
                        y: g52 + c68 / 10 + i271.config.yaxis[t473].labels.offsetY + 1,
                        text: x24,
                        textAnchor: i271.config.yaxis[t473].opposite ? "start" : "end",
                        fontSize: r147,
                        fontFamily: o127,
                        fontWeight: n112,
                        foreColor: Array.isArray(v17) ? v17[l90] : v17,
                        isPlainText: !1,
                        cssClass: "apexcharts-yaxis-label " + s174.cssClass
                    });
                    l90 === c68 && (f30 = m6), h81.add(m6);
                    var y17 = document.createElementNS(i271.globals.SVGNS, "title");
                    if (y17.textContent = Array.isArray(x24) ? x24.join(" ") : x24, m6.node.appendChild(y17), 0 !== i271.config.yaxis[t473].labels.rotate) {
                        var w15 = a215.rotateAroundCenter(f30.node), k14 = a215.rotateAroundCenter(m6.node);
                        m6.node.setAttribute("transform", "rotate(".concat(i271.config.yaxis[t473].labels.rotate, " ").concat(w15.x, " ").concat(k14.y, ")"));
                    }
                    g52 += d61;
                }, b23 = c68; b23 >= 0; b23--)x23(b23);
                if (void 0 !== i271.config.yaxis[t473].title.text) {
                    var v16 = a215.group({
                        class: "apexcharts-yaxis-title"
                    }), y16 = 0;
                    i271.config.yaxis[t473].opposite && (y16 = i271.globals.translateYAxisX[t473]);
                    var w14 = a215.drawText({
                        x: y16,
                        y: i271.globals.gridHeight / 2 + i271.globals.translateY + i271.config.yaxis[t473].title.offsetY,
                        text: i271.config.yaxis[t473].title.text,
                        textAnchor: "end",
                        foreColor: i271.config.yaxis[t473].title.style.color,
                        fontSize: i271.config.yaxis[t473].title.style.fontSize,
                        fontWeight: i271.config.yaxis[t473].title.style.fontWeight,
                        fontFamily: i271.config.yaxis[t473].title.style.fontFamily,
                        cssClass: "apexcharts-yaxis-title-text " + i271.config.yaxis[t473].title.style.cssClass
                    });
                    v16.add(w14), l89.add(v16);
                }
                var k13 = i271.config.yaxis[t473].axisBorder, A10 = 31 + k13.offsetX;
                if (i271.config.yaxis[t473].opposite && (A10 = -31 - k13.offsetX), k13.show) {
                    var S8 = a215.drawLine(A10, i271.globals.translateY + k13.offsetY - 2, A10, i271.globals.gridHeight + i271.globals.translateY + k13.offsetY + 2, k13.color, 0, k13.width);
                    l89.add(S8);
                }
                return i271.config.yaxis[t473].axisTicks.show && this.axesUtils.drawYAxisTicks(A10, c68, k13, i271.config.yaxis[t473].axisTicks, t473, d61, l89), l89;
            }
        },
        {
            key: "drawYaxisInversed",
            value: function(t474) {
                var e361 = this.w, i272 = new m(this.ctx), a216 = i272.group({
                    class: "apexcharts-xaxis apexcharts-yaxis-inversed"
                }), s175 = i272.group({
                    class: "apexcharts-xaxis-texts-g",
                    transform: "translate(".concat(e361.globals.translateXAxisX, ", ").concat(e361.globals.translateXAxisY, ")")
                });
                a216.add(s175);
                var r148 = e361.globals.yAxisScale[t474].result.length - 1, o128 = e361.globals.gridWidth / r148 + .1, n113 = o128 + e361.config.xaxis.labels.offsetX, l91 = e361.globals.xLabelFormatter, h82 = e361.globals.yAxisScale[t474].result.slice(), c69 = e361.globals.timescaleLabels;
                c69.length > 0 && (this.xaxisLabels = c69.slice(), r148 = (h82 = c69.slice()).length), h82 = this.axesUtils.checkForReversedLabels(t474, h82);
                var d62 = c69.length;
                if (e361.config.xaxis.labels.show) for(var g53 = d62 ? 0 : r148; d62 ? g53 < d62 : g53 >= 0; d62 ? g53++ : g53--){
                    var u42 = h82[g53];
                    u42 = l91(u42, g53, e361);
                    var p35 = e361.globals.gridWidth + e361.globals.padHorizontal - (n113 - o128 + e361.config.xaxis.labels.offsetX);
                    if (c69.length) {
                        var f31 = this.axesUtils.getLabel(h82, c69, p35, g53, this.drawnLabels, this.xaxisFontSize);
                        p35 = f31.x, u42 = f31.text, this.drawnLabels.push(f31.text), 0 === g53 && e361.globals.skipFirstTimelinelabel && (u42 = ""), g53 === h82.length - 1 && e361.globals.skipLastTimelinelabel && (u42 = "");
                    }
                    var x25 = i272.drawText({
                        x: p35,
                        y: this.xAxisoffX + e361.config.xaxis.labels.offsetY + 30 - ("top" === e361.config.xaxis.position ? e361.globals.xAxisHeight + e361.config.xaxis.axisTicks.height - 2 : 0),
                        text: u42,
                        textAnchor: "middle",
                        foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t474] : this.xaxisForeColors,
                        fontSize: this.xaxisFontSize,
                        fontFamily: this.xaxisFontFamily,
                        fontWeight: e361.config.xaxis.labels.style.fontWeight,
                        isPlainText: !1,
                        cssClass: "apexcharts-xaxis-label " + e361.config.xaxis.labels.style.cssClass
                    });
                    s175.add(x25), x25.tspan(u42);
                    var b25 = document.createElementNS(e361.globals.SVGNS, "title");
                    b25.textContent = u42, x25.node.appendChild(b25), n113 += o128;
                }
                return this.inversedYAxisTitleText(a216), this.inversedYAxisBorder(a216), a216;
            }
        },
        {
            key: "inversedYAxisBorder",
            value: function(t475) {
                var e362 = this.w, i273 = new m(this.ctx), a217 = e362.config.xaxis.axisBorder;
                if (a217.show) {
                    var s176 = 0;
                    "bar" === e362.config.chart.type && e362.globals.isXNumeric && (s176 -= 15);
                    var r149 = i273.drawLine(e362.globals.padHorizontal + s176 + a217.offsetX, this.xAxisoffX, e362.globals.gridWidth, this.xAxisoffX, a217.color, 0, a217.height);
                    t475.add(r149);
                }
            }
        },
        {
            key: "inversedYAxisTitleText",
            value: function(t476) {
                var e363 = this.w, i274 = new m(this.ctx);
                if (void 0 !== e363.config.xaxis.title.text) {
                    var a218 = i274.group({
                        class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed"
                    }), s177 = i274.drawText({
                        x: e363.globals.gridWidth / 2 + e363.config.xaxis.title.offsetX,
                        y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e363.config.xaxis.title.style.fontSize) + e363.config.xaxis.title.offsetY + 20,
                        text: e363.config.xaxis.title.text,
                        textAnchor: "middle",
                        fontSize: e363.config.xaxis.title.style.fontSize,
                        fontFamily: e363.config.xaxis.title.style.fontFamily,
                        fontWeight: e363.config.xaxis.title.style.fontWeight,
                        foreColor: e363.config.xaxis.title.style.color,
                        cssClass: "apexcharts-xaxis-title-text " + e363.config.xaxis.title.style.cssClass
                    });
                    a218.add(s177), t476.add(a218);
                }
            }
        },
        {
            key: "yAxisTitleRotate",
            value: function(t477, e364) {
                var i275 = this.w, a219 = new m(this.ctx), s178 = {
                    width: 0,
                    height: 0
                }, r150 = {
                    width: 0,
                    height: 0
                }, o129 = i275.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t477, "'] .apexcharts-yaxis-texts-g"));
                null !== o129 && (s178 = o129.getBoundingClientRect());
                var n114 = i275.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t477, "'] .apexcharts-yaxis-title text"));
                if (null !== n114 && (r150 = n114.getBoundingClientRect()), null !== n114) {
                    var l92 = this.xPaddingForYAxisTitle(t477, s178, r150, e364);
                    n114.setAttribute("x", l92.xPos - (e364 ? 10 : 0));
                }
                if (null !== n114) {
                    var h83 = a219.rotateAroundCenter(n114);
                    n114.setAttribute("transform", "rotate(".concat(e364 ? -1 * i275.config.yaxis[t477].title.rotate : i275.config.yaxis[t477].title.rotate, " ").concat(h83.x, " ").concat(h83.y, ")"));
                }
            }
        },
        {
            key: "xPaddingForYAxisTitle",
            value: function(t478, e365, i276, a220) {
                var s179 = this.w, r151 = 0, o130 = 0, n115 = 10;
                return void 0 === s179.config.yaxis[t478].title.text || t478 < 0 ? {
                    xPos: o130,
                    padd: 0
                } : (a220 ? (o130 = e365.width + s179.config.yaxis[t478].title.offsetX + i276.width / 2 + n115 / 2, 0 === (r151 += 1) && (o130 -= n115 / 2)) : (o130 = -1 * e365.width + s179.config.yaxis[t478].title.offsetX + n115 / 2 + i276.width / 2, s179.globals.isBarHorizontal && (n115 = 25, o130 = -1 * e365.width - s179.config.yaxis[t478].title.offsetX - n115)), {
                    xPos: o130,
                    padd: n115
                });
            }
        },
        {
            key: "setYAxisXPosition",
            value: function(t479, e366) {
                var i277 = this.w, a221 = 0, s180 = 0, r152 = 18, o131 = 1;
                i277.config.yaxis.length > 1 && (this.multipleYs = !0), i277.config.yaxis.map(function(n116, l93) {
                    var h84 = i277.globals.ignoreYAxisIndexes.indexOf(l93) > -1 || !n116.show || n116.floating || 0 === t479[l93].width, c70 = t479[l93].width + e366[l93].width;
                    n116.opposite ? i277.globals.isBarHorizontal ? (s180 = i277.globals.gridWidth + i277.globals.translateX - 1, i277.globals.translateYAxisX[l93] = s180 - n116.labels.offsetX) : (s180 = i277.globals.gridWidth + i277.globals.translateX + o131, h84 || (o131 = o131 + c70 + 20), i277.globals.translateYAxisX[l93] = s180 - n116.labels.offsetX + 20) : (a221 = i277.globals.translateX - r152, h84 || (r152 = r152 + c70 + 20), i277.globals.translateYAxisX[l93] = a221 + n116.labels.offsetX);
                });
            }
        },
        {
            key: "setYAxisTextAlignments",
            value: function() {
                var t480 = this.w, e367 = t480.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
                (e367 = x.listToArray(e367)).forEach(function(e, i278) {
                    var a222 = t480.config.yaxis[i278];
                    if (a222 && void 0 !== a222.labels.align) {
                        var s181 = t480.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i278, "'] .apexcharts-yaxis-texts-g")), r153 = t480.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i278, "'] .apexcharts-yaxis-label"));
                        r153 = x.listToArray(r153);
                        var o132 = s181.getBoundingClientRect();
                        "left" === a222.labels.align ? (r153.forEach(function(t481, e) {
                            t481.setAttribute("text-anchor", "start");
                        }), a222.opposite || s181.setAttribute("transform", "translate(-".concat(o132.width, ", 0)"))) : "center" === a222.labels.align ? (r153.forEach(function(t482, e) {
                            t482.setAttribute("text-anchor", "middle");
                        }), s181.setAttribute("transform", "translate(".concat(o132.width / 2 * (a222.opposite ? 1 : -1), ", 0)"))) : "right" === a222.labels.align && (r153.forEach(function(t483, e) {
                            t483.setAttribute("text-anchor", "end");
                        }), a222.opposite && s181.setAttribute("transform", "translate(".concat(o132.width, ", 0)")));
                    }
                });
            }
        }
    ]), t472;
}(), J = function() {
    function t484(e368) {
        a(this, t484), this.ctx = e368, this.w = e368.w, this.documentEvent = x.bind(this.documentEvent, this);
    }
    return r(t484, [
        {
            key: "addEventListener",
            value: function(t485, e369) {
                var i279 = this.w;
                i279.globals.events.hasOwnProperty(t485) ? i279.globals.events[t485].push(e369) : i279.globals.events[t485] = [
                    e369
                ];
            }
        },
        {
            key: "removeEventListener",
            value: function(t486, e370) {
                var i280 = this.w;
                if (i280.globals.events.hasOwnProperty(t486)) {
                    var a223 = i280.globals.events[t486].indexOf(e370);
                    -1 !== a223 && i280.globals.events[t486].splice(a223, 1);
                }
            }
        },
        {
            key: "fireEvent",
            value: function(t487, e371) {
                var i281 = this.w;
                if (i281.globals.events.hasOwnProperty(t487)) {
                    e371 && e371.length || (e371 = []);
                    for(var a224 = i281.globals.events[t487], s182 = a224.length, r154 = 0; r154 < s182; r154++)a224[r154].apply(null, e371);
                }
            }
        },
        {
            key: "setupEventHandlers",
            value: function() {
                var t488 = this, e372 = this.w, i282 = this.ctx, a225 = e372.globals.dom.baseEl.querySelector(e372.globals.chartClass);
                this.ctx.eventList.forEach(function(t489) {
                    a225.addEventListener(t489, function(t490) {
                        var a226 = Object.assign({}, e372, {
                            seriesIndex: e372.globals.capturedSeriesIndex,
                            dataPointIndex: e372.globals.capturedDataPointIndex
                        });
                        "mousemove" === t490.type || "touchmove" === t490.type ? "function" == typeof e372.config.chart.events.mouseMove && e372.config.chart.events.mouseMove(t490, i282, a226) : "mouseleave" === t490.type || "touchleave" === t490.type ? "function" == typeof e372.config.chart.events.mouseLeave && e372.config.chart.events.mouseLeave(t490, i282, a226) : ("mouseup" === t490.type && 1 === t490.which || "touchend" === t490.type) && ("function" == typeof e372.config.chart.events.click && e372.config.chart.events.click(t490, i282, a226), i282.ctx.events.fireEvent("click", [
                            t490,
                            i282,
                            a226
                        ]));
                    }, {
                        capture: !1,
                        passive: !0
                    });
                }), this.ctx.eventList.forEach(function(i283) {
                    e372.globals.dom.baseEl.addEventListener(i283, t488.documentEvent, {
                        passive: !0
                    });
                }), this.ctx.core.setupBrushHandler();
            }
        },
        {
            key: "documentEvent",
            value: function(t491) {
                var e373 = this.w, i284 = t491.target.className;
                if ("click" === t491.type) {
                    var a227 = e373.globals.dom.baseEl.querySelector(".apexcharts-menu");
                    a227 && a227.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== i284 && a227.classList.remove("apexcharts-menu-open");
                }
                e373.globals.clientX = "touchmove" === t491.type ? t491.touches[0].clientX : t491.clientX, e373.globals.clientY = "touchmove" === t491.type ? t491.touches[0].clientY : t491.clientY;
            }
        }
    ]), t484;
}(), Q = function() {
    function t492(e374) {
        a(this, t492), this.ctx = e374, this.w = e374.w;
    }
    return r(t492, [
        {
            key: "setCurrentLocaleValues",
            value: function(t493) {
                var e375 = this.w.config.chart.locales;
                window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e375 = this.w.config.chart.locales.concat(window.Apex.chart.locales));
                var i285 = e375.filter(function(e376) {
                    return e376.name === t493;
                })[0];
                if (!i285) throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
                var a228 = x.extend(C, i285);
                this.w.globals.locale = a228.options;
            }
        }
    ]), t492;
}(), K = function() {
    function t494(e377) {
        a(this, t494), this.ctx = e377, this.w = e377.w;
    }
    return r(t494, [
        {
            key: "drawAxis",
            value: function(t495, e378) {
                var i286, a229, s183 = this.w.globals, r155 = this.w.config, o133 = new _(this.ctx), n117 = new $(this.ctx);
                s183.axisCharts && "radar" !== t495 && (s183.isBarHorizontal ? (a229 = n117.drawYaxisInversed(0), i286 = o133.drawXaxisInversed(0), s183.dom.elGraphical.add(i286), s183.dom.elGraphical.add(a229)) : (i286 = o133.drawXaxis(), s183.dom.elGraphical.add(i286), r155.yaxis.map(function(t, e379) {
                    -1 === s183.ignoreYAxisIndexes.indexOf(e379) && (a229 = n117.drawYaxis(e379), s183.dom.Paper.add(a229));
                })));
            }
        }
    ]), t494;
}(), tt = function() {
    function t496(e380) {
        a(this, t496), this.ctx = e380, this.w = e380.w;
    }
    return r(t496, [
        {
            key: "drawXCrosshairs",
            value: function() {
                var t497 = this.w, e381 = new m(this.ctx), i287 = new v(this.ctx), a230 = t497.config.xaxis.crosshairs.fill.gradient, s184 = t497.config.xaxis.crosshairs.dropShadow, r156 = t497.config.xaxis.crosshairs.fill.type, o134 = a230.colorFrom, n118 = a230.colorTo, l94 = a230.opacityFrom, h85 = a230.opacityTo, c71 = a230.stops, d63 = s184.enabled, g54 = s184.left, u43 = s184.top, p36 = s184.blur, f32 = s184.color, b26 = s184.opacity, y18 = t497.config.xaxis.crosshairs.fill.color;
                if (t497.config.xaxis.crosshairs.show) {
                    "gradient" === r156 && (y18 = e381.drawGradient("vertical", o134, n118, l94, h85, null, c71, null));
                    var w16 = e381.drawRect();
                    1 === t497.config.xaxis.crosshairs.width && (w16 = e381.drawLine());
                    var k15 = t497.globals.gridHeight;
                    (!x.isNumber(k15) || k15 < 0) && (k15 = 0);
                    var A11 = t497.config.xaxis.crosshairs.width;
                    (!x.isNumber(A11) || A11 < 0) && (A11 = 0), w16.attr({
                        class: "apexcharts-xcrosshairs",
                        x: 0,
                        y: 0,
                        y2: k15,
                        width: A11,
                        height: k15,
                        fill: y18,
                        filter: "none",
                        "fill-opacity": t497.config.xaxis.crosshairs.opacity,
                        stroke: t497.config.xaxis.crosshairs.stroke.color,
                        "stroke-width": t497.config.xaxis.crosshairs.stroke.width,
                        "stroke-dasharray": t497.config.xaxis.crosshairs.stroke.dashArray
                    }), d63 && (w16 = i287.dropShadow(w16, {
                        left: g54,
                        top: u43,
                        blur: p36,
                        color: f32,
                        opacity: b26
                    })), t497.globals.dom.elGraphical.add(w16);
                }
            }
        },
        {
            key: "drawYCrosshairs",
            value: function() {
                var t498 = this.w, e382 = new m(this.ctx), i288 = t498.config.yaxis[0].crosshairs, a231 = t498.globals.barPadForNumericAxis;
                if (t498.config.yaxis[0].crosshairs.show) {
                    var s185 = e382.drawLine(-a231, 0, t498.globals.gridWidth + a231, 0, i288.stroke.color, i288.stroke.dashArray, i288.stroke.width);
                    s185.attr({
                        class: "apexcharts-ycrosshairs"
                    }), t498.globals.dom.elGraphical.add(s185);
                }
                var r157 = e382.drawLine(-a231, 0, t498.globals.gridWidth + a231, 0, i288.stroke.color, 0, 0);
                r157.attr({
                    class: "apexcharts-ycrosshairs-hidden"
                }), t498.globals.dom.elGraphical.add(r157);
            }
        }
    ]), t496;
}(), et = function() {
    function t499(e383) {
        a(this, t499), this.ctx = e383, this.w = e383.w;
    }
    return r(t499, [
        {
            key: "checkResponsiveConfig",
            value: function(t500) {
                var e384 = this, i289 = this.w, a232 = i289.config;
                if (0 !== a232.responsive.length) {
                    var s186 = a232.responsive.slice();
                    s186.sort(function(t501, e385) {
                        return t501.breakpoint > e385.breakpoint ? 1 : e385.breakpoint > t501.breakpoint ? -1 : 0;
                    }).reverse();
                    var r158 = new N({}), o135 = function() {
                        var t502 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, a233 = s186[0].breakpoint, o137 = window.innerWidth > 0 ? window.innerWidth : screen.width;
                        if (o137 > a233) {
                            var n121 = y.extendArrayProps(r158, i289.globals.initialConfig, i289);
                            t502 = x.extend(n121, t502), t502 = x.extend(i289.config, t502), e384.overrideResponsiveOptions(t502);
                        } else for(var l95 = 0; l95 < s186.length; l95++)o137 < s186[l95].breakpoint && (t502 = y.extendArrayProps(r158, s186[l95].options, i289), t502 = x.extend(i289.config, t502), e384.overrideResponsiveOptions(t502));
                    };
                    if (t500) {
                        var n119 = y.extendArrayProps(r158, t500, i289);
                        n119 = x.extend(i289.config, n119), o135(n119 = x.extend(n119, t500));
                    } else o135({});
                }
            }
        },
        {
            key: "overrideResponsiveOptions",
            value: function(t503) {
                var e386 = new N(t503).init({
                    responsiveOverride: !0
                });
                this.w.config = e386;
            }
        }
    ]), t499;
}(), it = function() {
    function t504(e387) {
        a(this, t504), this.ctx = e387, this.colors = [], this.w = e387.w;
        var i290 = this.w;
        this.isColorFn = !1, this.isHeatmapDistributed = "treemap" === i290.config.chart.type && i290.config.plotOptions.treemap.distributed || "heatmap" === i290.config.chart.type && i290.config.plotOptions.heatmap.distributed, this.isBarDistributed = i290.config.plotOptions.bar.distributed && ("bar" === i290.config.chart.type || "rangeBar" === i290.config.chart.type);
    }
    return r(t504, [
        {
            key: "init",
            value: function() {
                this.setDefaultColors();
            }
        },
        {
            key: "setDefaultColors",
            value: function() {
                var t505 = this, e388 = this.w, i291 = new x;
                if (e388.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(e388.config.theme.mode)), void 0 === e388.config.colors ? e388.globals.colors = this.predefined() : (e388.globals.colors = e388.config.colors, Array.isArray(e388.config.colors) && e388.config.colors.length > 0 && "function" == typeof e388.config.colors[0] && (e388.globals.colors = e388.config.series.map(function(i, a235) {
                    var s188 = e388.config.colors[a235];
                    return s188 || (s188 = e388.config.colors[0]), "function" == typeof s188 ? (t505.isColorFn = !0, s188({
                        value: e388.globals.axisCharts ? e388.globals.series[a235][0] ? e388.globals.series[a235][0] : 0 : e388.globals.series[a235],
                        seriesIndex: a235,
                        dataPointIndex: a235,
                        w: e388
                    })) : s188;
                }))), e388.globals.seriesColors.map(function(t506, i292) {
                    t506 && (e388.globals.colors[i292] = t506);
                }), e388.config.theme.monochrome.enabled) {
                    var a234 = [], s187 = e388.globals.series.length;
                    (this.isBarDistributed || this.isHeatmapDistributed) && (s187 = e388.globals.series[0].length * e388.globals.series.length);
                    for(var r159 = e388.config.theme.monochrome.color, o138 = 1 / (s187 / e388.config.theme.monochrome.shadeIntensity), n122 = e388.config.theme.monochrome.shadeTo, l96 = 0, h86 = 0; h86 < s187; h86++){
                        var c72 = void 0;
                        "dark" === n122 ? (c72 = i291.shadeColor(-1 * l96, r159), l96 += o138) : (c72 = i291.shadeColor(l96, r159), l96 += o138), a234.push(c72);
                    }
                    e388.globals.colors = a234.slice();
                }
                var d64 = e388.globals.colors.slice();
                this.pushExtraColors(e388.globals.colors);
                [
                    "fill",
                    "stroke"
                ].forEach(function(i293) {
                    void 0 === e388.config[i293].colors ? e388.globals[i293].colors = t505.isColorFn ? e388.config.colors : d64 : e388.globals[i293].colors = e388.config[i293].colors.slice(), t505.pushExtraColors(e388.globals[i293].colors);
                }), void 0 === e388.config.dataLabels.style.colors ? e388.globals.dataLabels.style.colors = d64 : e388.globals.dataLabels.style.colors = e388.config.dataLabels.style.colors.slice(), this.pushExtraColors(e388.globals.dataLabels.style.colors, 50), void 0 === e388.config.plotOptions.radar.polygons.fill.colors ? e388.globals.radarPolygons.fill.colors = [
                    "dark" === e388.config.theme.mode ? "#424242" : "none"
                ] : e388.globals.radarPolygons.fill.colors = e388.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(e388.globals.radarPolygons.fill.colors, 20), void 0 === e388.config.markers.colors ? e388.globals.markers.colors = d64 : e388.globals.markers.colors = e388.config.markers.colors.slice(), this.pushExtraColors(e388.globals.markers.colors);
            }
        },
        {
            key: "pushExtraColors",
            value: function(t507, e389) {
                var i294 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a236 = this.w, s189 = e389 || a236.globals.series.length;
                if (null === i294 && (i294 = this.isBarDistributed || this.isHeatmapDistributed || "heatmap" === a236.config.chart.type && a236.config.plotOptions.heatmap.colorScale.inverse), i294 && a236.globals.series.length && (s189 = a236.globals.series[a236.globals.maxValsInArrayIndex].length * a236.globals.series.length), t507.length < s189) for(var r160 = s189 - t507.length, o139 = 0; o139 < r160; o139++)t507.push(t507[o139]);
            }
        },
        {
            key: "updateThemeOptions",
            value: function(t508) {
                t508.chart = t508.chart || {}, t508.tooltip = t508.tooltip || {};
                var e390 = t508.theme.mode || "light", i295 = t508.theme.palette ? t508.theme.palette : "dark" === e390 ? "palette4" : "palette1", a237 = t508.chart.foreColor ? t508.chart.foreColor : "dark" === e390 ? "#f6f7f8" : "#373d3f";
                return t508.tooltip.theme = e390, t508.chart.foreColor = a237, t508.theme.palette = i295, t508;
            }
        },
        {
            key: "predefined",
            value: function() {
                switch(this.w.config.theme.palette){
                    case "palette1":
                        this.colors = [
                            "#008FFB",
                            "#00E396",
                            "#FEB019",
                            "#FF4560",
                            "#775DD0"
                        ];
                        break;
                    case "palette2":
                        this.colors = [
                            "#3f51b5",
                            "#03a9f4",
                            "#4caf50",
                            "#f9ce1d",
                            "#FF9800"
                        ];
                        break;
                    case "palette3":
                        this.colors = [
                            "#33b2df",
                            "#546E7A",
                            "#d4526e",
                            "#13d8aa",
                            "#A5978B"
                        ];
                        break;
                    case "palette4":
                        this.colors = [
                            "#4ecdc4",
                            "#c7f464",
                            "#81D4FA",
                            "#fd6a6a",
                            "#546E7A"
                        ];
                        break;
                    case "palette5":
                        this.colors = [
                            "#2b908f",
                            "#f9a3a4",
                            "#90ee7e",
                            "#fa4443",
                            "#69d2e7"
                        ];
                        break;
                    case "palette6":
                        this.colors = [
                            "#449DD1",
                            "#F86624",
                            "#EA3546",
                            "#662E9B",
                            "#C5D86D"
                        ];
                        break;
                    case "palette7":
                        this.colors = [
                            "#D7263D",
                            "#1B998B",
                            "#2E294E",
                            "#F46036",
                            "#E2C044"
                        ];
                        break;
                    case "palette8":
                        this.colors = [
                            "#662E9B",
                            "#F86624",
                            "#F9C80E",
                            "#EA3546",
                            "#43BCCD"
                        ];
                        break;
                    case "palette9":
                        this.colors = [
                            "#5C4742",
                            "#A5978B",
                            "#8D5B4C",
                            "#5A2A27",
                            "#C4BBAF"
                        ];
                        break;
                    case "palette10":
                        this.colors = [
                            "#A300D6",
                            "#7D02EB",
                            "#5653FE",
                            "#2983FF",
                            "#00B1F2"
                        ];
                        break;
                    default:
                        this.colors = [
                            "#008FFB",
                            "#00E396",
                            "#FEB019",
                            "#FF4560",
                            "#775DD0"
                        ];
                }
                return this.colors;
            }
        }
    ]), t504;
}(), at = function() {
    function t509(e391) {
        a(this, t509), this.ctx = e391, this.w = e391.w;
    }
    return r(t509, [
        {
            key: "draw",
            value: function() {
                this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
            }
        },
        {
            key: "drawTitleSubtitle",
            value: function(t510) {
                var e392 = this.w, i296 = "title" === t510 ? e392.config.title : e392.config.subtitle, a238 = e392.globals.svgWidth / 2, s190 = i296.offsetY, r161 = "middle";
                if ("left" === i296.align ? (a238 = 10, r161 = "start") : "right" === i296.align && (a238 = e392.globals.svgWidth - 10, r161 = "end"), a238 += i296.offsetX, s190 = s190 + parseInt(i296.style.fontSize, 10) + i296.margin / 2, void 0 !== i296.text) {
                    var o140 = new m(this.ctx).drawText({
                        x: a238,
                        y: s190,
                        text: i296.text,
                        textAnchor: r161,
                        fontSize: i296.style.fontSize,
                        fontFamily: i296.style.fontFamily,
                        fontWeight: i296.style.fontWeight,
                        foreColor: i296.style.color,
                        opacity: 1
                    });
                    o140.node.setAttribute("class", "apexcharts-".concat(t510, "-text")), e392.globals.dom.Paper.add(o140);
                }
            }
        }
    ]), t509;
}(), st = function() {
    function t511(e393) {
        a(this, t511), this.w = e393.w, this.dCtx = e393;
    }
    return r(t511, [
        {
            key: "getTitleSubtitleCoords",
            value: function(t512) {
                var e394 = this.w, i297 = 0, a239 = 0, s191 = "title" === t512 ? e394.config.title.floating : e394.config.subtitle.floating, r162 = e394.globals.dom.baseEl.querySelector(".apexcharts-".concat(t512, "-text"));
                if (null !== r162 && !s191) {
                    var o141 = r162.getBoundingClientRect();
                    i297 = o141.width, a239 = e394.globals.axisCharts ? o141.height + 5 : o141.height;
                }
                return {
                    width: i297,
                    height: a239
                };
            }
        },
        {
            key: "getLegendsRect",
            value: function() {
                var t513 = this.w, e395 = t513.globals.dom.baseEl.querySelector(".apexcharts-legend");
                t513.config.legend.height || "top" !== t513.config.legend.position && "bottom" !== t513.config.legend.position || (e395.style.maxHeight = t513.globals.svgHeight / 2 + "px");
                var i298 = Object.assign({}, x.getBoundingClientRect(e395));
                return null !== e395 && !t513.config.legend.floating && t513.config.legend.show ? this.dCtx.lgRect = {
                    x: i298.x,
                    y: i298.y,
                    height: i298.height,
                    width: 0 === i298.height ? 0 : i298.width
                } : this.dCtx.lgRect = {
                    x: 0,
                    y: 0,
                    height: 0,
                    width: 0
                }, "left" !== t513.config.legend.position && "right" !== t513.config.legend.position || 1.5 * this.dCtx.lgRect.width > t513.globals.svgWidth && (this.dCtx.lgRect.width = t513.globals.svgWidth / 1.5), this.dCtx.lgRect;
            }
        },
        {
            key: "getLargestStringFromMultiArr",
            value: function(t514, e396) {
                var i299 = t514;
                if (this.w.globals.isMultiLineX) {
                    var a240 = e396.map(function(t515, e) {
                        return Array.isArray(t515) ? t515.length : 1;
                    }), s192 = Math.max.apply(Math, u(a240));
                    i299 = e396[a240.indexOf(s192)];
                }
                return i299;
            }
        }
    ]), t511;
}(), rt = function() {
    function t516(e397) {
        a(this, t516), this.w = e397.w, this.dCtx = e397;
    }
    return r(t516, [
        {
            key: "getxAxisLabelsCoords",
            value: function() {
                var t517, e398 = this.w, i300 = e398.globals.labels.slice();
                if (e398.config.xaxis.convertedCatToNumeric && 0 === i300.length && (i300 = e398.globals.categoryLabels), e398.globals.timescaleLabels.length > 0) {
                    var a241 = this.getxAxisTimeScaleLabelsCoords();
                    t517 = {
                        width: a241.width,
                        height: a241.height
                    }, e398.globals.rotateXLabels = !1;
                } else {
                    this.dCtx.lgWidthForSideLegends = "left" !== e398.config.legend.position && "right" !== e398.config.legend.position || e398.config.legend.floating ? 0 : this.dCtx.lgRect.width;
                    var s193 = e398.globals.xLabelFormatter, r163 = x.getLargestStringFromArr(i300), o142 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r163, i300);
                    e398.globals.isBarHorizontal && (o142 = r163 = e398.globals.yAxisScale[0].result.reduce(function(t518, e399) {
                        return t518.length > e399.length ? t518 : e399;
                    }, 0));
                    var n123 = new V(this.dCtx.ctx), l97 = r163;
                    r163 = n123.xLabelFormat(s193, r163, l97, {
                        i: void 0,
                        dateFormatter: new R(this.dCtx.ctx).formatDate,
                        w: e398
                    }), o142 = n123.xLabelFormat(s193, o142, l97, {
                        i: void 0,
                        dateFormatter: new R(this.dCtx.ctx).formatDate,
                        w: e398
                    }), (e398.config.xaxis.convertedCatToNumeric && void 0 === r163 || "" === String(r163).trim()) && (o142 = r163 = "1");
                    var h87 = new m(this.dCtx.ctx), c73 = h87.getTextRects(r163, e398.config.xaxis.labels.style.fontSize), d65 = c73;
                    if (r163 !== o142 && (d65 = h87.getTextRects(o142, e398.config.xaxis.labels.style.fontSize)), (t517 = {
                        width: c73.width >= d65.width ? c73.width : d65.width,
                        height: c73.height >= d65.height ? c73.height : d65.height
                    }).width * i300.length > e398.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== e398.config.xaxis.labels.rotate || e398.config.xaxis.labels.rotateAlways) {
                        if (!e398.globals.isBarHorizontal) {
                            e398.globals.rotateXLabels = !0;
                            var g55 = function(t519) {
                                return h87.getTextRects(t519, e398.config.xaxis.labels.style.fontSize, e398.config.xaxis.labels.style.fontFamily, "rotate(".concat(e398.config.xaxis.labels.rotate, " 0 0)"), !1);
                            };
                            c73 = g55(r163), r163 !== o142 && (d65 = g55(o142)), t517.height = (c73.height > d65.height ? c73.height : d65.height) / 1.5, t517.width = c73.width > d65.width ? c73.width : d65.width;
                        }
                    } else e398.globals.rotateXLabels = !1;
                }
                return e398.config.xaxis.labels.show || (t517 = {
                    width: 0,
                    height: 0
                }), {
                    width: t517.width,
                    height: t517.height
                };
            }
        },
        {
            key: "getxAxisGroupLabelsCoords",
            value: function() {
                var t520, e400 = this.w;
                if (!e400.globals.hasGroups) return {
                    width: 0,
                    height: 0
                };
                var i301, a242 = (null === (t520 = e400.config.xaxis.group.style) || void 0 === t520 ? void 0 : t520.fontSize) || e400.config.xaxis.labels.style.fontSize, s194 = e400.globals.groups.map(function(t521) {
                    return t521.title;
                }), r164 = x.getLargestStringFromArr(s194), o143 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r164, s194), n124 = new m(this.dCtx.ctx), l98 = n124.getTextRects(r164, a242), h88 = l98;
                return r164 !== o143 && (h88 = n124.getTextRects(o143, a242)), i301 = {
                    width: l98.width >= h88.width ? l98.width : h88.width,
                    height: l98.height >= h88.height ? l98.height : h88.height
                }, e400.config.xaxis.labels.show || (i301 = {
                    width: 0,
                    height: 0
                }), {
                    width: i301.width,
                    height: i301.height
                };
            }
        },
        {
            key: "getxAxisTitleCoords",
            value: function() {
                var t522 = this.w, e401 = 0, i302 = 0;
                if (void 0 !== t522.config.xaxis.title.text) {
                    var a243 = new m(this.dCtx.ctx).getTextRects(t522.config.xaxis.title.text, t522.config.xaxis.title.style.fontSize);
                    e401 = a243.width, i302 = a243.height;
                }
                return {
                    width: e401,
                    height: i302
                };
            }
        },
        {
            key: "getxAxisTimeScaleLabelsCoords",
            value: function() {
                var t523, e402 = this.w;
                this.dCtx.timescaleLabels = e402.globals.timescaleLabels.slice();
                var i303 = this.dCtx.timescaleLabels.map(function(t524) {
                    return t524.value;
                }), a244 = i303.reduce(function(t525, e403) {
                    return void 0 === t525 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : t525.length > e403.length ? t525 : e403;
                }, 0);
                return 1.05 * (t523 = new m(this.dCtx.ctx).getTextRects(a244, e402.config.xaxis.labels.style.fontSize)).width * i303.length > e402.globals.gridWidth && 0 !== e402.config.xaxis.labels.rotate && (e402.globals.overlappingXLabels = !0), t523;
            }
        },
        {
            key: "additionalPaddingXLabels",
            value: function(t526) {
                var e404 = this, i304 = this.w, a245 = i304.globals, s195 = i304.config, r165 = s195.xaxis.type, o144 = t526.width;
                a245.skipLastTimelinelabel = !1, a245.skipFirstTimelinelabel = !1;
                var n125 = i304.config.yaxis[0].opposite && i304.globals.isBarHorizontal, l99 = function(t527, n126) {
                    (function(t528) {
                        return -1 !== a245.collapsedSeriesIndices.indexOf(t528);
                    })(n126) || function(t529) {
                        if (e404.dCtx.timescaleLabels && e404.dCtx.timescaleLabels.length) {
                            var n127 = e404.dCtx.timescaleLabels[0], l100 = e404.dCtx.timescaleLabels[e404.dCtx.timescaleLabels.length - 1].position + o144 / 1.75 - e404.dCtx.yAxisWidthRight, h89 = n127.position - o144 / 1.75 + e404.dCtx.yAxisWidthLeft, c74 = "right" === i304.config.legend.position && e404.dCtx.lgRect.width > 0 ? e404.dCtx.lgRect.width : 0;
                            l100 > a245.svgWidth - a245.translateX - c74 && (a245.skipLastTimelinelabel = !0), h89 < -(t529.show && !t529.floating || "bar" !== s195.chart.type && "candlestick" !== s195.chart.type && "rangeBar" !== s195.chart.type && "boxPlot" !== s195.chart.type ? 10 : o144 / 1.75) && (a245.skipFirstTimelinelabel = !0);
                        } else "datetime" === r165 ? e404.dCtx.gridPad.right < o144 && !a245.rotateXLabels && (a245.skipLastTimelinelabel = !0) : "datetime" !== r165 && e404.dCtx.gridPad.right < o144 / 2 - e404.dCtx.yAxisWidthRight && !a245.rotateXLabels && !i304.config.xaxis.labels.trim && ("between" !== i304.config.xaxis.tickPlacement || i304.globals.isBarHorizontal) && (e404.dCtx.xPadRight = o144 / 2 + 1);
                    }(t527);
                };
                s195.yaxis.forEach(function(t530, i305) {
                    n125 ? (e404.dCtx.gridPad.left < o144 && (e404.dCtx.xPadLeft = o144 / 2 + 1), e404.dCtx.xPadRight = o144 / 2 + 1) : l99(t530, i305);
                });
            }
        }
    ]), t516;
}(), ot = function() {
    function t531(e405) {
        a(this, t531), this.w = e405.w, this.dCtx = e405;
    }
    return r(t531, [
        {
            key: "getyAxisLabelsCoords",
            value: function() {
                var t532 = this, e406 = this.w, i306 = [], a246 = 10, s196 = new G(this.dCtx.ctx);
                return e406.config.yaxis.map(function(r166, o145) {
                    var n128 = e406.globals.yAxisScale[o145], l101 = 0;
                    if (!s196.isYAxisHidden(o145) && r166.labels.show && void 0 !== r166.labels.minWidth && (l101 = r166.labels.minWidth), !s196.isYAxisHidden(o145) && r166.labels.show && n128.result.length) {
                        var h90 = e406.globals.yLabelFormatters[o145], c75 = n128.niceMin === Number.MIN_VALUE ? 0 : n128.niceMin, d66 = String(c75).length > String(n128.niceMax).length ? c75 : n128.niceMax, g56 = h90(d66, {
                            seriesIndex: o145,
                            dataPointIndex: -1,
                            w: e406
                        }), u44 = g56;
                        if (void 0 !== g56 && 0 !== g56.length || (g56 = d66), e406.globals.isBarHorizontal) {
                            a246 = 0;
                            var p37 = e406.globals.labels.slice();
                            g56 = h90(g56 = x.getLargestStringFromArr(p37), {
                                seriesIndex: o145,
                                dataPointIndex: -1,
                                w: e406
                            }), u44 = t532.dCtx.dimHelpers.getLargestStringFromMultiArr(g56, p37);
                        }
                        var f33 = new m(t532.dCtx.ctx), b27 = "rotate(".concat(r166.labels.rotate, " 0 0)"), v18 = f33.getTextRects(g56, r166.labels.style.fontSize, r166.labels.style.fontFamily, b27, !1), y19 = v18;
                        g56 !== u44 && (y19 = f33.getTextRects(u44, r166.labels.style.fontSize, r166.labels.style.fontFamily, b27, !1)), i306.push({
                            width: (l101 > y19.width || l101 > v18.width ? l101 : y19.width > v18.width ? y19.width : v18.width) + a246,
                            height: y19.height > v18.height ? y19.height : v18.height
                        });
                    } else i306.push({
                        width: 0,
                        height: 0
                    });
                }), i306;
            }
        },
        {
            key: "getyAxisTitleCoords",
            value: function() {
                var t533 = this, e407 = this.w, i307 = [];
                return e407.config.yaxis.map(function(e408, a) {
                    if (e408.show && void 0 !== e408.title.text) {
                        var s197 = new m(t533.dCtx.ctx), r167 = "rotate(".concat(e408.title.rotate, " 0 0)"), o146 = s197.getTextRects(e408.title.text, e408.title.style.fontSize, e408.title.style.fontFamily, r167, !1);
                        i307.push({
                            width: o146.width,
                            height: o146.height
                        });
                    } else i307.push({
                        width: 0,
                        height: 0
                    });
                }), i307;
            }
        },
        {
            key: "getTotalYAxisWidth",
            value: function() {
                var t534 = this.w, e409 = 0, i308 = 0, a247 = 0, s198 = t534.globals.yAxisScale.length > 1 ? 10 : 0, r168 = new G(this.dCtx.ctx), o147 = function(o148, n129) {
                    var l102 = t534.config.yaxis[n129].floating, h91 = 0;
                    o148.width > 0 && !l102 ? (h91 = o148.width + s198, function(e410) {
                        return t534.globals.ignoreYAxisIndexes.indexOf(e410) > -1;
                    }(n129) && (h91 = h91 - o148.width - s198)) : h91 = l102 || r168.isYAxisHidden(n129) ? 0 : 5, t534.config.yaxis[n129].opposite ? a247 += h91 : i308 += h91, e409 += h91;
                };
                return t534.globals.yLabelsCoords.map(function(t535, e411) {
                    o147(t535, e411);
                }), t534.globals.yTitleCoords.map(function(t536, e412) {
                    o147(t536, e412);
                }), t534.globals.isBarHorizontal && !t534.config.yaxis[0].floating && (e409 = t534.globals.yLabelsCoords[0].width + t534.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i308, this.dCtx.yAxisWidthRight = a247, e409;
            }
        }
    ]), t531;
}(), nt = function() {
    function t537(e413) {
        a(this, t537), this.w = e413.w, this.dCtx = e413;
    }
    return r(t537, [
        {
            key: "gridPadForColumnsInNumericAxis",
            value: function(t538) {
                var e414 = this.w;
                if (e414.globals.noData || e414.globals.allSeriesCollapsed) return 0;
                var i309 = function(t539) {
                    return "bar" === t539 || "rangeBar" === t539 || "candlestick" === t539 || "boxPlot" === t539;
                }, a248 = e414.config.chart.type, s199 = 0, r169 = i309(a248) ? e414.config.series.length : 1;
                if (e414.globals.comboBarCount > 0 && (r169 = e414.globals.comboBarCount), e414.globals.collapsedSeries.forEach(function(t540) {
                    i309(t540.type) && (r169 -= 1);
                }), e414.config.chart.stacked && (r169 = 1), (i309(a248) || e414.globals.comboBarCount > 0) && e414.globals.isXNumeric && !e414.globals.isBarHorizontal && r169 > 0) {
                    var o149, n130, l103 = Math.abs(e414.globals.initialMaxX - e414.globals.initialMinX);
                    l103 <= 3 && (l103 = e414.globals.dataPoints), o149 = l103 / t538, e414.globals.minXDiff && e414.globals.minXDiff / o149 > 0 && (n130 = e414.globals.minXDiff / o149), n130 > t538 / 2 && (n130 /= 2), (s199 = n130 / r169 * parseInt(e414.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (s199 = 1), s199 = s199 / (r169 > 1 ? 1 : 1.5) + 5, e414.globals.barPadForNumericAxis = s199;
                }
                return s199;
            }
        },
        {
            key: "gridPadFortitleSubtitle",
            value: function() {
                var t541 = this, e415 = this.w, i310 = e415.globals, a249 = this.dCtx.isSparkline || !e415.globals.axisCharts ? 0 : 10;
                [
                    "title",
                    "subtitle"
                ].forEach(function(i311) {
                    void 0 !== e415.config[i311].text ? a249 += e415.config[i311].margin : a249 += t541.dCtx.isSparkline || !e415.globals.axisCharts ? 0 : 5;
                }), !e415.config.legend.show || "bottom" !== e415.config.legend.position || e415.config.legend.floating || e415.globals.axisCharts || (a249 += 10);
                var s200 = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), r170 = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
                i310.gridHeight = i310.gridHeight - s200.height - r170.height - a249, i310.translateY = i310.translateY + s200.height + r170.height + a249;
            }
        },
        {
            key: "setGridXPosForDualYAxis",
            value: function(t542, e416) {
                var i312 = this.w, a250 = new G(this.dCtx.ctx);
                i312.config.yaxis.map(function(s201, r171) {
                    -1 !== i312.globals.ignoreYAxisIndexes.indexOf(r171) || s201.floating || a250.isYAxisHidden(r171) || (s201.opposite && (i312.globals.translateX = i312.globals.translateX - (e416[r171].width + t542[r171].width) - parseInt(i312.config.yaxis[r171].labels.style.fontSize, 10) / 1.2 - 12), i312.globals.translateX < 2 && (i312.globals.translateX = 2));
                });
            }
        }
    ]), t537;
}(), lt = function() {
    function t543(e417) {
        a(this, t543), this.ctx = e417, this.w = e417.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new st(this), this.dimYAxis = new ot(this), this.dimXAxis = new rt(this), this.dimGrid = new nt(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
    }
    return r(t543, [
        {
            key: "plotCoords",
            value: function() {
                var t544 = this, e418 = this.w, i313 = e418.globals;
                this.lgRect = this.dimHelpers.getLegendsRect(), this.isSparkline && (e418.config.markers.discrete.length > 0 || e418.config.markers.size > 0) && Object.entries(this.gridPad).forEach(function(e419) {
                    var i314 = g(e419, 2), a252 = i314[0], s202 = i314[1];
                    t544.gridPad[a252] = Math.max(s202, t544.w.globals.markers.largestSize / 1.5);
                }), i313.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i313.gridHeight = i313.gridHeight - this.gridPad.top - this.gridPad.bottom, i313.gridWidth = i313.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
                var a251 = this.dimGrid.gridPadForColumnsInNumericAxis(i313.gridWidth);
                i313.gridWidth = i313.gridWidth - 2 * a251, i313.translateX = i313.translateX + this.gridPad.left + this.xPadLeft + (a251 > 0 ? a251 + 4 : 0), i313.translateY = i313.translateY + this.gridPad.top;
            }
        },
        {
            key: "setDimensionsForAxisCharts",
            value: function() {
                var t545 = this, e420 = this.w, i315 = e420.globals, a253 = this.dimYAxis.getyAxisLabelsCoords(), s203 = this.dimYAxis.getyAxisTitleCoords();
                e420.globals.yLabelsCoords = [], e420.globals.yTitleCoords = [], e420.config.yaxis.map(function(t, i316) {
                    e420.globals.yLabelsCoords.push({
                        width: a253[i316].width,
                        index: i316
                    }), e420.globals.yTitleCoords.push({
                        width: s203[i316].width,
                        index: i316
                    });
                }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
                var r172 = this.dimXAxis.getxAxisLabelsCoords(), o150 = this.dimXAxis.getxAxisGroupLabelsCoords(), n131 = this.dimXAxis.getxAxisTitleCoords();
                this.conditionalChecksForAxisCoords(r172, n131, o150), i315.translateXAxisY = e420.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i315.translateXAxisX = e420.globals.rotateXLabels && e420.globals.isXNumeric && e420.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e420.globals.isBarHorizontal && (i315.rotateXLabels = !1, i315.translateXAxisY = parseInt(e420.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i315.translateXAxisY = i315.translateXAxisY + e420.config.xaxis.labels.offsetY, i315.translateXAxisX = i315.translateXAxisX + e420.config.xaxis.labels.offsetX;
                var l104 = this.yAxisWidth, h92 = this.xAxisHeight;
                i315.xAxisLabelsHeight = this.xAxisHeight - n131.height, i315.xAxisGroupLabelsHeight = i315.xAxisLabelsHeight - r172.height, i315.xAxisLabelsWidth = this.xAxisWidth, i315.xAxisHeight = this.xAxisHeight;
                var c76 = 10;
                ("radar" === e420.config.chart.type || this.isSparkline) && (l104 = 0, h92 = i315.goldenPadding), this.isSparkline && (this.lgRect = {
                    height: 0,
                    width: 0
                }), (this.isSparkline || "treemap" === e420.config.chart.type) && (l104 = 0, h92 = 0, c76 = 0), this.isSparkline || this.dimXAxis.additionalPaddingXLabels(r172);
                var d67 = function() {
                    i315.translateX = l104, i315.gridHeight = i315.svgHeight - t545.lgRect.height - h92 - (t545.isSparkline || "treemap" === e420.config.chart.type ? 0 : e420.globals.rotateXLabels ? 10 : 15), i315.gridWidth = i315.svgWidth - l104;
                };
                switch("top" === e420.config.xaxis.position && (c76 = i315.xAxisHeight - e420.config.xaxis.axisTicks.height - 5), e420.config.legend.position){
                    case "bottom":
                        i315.translateY = c76, d67();
                        break;
                    case "top":
                        i315.translateY = this.lgRect.height + c76, d67();
                        break;
                    case "left":
                        i315.translateY = c76, i315.translateX = this.lgRect.width + l104, i315.gridHeight = i315.svgHeight - h92 - 12, i315.gridWidth = i315.svgWidth - this.lgRect.width - l104;
                        break;
                    case "right":
                        i315.translateY = c76, i315.translateX = l104, i315.gridHeight = i315.svgHeight - h92 - 12, i315.gridWidth = i315.svgWidth - this.lgRect.width - l104 - 5;
                        break;
                    default:
                        throw new Error("Legend position not supported");
                }
                this.dimGrid.setGridXPosForDualYAxis(s203, a253), new $(this.ctx).setYAxisXPosition(a253, s203);
            }
        },
        {
            key: "setDimensionsForNonAxisCharts",
            value: function() {
                var t546 = this.w, e421 = t546.globals, i317 = t546.config, a254 = 0;
                t546.config.legend.show && !t546.config.legend.floating && (a254 = 20);
                var s204 = "pie" === i317.chart.type || "polarArea" === i317.chart.type || "donut" === i317.chart.type ? "pie" : "radialBar", r173 = i317.plotOptions[s204].offsetY, o151 = i317.plotOptions[s204].offsetX;
                if (!i317.legend.show || i317.legend.floating) return e421.gridHeight = e421.svgHeight - i317.grid.padding.left + i317.grid.padding.right, e421.gridWidth = e421.gridHeight, e421.translateY = r173, void (e421.translateX = o151 + (e421.svgWidth - e421.gridWidth) / 2);
                switch(i317.legend.position){
                    case "bottom":
                        e421.gridHeight = e421.svgHeight - this.lgRect.height - e421.goldenPadding, e421.gridWidth = e421.svgWidth, e421.translateY = r173 - 10, e421.translateX = o151 + (e421.svgWidth - e421.gridWidth) / 2;
                        break;
                    case "top":
                        e421.gridHeight = e421.svgHeight - this.lgRect.height - e421.goldenPadding, e421.gridWidth = e421.svgWidth, e421.translateY = this.lgRect.height + r173 + 10, e421.translateX = o151 + (e421.svgWidth - e421.gridWidth) / 2;
                        break;
                    case "left":
                        e421.gridWidth = e421.svgWidth - this.lgRect.width - a254, e421.gridHeight = "auto" !== i317.chart.height ? e421.svgHeight : e421.gridWidth, e421.translateY = r173, e421.translateX = o151 + this.lgRect.width + a254;
                        break;
                    case "right":
                        e421.gridWidth = e421.svgWidth - this.lgRect.width - a254 - 5, e421.gridHeight = "auto" !== i317.chart.height ? e421.svgHeight : e421.gridWidth, e421.translateY = r173, e421.translateX = o151 + 10;
                        break;
                    default:
                        throw new Error("Legend position not supported");
                }
            }
        },
        {
            key: "conditionalChecksForAxisCoords",
            value: function(t547, e422, i318) {
                var a255 = this.w, s205 = a255.globals.hasGroups ? 2 : 1, r174 = i318.height + t547.height + e422.height, o152 = a255.globals.isMultiLineX ? 1.2 : a255.globals.LINE_HEIGHT_RATIO, n132 = a255.globals.rotateXLabels ? 22 : 10, l105 = a255.globals.rotateXLabels && "bottom" === a255.config.legend.position ? 10 : 0;
                this.xAxisHeight = r174 * o152 + s205 * n132 + l105, this.xAxisWidth = t547.width, this.xAxisHeight - e422.height > a255.config.xaxis.labels.maxHeight && (this.xAxisHeight = a255.config.xaxis.labels.maxHeight), a255.config.xaxis.labels.minHeight && this.xAxisHeight < a255.config.xaxis.labels.minHeight && (this.xAxisHeight = a255.config.xaxis.labels.minHeight), a255.config.xaxis.floating && (this.xAxisHeight = 0);
                var h93 = 0, c77 = 0;
                a255.config.yaxis.forEach(function(t548) {
                    h93 += t548.labels.minWidth, c77 += t548.labels.maxWidth;
                }), this.yAxisWidth < h93 && (this.yAxisWidth = h93), this.yAxisWidth > c77 && (this.yAxisWidth = c77);
            }
        }
    ]), t543;
}(), ht = function() {
    function t549(e423) {
        a(this, t549), this.w = e423.w, this.lgCtx = e423;
    }
    return r(t549, [
        {
            key: "getLegendStyles",
            value: function() {
                var t550 = document.createElement("style");
                t550.setAttribute("type", "text/css");
                var e424 = document.createTextNode("\t\n    \t\n      .apexcharts-legend {\t\n        display: flex;\t\n        overflow: auto;\t\n        padding: 0 10px;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\t\n        flex-wrap: wrap\t\n      }\t\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\t\n        flex-direction: column;\t\n        bottom: 0;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\t\n        justify-content: flex-start;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\t\n        justify-content: center;  \t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\t\n        justify-content: flex-end;\t\n      }\t\n      .apexcharts-legend-series {\t\n        cursor: pointer;\t\n        line-height: normal;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{\t\n        display: flex;\t\n        align-items: center;\t\n      }\t\n      .apexcharts-legend-text {\t\n        position: relative;\t\n        font-size: 14px;\t\n      }\t\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\t\n        pointer-events: none;\t\n      }\t\n      .apexcharts-legend-marker {\t\n        position: relative;\t\n        display: inline-block;\t\n        cursor: pointer;\t\n        margin-right: 3px;\t\n        border-style: solid;\n      }\t\n      \t\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{\t\n        display: inline-block;\t\n      }\t\n      .apexcharts-legend-series.apexcharts-no-click {\t\n        cursor: auto;\t\n      }\t\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\t\n        display: none !important;\t\n      }\t\n      .apexcharts-inactive-legend {\t\n        opacity: 0.45;\t\n      }");
                return t550.appendChild(e424), t550;
            }
        },
        {
            key: "getLegendBBox",
            value: function() {
                var t551 = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(), e425 = t551.width;
                return {
                    clwh: t551.height,
                    clww: e425
                };
            }
        },
        {
            key: "appendToForeignObject",
            value: function() {
                var t552 = this.w.globals;
                t552.dom.elLegendForeign = document.createElementNS(t552.SVGNS, "foreignObject");
                var e426 = t552.dom.elLegendForeign;
                e426.setAttribute("x", 0), e426.setAttribute("y", 0), e426.setAttribute("width", t552.svgWidth), e426.setAttribute("height", t552.svgHeight), t552.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), e426.appendChild(t552.dom.elLegendWrap), e426.appendChild(this.getLegendStyles()), t552.dom.Paper.node.insertBefore(e426, t552.dom.elGraphical.node);
            }
        },
        {
            key: "toggleDataSeries",
            value: function(t553, e427) {
                var i319 = this, a256 = this.w;
                if (a256.globals.axisCharts || "radialBar" === a256.config.chart.type) {
                    a256.globals.resized = !0;
                    var s206 = null, r175 = null;
                    if (a256.globals.risingSeries = [], a256.globals.axisCharts ? (s206 = a256.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t553, "']")), r175 = parseInt(s206.getAttribute("data:realIndex"), 10)) : (s206 = a256.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t553 + 1, "']")), r175 = parseInt(s206.getAttribute("rel"), 10) - 1), e427) [
                        {
                            cs: a256.globals.collapsedSeries,
                            csi: a256.globals.collapsedSeriesIndices
                        },
                        {
                            cs: a256.globals.ancillaryCollapsedSeries,
                            csi: a256.globals.ancillaryCollapsedSeriesIndices
                        }
                    ].forEach(function(t554) {
                        i319.riseCollapsedSeries(t554.cs, t554.csi, r175);
                    });
                    else this.hideSeries({
                        seriesEl: s206,
                        realIndex: r175
                    });
                } else {
                    var o153 = a256.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t553 + 1, "'] path")), n133 = a256.config.chart.type;
                    if ("pie" === n133 || "polarArea" === n133 || "donut" === n133) {
                        var l106 = a256.config.plotOptions.pie.donut.labels;
                        new m(this.lgCtx.ctx).pathMouseDown(o153.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(o153.members[0].node, l106);
                    }
                    o153.fire("click");
                }
            }
        },
        {
            key: "hideSeries",
            value: function(t555) {
                var e428 = t555.seriesEl, i320 = t555.realIndex, a257 = this.w, s207 = x.clone(a257.config.series);
                if (a257.globals.axisCharts) {
                    var r176 = !1;
                    if (a257.config.yaxis[i320] && a257.config.yaxis[i320].show && a257.config.yaxis[i320].showAlways && (r176 = !0, a257.globals.ancillaryCollapsedSeriesIndices.indexOf(i320) < 0 && (a257.globals.ancillaryCollapsedSeries.push({
                        index: i320,
                        data: s207[i320].data.slice(),
                        type: e428.parentNode.className.baseVal.split("-")[1]
                    }), a257.globals.ancillaryCollapsedSeriesIndices.push(i320))), !r176) {
                        a257.globals.collapsedSeries.push({
                            index: i320,
                            data: s207[i320].data.slice(),
                            type: e428.parentNode.className.baseVal.split("-")[1]
                        }), a257.globals.collapsedSeriesIndices.push(i320);
                        var o154 = a257.globals.risingSeries.indexOf(i320);
                        a257.globals.risingSeries.splice(o154, 1);
                    }
                } else a257.globals.collapsedSeries.push({
                    index: i320,
                    data: s207[i320]
                }), a257.globals.collapsedSeriesIndices.push(i320);
                for(var n134 = e428.childNodes, l107 = 0; l107 < n134.length; l107++)n134[l107].classList.contains("apexcharts-series-markers-wrap") && (n134[l107].classList.contains("apexcharts-hide") ? n134[l107].classList.remove("apexcharts-hide") : n134[l107].classList.add("apexcharts-hide"));
                a257.globals.allSeriesCollapsed = a257.globals.collapsedSeries.length === a257.config.series.length, s207 = this._getSeriesBasedOnCollapsedState(s207), this.lgCtx.ctx.updateHelpers._updateSeries(s207, a257.config.chart.animations.dynamicAnimation.enabled);
            }
        },
        {
            key: "riseCollapsedSeries",
            value: function(t556, e429, i321) {
                var a258 = this.w, s208 = x.clone(a258.config.series);
                if (t556.length > 0) {
                    for(var r177 = 0; r177 < t556.length; r177++)t556[r177].index === i321 && (a258.globals.axisCharts ? (s208[i321].data = t556[r177].data.slice(), t556.splice(r177, 1), e429.splice(r177, 1), a258.globals.risingSeries.push(i321)) : (s208[i321] = t556[r177].data, t556.splice(r177, 1), e429.splice(r177, 1), a258.globals.risingSeries.push(i321)));
                    s208 = this._getSeriesBasedOnCollapsedState(s208), this.lgCtx.ctx.updateHelpers._updateSeries(s208, a258.config.chart.animations.dynamicAnimation.enabled);
                }
            }
        },
        {
            key: "_getSeriesBasedOnCollapsedState",
            value: function(t557) {
                var e430 = this.w;
                return e430.globals.axisCharts ? t557.forEach(function(i, a259) {
                    e430.globals.collapsedSeriesIndices.indexOf(a259) > -1 && (t557[a259].data = []);
                }) : t557.forEach(function(i, a260) {
                    e430.globals.collapsedSeriesIndices.indexOf(a260) > -1 && (t557[a260] = 0);
                }), t557;
            }
        }
    ]), t549;
}(), ct = function() {
    function t558(e431, i) {
        a(this, t558), this.ctx = e431, this.w = e431.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length, this.legendHelpers = new ht(this);
    }
    return r(t558, [
        {
            key: "init",
            value: function() {
                var t559 = this.w, e432 = t559.globals, i322 = t559.config;
                if ((i322.legend.showForSingleSeries && 1 === e432.series.length || this.isBarsDistributed || e432.series.length > 1 || !e432.axisCharts) && i322.legend.show) {
                    for(; e432.dom.elLegendWrap.firstChild;)e432.dom.elLegendWrap.removeChild(e432.dom.elLegendWrap.firstChild);
                    this.drawLegends(), x.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), "bottom" === i322.legend.position || "top" === i322.legend.position ? this.legendAlignHorizontal() : "right" !== i322.legend.position && "left" !== i322.legend.position || this.legendAlignVertical();
                }
            }
        },
        {
            key: "drawLegends",
            value: function() {
                var t560 = this, e433 = this.w, i323 = e433.config.legend.fontFamily, a261 = e433.globals.seriesNames, s209 = e433.globals.colors.slice();
                if ("heatmap" === e433.config.chart.type) {
                    var r178 = e433.config.plotOptions.heatmap.colorScale.ranges;
                    a261 = r178.map(function(t561) {
                        return t561.name ? t561.name : t561.from + " - " + t561.to;
                    }), s209 = r178.map(function(t562) {
                        return t562.color;
                    });
                } else this.isBarsDistributed && (a261 = e433.globals.labels.slice());
                e433.config.legend.customLegendItems.length && (a261 = e433.config.legend.customLegendItems);
                for(var o155 = e433.globals.legendFormatter, n135 = e433.config.legend.inverseOrder, l108 = n135 ? a261.length - 1 : 0; n135 ? l108 >= 0 : l108 <= a261.length - 1; n135 ? l108-- : l108++){
                    var h94 = o155(a261[l108], {
                        seriesIndex: l108,
                        w: e433
                    }), c78 = !1, d68 = !1;
                    if (e433.globals.collapsedSeries.length > 0) for(var g57 = 0; g57 < e433.globals.collapsedSeries.length; g57++)e433.globals.collapsedSeries[g57].index === l108 && (c78 = !0);
                    if (e433.globals.ancillaryCollapsedSeriesIndices.length > 0) for(var u45 = 0; u45 < e433.globals.ancillaryCollapsedSeriesIndices.length; u45++)e433.globals.ancillaryCollapsedSeriesIndices[u45] === l108 && (d68 = !0);
                    var p38 = document.createElement("span");
                    p38.classList.add("apexcharts-legend-marker");
                    var f34 = e433.config.legend.markers.offsetX, b28 = e433.config.legend.markers.offsetY, v19 = e433.config.legend.markers.height, w17 = e433.config.legend.markers.width, k16 = e433.config.legend.markers.strokeWidth, A12 = e433.config.legend.markers.strokeColor, S9 = e433.config.legend.markers.radius, C8 = p38.style;
                    C8.background = s209[l108], C8.color = s209[l108], C8.setProperty("background", s209[l108], "important"), e433.config.legend.markers.fillColors && e433.config.legend.markers.fillColors[l108] && (C8.background = e433.config.legend.markers.fillColors[l108]), void 0 !== e433.globals.seriesColors[l108] && (C8.background = e433.globals.seriesColors[l108], C8.color = e433.globals.seriesColors[l108]), C8.height = Array.isArray(v19) ? parseFloat(v19[l108]) + "px" : parseFloat(v19) + "px", C8.width = Array.isArray(w17) ? parseFloat(w17[l108]) + "px" : parseFloat(w17) + "px", C8.left = (Array.isArray(f34) ? parseFloat(f34[l108]) : parseFloat(f34)) + "px", C8.top = (Array.isArray(b28) ? parseFloat(b28[l108]) : parseFloat(b28)) + "px", C8.borderWidth = Array.isArray(k16) ? k16[l108] : k16, C8.borderColor = Array.isArray(A12) ? A12[l108] : A12, C8.borderRadius = Array.isArray(S9) ? parseFloat(S9[l108]) + "px" : parseFloat(S9) + "px", e433.config.legend.markers.customHTML && (Array.isArray(e433.config.legend.markers.customHTML) ? e433.config.legend.markers.customHTML[l108] && (p38.innerHTML = e433.config.legend.markers.customHTML[l108]()) : p38.innerHTML = e433.config.legend.markers.customHTML()), m.setAttrs(p38, {
                        rel: l108 + 1,
                        "data:collapsed": c78 || d68
                    }), (c78 || d68) && p38.classList.add("apexcharts-inactive-legend");
                    var L8 = document.createElement("div"), P8 = document.createElement("span");
                    P8.classList.add("apexcharts-legend-text"), P8.innerHTML = Array.isArray(h94) ? h94.join(" ") : h94;
                    var T7 = e433.config.legend.labels.useSeriesColors ? e433.globals.colors[l108] : e433.config.legend.labels.colors;
                    T7 || (T7 = e433.config.chart.foreColor), P8.style.color = T7, P8.style.fontSize = parseFloat(e433.config.legend.fontSize) + "px", P8.style.fontWeight = e433.config.legend.fontWeight, P8.style.fontFamily = i323 || e433.config.chart.fontFamily, m.setAttrs(P8, {
                        rel: l108 + 1,
                        i: l108,
                        "data:default-text": encodeURIComponent(h94),
                        "data:collapsed": c78 || d68
                    }), L8.appendChild(p38), L8.appendChild(P8);
                    var M7 = new y(this.ctx);
                    if (!e433.config.legend.showForZeroSeries) 0 === M7.getSeriesTotalByIndex(l108) && M7.seriesHaveSameValues(l108) && !M7.isSeriesNull(l108) && -1 === e433.globals.collapsedSeriesIndices.indexOf(l108) && -1 === e433.globals.ancillaryCollapsedSeriesIndices.indexOf(l108) && L8.classList.add("apexcharts-hidden-zero-series");
                    e433.config.legend.showForNullSeries || M7.isSeriesNull(l108) && -1 === e433.globals.collapsedSeriesIndices.indexOf(l108) && -1 === e433.globals.ancillaryCollapsedSeriesIndices.indexOf(l108) && L8.classList.add("apexcharts-hidden-null-series"), e433.globals.dom.elLegendWrap.appendChild(L8), e433.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(e433.config.legend.horizontalAlign)), e433.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + e433.config.legend.position), L8.classList.add("apexcharts-legend-series"), L8.style.margin = "".concat(e433.config.legend.itemMargin.vertical, "px ").concat(e433.config.legend.itemMargin.horizontal, "px"), e433.globals.dom.elLegendWrap.style.width = e433.config.legend.width ? e433.config.legend.width + "px" : "", e433.globals.dom.elLegendWrap.style.height = e433.config.legend.height ? e433.config.legend.height + "px" : "", m.setAttrs(L8, {
                        rel: l108 + 1,
                        seriesName: x.escapeString(a261[l108]),
                        "data:collapsed": c78 || d68
                    }), (c78 || d68) && L8.classList.add("apexcharts-inactive-legend"), e433.config.legend.onItemClick.toggleDataSeries || L8.classList.add("apexcharts-no-click");
                }
                e433.globals.dom.elWrap.addEventListener("click", t560.onLegendClick, !0), e433.config.legend.onItemHover.highlightDataSeries && 0 === e433.config.legend.customLegendItems.length && (e433.globals.dom.elWrap.addEventListener("mousemove", t560.onLegendHovered, !0), e433.globals.dom.elWrap.addEventListener("mouseout", t560.onLegendHovered, !0));
            }
        },
        {
            key: "setLegendWrapXY",
            value: function(t563, e434) {
                var i324 = this.w, a262 = i324.globals.dom.baseEl.querySelector(".apexcharts-legend"), s210 = a262.getBoundingClientRect(), r179 = 0, o156 = 0;
                if ("bottom" === i324.config.legend.position) o156 += i324.globals.svgHeight - s210.height / 2;
                else if ("top" === i324.config.legend.position) {
                    var n136 = new lt(this.ctx), l109 = n136.dimHelpers.getTitleSubtitleCoords("title").height, h95 = n136.dimHelpers.getTitleSubtitleCoords("subtitle").height;
                    o156 = o156 + (l109 > 0 ? l109 - 10 : 0) + (h95 > 0 ? h95 - 10 : 0);
                }
                a262.style.position = "absolute", r179 = r179 + t563 + i324.config.legend.offsetX, o156 = o156 + e434 + i324.config.legend.offsetY, a262.style.left = r179 + "px", a262.style.top = o156 + "px", "bottom" === i324.config.legend.position ? (a262.style.top = "auto", a262.style.bottom = 5 - i324.config.legend.offsetY + "px") : "right" === i324.config.legend.position && (a262.style.left = "auto", a262.style.right = 25 + i324.config.legend.offsetX + "px");
                [
                    "width",
                    "height"
                ].forEach(function(t564) {
                    a262.style[t564] && (a262.style[t564] = parseInt(i324.config.legend[t564], 10) + "px");
                });
            }
        },
        {
            key: "legendAlignHorizontal",
            value: function() {
                var t565 = this.w;
                t565.globals.dom.baseEl.querySelector(".apexcharts-legend").style.right = 0;
                var e435 = this.legendHelpers.getLegendBBox(), i325 = new lt(this.ctx), a263 = i325.dimHelpers.getTitleSubtitleCoords("title"), s211 = i325.dimHelpers.getTitleSubtitleCoords("subtitle"), r180 = 0;
                "bottom" === t565.config.legend.position ? r180 = -e435.clwh / 1.8 : "top" === t565.config.legend.position && (r180 = a263.height + s211.height + t565.config.title.margin + t565.config.subtitle.margin - 10), this.setLegendWrapXY(20, r180);
            }
        },
        {
            key: "legendAlignVertical",
            value: function() {
                var t566 = this.w, e436 = this.legendHelpers.getLegendBBox(), i326 = 0;
                "left" === t566.config.legend.position && (i326 = 20), "right" === t566.config.legend.position && (i326 = t566.globals.svgWidth - e436.clww - 10), this.setLegendWrapXY(i326, 20);
            }
        },
        {
            key: "onLegendHovered",
            value: function(t567) {
                var e437 = this.w, i327 = t567.target.classList.contains("apexcharts-legend-text") || t567.target.classList.contains("apexcharts-legend-marker");
                if ("heatmap" === e437.config.chart.type || this.isBarsDistributed) {
                    if (i327) {
                        var a264 = parseInt(t567.target.getAttribute("rel"), 10) - 1;
                        this.ctx.events.fireEvent("legendHover", [
                            this.ctx,
                            a264,
                            this.w
                        ]), new E(this.ctx).highlightRangeInSeries(t567, t567.target);
                    }
                } else !t567.target.classList.contains("apexcharts-inactive-legend") && i327 && new E(this.ctx).toggleSeriesOnHover(t567, t567.target);
            }
        },
        {
            key: "onLegendClick",
            value: function(t568) {
                var e438 = this.w;
                if (!e438.config.legend.customLegendItems.length && (t568.target.classList.contains("apexcharts-legend-text") || t568.target.classList.contains("apexcharts-legend-marker"))) {
                    var i328 = parseInt(t568.target.getAttribute("rel"), 10) - 1, a265 = "true" === t568.target.getAttribute("data:collapsed"), s212 = this.w.config.chart.events.legendClick;
                    "function" == typeof s212 && s212(this.ctx, i328, this.w), this.ctx.events.fireEvent("legendClick", [
                        this.ctx,
                        i328,
                        this.w
                    ]);
                    var r181 = this.w.config.legend.markers.onClick;
                    "function" == typeof r181 && t568.target.classList.contains("apexcharts-legend-marker") && (r181(this.ctx, i328, this.w), this.ctx.events.fireEvent("legendMarkerClick", [
                        this.ctx,
                        i328,
                        this.w
                    ])), "treemap" !== e438.config.chart.type && "heatmap" !== e438.config.chart.type && !this.isBarsDistributed && e438.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i328, a265);
                }
            }
        }
    ]), t558;
}(), dt = function() {
    function t569(e439) {
        a(this, t569), this.ctx = e439, this.w = e439.w;
        var i329 = this.w;
        this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = i329.globals.minX, this.maxX = i329.globals.maxX;
    }
    return r(t569, [
        {
            key: "createToolbar",
            value: function() {
                var t570 = this, e440 = this.w, i330 = function() {
                    return document.createElement("div");
                }, a266 = i330();
                if (a266.setAttribute("class", "apexcharts-toolbar"), a266.style.top = e440.config.chart.toolbar.offsetY + "px", a266.style.right = 3 - e440.config.chart.toolbar.offsetX + "px", e440.globals.dom.elWrap.appendChild(a266), this.elZoom = i330(), this.elZoomIn = i330(), this.elZoomOut = i330(), this.elPan = i330(), this.elSelection = i330(), this.elZoomReset = i330(), this.elMenuIcon = i330(), this.elMenu = i330(), this.elCustomIcons = [], this.t = e440.config.chart.toolbar.tools, Array.isArray(this.t.customIcons)) for(var s213 = 0; s213 < this.t.customIcons.length; s213++)this.elCustomIcons.push(i330());
                var r182 = [], o157 = function(i331, a267, s214) {
                    var o158 = i331.toLowerCase();
                    t570.t[o158] && e440.config.chart.zoom.enabled && r182.push({
                        el: a267,
                        icon: "string" == typeof t570.t[o158] ? t570.t[o158] : s214,
                        title: t570.localeValues[i331],
                        class: "apexcharts-".concat(o158, "-icon")
                    });
                };
                o157("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'), o157("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');
                var n137 = function(i332) {
                    t570.t[i332] && e440.config.chart[i332].enabled && r182.push({
                        el: "zoom" === i332 ? t570.elZoom : t570.elSelection,
                        icon: "string" == typeof t570.t[i332] ? t570.t[i332] : "zoom" === i332 ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>',
                        title: t570.localeValues["zoom" === i332 ? "selectionZoom" : "selection"],
                        class: e440.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(i332, "-icon")
                    });
                };
                n137("zoom"), n137("selection"), this.t.pan && e440.config.chart.zoom.enabled && r182.push({
                    el: this.elPan,
                    icon: "string" == typeof this.t.pan ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>',
                    title: this.localeValues.pan,
                    class: e440.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon"
                }), o157("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'), this.t.download && r182.push({
                    el: this.elMenuIcon,
                    icon: "string" == typeof this.t.download ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>',
                    title: this.localeValues.menu,
                    class: "apexcharts-menu-icon"
                });
                for(var l110 = 0; l110 < this.elCustomIcons.length; l110++)r182.push({
                    el: this.elCustomIcons[l110],
                    icon: this.t.customIcons[l110].icon,
                    title: this.t.customIcons[l110].title,
                    index: this.t.customIcons[l110].index,
                    class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l110].class
                });
                r182.forEach(function(t571, e441) {
                    t571.index && x.moveIndexInArray(r182, e441, t571.index);
                });
                for(var h96 = 0; h96 < r182.length; h96++)m.setAttrs(r182[h96].el, {
                    class: r182[h96].class,
                    title: r182[h96].title
                }), r182[h96].el.innerHTML = r182[h96].icon, a266.appendChild(r182[h96].el);
                this._createHamburgerMenu(a266), e440.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e440.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e440.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
            }
        },
        {
            key: "_createHamburgerMenu",
            value: function(t572) {
                this.elMenuItems = [], t572.appendChild(this.elMenu), m.setAttrs(this.elMenu, {
                    class: "apexcharts-menu"
                });
                var e442 = [
                    {
                        name: "exportSVG",
                        title: this.localeValues.exportToSVG
                    },
                    {
                        name: "exportPNG",
                        title: this.localeValues.exportToPNG
                    },
                    {
                        name: "exportCSV",
                        title: this.localeValues.exportToCSV
                    }
                ];
                this.w.globals.allSeriesHasEqualX || e442.splice(2, 1);
                for(var i333 = 0; i333 < e442.length; i333++)this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i333].innerHTML = e442[i333].title, m.setAttrs(this.elMenuItems[i333], {
                    class: "apexcharts-menu-item ".concat(e442[i333].name),
                    title: e442[i333].title
                }), this.elMenu.appendChild(this.elMenuItems[i333]);
            }
        },
        {
            key: "addToolbarEventListeners",
            value: function() {
                var t573 = this;
                this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(e444) {
                    e444.classList.contains("exportSVG") ? e444.addEventListener("click", t573.handleDownload.bind(t573, "svg")) : e444.classList.contains("exportPNG") ? e444.addEventListener("click", t573.handleDownload.bind(t573, "png")) : e444.classList.contains("exportCSV") && e444.addEventListener("click", t573.handleDownload.bind(t573, "csv"));
                });
                for(var e443 = 0; e443 < this.t.customIcons.length; e443++)this.elCustomIcons[e443].addEventListener("click", this.t.customIcons[e443].click.bind(this, this.ctx, this.ctx.w));
            }
        },
        {
            key: "toggleZoomSelection",
            value: function(t574) {
                this.ctx.getSyncedCharts().forEach(function(e445) {
                    e445.ctx.toolbar.toggleOtherControls();
                    var i334 = "selection" === t574 ? e445.ctx.toolbar.elSelection : e445.ctx.toolbar.elZoom, a268 = "selection" === t574 ? "selectionEnabled" : "zoomEnabled";
                    e445.w.globals[a268] = !e445.w.globals[a268], i334.classList.contains(e445.ctx.toolbar.selectedClass) ? i334.classList.remove(e445.ctx.toolbar.selectedClass) : i334.classList.add(e445.ctx.toolbar.selectedClass);
                });
            }
        },
        {
            key: "getToolbarIconsReference",
            value: function() {
                var t575 = this.w;
                this.elZoom || (this.elZoom = t575.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t575.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t575.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
            }
        },
        {
            key: "enableZoomPanFromToolbar",
            value: function(t576) {
                this.toggleOtherControls(), "pan" === t576 ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
                var e446 = "pan" === t576 ? this.elPan : this.elZoom, i335 = "pan" === t576 ? this.elZoom : this.elPan;
                e446 && e446.classList.add(this.selectedClass), i335 && i335.classList.remove(this.selectedClass);
            }
        },
        {
            key: "togglePanning",
            value: function() {
                this.ctx.getSyncedCharts().forEach(function(t577) {
                    t577.ctx.toolbar.toggleOtherControls(), t577.w.globals.panEnabled = !t577.w.globals.panEnabled, t577.ctx.toolbar.elPan.classList.contains(t577.ctx.toolbar.selectedClass) ? t577.ctx.toolbar.elPan.classList.remove(t577.ctx.toolbar.selectedClass) : t577.ctx.toolbar.elPan.classList.add(t577.ctx.toolbar.selectedClass);
                });
            }
        },
        {
            key: "toggleOtherControls",
            value: function() {
                var t578 = this, e447 = this.w;
                e447.globals.panEnabled = !1, e447.globals.zoomEnabled = !1, e447.globals.selectionEnabled = !1, this.getToolbarIconsReference(), [
                    this.elPan,
                    this.elSelection,
                    this.elZoom
                ].forEach(function(e448) {
                    e448 && e448.classList.remove(t578.selectedClass);
                });
            }
        },
        {
            key: "handleZoomIn",
            value: function() {
                var t579 = this.w;
                t579.globals.isRangeBar && (this.minX = t579.globals.minY, this.maxX = t579.globals.maxY);
                var e449 = (this.minX + this.maxX) / 2, i336 = (this.minX + e449) / 2, a269 = (this.maxX + e449) / 2, s215 = this._getNewMinXMaxX(i336, a269);
                t579.globals.disableZoomIn || this.zoomUpdateOptions(s215.minX, s215.maxX);
            }
        },
        {
            key: "handleZoomOut",
            value: function() {
                var t580 = this.w;
                if (t580.globals.isRangeBar && (this.minX = t580.globals.minY, this.maxX = t580.globals.maxY), !("datetime" === t580.config.xaxis.type && new Date(this.minX).getUTCFullYear() < 1e3)) {
                    var e450 = (this.minX + this.maxX) / 2, i337 = this.minX - (e450 - this.minX), a270 = this.maxX - (e450 - this.maxX), s216 = this._getNewMinXMaxX(i337, a270);
                    t580.globals.disableZoomOut || this.zoomUpdateOptions(s216.minX, s216.maxX);
                }
            }
        },
        {
            key: "_getNewMinXMaxX",
            value: function(t581, e451) {
                var i338 = this.w.config.xaxis.convertedCatToNumeric;
                return {
                    minX: i338 ? Math.floor(t581) : t581,
                    maxX: i338 ? Math.floor(e451) : e451
                };
            }
        },
        {
            key: "zoomUpdateOptions",
            value: function(t582, e452) {
                var i339 = this.w;
                if (void 0 !== t582 || void 0 !== e452) {
                    if (!(i339.config.xaxis.convertedCatToNumeric && (t582 < 1 && (t582 = 1, e452 = i339.globals.dataPoints), e452 - t582 < 2))) {
                        var a271 = {
                            min: t582,
                            max: e452
                        }, s217 = this.getBeforeZoomRange(a271);
                        s217 && (a271 = s217.xaxis);
                        var r183 = {
                            xaxis: a271
                        }, o159 = x.clone(i339.globals.initialConfig.yaxis);
                        if (i339.config.chart.zoom.autoScaleYaxis) o159 = new q(this.ctx).autoScaleY(this.ctx, o159, {
                            xaxis: a271
                        });
                        i339.config.chart.group || (r183.yaxis = o159), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(r183, !1, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a271, o159);
                    }
                } else this.handleZoomReset();
            }
        },
        {
            key: "zoomCallback",
            value: function(t583, e453) {
                "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, {
                    xaxis: t583,
                    yaxis: e453
                });
            }
        },
        {
            key: "getBeforeZoomRange",
            value: function(t584, e454) {
                var i340 = null;
                return "function" == typeof this.ev.beforeZoom && (i340 = this.ev.beforeZoom(this, {
                    xaxis: t584,
                    yaxis: e454
                })), i340;
            }
        },
        {
            key: "toggleMenu",
            value: function() {
                var t585 = this;
                window.setTimeout(function() {
                    t585.elMenu.classList.contains("apexcharts-menu-open") ? t585.elMenu.classList.remove("apexcharts-menu-open") : t585.elMenu.classList.add("apexcharts-menu-open");
                }, 0);
            }
        },
        {
            key: "handleDownload",
            value: function(t586) {
                var e455 = this.w, i341 = new j(this.ctx);
                switch(t586){
                    case "svg":
                        i341.exportToSVG(this.ctx);
                        break;
                    case "png":
                        i341.exportToPng(this.ctx);
                        break;
                    case "csv":
                        i341.exportToCSV({
                            series: e455.config.series,
                            columnDelimiter: e455.config.chart.toolbar.export.csv.columnDelimiter
                        });
                }
            }
        },
        {
            key: "handleZoomReset",
            value: function(t587) {
                this.ctx.getSyncedCharts().forEach(function(t588) {
                    var e456 = t588.w;
                    if (e456.globals.lastXAxis.min = void 0, e456.globals.lastXAxis.max = void 0, t588.updateHelpers.revertDefaultAxisMinMax(), "function" == typeof e456.config.chart.events.beforeResetZoom) {
                        var i342 = e456.config.chart.events.beforeResetZoom(t588, e456);
                        i342 && t588.updateHelpers.revertDefaultAxisMinMax(i342);
                    }
                    "function" == typeof e456.config.chart.events.zoomed && t588.ctx.toolbar.zoomCallback({
                        min: e456.config.xaxis.min,
                        max: e456.config.xaxis.max
                    }), e456.globals.zoomed = !1;
                    var a272 = t588.ctx.series.emptyCollapsedSeries(x.clone(e456.globals.initialSeries));
                    t588.updateHelpers._updateSeries(a272, e456.config.chart.animations.dynamicAnimation.enabled);
                });
            }
        },
        {
            key: "destroy",
            value: function() {
                this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
            }
        }
    ]), t569;
}(), gt = function(t589) {
    n(i343, dt);
    var e457 = d(i343);
    function i343(t590) {
        var s218;
        return a(this, i343), (s218 = e457.call(this, t590)).ctx = t590, s218.w = t590.w, s218.dragged = !1, s218.graphics = new m(s218.ctx), s218.eventList = [
            "mousedown",
            "mouseleave",
            "mousemove",
            "touchstart",
            "touchmove",
            "mouseup",
            "touchend"
        ], s218.clientX = 0, s218.clientY = 0, s218.startX = 0, s218.endX = 0, s218.dragX = 0, s218.startY = 0, s218.endY = 0, s218.dragY = 0, s218.moveDirection = "none", s218;
    }
    return r(i343, [
        {
            key: "init",
            value: function(t591) {
                var e458 = this, i344 = t591.xyRatios, a273 = this.w, s219 = this;
                this.xyRatios = i344, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a273.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), a273.globals.dom.elGraphical.add(this.zoomRect), a273.globals.dom.elGraphical.add(this.selectionRect), "x" === a273.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({
                    minX: 0,
                    minY: 0,
                    maxX: a273.globals.gridWidth,
                    maxY: a273.globals.gridHeight
                }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : "y" === a273.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({
                    minX: 0,
                    maxX: a273.globals.gridWidth
                }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = a273.globals.dom.baseEl.querySelector("".concat(a273.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function(t592) {
                    e458.hoverArea.addEventListener(t592, s219.svgMouseEvents.bind(s219, i344), {
                        capture: !1,
                        passive: !0
                    });
                });
            }
        },
        {
            key: "destroy",
            value: function() {
                this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
            }
        },
        {
            key: "svgMouseEvents",
            value: function(t593, e459) {
                var i345 = this.w, a274 = this, s220 = this.ctx.toolbar, r184 = i345.globals.zoomEnabled ? i345.config.chart.zoom.type : i345.config.chart.selection.type, o160 = i345.config.chart.toolbar.autoSelected;
                if (e459.shiftKey ? (this.shiftWasPressed = !0, s220.enableZoomPanFromToolbar("pan" === o160 ? "zoom" : "pan")) : this.shiftWasPressed && (s220.enableZoomPanFromToolbar(o160), this.shiftWasPressed = !1), e459.target) {
                    var n138, l111 = e459.target.classList;
                    if (e459.target.parentNode && null !== e459.target.parentNode && (n138 = e459.target.parentNode.classList), !(l111.contains("apexcharts-selection-rect") || l111.contains("apexcharts-legend-marker") || l111.contains("apexcharts-legend-text") || n138 && n138.contains("apexcharts-toolbar"))) {
                        if (a274.clientX = "touchmove" === e459.type || "touchstart" === e459.type ? e459.touches[0].clientX : "touchend" === e459.type ? e459.changedTouches[0].clientX : e459.clientX, a274.clientY = "touchmove" === e459.type || "touchstart" === e459.type ? e459.touches[0].clientY : "touchend" === e459.type ? e459.changedTouches[0].clientY : e459.clientY, "mousedown" === e459.type && 1 === e459.which) {
                            var h97 = a274.gridRect.getBoundingClientRect();
                            a274.startX = a274.clientX - h97.left, a274.startY = a274.clientY - h97.top, a274.dragged = !1, a274.w.globals.mousedown = !0;
                        }
                        if (("mousemove" === e459.type && 1 === e459.which || "touchmove" === e459.type) && (a274.dragged = !0, i345.globals.panEnabled ? (i345.globals.selection = null, a274.w.globals.mousedown && a274.panDragging({
                            context: a274,
                            zoomtype: r184,
                            xyRatios: t593
                        })) : (a274.w.globals.mousedown && i345.globals.zoomEnabled || a274.w.globals.mousedown && i345.globals.selectionEnabled) && (a274.selection = a274.selectionDrawing({
                            context: a274,
                            zoomtype: r184
                        }))), "mouseup" === e459.type || "touchend" === e459.type || "mouseleave" === e459.type) {
                            var c79 = a274.gridRect.getBoundingClientRect();
                            a274.w.globals.mousedown && (a274.endX = a274.clientX - c79.left, a274.endY = a274.clientY - c79.top, a274.dragX = Math.abs(a274.endX - a274.startX), a274.dragY = Math.abs(a274.endY - a274.startY), (i345.globals.zoomEnabled || i345.globals.selectionEnabled) && a274.selectionDrawn({
                                context: a274,
                                zoomtype: r184
                            }), i345.globals.panEnabled && i345.config.xaxis.convertedCatToNumeric && a274.delayedPanScrolled()), i345.globals.zoomEnabled && a274.hideSelectionRect(this.selectionRect), a274.dragged = !1, a274.w.globals.mousedown = !1;
                        }
                        this.makeSelectionRectDraggable();
                    }
                }
            }
        },
        {
            key: "makeSelectionRectDraggable",
            value: function() {
                var t594 = this.w;
                if (this.selectionRect) {
                    var e460 = this.selectionRect.node.getBoundingClientRect();
                    e460.width > 0 && e460.height > 0 && this.slDraggableRect.selectize({
                        points: "l, r",
                        pointSize: 8,
                        pointType: "rect"
                    }).resize({
                        constraint: {
                            minX: 0,
                            minY: 0,
                            maxX: t594.globals.gridWidth,
                            maxY: t594.globals.gridHeight
                        }
                    }).on("resizing", this.selectionDragging.bind(this, "resizing"));
                }
            }
        },
        {
            key: "preselectedSelection",
            value: function() {
                var t595 = this.w, e461 = this.xyRatios;
                if (!t595.globals.zoomEnabled) {
                    if (void 0 !== t595.globals.selection && null !== t595.globals.selection) this.drawSelectionRect(t595.globals.selection);
                    else if (void 0 !== t595.config.chart.selection.xaxis.min && void 0 !== t595.config.chart.selection.xaxis.max) {
                        var i346 = (t595.config.chart.selection.xaxis.min - t595.globals.minX) / e461.xRatio, a275 = {
                            x: i346,
                            y: 0,
                            width: t595.globals.gridWidth - (t595.globals.maxX - t595.config.chart.selection.xaxis.max) / e461.xRatio - i346,
                            height: t595.globals.gridHeight,
                            translateX: 0,
                            translateY: 0,
                            selectionEnabled: !0
                        };
                        this.drawSelectionRect(a275), this.makeSelectionRectDraggable(), "function" == typeof t595.config.chart.events.selection && t595.config.chart.events.selection(this.ctx, {
                            xaxis: {
                                min: t595.config.chart.selection.xaxis.min,
                                max: t595.config.chart.selection.xaxis.max
                            },
                            yaxis: {}
                        });
                    }
                }
            }
        },
        {
            key: "drawSelectionRect",
            value: function(t596) {
                var e462 = t596.x, i347 = t596.y, a276 = t596.width, s221 = t596.height, r185 = t596.translateX, o161 = void 0 === r185 ? 0 : r185, n139 = t596.translateY, l112 = void 0 === n139 ? 0 : n139, h98 = this.w, c80 = this.zoomRect, d69 = this.selectionRect;
                if (this.dragged || null !== h98.globals.selection) {
                    var g58 = {
                        transform: "translate(" + o161 + ", " + l112 + ")"
                    };
                    h98.globals.zoomEnabled && this.dragged && (a276 < 0 && (a276 = 1), c80.attr({
                        x: e462,
                        y: i347,
                        width: a276,
                        height: s221,
                        fill: h98.config.chart.zoom.zoomedArea.fill.color,
                        "fill-opacity": h98.config.chart.zoom.zoomedArea.fill.opacity,
                        stroke: h98.config.chart.zoom.zoomedArea.stroke.color,
                        "stroke-width": h98.config.chart.zoom.zoomedArea.stroke.width,
                        "stroke-opacity": h98.config.chart.zoom.zoomedArea.stroke.opacity
                    }), m.setAttrs(c80.node, g58)), h98.globals.selectionEnabled && (d69.attr({
                        x: e462,
                        y: i347,
                        width: a276 > 0 ? a276 : 0,
                        height: s221 > 0 ? s221 : 0,
                        fill: h98.config.chart.selection.fill.color,
                        "fill-opacity": h98.config.chart.selection.fill.opacity,
                        stroke: h98.config.chart.selection.stroke.color,
                        "stroke-width": h98.config.chart.selection.stroke.width,
                        "stroke-dasharray": h98.config.chart.selection.stroke.dashArray,
                        "stroke-opacity": h98.config.chart.selection.stroke.opacity
                    }), m.setAttrs(d69.node, g58));
                }
            }
        },
        {
            key: "hideSelectionRect",
            value: function(t597) {
                t597 && t597.attr({
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                });
            }
        },
        {
            key: "selectionDrawing",
            value: function(t598) {
                var e463 = t598.context, i348 = t598.zoomtype, a277 = this.w, s222 = e463, r186 = this.gridRect.getBoundingClientRect(), o162 = s222.startX - 1, n140 = s222.startY, l113 = !1, h99 = !1, c81 = s222.clientX - r186.left - o162, d70 = s222.clientY - r186.top - n140, g59 = {};
                return Math.abs(c81 + o162) > a277.globals.gridWidth ? c81 = a277.globals.gridWidth - o162 : s222.clientX - r186.left < 0 && (c81 = o162), o162 > s222.clientX - r186.left && (l113 = !0, c81 = Math.abs(c81)), n140 > s222.clientY - r186.top && (h99 = !0, d70 = Math.abs(d70)), g59 = "x" === i348 ? {
                    x: l113 ? o162 - c81 : o162,
                    y: 0,
                    width: c81,
                    height: a277.globals.gridHeight
                } : "y" === i348 ? {
                    x: 0,
                    y: h99 ? n140 - d70 : n140,
                    width: a277.globals.gridWidth,
                    height: d70
                } : {
                    x: l113 ? o162 - c81 : o162,
                    y: h99 ? n140 - d70 : n140,
                    width: c81,
                    height: d70
                }, s222.drawSelectionRect(g59), s222.selectionDragging("resizing"), g59;
            }
        },
        {
            key: "selectionDragging",
            value: function(t599, e464) {
                var i349 = this, a278 = this.w, s223 = this.xyRatios, r187 = this.selectionRect, o163 = 0;
                "resizing" === t599 && (o163 = 30);
                var n141 = function(t600) {
                    return parseFloat(r187.node.getAttribute(t600));
                }, l114 = {
                    x: n141("x"),
                    y: n141("y"),
                    width: n141("width"),
                    height: n141("height")
                };
                a278.globals.selection = l114, "function" == typeof a278.config.chart.events.selection && a278.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
                    var t601 = i349.gridRect.getBoundingClientRect(), e465 = r187.node.getBoundingClientRect(), o164 = {
                        xaxis: {
                            min: a278.globals.xAxisScale.niceMin + (e465.left - t601.left) * s223.xRatio,
                            max: a278.globals.xAxisScale.niceMin + (e465.right - t601.left) * s223.xRatio
                        },
                        yaxis: {
                            min: a278.globals.yAxisScale[0].niceMin + (t601.bottom - e465.bottom) * s223.yRatio[0],
                            max: a278.globals.yAxisScale[0].niceMax - (e465.top - t601.top) * s223.yRatio[0]
                        }
                    };
                    a278.config.chart.events.selection(i349.ctx, o164), a278.config.chart.brush.enabled && void 0 !== a278.config.chart.events.brushScrolled && a278.config.chart.events.brushScrolled(i349.ctx, o164);
                }, o163));
            }
        },
        {
            key: "selectionDrawn",
            value: function(t602) {
                var e466 = t602.context, i350 = t602.zoomtype, a279 = this.w, s224 = e466, r188 = this.xyRatios, o165 = this.ctx.toolbar;
                if (s224.startX > s224.endX) {
                    var n142 = s224.startX;
                    s224.startX = s224.endX, s224.endX = n142;
                }
                if (s224.startY > s224.endY) {
                    var l115 = s224.startY;
                    s224.startY = s224.endY, s224.endY = l115;
                }
                var h100 = void 0, c82 = void 0;
                a279.globals.isRangeBar ? (h100 = a279.globals.yAxisScale[0].niceMin + s224.startX * r188.invertedYRatio, c82 = a279.globals.yAxisScale[0].niceMin + s224.endX * r188.invertedYRatio) : (h100 = a279.globals.xAxisScale.niceMin + s224.startX * r188.xRatio, c82 = a279.globals.xAxisScale.niceMin + s224.endX * r188.xRatio);
                var d71 = [], g60 = [];
                if (a279.config.yaxis.forEach(function(t, e467) {
                    d71.push(a279.globals.yAxisScale[e467].niceMax - r188.yRatio[e467] * s224.startY), g60.push(a279.globals.yAxisScale[e467].niceMax - r188.yRatio[e467] * s224.endY);
                }), s224.dragged && (s224.dragX > 10 || s224.dragY > 10) && h100 !== c82) {
                    if (a279.globals.zoomEnabled) {
                        var u46 = x.clone(a279.globals.initialConfig.yaxis), p39 = x.clone(a279.globals.initialConfig.xaxis);
                        if (a279.globals.zoomed = !0, a279.config.xaxis.convertedCatToNumeric && (h100 = Math.floor(h100), c82 = Math.floor(c82), h100 < 1 && (h100 = 1, c82 = a279.globals.dataPoints), c82 - h100 < 2 && (c82 = h100 + 1)), "xy" !== i350 && "x" !== i350 || (p39 = {
                            min: h100,
                            max: c82
                        }), "xy" !== i350 && "y" !== i350 || u46.forEach(function(t, e468) {
                            u46[e468].min = g60[e468], u46[e468].max = d71[e468];
                        }), a279.config.chart.zoom.autoScaleYaxis) {
                            var f35 = new q(s224.ctx);
                            u46 = f35.autoScaleY(s224.ctx, u46, {
                                xaxis: p39
                            });
                        }
                        if (o165) {
                            var b29 = o165.getBeforeZoomRange(p39, u46);
                            b29 && (p39 = b29.xaxis ? b29.xaxis : p39, u46 = b29.yaxis ? b29.yaxis : u46);
                        }
                        var v20 = {
                            xaxis: p39
                        };
                        a279.config.chart.group || (v20.yaxis = u46), s224.ctx.updateHelpers._updateOptions(v20, !1, s224.w.config.chart.animations.dynamicAnimation.enabled), "function" == typeof a279.config.chart.events.zoomed && o165.zoomCallback(p39, u46);
                    } else if (a279.globals.selectionEnabled) {
                        var m7, y20 = null;
                        m7 = {
                            min: h100,
                            max: c82
                        }, "xy" !== i350 && "y" !== i350 || (y20 = x.clone(a279.config.yaxis)).forEach(function(t, e469) {
                            y20[e469].min = g60[e469], y20[e469].max = d71[e469];
                        }), a279.globals.selection = s224.selection, "function" == typeof a279.config.chart.events.selection && a279.config.chart.events.selection(s224.ctx, {
                            xaxis: m7,
                            yaxis: y20
                        });
                    }
                }
            }
        },
        {
            key: "panDragging",
            value: function(t603) {
                var e470 = t603.context, i351 = this.w, a280 = e470;
                if (void 0 !== i351.globals.lastClientPosition.x) {
                    var s225 = i351.globals.lastClientPosition.x - a280.clientX, r189 = i351.globals.lastClientPosition.y - a280.clientY;
                    Math.abs(s225) > Math.abs(r189) && s225 > 0 ? this.moveDirection = "left" : Math.abs(s225) > Math.abs(r189) && s225 < 0 ? this.moveDirection = "right" : Math.abs(r189) > Math.abs(s225) && r189 > 0 ? this.moveDirection = "up" : Math.abs(r189) > Math.abs(s225) && r189 < 0 && (this.moveDirection = "down");
                }
                i351.globals.lastClientPosition = {
                    x: a280.clientX,
                    y: a280.clientY
                };
                var o166 = i351.globals.isRangeBar ? i351.globals.minY : i351.globals.minX, n143 = i351.globals.isRangeBar ? i351.globals.maxY : i351.globals.maxX;
                i351.config.xaxis.convertedCatToNumeric || a280.panScrolled(o166, n143);
            }
        },
        {
            key: "delayedPanScrolled",
            value: function() {
                var t604 = this.w, e471 = t604.globals.minX, i352 = t604.globals.maxX, a281 = (t604.globals.maxX - t604.globals.minX) / 2;
                "left" === this.moveDirection ? (e471 = t604.globals.minX + a281, i352 = t604.globals.maxX + a281) : "right" === this.moveDirection && (e471 = t604.globals.minX - a281, i352 = t604.globals.maxX - a281), e471 = Math.floor(e471), i352 = Math.floor(i352), this.updateScrolledChart({
                    xaxis: {
                        min: e471,
                        max: i352
                    }
                }, e471, i352);
            }
        },
        {
            key: "panScrolled",
            value: function(t605, e472) {
                var i353 = this.w, a282 = this.xyRatios, s226 = x.clone(i353.globals.initialConfig.yaxis), r190 = a282.xRatio, o167 = i353.globals.minX, n144 = i353.globals.maxX;
                i353.globals.isRangeBar && (r190 = a282.invertedYRatio, o167 = i353.globals.minY, n144 = i353.globals.maxY), "left" === this.moveDirection ? (t605 = o167 + i353.globals.gridWidth / 15 * r190, e472 = n144 + i353.globals.gridWidth / 15 * r190) : "right" === this.moveDirection && (t605 = o167 - i353.globals.gridWidth / 15 * r190, e472 = n144 - i353.globals.gridWidth / 15 * r190), i353.globals.isRangeBar || (t605 < i353.globals.initialMinX || e472 > i353.globals.initialMaxX) && (t605 = o167, e472 = n144);
                var l116 = {
                    min: t605,
                    max: e472
                };
                i353.config.chart.zoom.autoScaleYaxis && (s226 = new q(this.ctx).autoScaleY(this.ctx, s226, {
                    xaxis: l116
                }));
                var h101 = {
                    xaxis: {
                        min: t605,
                        max: e472
                    }
                };
                i353.config.chart.group || (h101.yaxis = s226), this.updateScrolledChart(h101, t605, e472);
            }
        },
        {
            key: "updateScrolledChart",
            value: function(t606, e473, i354) {
                var a283 = this.w;
                this.ctx.updateHelpers._updateOptions(t606, !1, !1), "function" == typeof a283.config.chart.events.scrolled && a283.config.chart.events.scrolled(this.ctx, {
                    xaxis: {
                        min: e473,
                        max: i354
                    }
                });
            }
        }
    ]), i343;
}(), ut = function() {
    function t607(e474) {
        a(this, t607), this.w = e474.w, this.ttCtx = e474, this.ctx = e474.ctx;
    }
    return r(t607, [
        {
            key: "getNearestValues",
            value: function(t608) {
                var e475 = t608.hoverArea, i355 = t608.elGrid, a284 = t608.clientX, s227 = t608.clientY, r191 = this.w, o168 = i355.getBoundingClientRect(), n145 = o168.width, l117 = o168.height, h102 = n145 / (r191.globals.dataPoints - 1), c83 = l117 / r191.globals.dataPoints, d72 = this.hasBars();
                !r191.globals.comboCharts && !d72 || r191.config.xaxis.convertedCatToNumeric || (h102 = n145 / r191.globals.dataPoints);
                var g61 = a284 - o168.left - r191.globals.barPadForNumericAxis, u47 = s227 - o168.top;
                g61 < 0 || u47 < 0 || g61 > n145 || u47 > l117 ? (e475.classList.remove("hovering-zoom"), e475.classList.remove("hovering-pan")) : r191.globals.zoomEnabled ? (e475.classList.remove("hovering-pan"), e475.classList.add("hovering-zoom")) : r191.globals.panEnabled && (e475.classList.remove("hovering-zoom"), e475.classList.add("hovering-pan"));
                var p40 = Math.round(g61 / h102), f36 = Math.floor(u47 / c83);
                d72 && !r191.config.xaxis.convertedCatToNumeric && (p40 = Math.ceil(g61 / h102), p40 -= 1);
                var b30 = null, v21 = null, m8 = [], y21 = [];
                if (r191.globals.seriesXvalues.forEach(function(t609) {
                    m8.push([
                        t609[0] + 1e-6
                    ].concat(t609));
                }), r191.globals.seriesYvalues.forEach(function(t610) {
                    y21.push([
                        t610[0] + 1e-6
                    ].concat(t610));
                }), m8 = m8.map(function(t611) {
                    return t611.filter(function(t612) {
                        return x.isNumber(t612);
                    });
                }), y21 = y21.map(function(t613) {
                    return t613.filter(function(t614) {
                        return x.isNumber(t614);
                    });
                }), r191.globals.isXNumeric) {
                    var w18 = this.ttCtx.getElGrid().getBoundingClientRect(), k17 = g61 * (w18.width / n145), A13 = u47 * (w18.height / l117);
                    b30 = (v21 = this.closestInMultiArray(k17, A13, m8, y21)).index, p40 = v21.j, null !== b30 && (m8 = r191.globals.seriesXvalues[b30], p40 = (v21 = this.closestInArray(k17, m8)).index);
                }
                return r191.globals.capturedSeriesIndex = null === b30 ? -1 : b30, (!p40 || p40 < 1) && (p40 = 0), r191.globals.isBarHorizontal ? r191.globals.capturedDataPointIndex = f36 : r191.globals.capturedDataPointIndex = p40, {
                    capturedSeries: b30,
                    j: r191.globals.isBarHorizontal ? f36 : p40,
                    hoverX: g61,
                    hoverY: u47
                };
            }
        },
        {
            key: "closestInMultiArray",
            value: function(t615, e476, i356, a285) {
                var s228 = this.w, r192 = 0, o169 = null, n146 = -1;
                s228.globals.series.length > 1 ? r192 = this.getFirstActiveXArray(i356) : o169 = 0;
                var l118 = i356[r192][0], h103 = Math.abs(t615 - l118);
                if (i356.forEach(function(e477) {
                    e477.forEach(function(e478, i357) {
                        var a286 = Math.abs(t615 - e478);
                        a286 < h103 && (h103 = a286, n146 = i357);
                    });
                }), -1 !== n146) {
                    var c84 = a285[r192][n146], d73 = Math.abs(e476 - c84);
                    o169 = r192, a285.forEach(function(t616, i358) {
                        var a287 = Math.abs(e476 - t616[n146]);
                        a287 < d73 && (d73 = a287, o169 = i358);
                    });
                }
                return {
                    index: o169,
                    j: n146
                };
            }
        },
        {
            key: "getFirstActiveXArray",
            value: function(t617) {
                for(var e479 = this.w, i359 = 0, a288 = t617.map(function(t618, e480) {
                    return t618.length > 0 ? e480 : -1;
                }), s229 = 0; s229 < a288.length; s229++)if (-1 !== a288[s229] && -1 === e479.globals.collapsedSeriesIndices.indexOf(s229) && -1 === e479.globals.ancillaryCollapsedSeriesIndices.indexOf(s229)) {
                    i359 = a288[s229];
                    break;
                }
                return i359;
            }
        },
        {
            key: "closestInArray",
            value: function(t619, e481) {
                for(var i360 = e481[0], a289 = null, s230 = Math.abs(t619 - i360), r193 = 0; r193 < e481.length; r193++){
                    var o170 = Math.abs(t619 - e481[r193]);
                    o170 < s230 && (s230 = o170, a289 = r193);
                }
                return {
                    index: a289
                };
            }
        },
        {
            key: "isXoverlap",
            value: function(t620) {
                var e482 = [], i361 = this.w.globals.seriesX.filter(function(t621) {
                    return void 0 !== t621[0];
                });
                if (i361.length > 0) for(var a290 = 0; a290 < i361.length - 1; a290++)void 0 !== i361[a290][t620] && void 0 !== i361[a290 + 1][t620] && i361[a290][t620] !== i361[a290 + 1][t620] && e482.push("unEqual");
                return 0 === e482.length;
            }
        },
        {
            key: "isInitialSeriesSameLen",
            value: function() {
                for(var t622 = !0, e483 = this.w.globals.initialSeries, i362 = 0; i362 < e483.length - 1; i362++)if (e483[i362].data.length !== e483[i362 + 1].data.length) {
                    t622 = !1;
                    break;
                }
                return t622;
            }
        },
        {
            key: "getBarsHeight",
            value: function(t623) {
                return u(t623).reduce(function(t624, e484) {
                    return t624 + e484.getBBox().height;
                }, 0);
            }
        },
        {
            key: "getElMarkers",
            value: function() {
                return this.w.globals.dom.baseEl.querySelectorAll(" .apexcharts-series-markers");
            }
        },
        {
            key: "getAllMarkers",
            value: function() {
                var t625 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
                (t625 = u(t625)).sort(function(t626, e486) {
                    return Number(e486.getAttribute("data:realIndex")) < Number(t626.getAttribute("data:realIndex")) ? 0 : -1;
                });
                var e485 = [];
                return t625.forEach(function(t627) {
                    e485.push(t627.querySelector(".apexcharts-marker"));
                }), e485;
            }
        },
        {
            key: "hasMarkers",
            value: function() {
                return this.getElMarkers().length > 0;
            }
        },
        {
            key: "getElBars",
            value: function() {
                return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
            }
        },
        {
            key: "hasBars",
            value: function() {
                return this.getElBars().length > 0;
            }
        },
        {
            key: "getHoverMarkerSize",
            value: function(t628) {
                var e487 = this.w, i363 = e487.config.markers.hover.size;
                return void 0 === i363 && (i363 = e487.globals.markers.size[t628] + e487.config.markers.hover.sizeOffset), i363;
            }
        },
        {
            key: "toggleAllTooltipSeriesGroups",
            value: function(t629) {
                var e488 = this.w, i364 = this.ttCtx;
                0 === i364.allTooltipSeriesGroups.length && (i364.allTooltipSeriesGroups = e488.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
                for(var a291 = i364.allTooltipSeriesGroups, s231 = 0; s231 < a291.length; s231++)"enable" === t629 ? (a291[s231].classList.add("apexcharts-active"), a291[s231].style.display = e488.config.tooltip.items.display) : (a291[s231].classList.remove("apexcharts-active"), a291[s231].style.display = "none");
            }
        }
    ]), t607;
}(), pt = function() {
    function t630(e489) {
        a(this, t630), this.w = e489.w, this.ctx = e489.ctx, this.ttCtx = e489, this.tooltipUtil = new ut(e489);
    }
    return r(t630, [
        {
            key: "drawSeriesTexts",
            value: function(t631) {
                var e490 = t631.shared, i365 = void 0 === e490 || e490, a292 = t631.ttItems, s232 = t631.i, r194 = void 0 === s232 ? 0 : s232, o171 = t631.j, n147 = void 0 === o171 ? null : o171, l119 = t631.y1, h104 = t631.y2, c85 = t631.e, d74 = this.w;
                void 0 !== d74.config.tooltip.custom ? this.handleCustomTooltip({
                    i: r194,
                    j: n147,
                    y1: l119,
                    y2: h104,
                    w: d74
                }) : this.toggleActiveInactiveSeries(i365);
                var g62 = this.getValuesToPrint({
                    i: r194,
                    j: n147
                });
                this.printLabels({
                    i: r194,
                    j: n147,
                    values: g62,
                    ttItems: a292,
                    shared: i365,
                    e: c85
                });
                var u48 = this.ttCtx.getElTooltip();
                this.ttCtx.tooltipRect.ttWidth = u48.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = u48.getBoundingClientRect().height;
            }
        },
        {
            key: "printLabels",
            value: function(t632) {
                var i366, a293 = this, s233 = t632.i, r195 = t632.j, o172 = t632.values, n148 = t632.ttItems, l120 = t632.shared, h105 = t632.e, c86 = this.w, d75 = [], g63 = function(t633) {
                    return c86.globals.seriesGoals[t633] && c86.globals.seriesGoals[t633][r195] && Array.isArray(c86.globals.seriesGoals[t633][r195]);
                }, u49 = o172.xVal, p41 = o172.zVal, f37 = o172.xAxisTTVal, x26 = "", b31 = c86.globals.colors[s233];
                null !== r195 && c86.config.plotOptions.bar.distributed && (b31 = c86.globals.colors[r195]);
                for(var v22 = function(t634, o173) {
                    var v23 = a293.getFormatters(s233);
                    x26 = a293.getSeriesName({
                        fn: v23.yLbTitleFormatter,
                        index: s233,
                        seriesIndex: s233,
                        j: r195
                    }), "treemap" === c86.config.chart.type && (x26 = v23.yLbTitleFormatter(String(c86.config.series[s233].data[r195].x), {
                        series: c86.globals.series,
                        seriesIndex: s233,
                        dataPointIndex: r195,
                        w: c86
                    }));
                    var m10 = c86.config.tooltip.inverseOrder ? o173 : t634;
                    if (c86.globals.axisCharts) {
                        var y23 = function(t635) {
                            return v23.yLbFormatter(c86.globals.series[t635][r195], {
                                series: c86.globals.series,
                                seriesIndex: t635,
                                dataPointIndex: r195,
                                w: c86
                            });
                        };
                        if (l120) v23 = a293.getFormatters(m10), x26 = a293.getSeriesName({
                            fn: v23.yLbTitleFormatter,
                            index: m10,
                            seriesIndex: s233,
                            j: r195
                        }), b31 = c86.globals.colors[m10], i366 = y23(m10), g63(m10) && (d75 = c86.globals.seriesGoals[m10][r195].map(function(t636) {
                            return {
                                attrs: t636,
                                val: v23.yLbFormatter(t636.value, {
                                    seriesIndex: m10,
                                    dataPointIndex: r195,
                                    w: c86
                                })
                            };
                        }));
                        else {
                            var w19, k18 = null == h105 || null === (w19 = h105.target) || void 0 === w19 ? void 0 : w19.getAttribute("fill");
                            k18 && (b31 = -1 !== k18.indexOf("url") ? document.querySelector(k18.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke") : k18), i366 = y23(s233), g63(s233) && Array.isArray(c86.globals.seriesGoals[s233][r195]) && (d75 = c86.globals.seriesGoals[s233][r195].map(function(t637) {
                                return {
                                    attrs: t637,
                                    val: v23.yLbFormatter(t637.value, {
                                        seriesIndex: s233,
                                        dataPointIndex: r195,
                                        w: c86
                                    })
                                };
                            }));
                        }
                    }
                    null === r195 && (i366 = v23.yLbFormatter(c86.globals.series[s233], e(e({}, c86), {}, {
                        seriesIndex: s233,
                        dataPointIndex: s233
                    }))), a293.DOMHandling({
                        i: s233,
                        t: m10,
                        j: r195,
                        ttItems: n148,
                        values: {
                            val: i366,
                            goalVals: d75,
                            xVal: u49,
                            xAxisTTVal: f37,
                            zVal: p41
                        },
                        seriesName: x26,
                        shared: l120,
                        pColor: b31
                    });
                }, m9 = 0, y22 = c86.globals.series.length - 1; m9 < c86.globals.series.length; m9++, y22--)v22(m9, y22);
            }
        },
        {
            key: "getFormatters",
            value: function(t638) {
                var e491, i367 = this.w, a294 = i367.globals.yLabelFormatters[t638];
                return void 0 !== i367.globals.ttVal ? Array.isArray(i367.globals.ttVal) ? (a294 = i367.globals.ttVal[t638] && i367.globals.ttVal[t638].formatter, e491 = i367.globals.ttVal[t638] && i367.globals.ttVal[t638].title && i367.globals.ttVal[t638].title.formatter) : (a294 = i367.globals.ttVal.formatter, "function" == typeof i367.globals.ttVal.title.formatter && (e491 = i367.globals.ttVal.title.formatter)) : e491 = i367.config.tooltip.y.title.formatter, "function" != typeof a294 && (a294 = i367.globals.yLabelFormatters[0] ? i367.globals.yLabelFormatters[0] : function(t639) {
                    return t639;
                }), "function" != typeof e491 && (e491 = function(t640) {
                    return t640;
                }), {
                    yLbFormatter: a294,
                    yLbTitleFormatter: e491
                };
            }
        },
        {
            key: "getSeriesName",
            value: function(t641) {
                var e492 = t641.fn, i368 = t641.index, a295 = t641.seriesIndex, s234 = t641.j, r196 = this.w;
                return e492(String(r196.globals.seriesNames[i368]), {
                    series: r196.globals.series,
                    seriesIndex: a295,
                    dataPointIndex: s234,
                    w: r196
                });
            }
        },
        {
            key: "DOMHandling",
            value: function(t642) {
                t642.i;
                var e493 = t642.t, i369 = t642.j, a296 = t642.ttItems, s235 = t642.values, r197 = t642.seriesName, o174 = t642.shared, n149 = t642.pColor, l121 = this.w, h106 = this.ttCtx, c87 = s235.val, d76 = s235.goalVals, g64 = s235.xVal, u50 = s235.xAxisTTVal, p42 = s235.zVal, f38 = null;
                f38 = a296[e493].children, l121.config.tooltip.fillSeriesColor && (a296[e493].style.backgroundColor = n149, f38[0].style.display = "none"), h106.showTooltipTitle && (null === h106.tooltipTitle && (h106.tooltipTitle = l121.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), h106.tooltipTitle.innerHTML = g64), h106.isXAxisTooltipEnabled && (h106.xaxisTooltipText.innerHTML = "" !== u50 ? u50 : g64);
                var x27 = a296[e493].querySelector(".apexcharts-tooltip-text-y-label");
                x27 && (x27.innerHTML = r197 || "");
                var b32 = a296[e493].querySelector(".apexcharts-tooltip-text-y-value");
                b32 && (b32.innerHTML = void 0 !== c87 ? c87 : ""), f38[0] && f38[0].classList.contains("apexcharts-tooltip-marker") && (l121.config.tooltip.marker.fillColors && Array.isArray(l121.config.tooltip.marker.fillColors) && (n149 = l121.config.tooltip.marker.fillColors[e493]), f38[0].style.backgroundColor = n149), l121.config.tooltip.marker.show || (f38[0].style.display = "none");
                var v24 = a296[e493].querySelector(".apexcharts-tooltip-text-goals-label"), m11 = a296[e493].querySelector(".apexcharts-tooltip-text-goals-value");
                if (d76.length && l121.globals.seriesGoals[e493]) {
                    var y24 = function() {
                        var t643 = "<div >", e494 = "<div>";
                        d76.forEach(function(i370, a) {
                            t643 += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(i370.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(i370.attrs.name, "</div>"), e494 += "<div>".concat(i370.val, "</div>");
                        }), v24.innerHTML = t643 + "</div>", m11.innerHTML = e494 + "</div>";
                    };
                    o174 ? l121.globals.seriesGoals[e493][i369] && Array.isArray(l121.globals.seriesGoals[e493][i369]) ? y24() : (v24.innerHTML = "", m11.innerHTML = "") : y24();
                } else v24.innerHTML = "", m11.innerHTML = "";
                null !== p42 && (a296[e493].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = l121.config.tooltip.z.title, a296[e493].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== p42 ? p42 : "");
                o174 && f38[0] && (null == c87 || l121.globals.ancillaryCollapsedSeriesIndices.indexOf(e493) > -1 || l121.globals.collapsedSeriesIndices.indexOf(e493) > -1 ? f38[0].parentNode.style.display = "none" : f38[0].parentNode.style.display = l121.config.tooltip.items.display);
            }
        },
        {
            key: "toggleActiveInactiveSeries",
            value: function(t644) {
                var e495 = this.w;
                if (t644) this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
                else {
                    this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
                    var i371 = e495.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
                    i371 && (i371.classList.add("apexcharts-active"), i371.style.display = e495.config.tooltip.items.display);
                }
            }
        },
        {
            key: "getValuesToPrint",
            value: function(t645) {
                var e496 = t645.i, i372 = t645.j, a297 = this.w, s236 = this.ctx.series.filteredSeriesX(), r198 = "", o175 = "", n150 = null, l122 = null, h107 = {
                    series: a297.globals.series,
                    seriesIndex: e496,
                    dataPointIndex: i372,
                    w: a297
                }, c88 = a297.globals.ttZFormatter;
                null === i372 ? l122 = a297.globals.series[e496] : a297.globals.isXNumeric && "treemap" !== a297.config.chart.type ? (r198 = s236[e496][i372], 0 === s236[e496].length && (r198 = s236[this.tooltipUtil.getFirstActiveXArray(s236)][i372])) : r198 = void 0 !== a297.globals.labels[i372] ? a297.globals.labels[i372] : "";
                var d77 = r198;
                a297.globals.isXNumeric && "datetime" === a297.config.xaxis.type ? r198 = new V(this.ctx).xLabelFormat(a297.globals.ttKeyFormatter, d77, d77, {
                    i: void 0,
                    dateFormatter: new R(this.ctx).formatDate,
                    w: this.w
                }) : r198 = a297.globals.isBarHorizontal ? a297.globals.yLabelFormatters[0](d77, h107) : a297.globals.xLabelFormatter(d77, h107);
                return void 0 !== a297.config.tooltip.x.formatter && (r198 = a297.globals.ttKeyFormatter(d77, h107)), a297.globals.seriesZ.length > 0 && a297.globals.seriesZ[e496].length > 0 && (n150 = c88(a297.globals.seriesZ[e496][i372], a297)), o175 = "function" == typeof a297.config.xaxis.tooltip.formatter ? a297.globals.xaxisTooltipFormatter(d77, h107) : r198, {
                    val: Array.isArray(l122) ? l122.join(" ") : l122,
                    xVal: Array.isArray(r198) ? r198.join(" ") : r198,
                    xAxisTTVal: Array.isArray(o175) ? o175.join(" ") : o175,
                    zVal: n150
                };
            }
        },
        {
            key: "handleCustomTooltip",
            value: function(t646) {
                var e497 = t646.i, i373 = t646.j, a298 = t646.y1, s237 = t646.y2, r199 = t646.w, o176 = this.ttCtx.getElTooltip(), n151 = r199.config.tooltip.custom;
                Array.isArray(n151) && n151[e497] && (n151 = n151[e497]), o176.innerHTML = n151({
                    ctx: this.ctx,
                    series: r199.globals.series,
                    seriesIndex: e497,
                    dataPointIndex: i373,
                    y1: a298,
                    y2: s237,
                    w: r199
                });
            }
        }
    ]), t630;
}(), ft = function() {
    function t647(e498) {
        a(this, t647), this.ttCtx = e498, this.ctx = e498.ctx, this.w = e498.w;
    }
    return r(t647, [
        {
            key: "moveXCrosshairs",
            value: function(t648) {
                var e499 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i374 = this.ttCtx, a299 = this.w, s238 = i374.getElXCrosshairs(), r200 = t648 - i374.xcrosshairsWidth / 2, o177 = a299.globals.labels.slice().length;
                if (null !== e499 && (r200 = a299.globals.gridWidth / o177 * e499), null === s238 || a299.globals.isBarHorizontal || (s238.setAttribute("x", r200), s238.setAttribute("x1", r200), s238.setAttribute("x2", r200), s238.setAttribute("y2", a299.globals.gridHeight), s238.classList.add("apexcharts-active")), r200 < 0 && (r200 = 0), r200 > a299.globals.gridWidth && (r200 = a299.globals.gridWidth), i374.isXAxisTooltipEnabled) {
                    var n152 = r200;
                    "tickWidth" !== a299.config.xaxis.crosshairs.width && "barWidth" !== a299.config.xaxis.crosshairs.width || (n152 = r200 + i374.xcrosshairsWidth / 2), this.moveXAxisTooltip(n152);
                }
            }
        },
        {
            key: "moveYCrosshairs",
            value: function(t649) {
                var e500 = this.ttCtx;
                null !== e500.ycrosshairs && m.setAttrs(e500.ycrosshairs, {
                    y1: t649,
                    y2: t649
                }), null !== e500.ycrosshairsHidden && m.setAttrs(e500.ycrosshairsHidden, {
                    y1: t649,
                    y2: t649
                });
            }
        },
        {
            key: "moveXAxisTooltip",
            value: function(t650) {
                var e501 = this.w, i375 = this.ttCtx;
                if (null !== i375.xaxisTooltip && 0 !== i375.xcrosshairsWidth) {
                    i375.xaxisTooltip.classList.add("apexcharts-active");
                    var a300 = i375.xaxisOffY + e501.config.xaxis.tooltip.offsetY + e501.globals.translateY + 1 + e501.config.xaxis.offsetY;
                    if (t650 -= i375.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t650)) {
                        t650 += e501.globals.translateX;
                        var s239;
                        s239 = new m(this.ctx).getTextRects(i375.xaxisTooltipText.innerHTML), i375.xaxisTooltipText.style.minWidth = s239.width + "px", i375.xaxisTooltip.style.left = t650 + "px", i375.xaxisTooltip.style.top = a300 + "px";
                    }
                }
            }
        },
        {
            key: "moveYAxisTooltip",
            value: function(t651) {
                var e502 = this.w, i376 = this.ttCtx;
                null === i376.yaxisTTEls && (i376.yaxisTTEls = e502.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                var a301 = parseInt(i376.ycrosshairsHidden.getAttribute("y1"), 10), s240 = e502.globals.translateY + a301, r201 = i376.yaxisTTEls[t651].getBoundingClientRect().height, o178 = e502.globals.translateYAxisX[t651] - 2;
                e502.config.yaxis[t651].opposite && (o178 -= 26), s240 -= r201 / 2, -1 === e502.globals.ignoreYAxisIndexes.indexOf(t651) ? (i376.yaxisTTEls[t651].classList.add("apexcharts-active"), i376.yaxisTTEls[t651].style.top = s240 + "px", i376.yaxisTTEls[t651].style.left = o178 + e502.config.yaxis[t651].tooltip.offsetX + "px") : i376.yaxisTTEls[t651].classList.remove("apexcharts-active");
            }
        },
        {
            key: "moveTooltip",
            value: function(t652, e503) {
                var i377 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a302 = this.w, s241 = this.ttCtx, r202 = s241.getElTooltip(), o179 = s241.tooltipRect, n153 = null !== i377 ? parseFloat(i377) : 1, l123 = parseFloat(t652) + n153 + 5, h108 = parseFloat(e503) + n153 / 2;
                if (l123 > a302.globals.gridWidth / 2 && (l123 = l123 - o179.ttWidth - n153 - 10), l123 > a302.globals.gridWidth - o179.ttWidth - 10 && (l123 = a302.globals.gridWidth - o179.ttWidth), l123 < -20 && (l123 = -20), a302.config.tooltip.followCursor) {
                    var c89 = s241.getElGrid(), d78 = c89.getBoundingClientRect();
                    h108 = s241.e.clientY + a302.globals.translateY - d78.top - o179.ttHeight / 2;
                } else a302.globals.isBarHorizontal || (o179.ttHeight / 2 + h108 > a302.globals.gridHeight && (h108 = a302.globals.gridHeight - o179.ttHeight + a302.globals.translateY), h108 < 0 && (h108 = 0));
                isNaN(l123) || (l123 += a302.globals.translateX, r202.style.left = l123 + "px", r202.style.top = h108 + "px");
            }
        },
        {
            key: "moveMarkers",
            value: function(t653, e504) {
                var i378 = this.w, a303 = this.ttCtx;
                if (i378.globals.markers.size[t653] > 0) for(var s242 = i378.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t653, "'] .apexcharts-marker")), r203 = 0; r203 < s242.length; r203++)parseInt(s242[r203].getAttribute("rel"), 10) === e504 && (a303.marker.resetPointsSize(), a303.marker.enlargeCurrentPoint(e504, s242[r203]));
                else a303.marker.resetPointsSize(), this.moveDynamicPointOnHover(e504, t653);
            }
        },
        {
            key: "moveDynamicPointOnHover",
            value: function(t654, e505) {
                var i379, a304, s243 = this.w, r204 = this.ttCtx, o180 = s243.globals.pointsArray, n154 = r204.tooltipUtil.getHoverMarkerSize(e505), l124 = s243.config.series[e505].type;
                if (!l124 || "column" !== l124 && "candlestick" !== l124 && "boxPlot" !== l124) {
                    i379 = o180[e505][t654][0], a304 = o180[e505][t654][1] ? o180[e505][t654][1] : 0;
                    var h109 = s243.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e505, "'] .apexcharts-series-markers circle"));
                    h109 && a304 < s243.globals.gridHeight && a304 > 0 && (h109.setAttribute("r", n154), h109.setAttribute("cx", i379), h109.setAttribute("cy", a304)), this.moveXCrosshairs(i379), r204.fixedTooltip || this.moveTooltip(i379, a304, n154);
                }
            }
        },
        {
            key: "moveDynamicPointsOnHover",
            value: function(t655) {
                var e506, i380 = this.ttCtx, a305 = i380.w, s244 = 0, r205 = 0, o181 = a305.globals.pointsArray;
                e506 = new E(this.ctx).getActiveConfigSeriesIndex(!0);
                var n155 = i380.tooltipUtil.getHoverMarkerSize(e506);
                o181[e506] && (s244 = o181[e506][t655][0], r205 = o181[e506][t655][1]);
                var l125 = i380.tooltipUtil.getAllMarkers();
                if (null !== l125) for(var h110 = 0; h110 < a305.globals.series.length; h110++){
                    var c90 = o181[h110];
                    if (a305.globals.comboCharts && void 0 === c90 && l125.splice(h110, 0, null), c90 && c90.length) {
                        var d79 = o181[h110][t655][1];
                        l125[h110].setAttribute("cx", s244), null !== d79 && !isNaN(d79) && d79 < a305.globals.gridHeight + n155 && d79 + n155 > 0 ? (l125[h110] && l125[h110].setAttribute("r", n155), l125[h110] && l125[h110].setAttribute("cy", d79)) : l125[h110] && l125[h110].setAttribute("r", 0);
                    }
                }
                if (this.moveXCrosshairs(s244), !i380.fixedTooltip) {
                    var g65 = r205 || a305.globals.gridHeight;
                    this.moveTooltip(s244, g65, n155);
                }
            }
        },
        {
            key: "moveStickyTooltipOverBars",
            value: function(t656) {
                var e507 = this.w, i381 = this.ttCtx, a306 = e507.globals.columnSeries ? e507.globals.columnSeries.length : e507.globals.series.length, s245 = a306 >= 2 && a306 % 2 == 0 ? Math.floor(a306 / 2) : Math.floor(a306 / 2) + 1;
                e507.globals.isBarHorizontal && (s245 = new E(this.ctx).getActiveConfigSeriesIndex(!1, "desc") + 1);
                var r206 = e507.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(s245, "'] path[j='").concat(t656, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(s245, "'] path[j='").concat(t656, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(s245, "'] path[j='").concat(t656, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(s245, "'] path[j='").concat(t656, "']")), o182 = r206 ? parseFloat(r206.getAttribute("cx")) : 0, n156 = r206 ? parseFloat(r206.getAttribute("cy")) : 0, l126 = r206 ? parseFloat(r206.getAttribute("barWidth")) : 0, h111 = r206 ? parseFloat(r206.getAttribute("barHeight")) : 0, c91 = i381.getElGrid().getBoundingClientRect(), d80 = r206.classList.contains("apexcharts-candlestick-area") || r206.classList.contains("apexcharts-boxPlot-area");
                if (e507.globals.isXNumeric ? (r206 && !d80 && (o182 -= a306 % 2 != 0 ? l126 / 2 : 0), r206 && d80 && e507.globals.comboCharts && (o182 -= l126 / 2)) : e507.globals.isBarHorizontal || (o182 = i381.xAxisTicksPositions[t656 - 1] + i381.dataPointsDividedWidth / 2, isNaN(o182) && (o182 = i381.xAxisTicksPositions[t656] - i381.dataPointsDividedWidth / 2)), e507.globals.isBarHorizontal ? (n156 > e507.globals.gridHeight / 2 && (n156 -= i381.tooltipRect.ttHeight), (n156 = n156 + e507.config.grid.padding.top + h111 / 3) + h111 > e507.globals.gridHeight && (n156 = e507.globals.gridHeight - h111)) : e507.config.tooltip.followCursor ? n156 = i381.e.clientY - c91.top - i381.tooltipRect.ttHeight / 2 : n156 + i381.tooltipRect.ttHeight + 15 > e507.globals.gridHeight && (n156 = e507.globals.gridHeight), n156 < -10 && (n156 = -10), e507.globals.isBarHorizontal || this.moveXCrosshairs(o182), !i381.fixedTooltip) {
                    var g66 = n156 || e507.globals.gridHeight;
                    this.moveTooltip(o182, g66);
                }
            }
        }
    ]), t647;
}(), xt = function() {
    function t657(e508) {
        a(this, t657), this.w = e508.w, this.ttCtx = e508, this.ctx = e508.ctx, this.tooltipPosition = new ft(e508);
    }
    return r(t657, [
        {
            key: "drawDynamicPoints",
            value: function() {
                var t658 = this.w, e509 = new m(this.ctx), i382 = new M(this.ctx), a307 = t658.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
                a307 = u(a307), t658.config.chart.stacked && a307.sort(function(t659, e510) {
                    return parseFloat(t659.getAttribute("data:realIndex")) - parseFloat(e510.getAttribute("data:realIndex"));
                });
                for(var s246 = 0; s246 < a307.length; s246++){
                    var r207 = a307[s246].querySelector(".apexcharts-series-markers-wrap");
                    if (null !== r207) {
                        var o183 = void 0, n157 = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
                        "line" !== t658.config.chart.type && "area" !== t658.config.chart.type || t658.globals.comboCharts || t658.config.tooltip.intersect || (n157 += " no-pointer-events");
                        var l127 = i382.getMarkerConfig({
                            cssClass: n157,
                            seriesIndex: Number(r207.getAttribute("data:realIndex"))
                        });
                        (o183 = e509.drawMarker(0, 0, l127)).node.setAttribute("default-marker-size", 0);
                        var h112 = document.createElementNS(t658.globals.SVGNS, "g");
                        h112.classList.add("apexcharts-series-markers"), h112.appendChild(o183.node), r207.appendChild(h112);
                    }
                }
            }
        },
        {
            key: "enlargeCurrentPoint",
            value: function(t660, e511) {
                var i383 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a308 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s247 = this.w;
                "bubble" !== s247.config.chart.type && this.newPointSize(t660, e511);
                var r208 = e511.getAttribute("cx"), o184 = e511.getAttribute("cy");
                if (null !== i383 && null !== a308 && (r208 = i383, o184 = a308), this.tooltipPosition.moveXCrosshairs(r208), !this.fixedTooltip) {
                    if ("radar" === s247.config.chart.type) {
                        var n158 = this.ttCtx.getElGrid(), l128 = n158.getBoundingClientRect();
                        r208 = this.ttCtx.e.clientX - l128.left;
                    }
                    this.tooltipPosition.moveTooltip(r208, o184, s247.config.markers.hover.size);
                }
            }
        },
        {
            key: "enlargePoints",
            value: function(t661) {
                for(var e512 = this.w, i384 = this, a309 = this.ttCtx, s248 = t661, r209 = e512.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), o185 = e512.config.markers.hover.size, n159 = 0; n159 < r209.length; n159++){
                    var l129 = r209[n159].getAttribute("rel"), h113 = r209[n159].getAttribute("index");
                    if (void 0 === o185 && (o185 = e512.globals.markers.size[h113] + e512.config.markers.hover.sizeOffset), s248 === parseInt(l129, 10)) {
                        i384.newPointSize(s248, r209[n159]);
                        var c92 = r209[n159].getAttribute("cx"), d81 = r209[n159].getAttribute("cy");
                        i384.tooltipPosition.moveXCrosshairs(c92), a309.fixedTooltip || i384.tooltipPosition.moveTooltip(c92, d81, o185);
                    } else i384.oldPointSize(r209[n159]);
                }
            }
        },
        {
            key: "newPointSize",
            value: function(t662, e513) {
                var i385 = this.w, a310 = i385.config.markers.hover.size, s249 = 0 === t662 ? e513.parentNode.firstChild : e513.parentNode.lastChild;
                if ("0" !== s249.getAttribute("default-marker-size")) {
                    var r210 = parseInt(s249.getAttribute("index"), 10);
                    void 0 === a310 && (a310 = i385.globals.markers.size[r210] + i385.config.markers.hover.sizeOffset), a310 < 0 && (a310 = 0), s249.setAttribute("r", a310);
                }
            }
        },
        {
            key: "oldPointSize",
            value: function(t663) {
                var e514 = parseFloat(t663.getAttribute("default-marker-size"));
                t663.setAttribute("r", e514);
            }
        },
        {
            key: "resetPointsSize",
            value: function() {
                for(var t664 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), e515 = 0; e515 < t664.length; e515++){
                    var i386 = parseFloat(t664[e515].getAttribute("default-marker-size"));
                    x.isNumber(i386) && i386 >= 0 ? t664[e515].setAttribute("r", i386) : t664[e515].setAttribute("r", 0);
                }
            }
        }
    ]), t657;
}(), bt = function() {
    function t665(e516) {
        a(this, t665), this.w = e516.w, this.ttCtx = e516;
    }
    return r(t665, [
        {
            key: "getAttr",
            value: function(t666, e517) {
                return parseFloat(t666.target.getAttribute(e517));
            }
        },
        {
            key: "handleHeatTreeTooltip",
            value: function(t667) {
                var e518 = t667.e, i387 = t667.opt, a311 = t667.x, s250 = t667.y, r211 = t667.type, o186 = this.ttCtx, n160 = this.w;
                if (e518.target.classList.contains("apexcharts-".concat(r211, "-rect"))) {
                    var l130 = this.getAttr(e518, "i"), h114 = this.getAttr(e518, "j"), c93 = this.getAttr(e518, "cx"), d82 = this.getAttr(e518, "cy"), g67 = this.getAttr(e518, "width"), u51 = this.getAttr(e518, "height");
                    if (o186.tooltipLabels.drawSeriesTexts({
                        ttItems: i387.ttItems,
                        i: l130,
                        j: h114,
                        shared: !1,
                        e: e518
                    }), n160.globals.capturedSeriesIndex = l130, n160.globals.capturedDataPointIndex = h114, a311 = c93 + o186.tooltipRect.ttWidth / 2 + g67, s250 = d82 + o186.tooltipRect.ttHeight / 2 - u51 / 2, o186.tooltipPosition.moveXCrosshairs(c93 + g67 / 2), a311 > n160.globals.gridWidth / 2 && (a311 = c93 - o186.tooltipRect.ttWidth / 2 + g67), o186.w.config.tooltip.followCursor) {
                        var p43 = n160.globals.dom.elWrap.getBoundingClientRect();
                        a311 = n160.globals.clientX - p43.left - (a311 > n160.globals.gridWidth / 2 ? o186.tooltipRect.ttWidth : 0), s250 = n160.globals.clientY - p43.top - (s250 > n160.globals.gridHeight / 2 ? o186.tooltipRect.ttHeight : 0);
                    }
                }
                return {
                    x: a311,
                    y: s250
                };
            }
        },
        {
            key: "handleMarkerTooltip",
            value: function(t668) {
                var e519, i388, a312 = t668.e, s251 = t668.opt, r212 = t668.x, o187 = t668.y, n161 = this.w, l131 = this.ttCtx;
                if (a312.target.classList.contains("apexcharts-marker")) {
                    var h115 = parseInt(s251.paths.getAttribute("cx"), 10), c94 = parseInt(s251.paths.getAttribute("cy"), 10), d83 = parseFloat(s251.paths.getAttribute("val"));
                    if (i388 = parseInt(s251.paths.getAttribute("rel"), 10), e519 = parseInt(s251.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, l131.intersect) {
                        var g68 = x.findAncestor(s251.paths, "apexcharts-series");
                        g68 && (e519 = parseInt(g68.getAttribute("data:realIndex"), 10));
                    }
                    if (l131.tooltipLabels.drawSeriesTexts({
                        ttItems: s251.ttItems,
                        i: e519,
                        j: i388,
                        shared: !l131.showOnIntersect && n161.config.tooltip.shared,
                        e: a312
                    }), "mouseup" === a312.type && l131.markerClick(a312, e519, i388), n161.globals.capturedSeriesIndex = e519, n161.globals.capturedDataPointIndex = i388, r212 = h115, o187 = c94 + n161.globals.translateY - 1.4 * l131.tooltipRect.ttHeight, l131.w.config.tooltip.followCursor) {
                        var u52 = l131.getElGrid().getBoundingClientRect();
                        o187 = l131.e.clientY + n161.globals.translateY - u52.top;
                    }
                    d83 < 0 && (o187 = c94), l131.marker.enlargeCurrentPoint(i388, s251.paths, r212, o187);
                }
                return {
                    x: r212,
                    y: o187
                };
            }
        },
        {
            key: "handleBarTooltip",
            value: function(t669) {
                var e520, i389, a313 = t669.e, s252 = t669.opt, r213 = this.w, o188 = this.ttCtx, n162 = o188.getElTooltip(), l132 = 0, h116 = 0, c95 = 0, d84 = this.getBarTooltipXY({
                    e: a313,
                    opt: s252
                });
                e520 = d84.i;
                var g69 = d84.barHeight, u53 = d84.j;
                r213.globals.capturedSeriesIndex = e520, r213.globals.capturedDataPointIndex = u53, r213.globals.isBarHorizontal && o188.tooltipUtil.hasBars() || !r213.config.tooltip.shared ? (h116 = d84.x, c95 = d84.y, i389 = Array.isArray(r213.config.stroke.width) ? r213.config.stroke.width[e520] : r213.config.stroke.width, l132 = h116) : r213.globals.comboCharts || r213.config.tooltip.shared || (l132 /= 2), isNaN(c95) ? c95 = r213.globals.svgHeight - o188.tooltipRect.ttHeight : c95 < 0 && (c95 = 0);
                var p44 = parseInt(s252.paths.parentNode.getAttribute("data:realIndex"), 10), f39 = r213.globals.isMultipleYAxis ? r213.config.yaxis[p44] && r213.config.yaxis[p44].reversed : r213.config.yaxis[0].reversed;
                if (h116 + o188.tooltipRect.ttWidth > r213.globals.gridWidth && !f39 ? h116 -= o188.tooltipRect.ttWidth : h116 < 0 && (h116 = 0), o188.w.config.tooltip.followCursor) {
                    var x28 = o188.getElGrid().getBoundingClientRect();
                    c95 = o188.e.clientY - x28.top;
                }
                null === o188.tooltip && (o188.tooltip = r213.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), r213.config.tooltip.shared || (r213.globals.comboBarCount > 0 ? o188.tooltipPosition.moveXCrosshairs(l132 + i389 / 2) : o188.tooltipPosition.moveXCrosshairs(l132)), !o188.fixedTooltip && (!r213.config.tooltip.shared || r213.globals.isBarHorizontal && o188.tooltipUtil.hasBars()) && (f39 && (h116 -= o188.tooltipRect.ttWidth) < 0 && (h116 = 0), !f39 || r213.globals.isBarHorizontal && o188.tooltipUtil.hasBars() || (c95 = c95 + g69 - 2 * (r213.globals.series[e520][u53] < 0 ? g69 : 0)), o188.tooltipRect.ttHeight + c95 > r213.globals.gridHeight ? c95 = r213.globals.gridHeight - o188.tooltipRect.ttHeight + r213.globals.translateY : (c95 = c95 + r213.globals.translateY - o188.tooltipRect.ttHeight / 2) < 0 && (c95 = 0), n162.style.left = h116 + r213.globals.translateX + "px", n162.style.top = c95 + "px");
            }
        },
        {
            key: "getBarTooltipXY",
            value: function(t670) {
                var e521 = t670.e, i390 = t670.opt, a314 = this.w, s253 = null, r214 = this.ttCtx, o189 = 0, n163 = 0, l133 = 0, h117 = 0, c96 = 0, d85 = e521.target.classList;
                if (d85.contains("apexcharts-bar-area") || d85.contains("apexcharts-candlestick-area") || d85.contains("apexcharts-boxPlot-area") || d85.contains("apexcharts-rangebar-area")) {
                    var g70 = e521.target, u54 = g70.getBoundingClientRect(), p45 = i390.elGrid.getBoundingClientRect(), f40 = u54.height;
                    c96 = u54.height;
                    var x29 = u54.width, b33 = parseInt(g70.getAttribute("cx"), 10), v25 = parseInt(g70.getAttribute("cy"), 10);
                    h117 = parseFloat(g70.getAttribute("barWidth"));
                    var m12 = "touchmove" === e521.type ? e521.touches[0].clientX : e521.clientX;
                    s253 = parseInt(g70.getAttribute("j"), 10), o189 = parseInt(g70.parentNode.getAttribute("rel"), 10) - 1;
                    var y25 = g70.getAttribute("data-range-y1"), w20 = g70.getAttribute("data-range-y2");
                    a314.globals.comboCharts && (o189 = parseInt(g70.parentNode.getAttribute("data:realIndex"), 10)), r214.tooltipLabels.drawSeriesTexts({
                        ttItems: i390.ttItems,
                        i: o189,
                        j: s253,
                        y1: y25 ? parseInt(y25, 10) : null,
                        y2: w20 ? parseInt(w20, 10) : null,
                        shared: !r214.showOnIntersect && a314.config.tooltip.shared,
                        e: e521
                    }), a314.config.tooltip.followCursor ? a314.globals.isBarHorizontal ? (n163 = m12 - p45.left + 15, l133 = v25 - r214.dataPointsDividedHeight + f40 / 2 - r214.tooltipRect.ttHeight / 2) : (n163 = a314.globals.isXNumeric ? b33 - x29 / 2 : b33 - r214.dataPointsDividedWidth + x29 / 2, l133 = e521.clientY - p45.top - r214.tooltipRect.ttHeight / 2 - 15) : a314.globals.isBarHorizontal ? ((n163 = b33) < r214.xyRatios.baseLineInvertedY && (n163 = b33 - r214.tooltipRect.ttWidth), l133 = v25 - r214.dataPointsDividedHeight + f40 / 2 - r214.tooltipRect.ttHeight / 2) : (n163 = a314.globals.isXNumeric ? b33 - x29 / 2 : b33 - r214.dataPointsDividedWidth + x29 / 2, l133 = v25);
                }
                return {
                    x: n163,
                    y: l133,
                    barHeight: c96,
                    barWidth: h117,
                    i: o189,
                    j: s253
                };
            }
        }
    ]), t665;
}(), vt = function() {
    function t671(e522) {
        a(this, t671), this.w = e522.w, this.ttCtx = e522;
    }
    return r(t671, [
        {
            key: "drawXaxisTooltip",
            value: function() {
                var t672 = this.w, e523 = this.ttCtx, i391 = "bottom" === t672.config.xaxis.position;
                e523.xaxisOffY = i391 ? t672.globals.gridHeight + 1 : -t672.globals.xAxisHeight - t672.config.xaxis.axisTicks.height + 3;
                var a315 = i391 ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", s254 = t672.globals.dom.elWrap;
                e523.isXAxisTooltipEnabled && null === t672.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (e523.xaxisTooltip = document.createElement("div"), e523.xaxisTooltip.setAttribute("class", a315 + " apexcharts-theme-" + t672.config.tooltip.theme), s254.appendChild(e523.xaxisTooltip), e523.xaxisTooltipText = document.createElement("div"), e523.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), e523.xaxisTooltipText.style.fontFamily = t672.config.xaxis.tooltip.style.fontFamily || t672.config.chart.fontFamily, e523.xaxisTooltipText.style.fontSize = t672.config.xaxis.tooltip.style.fontSize, e523.xaxisTooltip.appendChild(e523.xaxisTooltipText));
            }
        },
        {
            key: "drawYaxisTooltip",
            value: function() {
                for(var t673 = this.w, e524 = this.ttCtx, i392 = function(i393) {
                    var a317 = t673.config.yaxis[i393].opposite || t673.config.yaxis[i393].crosshairs.opposite;
                    e524.yaxisOffX = a317 ? t673.globals.gridWidth + 1 : 1;
                    var s255 = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i393, a317 ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
                    t673.globals.yAxisSameScaleIndices.map(function(e525, a318) {
                        e525.map(function(e, a319) {
                            a319 === i393 && (s255 += t673.config.yaxis[a319].show ? " " : " apexcharts-yaxistooltip-hidden");
                        });
                    });
                    var r215 = t673.globals.dom.elWrap;
                    null === t673.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i393)) && (e524.yaxisTooltip = document.createElement("div"), e524.yaxisTooltip.setAttribute("class", s255 + " apexcharts-theme-" + t673.config.tooltip.theme), r215.appendChild(e524.yaxisTooltip), 0 === i393 && (e524.yaxisTooltipText = []), e524.yaxisTooltipText[i393] = document.createElement("div"), e524.yaxisTooltipText[i393].classList.add("apexcharts-yaxistooltip-text"), e524.yaxisTooltip.appendChild(e524.yaxisTooltipText[i393]));
                }, a316 = 0; a316 < t673.config.yaxis.length; a316++)i392(a316);
            }
        },
        {
            key: "setXCrosshairWidth",
            value: function() {
                var t674 = this.w, e526 = this.ttCtx, i394 = e526.getElXCrosshairs();
                if (e526.xcrosshairsWidth = parseInt(t674.config.xaxis.crosshairs.width, 10), t674.globals.comboCharts) {
                    var a320 = t674.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
                    if (null !== a320 && "barWidth" === t674.config.xaxis.crosshairs.width) {
                        var s256 = parseFloat(a320.getAttribute("barWidth"));
                        e526.xcrosshairsWidth = s256;
                    } else if ("tickWidth" === t674.config.xaxis.crosshairs.width) {
                        var r216 = t674.globals.labels.length;
                        e526.xcrosshairsWidth = t674.globals.gridWidth / r216;
                    }
                } else if ("tickWidth" === t674.config.xaxis.crosshairs.width) {
                    var o190 = t674.globals.labels.length;
                    e526.xcrosshairsWidth = t674.globals.gridWidth / o190;
                } else if ("barWidth" === t674.config.xaxis.crosshairs.width) {
                    var n164 = t674.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
                    if (null !== n164) {
                        var l134 = parseFloat(n164.getAttribute("barWidth"));
                        e526.xcrosshairsWidth = l134;
                    } else e526.xcrosshairsWidth = 1;
                }
                t674.globals.isBarHorizontal && (e526.xcrosshairsWidth = 0), null !== i394 && e526.xcrosshairsWidth > 0 && i394.setAttribute("width", e526.xcrosshairsWidth);
            }
        },
        {
            key: "handleYCrosshair",
            value: function() {
                var t675 = this.w, e527 = this.ttCtx;
                e527.ycrosshairs = t675.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), e527.ycrosshairsHidden = t675.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
            }
        },
        {
            key: "drawYaxisTooltipText",
            value: function(t676, e528, i395) {
                var a321 = this.ttCtx, s257 = this.w, r217 = s257.globals.yLabelFormatters[t676];
                if (a321.yaxisTooltips[t676]) {
                    var o191 = a321.getElGrid().getBoundingClientRect(), n165 = (e528 - o191.top) * i395.yRatio[t676], l135 = s257.globals.maxYArr[t676] - s257.globals.minYArr[t676], h118 = s257.globals.minYArr[t676] + (l135 - n165);
                    a321.tooltipPosition.moveYCrosshairs(e528 - o191.top), a321.yaxisTooltipText[t676].innerHTML = r217(h118), a321.tooltipPosition.moveYAxisTooltip(t676);
                }
            }
        }
    ]), t671;
}(), mt = function() {
    function t677(e529) {
        a(this, t677), this.ctx = e529, this.w = e529.w;
        var i396 = this.w;
        this.tConfig = i396.config.tooltip, this.tooltipUtil = new ut(this), this.tooltipLabels = new pt(this), this.tooltipPosition = new ft(this), this.marker = new xt(this), this.intersect = new bt(this), this.axesTooltip = new vt(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !i396.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
    }
    return r(t677, [
        {
            key: "getElTooltip",
            value: function(t678) {
                return t678 || (t678 = this), t678.w.globals.dom.baseEl ? t678.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
            }
        },
        {
            key: "getElXCrosshairs",
            value: function() {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
            }
        },
        {
            key: "getElGrid",
            value: function() {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
            }
        },
        {
            key: "drawTooltip",
            value: function(t679) {
                var e530 = this.w;
                this.xyRatios = t679, this.isXAxisTooltipEnabled = e530.config.xaxis.tooltip.enabled && e530.globals.axisCharts, this.yaxisTooltips = e530.config.yaxis.map(function(t680, i) {
                    return !!(t680.show && t680.tooltip.enabled && e530.globals.axisCharts);
                }), this.allTooltipSeriesGroups = [], e530.globals.axisCharts || (this.showTooltipTitle = !1);
                var i397 = document.createElement("div");
                if (i397.classList.add("apexcharts-tooltip"), e530.config.tooltip.cssClass && i397.classList.add(e530.config.tooltip.cssClass), i397.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), e530.globals.dom.elWrap.appendChild(i397), e530.globals.axisCharts) {
                    this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
                    var a322 = new _(this.ctx);
                    this.xAxisTicksPositions = a322.getXAxisTicksPositions();
                }
                if (!e530.globals.comboCharts && !this.tConfig.intersect && "rangeBar" !== e530.config.chart.type || this.tConfig.shared || (this.showOnIntersect = !0), 0 !== e530.config.markers.size && 0 !== e530.globals.markers.largestSize || this.marker.drawDynamicPoints(this), e530.globals.collapsedSeries.length !== e530.globals.series.length) {
                    this.dataPointsDividedHeight = e530.globals.gridHeight / e530.globals.dataPoints, this.dataPointsDividedWidth = e530.globals.gridWidth / e530.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e530.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i397.appendChild(this.tooltipTitle));
                    var s258 = e530.globals.series.length;
                    (e530.globals.xyCharts || e530.globals.comboCharts) && this.tConfig.shared && (s258 = this.showOnIntersect ? 1 : e530.globals.series.length), this.legendLabels = e530.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(s258), this.addSVGEvents();
                }
            }
        },
        {
            key: "createTTElements",
            value: function(t681) {
                for(var e531 = this, i398 = this.w, a323 = [], s259 = this.getElTooltip(), r218 = function(r219) {
                    var o193 = document.createElement("div");
                    o193.classList.add("apexcharts-tooltip-series-group"), o193.style.order = i398.config.tooltip.inverseOrder ? t681 - r219 : r219 + 1, e531.tConfig.shared && e531.tConfig.enabledOnSeries && Array.isArray(e531.tConfig.enabledOnSeries) && e531.tConfig.enabledOnSeries.indexOf(r219) < 0 && o193.classList.add("apexcharts-tooltip-series-group-hidden");
                    var n166 = document.createElement("span");
                    n166.classList.add("apexcharts-tooltip-marker"), n166.style.backgroundColor = i398.globals.colors[r219], o193.appendChild(n166);
                    var l136 = document.createElement("div");
                    l136.classList.add("apexcharts-tooltip-text"), l136.style.fontFamily = e531.tConfig.style.fontFamily || i398.config.chart.fontFamily, l136.style.fontSize = e531.tConfig.style.fontSize, [
                        "y",
                        "goals",
                        "z"
                    ].forEach(function(t682) {
                        var e532 = document.createElement("div");
                        e532.classList.add("apexcharts-tooltip-".concat(t682, "-group"));
                        var i399 = document.createElement("span");
                        i399.classList.add("apexcharts-tooltip-text-".concat(t682, "-label")), e532.appendChild(i399);
                        var a324 = document.createElement("span");
                        a324.classList.add("apexcharts-tooltip-text-".concat(t682, "-value")), e532.appendChild(a324), l136.appendChild(e532);
                    }), o193.appendChild(l136), s259.appendChild(o193), a323.push(o193);
                }, o192 = 0; o192 < t681; o192++)r218(o192);
                return a323;
            }
        },
        {
            key: "addSVGEvents",
            value: function() {
                var t683 = this.w, e533 = t683.config.chart.type, i400 = this.getElTooltip(), a325 = !("bar" !== e533 && "candlestick" !== e533 && "boxPlot" !== e533 && "rangeBar" !== e533), s260 = "area" === e533 || "line" === e533 || "scatter" === e533 || "bubble" === e533 || "radar" === e533, r220 = t683.globals.dom.Paper.node, o194 = this.getElGrid();
                o194 && (this.seriesBound = o194.getBoundingClientRect());
                var n167, l137 = [], h119 = [], c97 = {
                    hoverArea: r220,
                    elGrid: o194,
                    tooltipEl: i400,
                    tooltipY: l137,
                    tooltipX: h119,
                    ttItems: this.ttItems
                };
                if (t683.globals.axisCharts && (s260 ? n167 = t683.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a325 ? n167 = t683.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" !== e533 && "treemap" !== e533 || (n167 = t683.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), n167 && n167.length)) for(var d86 = 0; d86 < n167.length; d86++)l137.push(n167[d86].getAttribute("cy")), h119.push(n167[d86].getAttribute("cx"));
                if (t683.globals.xyCharts && !this.showOnIntersect || t683.globals.comboCharts && !this.showOnIntersect || a325 && this.tooltipUtil.hasBars() && this.tConfig.shared) this.addPathsEventListeners([
                    r220
                ], c97);
                else if (a325 && !t683.globals.comboCharts || s260 && this.showOnIntersect) this.addDatapointEventsListeners(c97);
                else if (!t683.globals.axisCharts || "heatmap" === e533 || "treemap" === e533) {
                    var g71 = t683.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
                    this.addPathsEventListeners(g71, c97);
                }
                if (this.showOnIntersect) {
                    var u55 = t683.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
                    u55.length > 0 && this.addPathsEventListeners(u55, c97), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(c97);
                }
            }
        },
        {
            key: "drawFixedTooltipRect",
            value: function() {
                var t684 = this.w, e534 = this.getElTooltip(), i401 = e534.getBoundingClientRect(), a326 = i401.width + 10, s261 = i401.height + 10, r221 = this.tConfig.fixed.offsetX, o195 = this.tConfig.fixed.offsetY, n168 = this.tConfig.fixed.position.toLowerCase();
                return n168.indexOf("right") > -1 && (r221 = r221 + t684.globals.svgWidth - a326 + 10), n168.indexOf("bottom") > -1 && (o195 = o195 + t684.globals.svgHeight - s261 - 10), e534.style.left = r221 + "px", e534.style.top = o195 + "px", {
                    x: r221,
                    y: o195,
                    ttWidth: a326,
                    ttHeight: s261
                };
            }
        },
        {
            key: "addDatapointEventsListeners",
            value: function(t685) {
                var e535 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
                this.addPathsEventListeners(e535, t685);
            }
        },
        {
            key: "addPathsEventListeners",
            value: function(t686, e536) {
                for(var i402 = this, a327 = function(a328) {
                    var s263 = {
                        paths: t686[a328],
                        tooltipEl: e536.tooltipEl,
                        tooltipY: e536.tooltipY,
                        tooltipX: e536.tooltipX,
                        elGrid: e536.elGrid,
                        hoverArea: e536.hoverArea,
                        ttItems: e536.ttItems
                    };
                    [
                        "mousemove",
                        "mouseup",
                        "touchmove",
                        "mouseout",
                        "touchend"
                    ].map(function(e537) {
                        return t686[a328].addEventListener(e537, i402.onSeriesHover.bind(i402, s263), {
                            capture: !1,
                            passive: !0
                        });
                    });
                }, s262 = 0; s262 < t686.length; s262++)a327(s262);
            }
        },
        {
            key: "onSeriesHover",
            value: function(t687, e538) {
                var i403 = this, a329 = Date.now() - this.lastHoverTime;
                a329 >= 100 ? this.seriesHover(t687, e538) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function() {
                    i403.seriesHover(t687, e538);
                }, 100 - a329));
            }
        },
        {
            key: "seriesHover",
            value: function(t688, e539) {
                var i404 = this;
                this.lastHoverTime = Date.now();
                var a330 = [], s264 = this.w;
                s264.config.chart.group && (a330 = this.ctx.getGroupedCharts()), s264.globals.axisCharts && (s264.globals.minX === -1 / 0 && s264.globals.maxX === 1 / 0 || 0 === s264.globals.dataPoints) || (a330.length ? a330.forEach(function(a331) {
                    var s265 = i404.getElTooltip(a331), r222 = {
                        paths: t688.paths,
                        tooltipEl: s265,
                        tooltipY: t688.tooltipY,
                        tooltipX: t688.tooltipX,
                        elGrid: t688.elGrid,
                        hoverArea: t688.hoverArea,
                        ttItems: a331.w.globals.tooltip.ttItems
                    };
                    a331.w.globals.minX === i404.w.globals.minX && a331.w.globals.maxX === i404.w.globals.maxX && a331.w.globals.tooltip.seriesHoverByContext({
                        chartCtx: a331,
                        ttCtx: a331.w.globals.tooltip,
                        opt: r222,
                        e: e539
                    });
                }) : this.seriesHoverByContext({
                    chartCtx: this.ctx,
                    ttCtx: this.w.globals.tooltip,
                    opt: t688,
                    e: e539
                }));
            }
        },
        {
            key: "seriesHoverByContext",
            value: function(t689) {
                var e540 = t689.chartCtx, i405 = t689.ttCtx, a332 = t689.opt, s266 = t689.e, r223 = e540.w, o196 = this.getElTooltip();
                if (o196) {
                    if (i405.tooltipRect = {
                        x: 0,
                        y: 0,
                        ttWidth: o196.getBoundingClientRect().width,
                        ttHeight: o196.getBoundingClientRect().height
                    }, i405.e = s266, i405.tooltipUtil.hasBars() && !r223.globals.comboCharts && !i405.isBarShared) {
                        if (this.tConfig.onDatasetHover.highlightDataSeries) new E(e540).toggleSeriesOnHover(s266, s266.target.parentNode);
                    }
                    i405.fixedTooltip && i405.drawFixedTooltipRect(), r223.globals.axisCharts ? i405.axisChartsTooltips({
                        e: s266,
                        opt: a332,
                        tooltipRect: i405.tooltipRect
                    }) : i405.nonAxisChartsTooltips({
                        e: s266,
                        opt: a332,
                        tooltipRect: i405.tooltipRect
                    });
                }
            }
        },
        {
            key: "axisChartsTooltips",
            value: function(t690) {
                var e541, i406, a333 = t690.e, s267 = t690.opt, r224 = this.w, o197 = s267.elGrid.getBoundingClientRect(), n169 = "touchmove" === a333.type ? a333.touches[0].clientX : a333.clientX, l138 = "touchmove" === a333.type ? a333.touches[0].clientY : a333.clientY;
                if (this.clientY = l138, this.clientX = n169, r224.globals.capturedSeriesIndex = -1, r224.globals.capturedDataPointIndex = -1, l138 < o197.top || l138 > o197.top + o197.height) this.handleMouseOut(s267);
                else {
                    if (Array.isArray(this.tConfig.enabledOnSeries) && !r224.config.tooltip.shared) {
                        var h120 = parseInt(s267.paths.getAttribute("index"), 10);
                        if (this.tConfig.enabledOnSeries.indexOf(h120) < 0) return void this.handleMouseOut(s267);
                    }
                    var c98 = this.getElTooltip(), d87 = this.getElXCrosshairs(), g72 = r224.globals.xyCharts || "bar" === r224.config.chart.type && !r224.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r224.globals.comboCharts && this.tooltipUtil.hasBars();
                    if ("mousemove" === a333.type || "touchmove" === a333.type || "mouseup" === a333.type) {
                        if (r224.globals.collapsedSeries.length + r224.globals.ancillaryCollapsedSeries.length === r224.globals.series.length) return;
                        null !== d87 && d87.classList.add("apexcharts-active");
                        var u56 = this.yaxisTooltips.filter(function(t691) {
                            return !0 === t691;
                        });
                        if (null !== this.ycrosshairs && u56.length && this.ycrosshairs.classList.add("apexcharts-active"), g72 && !this.showOnIntersect) this.handleStickyTooltip(a333, n169, l138, s267);
                        else if ("heatmap" === r224.config.chart.type || "treemap" === r224.config.chart.type) {
                            var p46 = this.intersect.handleHeatTreeTooltip({
                                e: a333,
                                opt: s267,
                                x: e541,
                                y: i406,
                                type: r224.config.chart.type
                            });
                            e541 = p46.x, i406 = p46.y, c98.style.left = e541 + "px", c98.style.top = i406 + "px";
                        } else this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({
                            e: a333,
                            opt: s267
                        }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({
                            e: a333,
                            opt: s267,
                            x: e541,
                            y: i406
                        });
                        if (this.yaxisTooltips.length) for(var f41 = 0; f41 < r224.config.yaxis.length; f41++)this.axesTooltip.drawYaxisTooltipText(f41, l138, this.xyRatios);
                        s267.tooltipEl.classList.add("apexcharts-active");
                    } else "mouseout" !== a333.type && "touchend" !== a333.type || this.handleMouseOut(s267);
                }
            }
        },
        {
            key: "nonAxisChartsTooltips",
            value: function(t692) {
                var e542 = t692.e, i407 = t692.opt, a334 = t692.tooltipRect, s268 = this.w, r225 = i407.paths.getAttribute("rel"), o198 = this.getElTooltip(), n170 = s268.globals.dom.elWrap.getBoundingClientRect();
                if ("mousemove" === e542.type || "touchmove" === e542.type) {
                    o198.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({
                        ttItems: i407.ttItems,
                        i: parseInt(r225, 10) - 1,
                        shared: !1
                    });
                    var l139 = s268.globals.clientX - n170.left - a334.ttWidth / 2, h121 = s268.globals.clientY - n170.top - a334.ttHeight - 10;
                    if (o198.style.left = l139 + "px", o198.style.top = h121 + "px", s268.config.legend.tooltipHoverFormatter) {
                        var c99 = r225 - 1, d88 = (0, s268.config.legend.tooltipHoverFormatter)(this.legendLabels[c99].getAttribute("data:default-text"), {
                            seriesIndex: c99,
                            dataPointIndex: c99,
                            w: s268
                        });
                        this.legendLabels[c99].innerHTML = d88;
                    }
                } else "mouseout" !== e542.type && "touchend" !== e542.type || (o198.classList.remove("apexcharts-active"), s268.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t693) {
                    var e543 = t693.getAttribute("data:default-text");
                    t693.innerHTML = decodeURIComponent(e543);
                }));
            }
        },
        {
            key: "handleStickyTooltip",
            value: function(t694, e544, i408, a335) {
                var s269 = this.w, r226 = this.tooltipUtil.getNearestValues({
                    context: this,
                    hoverArea: a335.hoverArea,
                    elGrid: a335.elGrid,
                    clientX: e544,
                    clientY: i408
                }), o199 = r226.j, n171 = r226.capturedSeries, l140 = a335.elGrid.getBoundingClientRect();
                r226.hoverX < 0 || r226.hoverX > l140.width ? this.handleMouseOut(a335) : null !== n171 ? this.handleStickyCapturedSeries(t694, n171, a335, o199) : (this.tooltipUtil.isXoverlap(o199) || s269.globals.isBarHorizontal) && this.create(t694, this, 0, o199, a335.ttItems);
            }
        },
        {
            key: "handleStickyCapturedSeries",
            value: function(t695, e545, i409, a336) {
                var s270 = this.w;
                if (!this.tConfig.shared && null === s270.globals.series[e545][a336]) return void this.handleMouseOut(i409);
                void 0 !== s270.globals.series[e545][a336] ? this.tConfig.shared && this.tooltipUtil.isXoverlap(a336) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t695, this, e545, a336, i409.ttItems) : this.create(t695, this, e545, a336, i409.ttItems, !1) : this.tooltipUtil.isXoverlap(a336) && this.create(t695, this, 0, a336, i409.ttItems);
            }
        },
        {
            key: "deactivateHoverFilter",
            value: function() {
                for(var t696 = this.w, e546 = new m(this.ctx), i410 = t696.globals.dom.Paper.select(".apexcharts-bar-area"), a337 = 0; a337 < i410.length; a337++)e546.pathMouseLeave(i410[a337]);
            }
        },
        {
            key: "handleMouseOut",
            value: function(t697) {
                var e547 = this.w, i411 = this.getElXCrosshairs();
                if (t697.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), "bubble" !== e547.config.chart.type && this.marker.resetPointsSize(), null !== i411 && i411.classList.remove("apexcharts-active"), null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
                    null === this.yaxisTTEls && (this.yaxisTTEls = e547.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                    for(var a338 = 0; a338 < this.yaxisTTEls.length; a338++)this.yaxisTTEls[a338].classList.remove("apexcharts-active");
                }
                e547.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t698) {
                    var e548 = t698.getAttribute("data:default-text");
                    t698.innerHTML = decodeURIComponent(e548);
                });
            }
        },
        {
            key: "markerClick",
            value: function(t699, e549, i412) {
                var a339 = this.w;
                "function" == typeof a339.config.chart.events.markerClick && a339.config.chart.events.markerClick(t699, this.ctx, {
                    seriesIndex: e549,
                    dataPointIndex: i412,
                    w: a339
                }), this.ctx.events.fireEvent("markerClick", [
                    t699,
                    this.ctx,
                    {
                        seriesIndex: e549,
                        dataPointIndex: i412,
                        w: a339
                    }
                ]);
            }
        },
        {
            key: "create",
            value: function(t700, e550, i413, a340, s271) {
                var r227 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, o200 = this.w, n172 = e550;
                "mouseup" === t700.type && this.markerClick(t700, i413, a340), null === r227 && (r227 = this.tConfig.shared);
                var l141 = this.tooltipUtil.hasMarkers(), h122 = this.tooltipUtil.getElBars();
                if (o200.config.legend.tooltipHoverFormatter) {
                    var c100 = o200.config.legend.tooltipHoverFormatter, d89 = Array.from(this.legendLabels);
                    d89.forEach(function(t701) {
                        var e551 = t701.getAttribute("data:default-text");
                        t701.innerHTML = decodeURIComponent(e551);
                    });
                    for(var g73 = 0; g73 < d89.length; g73++){
                        var u57 = d89[g73], p47 = parseInt(u57.getAttribute("i"), 10), f42 = decodeURIComponent(u57.getAttribute("data:default-text")), x30 = c100(f42, {
                            seriesIndex: r227 ? p47 : i413,
                            dataPointIndex: a340,
                            w: o200
                        });
                        if (r227) u57.innerHTML = o200.globals.collapsedSeriesIndices.indexOf(p47) < 0 ? x30 : f42;
                        else if (u57.innerHTML = p47 === i413 ? x30 : f42, i413 === p47) break;
                    }
                }
                if (r227) {
                    if (n172.tooltipLabels.drawSeriesTexts({
                        ttItems: s271,
                        i: i413,
                        j: a340,
                        shared: !this.showOnIntersect && this.tConfig.shared
                    }), l141 && (o200.globals.markers.largestSize > 0 ? n172.marker.enlargePoints(a340) : n172.tooltipPosition.moveDynamicPointsOnHover(a340)), this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(h122), this.barSeriesHeight > 0)) {
                        var b34 = new m(this.ctx), v26 = o200.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(a340, "']"));
                        this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(a340);
                        for(var y26 = 0; y26 < v26.length; y26++)b34.pathMouseEnter(v26[y26]);
                    }
                } else n172.tooltipLabels.drawSeriesTexts({
                    shared: !1,
                    ttItems: s271,
                    i: i413,
                    j: a340
                }), this.tooltipUtil.hasBars() && n172.tooltipPosition.moveStickyTooltipOverBars(a340), l141 && n172.tooltipPosition.moveMarkers(i413, a340);
            }
        }
    ]), t677;
}(), yt = function(t702) {
    n(s272, F);
    var i414 = d(s272);
    function s272() {
        return a(this, s272), i414.apply(this, arguments);
    }
    return r(s272, [
        {
            key: "draw",
            value: function(t703, i415) {
                var a341 = this, s273 = this.w;
                this.graphics = new m(this.ctx), this.bar = new F(this.ctx, this.xyRatios);
                var r228 = new y(this.ctx, s273);
                t703 = r228.getLogSeries(t703), this.yRatio = r228.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t703), "100%" === s273.config.chart.stackType && (t703 = s273.globals.seriesPercent.slice()), this.series = t703, this.totalItems = 0, this.prevY = [], this.prevX = [], this.prevYF = [], this.prevXF = [], this.prevYVal = [], this.prevXVal = [], this.xArrj = [], this.xArrjF = [], this.xArrjVal = [], this.yArrj = [], this.yArrjF = [], this.yArrjVal = [];
                for(var o201 = 0; o201 < t703.length; o201++)t703[o201].length > 0 && (this.totalItems += t703[o201].length);
                for(var n173 = this.graphics.group({
                    class: "apexcharts-bar-series apexcharts-plot-series"
                }), l142 = 0, h123 = 0, c101 = function(r229, o202) {
                    var c102 = void 0, d91 = void 0, g75 = void 0, u58 = void 0, p48 = [], f43 = [], b35 = s273.globals.comboCharts ? i415[r229] : r229;
                    a341.yRatio.length > 1 && (a341.yaxisIndex = b35), a341.isReversed = s273.config.yaxis[a341.yaxisIndex] && s273.config.yaxis[a341.yaxisIndex].reversed;
                    var v27 = a341.graphics.group({
                        class: "apexcharts-series",
                        seriesName: x.escapeString(s273.globals.seriesNames[b35]),
                        rel: r229 + 1,
                        "data:realIndex": b35
                    });
                    a341.ctx.series.addCollapsedClassToSeries(v27, b35);
                    var m13 = a341.graphics.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": b35
                    }), y27 = 0, w21 = 0, k19 = a341.initialPositions(l142, h123, c102, d91, g75, u58);
                    h123 = k19.y, y27 = k19.barHeight, d91 = k19.yDivision, u58 = k19.zeroW, l142 = k19.x, w21 = k19.barWidth, c102 = k19.xDivision, g75 = k19.zeroH, a341.yArrj = [], a341.yArrjF = [], a341.yArrjVal = [], a341.xArrj = [], a341.xArrjF = [], a341.xArrjVal = [], 1 === a341.prevY.length && a341.prevY[0].every(function(t704) {
                        return isNaN(t704);
                    }) && (a341.prevY[0] = a341.prevY[0].map(function(t) {
                        return g75;
                    }), a341.prevYF[0] = a341.prevYF[0].map(function(t) {
                        return 0;
                    }));
                    for(var A14 = 0; A14 < s273.globals.dataPoints; A14++){
                        var S10 = a341.barHelpers.getStrokeWidth(r229, A14, b35), C9 = {
                            indexes: {
                                i: r229,
                                j: A14,
                                realIndex: b35,
                                bc: o202
                            },
                            strokeWidth: S10,
                            x: l142,
                            y: h123,
                            elSeries: v27
                        }, L9 = null;
                        a341.isHorizontal ? (L9 = a341.drawStackedBarPaths(e(e({}, C9), {}, {
                            zeroW: u58,
                            barHeight: y27,
                            yDivision: d91
                        })), w21 = a341.series[r229][A14] / a341.invertedYRatio) : (L9 = a341.drawStackedColumnPaths(e(e({}, C9), {}, {
                            xDivision: c102,
                            barWidth: w21,
                            zeroH: g75
                        })), y27 = a341.series[r229][A14] / a341.yRatio[a341.yaxisIndex]), h123 = L9.y, l142 = L9.x, p48.push(l142), f43.push(h123);
                        var P9 = a341.barHelpers.getPathFillColor(t703, r229, A14, b35);
                        v27 = a341.renderSeries({
                            realIndex: b35,
                            pathFill: P9,
                            j: A14,
                            i: r229,
                            pathFrom: L9.pathFrom,
                            pathTo: L9.pathTo,
                            strokeWidth: S10,
                            elSeries: v27,
                            x: l142,
                            y: h123,
                            series: t703,
                            barHeight: y27,
                            barWidth: w21,
                            elDataLabelsWrap: m13,
                            type: "bar",
                            visibleSeries: 0
                        });
                    }
                    s273.globals.seriesXvalues[b35] = p48, s273.globals.seriesYvalues[b35] = f43, a341.prevY.push(a341.yArrj), a341.prevYF.push(a341.yArrjF), a341.prevYVal.push(a341.yArrjVal), a341.prevX.push(a341.xArrj), a341.prevXF.push(a341.xArrjF), a341.prevXVal.push(a341.xArrjVal), n173.add(v27);
                }, d90 = 0, g74 = 0; d90 < t703.length; d90++, g74++)c101(d90, g74);
                return n173;
            }
        },
        {
            key: "initialPositions",
            value: function(t705, e552, i416, a342, s274, r230) {
                var o203, n174, l143 = this.w;
                return this.isHorizontal ? (o203 = (o203 = a342 = l143.globals.gridHeight / l143.globals.dataPoints) * parseInt(l143.config.plotOptions.bar.barHeight, 10) / 100, r230 = this.baseLineInvertedY + l143.globals.padHorizontal + (this.isReversed ? l143.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), e552 = (a342 - o203) / 2) : (n174 = i416 = l143.globals.gridWidth / l143.globals.dataPoints, n174 = l143.globals.isXNumeric && l143.globals.dataPoints > 1 ? (i416 = l143.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : n174 * parseInt(l143.config.plotOptions.bar.columnWidth, 10) / 100, s274 = this.baseLineY[this.yaxisIndex] + (this.isReversed ? l143.globals.gridHeight : 0) - (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), t705 = l143.globals.padHorizontal + (i416 - n174) / 2), {
                    x: t705,
                    y: e552,
                    yDivision: a342,
                    xDivision: i416,
                    barHeight: o203,
                    barWidth: n174,
                    zeroH: s274,
                    zeroW: r230
                };
            }
        },
        {
            key: "drawStackedBarPaths",
            value: function(t706) {
                for(var e553, i417 = t706.indexes, a343 = t706.barHeight, s275 = t706.strokeWidth, r231 = t706.zeroW, o204 = t706.x, n175 = t706.y, l144 = t706.yDivision, h124 = t706.elSeries, c103 = this.w, d92 = n175, g76 = i417.i, u59 = i417.j, p49 = 0, f44 = 0; f44 < this.prevXF.length; f44++)p49 += this.prevXF[f44][u59];
                if (g76 > 0) {
                    var x31 = r231;
                    this.prevXVal[g76 - 1][u59] < 0 ? x31 = this.series[g76][u59] >= 0 ? this.prevX[g76 - 1][u59] + p49 - 2 * (this.isReversed ? p49 : 0) : this.prevX[g76 - 1][u59] : this.prevXVal[g76 - 1][u59] >= 0 && (x31 = this.series[g76][u59] >= 0 ? this.prevX[g76 - 1][u59] : this.prevX[g76 - 1][u59] - p49 + 2 * (this.isReversed ? p49 : 0)), e553 = x31;
                } else e553 = r231;
                o204 = null === this.series[g76][u59] ? e553 : e553 + this.series[g76][u59] / this.invertedYRatio - 2 * (this.isReversed ? this.series[g76][u59] / this.invertedYRatio : 0);
                var b36 = this.barHelpers.getBarpaths({
                    barYPosition: d92,
                    barHeight: a343,
                    x1: e553,
                    x2: o204,
                    strokeWidth: s275,
                    series: this.series,
                    realIndex: i417.realIndex,
                    i: g76,
                    j: u59,
                    w: c103
                });
                return this.barHelpers.barBackground({
                    j: u59,
                    i: g76,
                    y1: d92,
                    y2: a343,
                    elSeries: h124
                }), n175 += l144, {
                    pathTo: b36.pathTo,
                    pathFrom: b36.pathFrom,
                    x: o204,
                    y: n175
                };
            }
        },
        {
            key: "drawStackedColumnPaths",
            value: function(t707) {
                var e554 = t707.indexes, i418 = t707.x, a344 = t707.y, s276 = t707.xDivision, r232 = t707.barWidth, o205 = t707.zeroH;
                t707.strokeWidth;
                var n176 = t707.elSeries, l145 = this.w, h125 = e554.i, c104 = e554.j, d93 = e554.bc;
                if (l145.globals.isXNumeric) {
                    var g77 = l145.globals.seriesX[h125][c104];
                    g77 || (g77 = 0), i418 = (g77 - l145.globals.minX) / this.xRatio - r232 / 2;
                }
                for(var u60, p50 = i418, f45 = 0, x32 = 0; x32 < this.prevYF.length; x32++)f45 += isNaN(this.prevYF[x32][c104]) ? 0 : this.prevYF[x32][c104];
                if (h125 > 0 && !l145.globals.isXNumeric || h125 > 0 && l145.globals.isXNumeric && l145.globals.seriesX[h125 - 1][c104] === l145.globals.seriesX[h125][c104]) {
                    var b37, v28, m14 = Math.min(this.yRatio.length + 1, h125 + 1);
                    if (void 0 !== this.prevY[h125 - 1]) {
                        for(var y28 = 1; y28 < m14; y28++)if (!isNaN(this.prevY[h125 - y28][c104])) {
                            v28 = this.prevY[h125 - y28][c104];
                            break;
                        }
                    }
                    for(var w22 = 1; w22 < m14; w22++){
                        if (this.prevYVal[h125 - w22][c104] < 0) {
                            b37 = this.series[h125][c104] >= 0 ? v28 - f45 + 2 * (this.isReversed ? f45 : 0) : v28;
                            break;
                        }
                        if (this.prevYVal[h125 - w22][c104] >= 0) {
                            b37 = this.series[h125][c104] >= 0 ? v28 : v28 + f45 - 2 * (this.isReversed ? f45 : 0);
                            break;
                        }
                    }
                    void 0 === b37 && (b37 = l145.globals.gridHeight), u60 = this.prevYF[0].every(function(t708) {
                        return 0 === t708;
                    }) && this.prevYF.slice(1, h125).every(function(t709) {
                        return t709.every(function(t710) {
                            return isNaN(t710);
                        });
                    }) ? l145.globals.gridHeight - o205 : b37;
                } else u60 = l145.globals.gridHeight - o205;
                a344 = u60 - this.series[h125][c104] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[h125][c104] / this.yRatio[this.yaxisIndex] : 0);
                var k20 = this.barHelpers.getColumnPaths({
                    barXPosition: p50,
                    barWidth: r232,
                    y1: u60,
                    y2: a344,
                    yRatio: this.yRatio[this.yaxisIndex],
                    strokeWidth: this.strokeWidth,
                    series: this.series,
                    realIndex: e554.realIndex,
                    i: h125,
                    j: c104,
                    w: l145
                });
                return this.barHelpers.barBackground({
                    bc: d93,
                    j: c104,
                    i: h125,
                    x1: p50,
                    x2: r232,
                    elSeries: n176
                }), i418 += s276, {
                    pathTo: k20.pathTo,
                    pathFrom: k20.pathFrom,
                    x: l145.globals.isXNumeric ? i418 - s276 : i418,
                    y: a344
                };
            }
        }
    ]), s272;
}(), wt = function(t711) {
    n(s277, F);
    var i419 = d(s277);
    function s277() {
        return a(this, s277), i419.apply(this, arguments);
    }
    return r(s277, [
        {
            key: "draw",
            value: function(t712, i420) {
                var a345 = this, s278 = this.w, r233 = new m(this.ctx), o206 = new T(this.ctx);
                this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = s278.config.plotOptions.bar.horizontal;
                var n177 = new y(this.ctx, s278);
                t712 = n177.getLogSeries(t712), this.series = t712, this.yRatio = n177.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t712);
                for(var l146 = r233.group({
                    class: "apexcharts-".concat(s278.config.chart.type, "-series apexcharts-plot-series")
                }), h126 = function(n178) {
                    a345.isBoxPlot = "boxPlot" === s278.config.chart.type || "boxPlot" === s278.config.series[n178].type;
                    var h127, c106, d94, g78, u61 = void 0, p51 = void 0, f46 = [], b38 = [], v29 = s278.globals.comboCharts ? i420[n178] : n178, m15 = r233.group({
                        class: "apexcharts-series",
                        seriesName: x.escapeString(s278.globals.seriesNames[v29]),
                        rel: n178 + 1,
                        "data:realIndex": v29
                    });
                    a345.ctx.series.addCollapsedClassToSeries(m15, v29), t712[n178].length > 0 && (a345.visibleI = a345.visibleI + 1);
                    var y29, w23;
                    a345.yRatio.length > 1 && (a345.yaxisIndex = v29);
                    var k21 = a345.barHelpers.initialPositions();
                    p51 = k21.y, y29 = k21.barHeight, c106 = k21.yDivision, g78 = k21.zeroW, u61 = k21.x, w23 = k21.barWidth, h127 = k21.xDivision, d94 = k21.zeroH, b38.push(u61 + w23 / 2);
                    for(var A15 = r233.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": v29
                    }), S11 = function(i421) {
                        var r234 = a345.barHelpers.getStrokeWidth(n178, i421, v29), l147 = null, x33 = {
                            indexes: {
                                i: n178,
                                j: i421,
                                realIndex: v29
                            },
                            x: u61,
                            y: p51,
                            strokeWidth: r234,
                            elSeries: m15
                        };
                        l147 = a345.isHorizontal ? a345.drawHorizontalBoxPaths(e(e({}, x33), {}, {
                            yDivision: c106,
                            barHeight: y29,
                            zeroW: g78
                        })) : a345.drawVerticalBoxPaths(e(e({}, x33), {}, {
                            xDivision: h127,
                            barWidth: w23,
                            zeroH: d94
                        })), p51 = l147.y, u61 = l147.x, i421 > 0 && b38.push(u61 + w23 / 2), f46.push(p51), l147.pathTo.forEach(function(e555, h128) {
                            var c107 = !a345.isBoxPlot && a345.candlestickOptions.wick.useFillColor ? l147.color[h128] : s278.globals.stroke.colors[n178], d95 = o206.fillPath({
                                seriesNumber: v29,
                                dataPointIndex: i421,
                                color: l147.color[h128],
                                value: t712[n178][i421]
                            });
                            a345.renderSeries({
                                realIndex: v29,
                                pathFill: d95,
                                lineFill: c107,
                                j: i421,
                                i: n178,
                                pathFrom: l147.pathFrom,
                                pathTo: e555,
                                strokeWidth: r234,
                                elSeries: m15,
                                x: u61,
                                y: p51,
                                series: t712,
                                barHeight: y29,
                                barWidth: w23,
                                elDataLabelsWrap: A15,
                                visibleSeries: a345.visibleI,
                                type: s278.config.chart.type
                            });
                        });
                    }, C10 = 0; C10 < s278.globals.dataPoints; C10++)S11(C10);
                    s278.globals.seriesXvalues[v29] = b38, s278.globals.seriesYvalues[v29] = f46, l146.add(m15);
                }, c105 = 0; c105 < t712.length; c105++)h126(c105);
                return l146;
            }
        },
        {
            key: "drawVerticalBoxPaths",
            value: function(t713) {
                var e556 = t713.indexes, i422 = t713.x;
                t713.y;
                var a346 = t713.xDivision, s279 = t713.barWidth, r235 = t713.zeroH, o207 = t713.strokeWidth, n179 = this.w, l148 = new m(this.ctx), h129 = e556.i, c108 = e556.j, d96 = !0, g79 = n179.config.plotOptions.candlestick.colors.upward, u62 = n179.config.plotOptions.candlestick.colors.downward, p52 = "";
                this.isBoxPlot && (p52 = [
                    this.boxOptions.colors.lower,
                    this.boxOptions.colors.upper
                ]);
                var f47 = this.yRatio[this.yaxisIndex], x34 = e556.realIndex, b39 = this.getOHLCValue(x34, c108), v30 = r235, y30 = r235;
                b39.o > b39.c && (d96 = !1);
                var w24 = Math.min(b39.o, b39.c), k22 = Math.max(b39.o, b39.c), A16 = b39.m;
                n179.globals.isXNumeric && (i422 = (n179.globals.seriesX[x34][c108] - n179.globals.minX) / this.xRatio - s279 / 2);
                var S12 = i422 + s279 * this.visibleI;
                void 0 === this.series[h129][c108] || null === this.series[h129][c108] ? (w24 = r235, k22 = r235) : (w24 = r235 - w24 / f47, k22 = r235 - k22 / f47, v30 = r235 - b39.h / f47, y30 = r235 - b39.l / f47, A16 = r235 - b39.m / f47);
                var C11 = l148.move(S12, r235), L10 = l148.move(S12 + s279 / 2, w24);
                return n179.globals.previousPaths.length > 0 && (L10 = this.getPreviousPath(x34, c108, !0)), C11 = this.isBoxPlot ? [
                    l148.move(S12, w24) + l148.line(S12 + s279 / 2, w24) + l148.line(S12 + s279 / 2, v30) + l148.line(S12 + s279 / 4, v30) + l148.line(S12 + s279 - s279 / 4, v30) + l148.line(S12 + s279 / 2, v30) + l148.line(S12 + s279 / 2, w24) + l148.line(S12 + s279, w24) + l148.line(S12 + s279, A16) + l148.line(S12, A16) + l148.line(S12, w24 + o207 / 2),
                    l148.move(S12, A16) + l148.line(S12 + s279, A16) + l148.line(S12 + s279, k22) + l148.line(S12 + s279 / 2, k22) + l148.line(S12 + s279 / 2, y30) + l148.line(S12 + s279 - s279 / 4, y30) + l148.line(S12 + s279 / 4, y30) + l148.line(S12 + s279 / 2, y30) + l148.line(S12 + s279 / 2, k22) + l148.line(S12, k22) + l148.line(S12, A16) + "z"
                ] : [
                    l148.move(S12, k22) + l148.line(S12 + s279 / 2, k22) + l148.line(S12 + s279 / 2, v30) + l148.line(S12 + s279 / 2, k22) + l148.line(S12 + s279, k22) + l148.line(S12 + s279, w24) + l148.line(S12 + s279 / 2, w24) + l148.line(S12 + s279 / 2, y30) + l148.line(S12 + s279 / 2, w24) + l148.line(S12, w24) + l148.line(S12, k22 - o207 / 2)
                ], L10 += l148.move(S12, w24), n179.globals.isXNumeric || (i422 += a346), {
                    pathTo: C11,
                    pathFrom: L10,
                    x: i422,
                    y: k22,
                    barXPosition: S12,
                    color: this.isBoxPlot ? p52 : d96 ? [
                        g79
                    ] : [
                        u62
                    ]
                };
            }
        },
        {
            key: "drawHorizontalBoxPaths",
            value: function(t714) {
                var e557 = t714.indexes;
                t714.x;
                var i423 = t714.y, a347 = t714.yDivision, s280 = t714.barHeight, r236 = t714.zeroW, o208 = t714.strokeWidth, n180 = this.w, l149 = new m(this.ctx), h130 = e557.i, c109 = e557.j, d97 = this.boxOptions.colors.lower;
                this.isBoxPlot && (d97 = [
                    this.boxOptions.colors.lower,
                    this.boxOptions.colors.upper
                ]);
                var g80 = this.invertedYRatio, u63 = e557.realIndex, p53 = this.getOHLCValue(u63, c109), f48 = r236, x35 = r236, b40 = Math.min(p53.o, p53.c), v31 = Math.max(p53.o, p53.c), y31 = p53.m;
                n180.globals.isXNumeric && (i423 = (n180.globals.seriesX[u63][c109] - n180.globals.minX) / this.invertedXRatio - s280 / 2);
                var w25 = i423 + s280 * this.visibleI;
                void 0 === this.series[h130][c109] || null === this.series[h130][c109] ? (b40 = r236, v31 = r236) : (b40 = r236 + b40 / g80, v31 = r236 + v31 / g80, f48 = r236 + p53.h / g80, x35 = r236 + p53.l / g80, y31 = r236 + p53.m / g80);
                var k23 = l149.move(r236, w25), A17 = l149.move(b40, w25 + s280 / 2);
                return n180.globals.previousPaths.length > 0 && (A17 = this.getPreviousPath(u63, c109, !0)), k23 = [
                    l149.move(b40, w25) + l149.line(b40, w25 + s280 / 2) + l149.line(f48, w25 + s280 / 2) + l149.line(f48, w25 + s280 / 2 - s280 / 4) + l149.line(f48, w25 + s280 / 2 + s280 / 4) + l149.line(f48, w25 + s280 / 2) + l149.line(b40, w25 + s280 / 2) + l149.line(b40, w25 + s280) + l149.line(y31, w25 + s280) + l149.line(y31, w25) + l149.line(b40 + o208 / 2, w25),
                    l149.move(y31, w25) + l149.line(y31, w25 + s280) + l149.line(v31, w25 + s280) + l149.line(v31, w25 + s280 / 2) + l149.line(x35, w25 + s280 / 2) + l149.line(x35, w25 + s280 - s280 / 4) + l149.line(x35, w25 + s280 / 4) + l149.line(x35, w25 + s280 / 2) + l149.line(v31, w25 + s280 / 2) + l149.line(v31, w25) + l149.line(y31, w25) + "z"
                ], A17 += l149.move(b40, w25), n180.globals.isXNumeric || (i423 += a347), {
                    pathTo: k23,
                    pathFrom: A17,
                    x: v31,
                    y: i423,
                    barYPosition: w25,
                    color: d97
                };
            }
        },
        {
            key: "getOHLCValue",
            value: function(t715, e558) {
                var i424 = this.w;
                return {
                    o: this.isBoxPlot ? i424.globals.seriesCandleH[t715][e558] : i424.globals.seriesCandleO[t715][e558],
                    h: this.isBoxPlot ? i424.globals.seriesCandleO[t715][e558] : i424.globals.seriesCandleH[t715][e558],
                    m: i424.globals.seriesCandleM[t715][e558],
                    l: this.isBoxPlot ? i424.globals.seriesCandleC[t715][e558] : i424.globals.seriesCandleL[t715][e558],
                    c: this.isBoxPlot ? i424.globals.seriesCandleL[t715][e558] : i424.globals.seriesCandleC[t715][e558]
                };
            }
        }
    ]), s277;
}(), kt = function() {
    function t716(e559) {
        a(this, t716), this.ctx = e559, this.w = e559.w;
    }
    return r(t716, [
        {
            key: "checkColorRange",
            value: function() {
                var t717 = this.w, e560 = !1, i425 = t717.config.plotOptions[t717.config.chart.type];
                return i425.colorScale.ranges.length > 0 && i425.colorScale.ranges.map(function(t718, i) {
                    t718.from <= 0 && (e560 = !0);
                }), e560;
            }
        },
        {
            key: "getShadeColor",
            value: function(t719, e561, i426, a348) {
                var s281 = this.w, r237 = 1, o209 = s281.config.plotOptions[t719].shadeIntensity, n181 = this.determineColor(t719, e561, i426);
                s281.globals.hasNegs || a348 ? r237 = s281.config.plotOptions[t719].reverseNegativeShade ? n181.percent < 0 ? n181.percent / 100 * (1.25 * o209) : (1 - n181.percent / 100) * (1.25 * o209) : n181.percent <= 0 ? 1 - (1 + n181.percent / 100) * o209 : (1 - n181.percent / 100) * o209 : (r237 = 1 - n181.percent / 100, "treemap" === t719 && (r237 = (1 - n181.percent / 100) * (1.25 * o209)));
                var l150 = n181.color, h131 = new x;
                return s281.config.plotOptions[t719].enableShades && (l150 = "dark" === this.w.config.theme.mode ? x.hexToRgba(h131.shadeColor(-1 * r237, n181.color), s281.config.fill.opacity) : x.hexToRgba(h131.shadeColor(r237, n181.color), s281.config.fill.opacity)), {
                    color: l150,
                    colorProps: n181
                };
            }
        },
        {
            key: "determineColor",
            value: function(t720, e562, i427) {
                var a349 = this.w, s282 = a349.globals.series[e562][i427], r238 = a349.config.plotOptions[t720], o210 = r238.colorScale.inverse ? i427 : e562;
                r238.distributed && "treemap" === a349.config.chart.type && (o210 = i427);
                var n182 = a349.globals.colors[o210], l151 = null, h132 = Math.min.apply(Math, u(a349.globals.series[e562])), c110 = Math.max.apply(Math, u(a349.globals.series[e562]));
                r238.distributed || "heatmap" !== t720 || (h132 = a349.globals.minY, c110 = a349.globals.maxY), void 0 !== r238.colorScale.min && (h132 = r238.colorScale.min < a349.globals.minY ? r238.colorScale.min : a349.globals.minY, c110 = r238.colorScale.max > a349.globals.maxY ? r238.colorScale.max : a349.globals.maxY);
                var d98 = Math.abs(c110) + Math.abs(h132), g81 = 100 * s282 / (0 === d98 ? d98 - 1e-6 : d98);
                r238.colorScale.ranges.length > 0 && r238.colorScale.ranges.map(function(t721, e) {
                    if (s282 >= t721.from && s282 <= t721.to) {
                        n182 = t721.color, l151 = t721.foreColor ? t721.foreColor : null, h132 = t721.from, c110 = t721.to;
                        var i428 = Math.abs(c110) + Math.abs(h132);
                        g81 = 100 * s282 / (0 === i428 ? i428 - 1e-6 : i428);
                    }
                });
                return {
                    color: n182,
                    foreColor: l151,
                    percent: g81
                };
            }
        },
        {
            key: "calculateDataLabels",
            value: function(t722) {
                var e563 = t722.text, i429 = t722.x, a350 = t722.y, s283 = t722.i, r239 = t722.j, o211 = t722.colorProps, n183 = t722.fontSize, l152 = this.w.config.dataLabels, h133 = new m(this.ctx), c111 = new z(this.ctx), d99 = null;
                if (l152.enabled) {
                    d99 = h133.group({
                        class: "apexcharts-data-labels"
                    });
                    var g82 = l152.offsetX, u64 = l152.offsetY, p54 = i429 + g82, f49 = a350 + parseFloat(l152.style.fontSize) / 3 + u64;
                    c111.plotDataLabelsText({
                        x: p54,
                        y: f49,
                        text: e563,
                        i: s283,
                        j: r239,
                        color: o211.foreColor,
                        parent: d99,
                        fontSize: n183,
                        dataLabelsConfig: l152
                    });
                }
                return d99;
            }
        },
        {
            key: "addListeners",
            value: function(t723) {
                var e564 = new m(this.ctx);
                t723.node.addEventListener("mouseenter", e564.pathMouseEnter.bind(this, t723)), t723.node.addEventListener("mouseleave", e564.pathMouseLeave.bind(this, t723)), t723.node.addEventListener("mousedown", e564.pathMouseDown.bind(this, t723));
            }
        }
    ]), t716;
}(), At = function() {
    function t724(e565, i430) {
        a(this, t724), this.ctx = e565, this.w = e565.w, this.xRatio = i430.xRatio, this.yRatio = i430.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new kt(e565), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
    }
    return r(t724, [
        {
            key: "draw",
            value: function(t725) {
                var e566 = this.w, i431 = new m(this.ctx), a351 = i431.group({
                    class: "apexcharts-heatmap"
                });
                a351.attr("clip-path", "url(#gridRectMask".concat(e566.globals.cuid, ")"));
                var s284 = e566.globals.gridWidth / e566.globals.dataPoints, r240 = e566.globals.gridHeight / e566.globals.series.length, o212 = 0, n184 = !1;
                this.negRange = this.helpers.checkColorRange();
                var l153 = t725.slice();
                e566.config.yaxis[0].reversed && (n184 = !0, l153.reverse());
                for(var h134 = n184 ? 0 : l153.length - 1; n184 ? h134 < l153.length : h134 >= 0; n184 ? h134++ : h134--){
                    var c112 = i431.group({
                        class: "apexcharts-series apexcharts-heatmap-series",
                        seriesName: x.escapeString(e566.globals.seriesNames[h134]),
                        rel: h134 + 1,
                        "data:realIndex": h134
                    });
                    if (this.ctx.series.addCollapsedClassToSeries(c112, h134), e566.config.chart.dropShadow.enabled) {
                        var d100 = e566.config.chart.dropShadow;
                        new v(this.ctx).dropShadow(c112, d100, h134);
                    }
                    for(var g83 = 0, u65 = e566.config.plotOptions.heatmap.shadeIntensity, p55 = 0; p55 < l153[h134].length; p55++){
                        var f50 = this.helpers.getShadeColor(e566.config.chart.type, h134, p55, this.negRange), b41 = f50.color, y32 = f50.colorProps;
                        if ("image" === e566.config.fill.type) b41 = new T(this.ctx).fillPath({
                            seriesNumber: h134,
                            dataPointIndex: p55,
                            opacity: e566.globals.hasNegs ? y32.percent < 0 ? 1 - (1 + y32.percent / 100) : u65 + y32.percent / 100 : y32.percent / 100,
                            patternID: x.randomId(),
                            width: e566.config.fill.image.width ? e566.config.fill.image.width : s284,
                            height: e566.config.fill.image.height ? e566.config.fill.image.height : r240
                        });
                        var w26 = this.rectRadius, k24 = i431.drawRect(g83, o212, s284, r240, w26);
                        if (k24.attr({
                            cx: g83,
                            cy: o212
                        }), k24.node.classList.add("apexcharts-heatmap-rect"), c112.add(k24), k24.attr({
                            fill: b41,
                            i: h134,
                            index: h134,
                            j: p55,
                            val: l153[h134][p55],
                            "stroke-width": this.strokeWidth,
                            stroke: e566.config.plotOptions.heatmap.useFillColorAsStroke ? b41 : e566.globals.stroke.colors[0],
                            color: b41
                        }), this.helpers.addListeners(k24), e566.config.chart.animations.enabled && !e566.globals.dataChanged) {
                            var A18 = 1;
                            e566.globals.resized || (A18 = e566.config.chart.animations.speed), this.animateHeatMap(k24, g83, o212, s284, r240, A18);
                        }
                        if (e566.globals.dataChanged) {
                            var S13 = 1;
                            if (this.dynamicAnim.enabled && e566.globals.shouldAnimate) {
                                S13 = this.dynamicAnim.speed;
                                var C12 = e566.globals.previousPaths[h134] && e566.globals.previousPaths[h134][p55] && e566.globals.previousPaths[h134][p55].color;
                                C12 || (C12 = "rgba(255, 255, 255, 0)"), this.animateHeatColor(k24, x.isColorHex(C12) ? C12 : x.rgb2hex(C12), x.isColorHex(b41) ? b41 : x.rgb2hex(b41), S13);
                            }
                        }
                        var L11 = (0, e566.config.dataLabels.formatter)(e566.globals.series[h134][p55], {
                            value: e566.globals.series[h134][p55],
                            seriesIndex: h134,
                            dataPointIndex: p55,
                            w: e566
                        }), P10 = this.helpers.calculateDataLabels({
                            text: L11,
                            x: g83 + s284 / 2,
                            y: o212 + r240 / 2,
                            i: h134,
                            j: p55,
                            colorProps: y32,
                            series: l153
                        });
                        null !== P10 && c112.add(P10), g83 += s284;
                    }
                    o212 += r240, a351.add(c112);
                }
                var M8 = e566.globals.yAxisScale[0].result.slice();
                e566.config.yaxis[0].reversed ? M8.unshift("") : M8.push(""), e566.globals.yAxisScale[0].result = M8;
                var I5 = e566.globals.gridHeight / e566.globals.series.length;
                return e566.config.yaxis[0].labels.offsetY = -I5 / 2, a351;
            }
        },
        {
            key: "animateHeatMap",
            value: function(t726, e567, i432, a352, s285, r241) {
                var o213 = new b(this.ctx);
                o213.animateRect(t726, {
                    x: e567 + a352 / 2,
                    y: i432 + s285 / 2,
                    width: 0,
                    height: 0
                }, {
                    x: e567,
                    y: i432,
                    width: a352,
                    height: s285
                }, r241, function() {
                    o213.animationCompleted(t726);
                });
            }
        },
        {
            key: "animateHeatColor",
            value: function(t727, e568, i433, a353) {
                t727.attr({
                    fill: e568
                }).animate(a353).attr({
                    fill: i433
                });
            }
        }
    ]), t724;
}(), St = function() {
    function t728(e569) {
        a(this, t728), this.ctx = e569, this.w = e569.w;
    }
    return r(t728, [
        {
            key: "drawYAxisTexts",
            value: function(t729, e570, i434, a354) {
                var s286 = this.w, r242 = s286.config.yaxis[0], o214 = s286.globals.yLabelFormatters[0];
                return new m(this.ctx).drawText({
                    x: t729 + r242.labels.offsetX,
                    y: e570 + r242.labels.offsetY,
                    text: o214(a354, i434),
                    textAnchor: "middle",
                    fontSize: r242.labels.style.fontSize,
                    fontFamily: r242.labels.style.fontFamily,
                    foreColor: Array.isArray(r242.labels.style.colors) ? r242.labels.style.colors[i434] : r242.labels.style.colors
                });
            }
        }
    ]), t728;
}(), Ct = function() {
    function t730(e571) {
        a(this, t730), this.ctx = e571, this.w = e571.w;
        var i435 = this.w;
        this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [
            0
        ], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = void 0 !== i435.globals.stroke.colors ? i435.globals.stroke.colors : i435.globals.colors, this.defaultSize = Math.min(i435.globals.gridWidth, i435.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = i435.globals.gridWidth / 2, "radialBar" === i435.config.chart.type ? this.fullAngle = 360 : this.fullAngle = Math.abs(i435.config.plotOptions.pie.endAngle - i435.config.plotOptions.pie.startAngle), this.initialAngle = i435.config.plotOptions.pie.startAngle % this.fullAngle, i435.globals.radialSize = this.defaultSize / 2.05 - i435.config.stroke.width - (i435.config.chart.sparkline.enabled ? 0 : i435.config.chart.dropShadow.blur), this.donutSize = i435.globals.radialSize * parseInt(i435.config.plotOptions.pie.donut.size, 10) / 100, this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
    }
    return r(t730, [
        {
            key: "draw",
            value: function(t731) {
                var e572 = this, i436 = this.w, a355 = new m(this.ctx);
                if (this.ret = a355.group({
                    class: "apexcharts-pie"
                }), i436.globals.noData) return this.ret;
                for(var s287 = 0, r243 = 0; r243 < t731.length; r243++)s287 += x.negToZero(t731[r243]);
                var o215 = [], n185 = a355.group();
                0 === s287 && (s287 = 1e-5), t731.forEach(function(t732) {
                    e572.maxY = Math.max(e572.maxY, t732);
                }), i436.config.yaxis[0].max && (this.maxY = i436.config.yaxis[0].max), "back" === i436.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret);
                for(var l154 = 0; l154 < t731.length; l154++){
                    var h135 = this.fullAngle * x.negToZero(t731[l154]) / s287;
                    o215.push(h135), "polarArea" === this.chartType ? (o215[l154] = this.fullAngle / t731.length, this.sliceSizes.push(i436.globals.radialSize * t731[l154] / this.maxY)) : this.sliceSizes.push(i436.globals.radialSize);
                }
                if (i436.globals.dataChanged) {
                    for(var c113, d101 = 0, g84 = 0; g84 < i436.globals.previousPaths.length; g84++)d101 += x.negToZero(i436.globals.previousPaths[g84]);
                    for(var u66 = 0; u66 < i436.globals.previousPaths.length; u66++)c113 = this.fullAngle * x.negToZero(i436.globals.previousPaths[u66]) / d101, this.prevSectorAngleArr.push(c113);
                }
                this.donutSize < 0 && (this.donutSize = 0);
                var p56 = i436.config.plotOptions.pie.customScale, f51 = i436.globals.gridWidth / 2, b42 = i436.globals.gridHeight / 2, v32 = f51 - i436.globals.gridWidth / 2 * p56, y33 = b42 - i436.globals.gridHeight / 2 * p56;
                if ("donut" === this.chartType) {
                    var w27 = a355.drawCircle(this.donutSize);
                    w27.attr({
                        cx: this.centerX,
                        cy: this.centerY,
                        fill: i436.config.plotOptions.pie.donut.background ? i436.config.plotOptions.pie.donut.background : "transparent"
                    }), n185.add(w27);
                }
                var k25 = this.drawArcs(o215, t731);
                if (this.sliceLabels.forEach(function(t733) {
                    k25.add(t733);
                }), n185.attr({
                    transform: "translate(".concat(v32, ", ").concat(y33, ") scale(").concat(p56, ")")
                }), n185.add(k25), this.ret.add(n185), this.donutDataLabels.show) {
                    var A19 = this.renderInnerDataLabels(this.donutDataLabels, {
                        hollowSize: this.donutSize,
                        centerX: this.centerX,
                        centerY: this.centerY,
                        opacity: this.donutDataLabels.show,
                        translateX: v32,
                        translateY: y33
                    });
                    this.ret.add(A19);
                }
                return "front" === i436.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret), this.ret;
            }
        },
        {
            key: "drawArcs",
            value: function(t734, e573) {
                var i437 = this.w, a356 = new v(this.ctx), s288 = new m(this.ctx), r244 = new T(this.ctx), o216 = s288.group({
                    class: "apexcharts-slices"
                }), n186 = this.initialAngle, l155 = this.initialAngle, h136 = this.initialAngle, c114 = this.initialAngle;
                this.strokeWidth = i437.config.stroke.show ? i437.config.stroke.width : 0;
                for(var d102 = 0; d102 < t734.length; d102++){
                    var g85 = s288.group({
                        class: "apexcharts-series apexcharts-pie-series",
                        seriesName: x.escapeString(i437.globals.seriesNames[d102]),
                        rel: d102 + 1,
                        "data:realIndex": d102
                    });
                    o216.add(g85), l155 = c114, h136 = (n186 = h136) + t734[d102], c114 = l155 + this.prevSectorAngleArr[d102];
                    var u67 = h136 < n186 ? this.fullAngle + h136 - n186 : h136 - n186, p57 = r244.fillPath({
                        seriesNumber: d102,
                        size: this.sliceSizes[d102],
                        value: e573[d102]
                    }), f52 = this.getChangedPath(l155, c114), b43 = s288.drawPath({
                        d: f52,
                        stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[d102] : this.lineColorArr,
                        strokeWidth: 0,
                        fill: p57,
                        fillOpacity: i437.config.fill.opacity,
                        classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(d102)
                    });
                    if (b43.attr({
                        index: 0,
                        j: d102
                    }), a356.setSelectionFilter(b43, 0, d102), i437.config.chart.dropShadow.enabled) {
                        var y34 = i437.config.chart.dropShadow;
                        a356.dropShadow(b43, y34, d102);
                    }
                    this.addListeners(b43, this.donutDataLabels), m.setAttrs(b43.node, {
                        "data:angle": u67,
                        "data:startAngle": n186,
                        "data:strokeWidth": this.strokeWidth,
                        "data:value": e573[d102]
                    });
                    var w28 = {
                        x: 0,
                        y: 0
                    };
                    "pie" === this.chartType || "polarArea" === this.chartType ? w28 = x.polarToCartesian(this.centerX, this.centerY, i437.globals.radialSize / 1.25 + i437.config.plotOptions.pie.dataLabels.offset, (n186 + u67 / 2) % this.fullAngle) : "donut" === this.chartType && (w28 = x.polarToCartesian(this.centerX, this.centerY, (i437.globals.radialSize + this.donutSize) / 2 + i437.config.plotOptions.pie.dataLabels.offset, (n186 + u67 / 2) % this.fullAngle)), g85.add(b43);
                    var k26 = 0;
                    if (!this.initialAnim || i437.globals.resized || i437.globals.dataChanged ? this.animBeginArr.push(0) : (0 === (k26 = u67 / this.fullAngle * i437.config.chart.animations.speed) && (k26 = 1), this.animDur = k26 + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i437.globals.dataChanged ? this.animatePaths(b43, {
                        size: this.sliceSizes[d102],
                        endAngle: h136,
                        startAngle: n186,
                        prevStartAngle: l155,
                        prevEndAngle: c114,
                        animateStartingPos: !0,
                        i: d102,
                        animBeginArr: this.animBeginArr,
                        shouldSetPrevPaths: !0,
                        dur: i437.config.chart.animations.dynamicAnimation.speed
                    }) : this.animatePaths(b43, {
                        size: this.sliceSizes[d102],
                        endAngle: h136,
                        startAngle: n186,
                        i: d102,
                        totalItems: t734.length - 1,
                        animBeginArr: this.animBeginArr,
                        dur: k26
                    }), i437.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && b43.click(this.pieClicked.bind(this, d102)), void 0 !== i437.globals.selectedDataPoints[0] && i437.globals.selectedDataPoints[0].indexOf(d102) > -1 && this.pieClicked(d102), i437.config.dataLabels.enabled) {
                        var A20 = w28.x, S14 = w28.y, C13 = 100 * u67 / this.fullAngle + "%";
                        if (0 !== u67 && i437.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t734[d102]) {
                            var L12 = i437.config.dataLabels.formatter;
                            void 0 !== L12 && (C13 = L12(i437.globals.seriesPercent[d102][0], {
                                seriesIndex: d102,
                                w: i437
                            }));
                            var P11 = i437.globals.dataLabels.style.colors[d102], M9 = s288.group({
                                class: "apexcharts-datalabels"
                            }), I6 = s288.drawText({
                                x: A20,
                                y: S14,
                                text: C13,
                                textAnchor: "middle",
                                fontSize: i437.config.dataLabels.style.fontSize,
                                fontFamily: i437.config.dataLabels.style.fontFamily,
                                fontWeight: i437.config.dataLabels.style.fontWeight,
                                foreColor: P11
                            });
                            if (M9.add(I6), i437.config.dataLabels.dropShadow.enabled) {
                                var z4 = i437.config.dataLabels.dropShadow;
                                a356.dropShadow(I6, z4);
                            }
                            I6.node.classList.add("apexcharts-pie-label"), i437.config.chart.animations.animate && !1 === i437.globals.resized && (I6.node.classList.add("apexcharts-pie-label-delay"), I6.node.style.animationDelay = i437.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(M9);
                        }
                    }
                }
                return o216;
            }
        },
        {
            key: "addListeners",
            value: function(t735, e574) {
                var i438 = new m(this.ctx);
                t735.node.addEventListener("mouseenter", i438.pathMouseEnter.bind(this, t735)), t735.node.addEventListener("mouseleave", i438.pathMouseLeave.bind(this, t735)), t735.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t735.node, e574)), t735.node.addEventListener("mousedown", i438.pathMouseDown.bind(this, t735)), this.donutDataLabels.total.showAlways || (t735.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t735.node, e574)), t735.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t735.node, e574)));
            }
        },
        {
            key: "animatePaths",
            value: function(t736, e575) {
                var i439 = this.w, a357 = e575.endAngle < e575.startAngle ? this.fullAngle + e575.endAngle - e575.startAngle : e575.endAngle - e575.startAngle, s289 = a357, r245 = e575.startAngle, o217 = e575.startAngle;
                void 0 !== e575.prevStartAngle && void 0 !== e575.prevEndAngle && (r245 = e575.prevEndAngle, s289 = e575.prevEndAngle < e575.prevStartAngle ? this.fullAngle + e575.prevEndAngle - e575.prevStartAngle : e575.prevEndAngle - e575.prevStartAngle), e575.i === i439.config.series.length - 1 && (a357 + o217 > this.fullAngle ? e575.endAngle = e575.endAngle - (a357 + o217) : a357 + o217 < this.fullAngle && (e575.endAngle = e575.endAngle + (this.fullAngle - (a357 + o217)))), a357 === this.fullAngle && (a357 = this.fullAngle - .01), this.animateArc(t736, r245, o217, a357, s289, e575);
            }
        },
        {
            key: "animateArc",
            value: function(t737, e576, i440, a358, s290, r246) {
                var o218, n187 = this, l156 = this.w, h137 = new b(this.ctx), c115 = r246.size;
                (isNaN(e576) || isNaN(s290)) && (e576 = i440, s290 = a358, r246.dur = 0);
                var d103 = a358, g86 = i440, u68 = e576 < i440 ? this.fullAngle + e576 - i440 : e576 - i440;
                l156.globals.dataChanged && r246.shouldSetPrevPaths && r246.prevEndAngle && (o218 = n187.getPiePath({
                    me: n187,
                    startAngle: r246.prevStartAngle,
                    angle: r246.prevEndAngle < r246.prevStartAngle ? this.fullAngle + r246.prevEndAngle - r246.prevStartAngle : r246.prevEndAngle - r246.prevStartAngle,
                    size: c115
                }), t737.attr({
                    d: o218
                })), 0 !== r246.dur ? t737.animate(r246.dur, l156.globals.easing, r246.animBeginArr[r246.i]).afterAll(function() {
                    "pie" !== n187.chartType && "donut" !== n187.chartType && "polarArea" !== n187.chartType || this.animate(l156.config.chart.animations.dynamicAnimation.speed).attr({
                        "stroke-width": n187.strokeWidth
                    }), r246.i === l156.config.series.length - 1 && h137.animationCompleted(t737);
                }).during(function(l157) {
                    d103 = u68 + (a358 - u68) * l157, r246.animateStartingPos && (d103 = s290 + (a358 - s290) * l157, g86 = e576 - s290 + (i440 - (e576 - s290)) * l157), o218 = n187.getPiePath({
                        me: n187,
                        startAngle: g86,
                        angle: d103,
                        size: c115
                    }), t737.node.setAttribute("data:pathOrig", o218), t737.attr({
                        d: o218
                    });
                }) : (o218 = n187.getPiePath({
                    me: n187,
                    startAngle: g86,
                    angle: a358,
                    size: c115
                }), r246.isTrack || (l156.globals.animationEnded = !0), t737.node.setAttribute("data:pathOrig", o218), t737.attr({
                    d: o218,
                    "stroke-width": n187.strokeWidth
                }));
            }
        },
        {
            key: "pieClicked",
            value: function(t738) {
                var e577, i441 = this.w, a359 = this, s291 = a359.sliceSizes[t738] + (i441.config.plotOptions.pie.expandOnClick ? 4 : 0), r247 = i441.globals.dom.Paper.select(".apexcharts-".concat(a359.chartType.toLowerCase(), "-slice-").concat(t738)).members[0];
                if ("true" !== r247.attr("data:pieClicked")) {
                    var o219 = i441.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
                    Array.prototype.forEach.call(o219, function(t739) {
                        t739.setAttribute("data:pieClicked", "false");
                        var e578 = t739.getAttribute("data:pathOrig");
                        t739.setAttribute("d", e578);
                    }), r247.attr("data:pieClicked", "true");
                    var n188 = parseInt(r247.attr("data:startAngle"), 10), l158 = parseInt(r247.attr("data:angle"), 10);
                    e577 = a359.getPiePath({
                        me: a359,
                        startAngle: n188,
                        angle: l158,
                        size: s291
                    }), 360 !== l158 && r247.plot(e577);
                } else {
                    r247.attr({
                        "data:pieClicked": "false"
                    }), this.revertDataLabelsInner(r247.node, this.donutDataLabels);
                    var h138 = r247.attr("data:pathOrig");
                    r247.attr({
                        d: h138
                    });
                }
            }
        },
        {
            key: "getChangedPath",
            value: function(t740, e579) {
                var i442 = "";
                return this.dynamicAnim && this.w.globals.dataChanged && (i442 = this.getPiePath({
                    me: this,
                    startAngle: t740,
                    angle: e579 - t740,
                    size: this.size
                })), i442;
            }
        },
        {
            key: "getPiePath",
            value: function(t741) {
                var e580 = t741.me, i443 = t741.startAngle, a360 = t741.angle, s292 = t741.size, r248 = i443, o220 = Math.PI * (r248 - 90) / 180, n189 = a360 + i443;
                Math.ceil(n189) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (n189 = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - .01), Math.ceil(n189) > this.fullAngle && (n189 -= this.fullAngle);
                var l159 = Math.PI * (n189 - 90) / 180, h139 = e580.centerX + s292 * Math.cos(o220), c116 = e580.centerY + s292 * Math.sin(o220), d104 = e580.centerX + s292 * Math.cos(l159), g87 = e580.centerY + s292 * Math.sin(l159), u69 = x.polarToCartesian(e580.centerX, e580.centerY, e580.donutSize, n189), p58 = x.polarToCartesian(e580.centerX, e580.centerY, e580.donutSize, r248), f53 = a360 > 180 ? 1 : 0, b44 = [
                    "M",
                    h139,
                    c116,
                    "A",
                    s292,
                    s292,
                    0,
                    f53,
                    1,
                    d104,
                    g87
                ];
                return "donut" === e580.chartType ? [].concat(b44, [
                    "L",
                    u69.x,
                    u69.y,
                    "A",
                    e580.donutSize,
                    e580.donutSize,
                    0,
                    f53,
                    0,
                    p58.x,
                    p58.y,
                    "L",
                    h139,
                    c116,
                    "z"
                ]).join(" ") : "pie" === e580.chartType || "polarArea" === e580.chartType ? [].concat(b44, [
                    "L",
                    e580.centerX,
                    e580.centerY,
                    "L",
                    h139,
                    c116
                ]).join(" ") : [].concat(b44).join(" ");
            }
        },
        {
            key: "drawPolarElements",
            value: function(t742) {
                var e581 = this.w, i444 = new q(this.ctx), a361 = new m(this.ctx), s293 = new St(this.ctx), r249 = a361.group(), o221 = a361.group(), n190 = i444.niceScale(0, Math.ceil(this.maxY), e581.config.yaxis[0].tickAmount, 0, !0), l160 = n190.result.reverse(), h140 = n190.result.length;
                this.maxY = n190.niceMax;
                for(var c117 = e581.globals.radialSize, d105 = c117 / (h140 - 1), g88 = 0; g88 < h140 - 1; g88++){
                    var u70 = a361.drawCircle(c117);
                    if (u70.attr({
                        cx: this.centerX,
                        cy: this.centerY,
                        fill: "none",
                        "stroke-width": e581.config.plotOptions.polarArea.rings.strokeWidth,
                        stroke: e581.config.plotOptions.polarArea.rings.strokeColor
                    }), e581.config.yaxis[0].show) {
                        var p59 = s293.drawYAxisTexts(this.centerX, this.centerY - c117 + parseInt(e581.config.yaxis[0].labels.style.fontSize, 10) / 2, g88, l160[g88]);
                        o221.add(p59);
                    }
                    r249.add(u70), c117 -= d105;
                }
                this.drawSpokes(t742), t742.add(r249), t742.add(o221);
            }
        },
        {
            key: "renderInnerDataLabels",
            value: function(t743, e582) {
                var i445 = this.w, a362 = new m(this.ctx), s294 = a362.group({
                    class: "apexcharts-datalabels-group",
                    transform: "translate(".concat(e582.translateX ? e582.translateX : 0, ", ").concat(e582.translateY ? e582.translateY : 0, ") scale(").concat(i445.config.plotOptions.pie.customScale, ")")
                }), r250 = t743.total.show;
                s294.node.style.opacity = e582.opacity;
                var o222, n191, l161 = e582.centerX, h141 = e582.centerY;
                o222 = void 0 === t743.name.color ? i445.globals.colors[0] : t743.name.color;
                var c118 = t743.name.fontSize, d106 = t743.name.fontFamily, g89 = t743.name.fontWeight;
                n191 = void 0 === t743.value.color ? i445.config.chart.foreColor : t743.value.color;
                var u71 = t743.value.formatter, p60 = "", f54 = "";
                if (r250 ? (o222 = t743.total.color, c118 = t743.total.fontSize, d106 = t743.total.fontFamily, g89 = t743.total.fontWeight, f54 = t743.total.label, p60 = t743.total.formatter(i445)) : 1 === i445.globals.series.length && (p60 = u71(i445.globals.series[0], i445), f54 = i445.globals.seriesNames[0]), f54 && (f54 = t743.name.formatter(f54, t743.total.show, i445)), t743.name.show) {
                    var x36 = a362.drawText({
                        x: l161,
                        y: h141 + parseFloat(t743.name.offsetY),
                        text: f54,
                        textAnchor: "middle",
                        foreColor: o222,
                        fontSize: c118,
                        fontWeight: g89,
                        fontFamily: d106
                    });
                    x36.node.classList.add("apexcharts-datalabel-label"), s294.add(x36);
                }
                if (t743.value.show) {
                    var b45 = t743.name.show ? parseFloat(t743.value.offsetY) + 16 : t743.value.offsetY, v33 = a362.drawText({
                        x: l161,
                        y: h141 + b45,
                        text: p60,
                        textAnchor: "middle",
                        foreColor: n191,
                        fontWeight: t743.value.fontWeight,
                        fontSize: t743.value.fontSize,
                        fontFamily: t743.value.fontFamily
                    });
                    v33.node.classList.add("apexcharts-datalabel-value"), s294.add(v33);
                }
                return s294;
            }
        },
        {
            key: "printInnerLabels",
            value: function(t744, e583, i446, a363) {
                var s295, r251 = this.w;
                a363 ? s295 = void 0 === t744.name.color ? r251.globals.colors[parseInt(a363.parentNode.getAttribute("rel"), 10) - 1] : t744.name.color : r251.globals.series.length > 1 && t744.total.show && (s295 = t744.total.color);
                var o223 = r251.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), n192 = r251.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
                i446 = (0, t744.value.formatter)(i446, r251), a363 || "function" != typeof t744.total.formatter || (i446 = t744.total.formatter(r251));
                var l162 = e583 === t744.total.label;
                e583 = t744.name.formatter(e583, l162, r251), null !== o223 && (o223.textContent = e583), null !== n192 && (n192.textContent = i446), null !== o223 && (o223.style.fill = s295);
            }
        },
        {
            key: "printDataLabelsInner",
            value: function(t745, e584) {
                var i447 = this.w, a364 = t745.getAttribute("data:value"), s296 = i447.globals.seriesNames[parseInt(t745.parentNode.getAttribute("rel"), 10) - 1];
                i447.globals.series.length > 1 && this.printInnerLabels(e584, s296, a364, t745);
                var r252 = i447.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
                null !== r252 && (r252.style.opacity = 1);
            }
        },
        {
            key: "drawSpokes",
            value: function(t746) {
                var e585 = this, i448 = this.w, a365 = new m(this.ctx), s297 = i448.config.plotOptions.polarArea.spokes;
                if (0 !== s297.strokeWidth) {
                    for(var r253 = [], o224 = 360 / i448.globals.series.length, n193 = 0; n193 < i448.globals.series.length; n193++)r253.push(x.polarToCartesian(this.centerX, this.centerY, i448.globals.radialSize, i448.config.plotOptions.pie.startAngle + o224 * n193));
                    r253.forEach(function(i449, r254) {
                        var o225 = a365.drawLine(i449.x, i449.y, e585.centerX, e585.centerY, Array.isArray(s297.connectorColors) ? s297.connectorColors[r254] : s297.connectorColors);
                        t746.add(o225);
                    });
                }
            }
        },
        {
            key: "revertDataLabelsInner",
            value: function(t747, e586, i450) {
                var a366 = this, s298 = this.w, r255 = s298.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"), o226 = !1, n194 = s298.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"), l163 = function(t748) {
                    var i451 = t748.makeSliceOut, s299 = t748.printLabel;
                    Array.prototype.forEach.call(n194, function(t749) {
                        "true" === t749.getAttribute("data:pieClicked") && (i451 && (o226 = !0), s299 && a366.printDataLabelsInner(t749, e586));
                    });
                };
                if (l163({
                    makeSliceOut: !0,
                    printLabel: !1
                }), e586.total.show && s298.globals.series.length > 1) o226 && !e586.total.showAlways ? l163({
                    makeSliceOut: !1,
                    printLabel: !0
                }) : this.printInnerLabels(e586, e586.total.label, e586.total.formatter(s298));
                else if (l163({
                    makeSliceOut: !1,
                    printLabel: !0
                }), !o226) {
                    if (s298.globals.selectedDataPoints.length && s298.globals.series.length > 1) {
                        if (s298.globals.selectedDataPoints[0].length > 0) {
                            var h142 = s298.globals.selectedDataPoints[0], c119 = s298.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(h142));
                            this.printDataLabelsInner(c119, e586);
                        } else r255 && s298.globals.selectedDataPoints.length && 0 === s298.globals.selectedDataPoints[0].length && (r255.style.opacity = 0);
                    } else r255 && s298.globals.series.length > 1 && (r255.style.opacity = 0);
                }
            }
        }
    ]), t730;
}(), Lt = function() {
    function t750(e587) {
        a(this, t750), this.ctx = e587, this.w = e587.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
        var i452 = this.w;
        this.graphics = new m(this.ctx), this.lineColorArr = void 0 !== i452.globals.stroke.colors ? i452.globals.stroke.colors : i452.globals.colors, this.defaultSize = i452.globals.svgHeight < i452.globals.svgWidth ? i452.globals.gridHeight + 1.5 * i452.globals.goldenPadding : i452.globals.gridWidth, this.isLog = i452.config.yaxis[0].logarithmic, this.coreUtils = new y(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(i452.globals.maxY, 0) : i452.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.w.globals.minY, 0) : i452.globals.minY, this.polygons = i452.config.plotOptions.radar.polygons, this.strokeWidth = i452.config.stroke.show ? i452.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - i452.config.chart.dropShadow.blur, i452.config.xaxis.labels.show && (this.size = this.size - i452.globals.xAxisLabelsWidth / 1.75), void 0 !== i452.config.plotOptions.radar.size && (this.size = i452.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
    }
    return r(t750, [
        {
            key: "draw",
            value: function(t751) {
                var i453 = this, a367 = this.w, s300 = new T(this.ctx), r256 = [], o227 = new z(this.ctx);
                t751.length && (this.dataPointsLen = t751[a367.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
                var n195 = a367.globals.gridWidth / 2, l164 = a367.globals.gridHeight / 2, h143 = n195 + a367.config.plotOptions.radar.offsetX, c120 = l164 + a367.config.plotOptions.radar.offsetY, d107 = this.graphics.group({
                    class: "apexcharts-radar-series apexcharts-plot-series",
                    transform: "translate(".concat(h143 || 0, ", ").concat(c120 || 0, ")")
                }), g90 = [], u72 = null, p61 = null;
                if (this.yaxisLabels = this.graphics.group({
                    class: "apexcharts-yaxis"
                }), t751.forEach(function(t752, n196) {
                    var l165 = t752.length === a367.globals.dataPoints, h144 = i453.graphics.group().attr({
                        class: "apexcharts-series",
                        "data:longestSeries": l165,
                        seriesName: x.escapeString(a367.globals.seriesNames[n196]),
                        rel: n196 + 1,
                        "data:realIndex": n196
                    });
                    i453.dataRadiusOfPercent[n196] = [], i453.dataRadius[n196] = [], i453.angleArr[n196] = [], t752.forEach(function(t753, e588) {
                        var a368 = Math.abs(i453.maxValue - i453.minValue);
                        t753 += Math.abs(i453.minValue), i453.isLog && (t753 = i453.coreUtils.getLogVal(t753, 0)), i453.dataRadiusOfPercent[n196][e588] = t753 / a368, i453.dataRadius[n196][e588] = i453.dataRadiusOfPercent[n196][e588] * i453.size, i453.angleArr[n196][e588] = e588 * i453.disAngle;
                    }), g90 = i453.getDataPointsPos(i453.dataRadius[n196], i453.angleArr[n196]);
                    var c121 = i453.createPaths(g90, {
                        x: 0,
                        y: 0
                    });
                    u72 = i453.graphics.group({
                        class: "apexcharts-series-markers-wrap apexcharts-element-hidden"
                    }), p61 = i453.graphics.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": n196
                    }), a367.globals.delayedElements.push({
                        el: u72.node,
                        index: n196
                    });
                    var d108 = {
                        i: n196,
                        realIndex: n196,
                        animationDelay: n196,
                        initialSpeed: a367.config.chart.animations.speed,
                        dataChangeSpeed: a367.config.chart.animations.dynamicAnimation.speed,
                        className: "apexcharts-radar",
                        shouldClipToGrid: !1,
                        bindEventsOnPaths: !1,
                        stroke: a367.globals.stroke.colors[n196],
                        strokeLineCap: a367.config.stroke.lineCap
                    }, f56 = null;
                    a367.globals.previousPaths.length > 0 && (f56 = i453.getPreviousPath(n196));
                    for(var b46 = 0; b46 < c121.linePathsTo.length; b46++){
                        var m16 = i453.graphics.renderPaths(e(e({}, d108), {}, {
                            pathFrom: null === f56 ? c121.linePathsFrom[b46] : f56,
                            pathTo: c121.linePathsTo[b46],
                            strokeWidth: Array.isArray(i453.strokeWidth) ? i453.strokeWidth[n196] : i453.strokeWidth,
                            fill: "none",
                            drawShadow: !1
                        }));
                        h144.add(m16);
                        var y35 = s300.fillPath({
                            seriesNumber: n196
                        }), w29 = i453.graphics.renderPaths(e(e({}, d108), {}, {
                            pathFrom: null === f56 ? c121.areaPathsFrom[b46] : f56,
                            pathTo: c121.areaPathsTo[b46],
                            strokeWidth: 0,
                            fill: y35,
                            drawShadow: !1
                        }));
                        if (a367.config.chart.dropShadow.enabled) {
                            var k27 = new v(i453.ctx), A21 = a367.config.chart.dropShadow;
                            k27.dropShadow(w29, Object.assign({}, A21, {
                                noUserSpaceOnUse: !0
                            }), n196);
                        }
                        h144.add(w29);
                    }
                    t752.forEach(function(t, s301) {
                        var r257 = new M(i453.ctx).getMarkerConfig({
                            cssClass: "apexcharts-marker",
                            seriesIndex: n196,
                            dataPointIndex: s301
                        }), l166 = i453.graphics.drawMarker(g90[s301].x, g90[s301].y, r257);
                        l166.attr("rel", s301), l166.attr("j", s301), l166.attr("index", n196), l166.node.setAttribute("default-marker-size", r257.pSize);
                        var c122 = i453.graphics.group({
                            class: "apexcharts-series-markers"
                        });
                        c122 && c122.add(l166), u72.add(c122), h144.add(u72);
                        var d109 = a367.config.dataLabels;
                        if (d109.enabled) {
                            var f57 = d109.formatter(a367.globals.series[n196][s301], {
                                seriesIndex: n196,
                                dataPointIndex: s301,
                                w: a367
                            });
                            o227.plotDataLabelsText({
                                x: g90[s301].x,
                                y: g90[s301].y,
                                text: f57,
                                textAnchor: "middle",
                                i: n196,
                                j: n196,
                                parent: p61,
                                offsetCorrection: !1,
                                dataLabelsConfig: e({}, d109)
                            });
                        }
                        h144.add(p61);
                    }), r256.push(h144);
                }), this.drawPolygons({
                    parent: d107
                }), a367.config.xaxis.labels.show) {
                    var f55 = this.drawXAxisTexts();
                    d107.add(f55);
                }
                return r256.forEach(function(t754) {
                    d107.add(t754);
                }), d107.add(this.yaxisLabels), d107;
            }
        },
        {
            key: "drawPolygons",
            value: function(t755) {
                for(var e589 = this, i454 = this.w, a369 = t755.parent, s302 = new St(this.ctx), r258 = i454.globals.yAxisScale[0].result.reverse(), o228 = r258.length, n197 = [], l167 = this.size / (o228 - 1), h145 = 0; h145 < o228; h145++)n197[h145] = l167 * h145;
                n197.reverse();
                var c123 = [], d110 = [];
                n197.forEach(function(t756, i455) {
                    var a370 = x.getPolygonPos(t756, e589.dataPointsLen), s303 = "";
                    a370.forEach(function(t757, a371) {
                        if (0 === i455) {
                            var r259 = e589.graphics.drawLine(t757.x, t757.y, 0, 0, Array.isArray(e589.polygons.connectorColors) ? e589.polygons.connectorColors[a371] : e589.polygons.connectorColors);
                            d110.push(r259);
                        }
                        0 === a371 && e589.yaxisLabelsTextsPos.push({
                            x: t757.x,
                            y: t757.y
                        }), s303 += t757.x + "," + t757.y + " ";
                    }), c123.push(s303);
                }), c123.forEach(function(t758, s304) {
                    var r260 = e589.polygons.strokeColors, o229 = e589.polygons.strokeWidth, n198 = e589.graphics.drawPolygon(t758, Array.isArray(r260) ? r260[s304] : r260, Array.isArray(o229) ? o229[s304] : o229, i454.globals.radarPolygons.fill.colors[s304]);
                    a369.add(n198);
                }), d110.forEach(function(t759) {
                    a369.add(t759);
                }), i454.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(t760, i456) {
                    var a372 = s302.drawYAxisTexts(t760.x, t760.y, i456, r258[i456]);
                    e589.yaxisLabels.add(a372);
                });
            }
        },
        {
            key: "drawXAxisTexts",
            value: function() {
                var t761 = this, i457 = this.w, a373 = i457.config.xaxis.labels, s305 = this.graphics.group({
                    class: "apexcharts-xaxis"
                }), r261 = x.getPolygonPos(this.size, this.dataPointsLen);
                return i457.globals.labels.forEach(function(o230, n199) {
                    var l168 = i457.config.xaxis.labels.formatter, h146 = new z(t761.ctx);
                    if (r261[n199]) {
                        var c124 = t761.getTextPos(r261[n199], t761.size), d111 = l168(o230, {
                            seriesIndex: -1,
                            dataPointIndex: n199,
                            w: i457
                        });
                        h146.plotDataLabelsText({
                            x: c124.newX,
                            y: c124.newY,
                            text: d111,
                            textAnchor: c124.textAnchor,
                            i: n199,
                            j: n199,
                            parent: s305,
                            color: Array.isArray(a373.style.colors) && a373.style.colors[n199] ? a373.style.colors[n199] : "#a8a8a8",
                            dataLabelsConfig: e({
                                textAnchor: c124.textAnchor,
                                dropShadow: {
                                    enabled: !1
                                }
                            }, a373),
                            offsetCorrection: !1
                        });
                    }
                }), s305;
            }
        },
        {
            key: "createPaths",
            value: function(t762, e590) {
                var i458 = this, a374 = [], s306 = [], r262 = [], o231 = [];
                if (t762.length) {
                    s306 = [
                        this.graphics.move(e590.x, e590.y)
                    ], o231 = [
                        this.graphics.move(e590.x, e590.y)
                    ];
                    var n200 = this.graphics.move(t762[0].x, t762[0].y), l169 = this.graphics.move(t762[0].x, t762[0].y);
                    t762.forEach(function(e591, a375) {
                        n200 += i458.graphics.line(e591.x, e591.y), l169 += i458.graphics.line(e591.x, e591.y), a375 === t762.length - 1 && (n200 += "Z", l169 += "Z");
                    }), a374.push(n200), r262.push(l169);
                }
                return {
                    linePathsFrom: s306,
                    linePathsTo: a374,
                    areaPathsFrom: o231,
                    areaPathsTo: r262
                };
            }
        },
        {
            key: "getTextPos",
            value: function(t763, e592) {
                var i459 = "middle", a376 = t763.x, s307 = t763.y;
                return Math.abs(t763.x) >= 10 ? t763.x > 0 ? (i459 = "start", a376 += 10) : t763.x < 0 && (i459 = "end", a376 -= 10) : i459 = "middle", Math.abs(t763.y) >= e592 - 10 && (t763.y < 0 ? s307 -= 10 : t763.y > 0 && (s307 += 10)), {
                    textAnchor: i459,
                    newX: a376,
                    newY: s307
                };
            }
        },
        {
            key: "getPreviousPath",
            value: function(t764) {
                for(var e593 = this.w, i460 = null, a377 = 0; a377 < e593.globals.previousPaths.length; a377++){
                    var s308 = e593.globals.previousPaths[a377];
                    s308.paths.length > 0 && parseInt(s308.realIndex, 10) === parseInt(t764, 10) && void 0 !== e593.globals.previousPaths[a377].paths[0] && (i460 = e593.globals.previousPaths[a377].paths[0].d);
                }
                return i460;
            }
        },
        {
            key: "getDataPointsPos",
            value: function(t765, e594) {
                var i461 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
                t765 = t765 || [], e594 = e594 || [];
                for(var a378 = [], s309 = 0; s309 < i461; s309++){
                    var r263 = {};
                    r263.x = t765[s309] * Math.sin(e594[s309]), r263.y = -t765[s309] * Math.cos(e594[s309]), a378.push(r263);
                }
                return a378;
            }
        }
    ]), t750;
}(), Pt = function(t766) {
    n(i462, Ct);
    var e595 = d(i462);
    function i462(t767) {
        var s310;
        a(this, i462), (s310 = e595.call(this, t767)).ctx = t767, s310.w = t767.w, s310.animBeginArr = [
            0
        ], s310.animDur = 0;
        var r264 = s310.w;
        return s310.startAngle = r264.config.plotOptions.radialBar.startAngle, s310.endAngle = r264.config.plotOptions.radialBar.endAngle, s310.totalAngle = Math.abs(r264.config.plotOptions.radialBar.endAngle - r264.config.plotOptions.radialBar.startAngle), s310.trackStartAngle = r264.config.plotOptions.radialBar.track.startAngle, s310.trackEndAngle = r264.config.plotOptions.radialBar.track.endAngle, s310.donutDataLabels = s310.w.config.plotOptions.radialBar.dataLabels, s310.radialDataLabels = s310.donutDataLabels, s310.trackStartAngle || (s310.trackStartAngle = s310.startAngle), s310.trackEndAngle || (s310.trackEndAngle = s310.endAngle), 360 === s310.endAngle && (s310.endAngle = 359.99), s310.margin = parseInt(r264.config.plotOptions.radialBar.track.margin, 10), s310;
    }
    return r(i462, [
        {
            key: "draw",
            value: function(t768) {
                var e596 = this.w, i463 = new m(this.ctx), a379 = i463.group({
                    class: "apexcharts-radialbar"
                });
                if (e596.globals.noData) return a379;
                var s311 = i463.group(), r265 = this.defaultSize / 2, o232 = e596.globals.gridWidth / 2, n201 = this.defaultSize / 2.05;
                e596.config.chart.sparkline.enabled || (n201 = n201 - e596.config.stroke.width - e596.config.chart.dropShadow.blur);
                var l170 = e596.globals.fill.colors;
                if (e596.config.plotOptions.radialBar.track.show) {
                    var h147 = this.drawTracks({
                        size: n201,
                        centerX: o232,
                        centerY: r265,
                        colorArr: l170,
                        series: t768
                    });
                    s311.add(h147);
                }
                var c125 = this.drawArcs({
                    size: n201,
                    centerX: o232,
                    centerY: r265,
                    colorArr: l170,
                    series: t768
                }), d112 = 360;
                e596.config.plotOptions.radialBar.startAngle < 0 && (d112 = this.totalAngle);
                var g91 = (360 - d112) / 360;
                if (e596.globals.radialSize = n201 - n201 * g91, this.radialDataLabels.value.show) {
                    var u73 = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
                    e596.globals.radialSize += u73 * g91;
                }
                return s311.add(c125.g), "front" === e596.config.plotOptions.radialBar.hollow.position && (c125.g.add(c125.elHollow), c125.dataLabels && c125.g.add(c125.dataLabels)), a379.add(s311), a379;
            }
        },
        {
            key: "drawTracks",
            value: function(t769) {
                var e597 = this.w, i464 = new m(this.ctx), a380 = i464.group({
                    class: "apexcharts-tracks"
                }), s312 = new v(this.ctx), r266 = new T(this.ctx), o233 = this.getStrokeWidth(t769);
                t769.size = t769.size - o233 / 2;
                for(var n202 = 0; n202 < t769.series.length; n202++){
                    var l171 = i464.group({
                        class: "apexcharts-radialbar-track apexcharts-track"
                    });
                    a380.add(l171), l171.attr({
                        rel: n202 + 1
                    }), t769.size = t769.size - o233 - this.margin;
                    var h148 = e597.config.plotOptions.radialBar.track, c126 = r266.fillPath({
                        seriesNumber: 0,
                        size: t769.size,
                        fillColors: Array.isArray(h148.background) ? h148.background[n202] : h148.background,
                        solid: !0
                    }), d113 = this.trackStartAngle, g92 = this.trackEndAngle;
                    Math.abs(g92) + Math.abs(d113) >= 360 && (g92 = 360 - Math.abs(this.startAngle) - .1);
                    var u74 = i464.drawPath({
                        d: "",
                        stroke: c126,
                        strokeWidth: o233 * parseInt(h148.strokeWidth, 10) / 100,
                        fill: "none",
                        strokeOpacity: h148.opacity,
                        classes: "apexcharts-radialbar-area"
                    });
                    if (h148.dropShadow.enabled) {
                        var p62 = h148.dropShadow;
                        s312.dropShadow(u74, p62);
                    }
                    l171.add(u74), u74.attr("id", "apexcharts-radialbarTrack-" + n202), this.animatePaths(u74, {
                        centerX: t769.centerX,
                        centerY: t769.centerY,
                        endAngle: g92,
                        startAngle: d113,
                        size: t769.size,
                        i: n202,
                        totalItems: 2,
                        animBeginArr: 0,
                        dur: 0,
                        isTrack: !0,
                        easing: e597.globals.easing
                    });
                }
                return a380;
            }
        },
        {
            key: "drawArcs",
            value: function(t770) {
                var e598 = this.w, i465 = new m(this.ctx), a381 = new T(this.ctx), s313 = new v(this.ctx), r267 = i465.group(), o234 = this.getStrokeWidth(t770);
                t770.size = t770.size - o234 / 2;
                var n203 = e598.config.plotOptions.radialBar.hollow.background, l172 = t770.size - o234 * t770.series.length - this.margin * t770.series.length - o234 * parseInt(e598.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, h149 = l172 - e598.config.plotOptions.radialBar.hollow.margin;
                void 0 !== e598.config.plotOptions.radialBar.hollow.image && (n203 = this.drawHollowImage(t770, r267, l172, n203));
                var c127 = this.drawHollow({
                    size: h149,
                    centerX: t770.centerX,
                    centerY: t770.centerY,
                    fill: n203 || "transparent"
                });
                if (e598.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
                    var d114 = e598.config.plotOptions.radialBar.hollow.dropShadow;
                    s313.dropShadow(c127, d114);
                }
                var g93 = 1;
                !this.radialDataLabels.total.show && e598.globals.series.length > 1 && (g93 = 0);
                var u75 = null;
                this.radialDataLabels.show && (u75 = this.renderInnerDataLabels(this.radialDataLabels, {
                    hollowSize: l172,
                    centerX: t770.centerX,
                    centerY: t770.centerY,
                    opacity: g93
                })), "back" === e598.config.plotOptions.radialBar.hollow.position && (r267.add(c127), u75 && r267.add(u75));
                var p63 = !1;
                e598.config.plotOptions.radialBar.inverseOrder && (p63 = !0);
                for(var f58 = p63 ? t770.series.length - 1 : 0; p63 ? f58 >= 0 : f58 < t770.series.length; p63 ? f58-- : f58++){
                    var b47 = i465.group({
                        class: "apexcharts-series apexcharts-radial-series",
                        seriesName: x.escapeString(e598.globals.seriesNames[f58])
                    });
                    r267.add(b47), b47.attr({
                        rel: f58 + 1,
                        "data:realIndex": f58
                    }), this.ctx.series.addCollapsedClassToSeries(b47, f58), t770.size = t770.size - o234 - this.margin;
                    var y36 = a381.fillPath({
                        seriesNumber: f58,
                        size: t770.size,
                        value: t770.series[f58]
                    }), w30 = this.startAngle, k28 = void 0, A22 = x.negToZero(t770.series[f58] > 100 ? 100 : t770.series[f58]) / 100, S15 = Math.round(this.totalAngle * A22) + this.startAngle, C14 = void 0;
                    e598.globals.dataChanged && (k28 = this.startAngle, C14 = Math.round(this.totalAngle * x.negToZero(e598.globals.previousPaths[f58]) / 100) + k28), Math.abs(S15) + Math.abs(w30) >= 360 && (S15 -= .01), Math.abs(C14) + Math.abs(k28) >= 360 && (C14 -= .01);
                    var L13 = S15 - w30, P12 = Array.isArray(e598.config.stroke.dashArray) ? e598.config.stroke.dashArray[f58] : e598.config.stroke.dashArray, M10 = i465.drawPath({
                        d: "",
                        stroke: y36,
                        strokeWidth: o234,
                        fill: "none",
                        fillOpacity: e598.config.fill.opacity,
                        classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + f58,
                        strokeDashArray: P12
                    });
                    if (m.setAttrs(M10.node, {
                        "data:angle": L13,
                        "data:value": t770.series[f58]
                    }), e598.config.chart.dropShadow.enabled) {
                        var I7 = e598.config.chart.dropShadow;
                        s313.dropShadow(M10, I7, f58);
                    }
                    s313.setSelectionFilter(M10, 0, f58), this.addListeners(M10, this.radialDataLabels), b47.add(M10), M10.attr({
                        index: 0,
                        j: f58
                    });
                    var z5 = 0;
                    !this.initialAnim || e598.globals.resized || e598.globals.dataChanged || (z5 = e598.config.chart.animations.speed), e598.globals.dataChanged && (z5 = e598.config.chart.animations.dynamicAnimation.speed), this.animDur = z5 / (1.2 * t770.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(M10, {
                        centerX: t770.centerX,
                        centerY: t770.centerY,
                        endAngle: S15,
                        startAngle: w30,
                        prevEndAngle: C14,
                        prevStartAngle: k28,
                        size: t770.size,
                        i: f58,
                        totalItems: 2,
                        animBeginArr: this.animBeginArr,
                        dur: z5,
                        shouldSetPrevPaths: !0,
                        easing: e598.globals.easing
                    });
                }
                return {
                    g: r267,
                    elHollow: c127,
                    dataLabels: u75
                };
            }
        },
        {
            key: "drawHollow",
            value: function(t771) {
                var e599 = new m(this.ctx).drawCircle(2 * t771.size);
                return e599.attr({
                    class: "apexcharts-radialbar-hollow",
                    cx: t771.centerX,
                    cy: t771.centerY,
                    r: t771.size,
                    fill: t771.fill
                }), e599;
            }
        },
        {
            key: "drawHollowImage",
            value: function(t772, e600, i466, a382) {
                var s314 = this.w, r268 = new T(this.ctx), o235 = x.randomId(), n204 = s314.config.plotOptions.radialBar.hollow.image;
                if (s314.config.plotOptions.radialBar.hollow.imageClipped) r268.clippedImgArea({
                    width: i466,
                    height: i466,
                    image: n204,
                    patternID: "pattern".concat(s314.globals.cuid).concat(o235)
                }), a382 = "url(#pattern".concat(s314.globals.cuid).concat(o235, ")");
                else {
                    var l173 = s314.config.plotOptions.radialBar.hollow.imageWidth, h150 = s314.config.plotOptions.radialBar.hollow.imageHeight;
                    if (void 0 === l173 && void 0 === h150) {
                        var c128 = s314.globals.dom.Paper.image(n204).loaded(function(e601) {
                            this.move(t772.centerX - e601.width / 2 + s314.config.plotOptions.radialBar.hollow.imageOffsetX, t772.centerY - e601.height / 2 + s314.config.plotOptions.radialBar.hollow.imageOffsetY);
                        });
                        e600.add(c128);
                    } else {
                        var d115 = s314.globals.dom.Paper.image(n204).loaded(function(e) {
                            this.move(t772.centerX - l173 / 2 + s314.config.plotOptions.radialBar.hollow.imageOffsetX, t772.centerY - h150 / 2 + s314.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l173, h150);
                        });
                        e600.add(d115);
                    }
                }
                return a382;
            }
        },
        {
            key: "getStrokeWidth",
            value: function(t773) {
                var e602 = this.w;
                return t773.size * (100 - parseInt(e602.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t773.series.length + 1) - this.margin;
            }
        }
    ]), i462;
}(), Tt = function() {
    function t774(e603) {
        a(this, t774), this.w = e603.w, this.lineCtx = e603;
    }
    return r(t774, [
        {
            key: "sameValueSeriesFix",
            value: function(t775, e604) {
                var i467 = this.w;
                if ("line" === i467.config.chart.type && ("gradient" === i467.config.fill.type || "gradient" === i467.config.fill.type[t775]) && new y(this.lineCtx.ctx, i467).seriesHaveSameValues(t775)) {
                    var a383 = e604[t775].slice();
                    a383[a383.length - 1] = a383[a383.length - 1] + 1e-6, e604[t775] = a383;
                }
                return e604;
            }
        },
        {
            key: "calculatePoints",
            value: function(t776) {
                var e605 = t776.series, i468 = t776.realIndex, a384 = t776.x, s315 = t776.y, r269 = t776.i, o236 = t776.j, n205 = t776.prevY, l174 = this.w, h151 = [], c129 = [];
                if (0 === o236) {
                    var d116 = this.lineCtx.categoryAxisCorrection + l174.config.markers.offsetX;
                    l174.globals.isXNumeric && (d116 = (l174.globals.seriesX[i468][0] - l174.globals.minX) / this.lineCtx.xRatio + l174.config.markers.offsetX), h151.push(d116), c129.push(x.isNumber(e605[r269][0]) ? n205 + l174.config.markers.offsetY : null), h151.push(a384 + l174.config.markers.offsetX), c129.push(x.isNumber(e605[r269][o236 + 1]) ? s315 + l174.config.markers.offsetY : null);
                } else h151.push(a384 + l174.config.markers.offsetX), c129.push(x.isNumber(e605[r269][o236 + 1]) ? s315 + l174.config.markers.offsetY : null);
                return {
                    x: h151,
                    y: c129
                };
            }
        },
        {
            key: "checkPreviousPaths",
            value: function(t777) {
                for(var e606 = t777.pathFromLine, i469 = t777.pathFromArea, a385 = t777.realIndex, s316 = this.w, r270 = 0; r270 < s316.globals.previousPaths.length; r270++){
                    var o237 = s316.globals.previousPaths[r270];
                    ("line" === o237.type || "area" === o237.type) && o237.paths.length > 0 && parseInt(o237.realIndex, 10) === parseInt(a385, 10) && ("line" === o237.type ? (this.lineCtx.appendPathFrom = !1, e606 = s316.globals.previousPaths[r270].paths[0].d) : "area" === o237.type && (this.lineCtx.appendPathFrom = !1, i469 = s316.globals.previousPaths[r270].paths[0].d, s316.config.stroke.show && s316.globals.previousPaths[r270].paths[1] && (e606 = s316.globals.previousPaths[r270].paths[1].d)));
                }
                return {
                    pathFromLine: e606,
                    pathFromArea: i469
                };
            }
        },
        {
            key: "determineFirstPrevY",
            value: function(t778) {
                var e607 = t778.i, i470 = t778.series, a386 = t778.prevY, s317 = t778.lineYPosition, r271 = this.w;
                if (void 0 !== i470[e607][0]) a386 = (s317 = r271.config.chart.stacked && e607 > 0 ? this.lineCtx.prevSeriesY[e607 - 1][0] : this.lineCtx.zeroY) - i470[e607][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? i470[e607][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0);
                else if (r271.config.chart.stacked && e607 > 0 && void 0 === i470[e607][0]) {
                    for(var o238 = e607 - 1; o238 >= 0; o238--)if (null !== i470[o238][0] && void 0 !== i470[o238][0]) {
                        a386 = s317 = this.lineCtx.prevSeriesY[o238][0];
                        break;
                    }
                }
                return {
                    prevY: a386,
                    lineYPosition: s317
                };
            }
        }
    ]), t774;
}(), Mt = function() {
    function t779(e608, i471, s318) {
        a(this, t779), this.ctx = e608, this.w = e608.w, this.xyRatios = i471, this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || s318, this.scatter = new I(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new Tt(this), this.markers = new M(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
    }
    return r(t779, [
        {
            key: "draw",
            value: function(t780, e609, i472) {
                var a387 = this.w, s319 = new m(this.ctx), r272 = a387.globals.comboCharts ? e609 : a387.config.chart.type, o239 = s319.group({
                    class: "apexcharts-".concat(r272, "-series apexcharts-plot-series")
                }), n206 = new y(this.ctx, a387);
                this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t780 = n206.getLogSeries(t780), this.yRatio = n206.getLogYRatios(this.yRatio);
                for(var l175 = [], h152 = 0; h152 < t780.length; h152++){
                    t780 = this.lineHelpers.sameValueSeriesFix(h152, t780);
                    var c130 = a387.globals.comboCharts ? i472[h152] : h152;
                    this._initSerieVariables(t780, h152, c130);
                    var d117 = [], g94 = [], u76 = a387.globals.padHorizontal + this.categoryAxisCorrection;
                    this.ctx.series.addCollapsedClassToSeries(this.elSeries, c130), a387.globals.isXNumeric && a387.globals.seriesX.length > 0 && (u76 = (a387.globals.seriesX[c130][0] - a387.globals.minX) / this.xRatio), g94.push(u76);
                    var p64, f59 = u76, x37 = f59, b48 = this.zeroY;
                    b48 = this.lineHelpers.determineFirstPrevY({
                        i: h152,
                        series: t780,
                        prevY: b48,
                        lineYPosition: 0
                    }).prevY, d117.push(b48), p64 = b48;
                    var v34 = this._calculatePathsFrom({
                        series: t780,
                        i: h152,
                        realIndex: c130,
                        prevX: x37,
                        prevY: b48
                    }), w31 = this._iterateOverDataPoints({
                        series: t780,
                        realIndex: c130,
                        i: h152,
                        x: u76,
                        y: 1,
                        pX: f59,
                        pY: p64,
                        pathsFrom: v34,
                        linePaths: [],
                        areaPaths: [],
                        seriesIndex: i472,
                        lineYPosition: 0,
                        xArrj: g94,
                        yArrj: d117
                    });
                    this._handlePaths({
                        type: r272,
                        realIndex: c130,
                        i: h152,
                        paths: w31
                    }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), l175.push(this.elSeries);
                }
                if (a387.config.chart.stacked) for(var k29 = l175.length; k29 > 0; k29--)o239.add(l175[k29 - 1]);
                else for(var A23 = 0; A23 < l175.length; A23++)o239.add(l175[A23]);
                return o239;
            }
        },
        {
            key: "_initSerieVariables",
            value: function(t781, e610, i473) {
                var a388 = this.w, s320 = new m(this.ctx);
                this.xDivision = a388.globals.gridWidth / (a388.globals.dataPoints - ("on" === a388.config.xaxis.tickPlacement ? 1 : 0)), this.strokeWidth = Array.isArray(a388.config.stroke.width) ? a388.config.stroke.width[i473] : a388.config.stroke.width, this.yRatio.length > 1 && (this.yaxisIndex = i473), this.isReversed = a388.config.yaxis[this.yaxisIndex] && a388.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a388.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? a388.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), this.areaBottomY = this.zeroY, (this.zeroY > a388.globals.gridHeight || "end" === a388.config.plotOptions.area.fillTo) && (this.areaBottomY = a388.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s320.group({
                    class: "apexcharts-series",
                    seriesName: x.escapeString(a388.globals.seriesNames[i473])
                }), this.elPointsMain = s320.group({
                    class: "apexcharts-series-markers-wrap",
                    "data:realIndex": i473
                }), this.elDataLabelsWrap = s320.group({
                    class: "apexcharts-datalabels",
                    "data:realIndex": i473
                });
                var r273 = t781[e610].length === a388.globals.dataPoints;
                this.elSeries.attr({
                    "data:longestSeries": r273,
                    rel: e610 + 1,
                    "data:realIndex": i473
                }), this.appendPathFrom = !0;
            }
        },
        {
            key: "_calculatePathsFrom",
            value: function(t782) {
                var e611, i474, a389, s321, r274 = t782.series, o240 = t782.i, n207 = t782.realIndex, l176 = t782.prevX, h153 = t782.prevY, c131 = this.w, d118 = new m(this.ctx);
                if (null === r274[o240][0]) {
                    for(var g95 = 0; g95 < r274[o240].length; g95++)if (null !== r274[o240][g95]) {
                        l176 = this.xDivision * g95, h153 = this.zeroY - r274[o240][g95] / this.yRatio[this.yaxisIndex], e611 = d118.move(l176, h153), i474 = d118.move(l176, this.areaBottomY);
                        break;
                    }
                } else e611 = d118.move(l176, h153), i474 = d118.move(l176, this.areaBottomY) + d118.line(l176, h153);
                if (a389 = d118.move(-1, this.zeroY) + d118.line(-1, this.zeroY), s321 = d118.move(-1, this.zeroY) + d118.line(-1, this.zeroY), c131.globals.previousPaths.length > 0) {
                    var u77 = this.lineHelpers.checkPreviousPaths({
                        pathFromLine: a389,
                        pathFromArea: s321,
                        realIndex: n207
                    });
                    a389 = u77.pathFromLine, s321 = u77.pathFromArea;
                }
                return {
                    prevX: l176,
                    prevY: h153,
                    linePath: e611,
                    areaPath: i474,
                    pathFromLine: a389,
                    pathFromArea: s321
                };
            }
        },
        {
            key: "_handlePaths",
            value: function(t783) {
                var i475 = t783.type, a390 = t783.realIndex, s322 = t783.i, r275 = t783.paths, o241 = this.w, n208 = new m(this.ctx), l177 = new T(this.ctx);
                this.prevSeriesY.push(r275.yArrj), o241.globals.seriesXvalues[a390] = r275.xArrj, o241.globals.seriesYvalues[a390] = r275.yArrj;
                var h154 = o241.config.forecastDataPoints;
                if (h154.count > 0) {
                    var c132 = o241.globals.seriesXvalues[a390][o241.globals.seriesXvalues[a390].length - h154.count - 1], d119 = n208.drawRect(c132, 0, o241.globals.gridWidth, o241.globals.gridHeight, 0);
                    o241.globals.dom.elForecastMask.appendChild(d119.node);
                    var g96 = n208.drawRect(0, 0, c132, o241.globals.gridHeight, 0);
                    o241.globals.dom.elNonForecastMask.appendChild(g96.node);
                }
                this.pointsChart || o241.globals.delayedElements.push({
                    el: this.elPointsMain.node,
                    index: a390
                });
                var u78 = {
                    i: s322,
                    realIndex: a390,
                    animationDelay: s322,
                    initialSpeed: o241.config.chart.animations.speed,
                    dataChangeSpeed: o241.config.chart.animations.dynamicAnimation.speed,
                    className: "apexcharts-".concat(i475)
                };
                if ("area" === i475) for(var p65 = l177.fillPath({
                    seriesNumber: a390
                }), f60 = 0; f60 < r275.areaPaths.length; f60++){
                    var x38 = n208.renderPaths(e(e({}, u78), {}, {
                        pathFrom: r275.pathFromArea,
                        pathTo: r275.areaPaths[f60],
                        stroke: "none",
                        strokeWidth: 0,
                        strokeLineCap: null,
                        fill: p65
                    }));
                    this.elSeries.add(x38);
                }
                if (o241.config.stroke.show && !this.pointsChart) {
                    var b49 = null;
                    b49 = "line" === i475 ? l177.fillPath({
                        seriesNumber: a390,
                        i: s322
                    }) : o241.globals.stroke.colors[a390];
                    for(var v35 = 0; v35 < r275.linePaths.length; v35++){
                        var y37 = e(e({}, u78), {}, {
                            pathFrom: r275.pathFromLine,
                            pathTo: r275.linePaths[v35],
                            stroke: b49,
                            strokeWidth: this.strokeWidth,
                            strokeLineCap: o241.config.stroke.lineCap,
                            fill: "none"
                        }), w32 = n208.renderPaths(y37);
                        if (this.elSeries.add(w32), h154.count > 0) {
                            var k30 = n208.renderPaths(y37);
                            k30.node.setAttribute("stroke-dasharray", h154.dashArray), h154.strokeWidth && k30.node.setAttribute("stroke-width", h154.strokeWidth), this.elSeries.add(k30), k30.attr("clip-path", "url(#forecastMask".concat(o241.globals.cuid, ")")), w32.attr("clip-path", "url(#nonForecastMask".concat(o241.globals.cuid, ")"));
                        }
                    }
                }
            }
        },
        {
            key: "_iterateOverDataPoints",
            value: function(t784) {
                for(var e612 = t784.series, i476 = t784.realIndex, a391 = t784.i, s323 = t784.x, r276 = t784.y, o242 = t784.pX, n209 = t784.pY, l178 = t784.pathsFrom, h155 = t784.linePaths, c133 = t784.areaPaths, d120 = t784.seriesIndex, g97 = t784.lineYPosition, u79 = t784.xArrj, p66 = t784.yArrj, f61 = this.w, b50 = new m(this.ctx), v36 = this.yRatio, y38 = l178.prevY, w33 = l178.linePath, k31 = l178.areaPath, A24 = l178.pathFromLine, S16 = l178.pathFromArea, C15 = x.isNumber(f61.globals.minYArr[i476]) ? f61.globals.minYArr[i476] : f61.globals.minY, L14 = f61.globals.dataPoints > 1 ? f61.globals.dataPoints - 1 : f61.globals.dataPoints, P13 = 0; P13 < L14; P13++){
                    var T8 = void 0 === e612[a391][P13 + 1] || null === e612[a391][P13 + 1];
                    if (f61.globals.isXNumeric) {
                        var M11 = f61.globals.seriesX[i476][P13 + 1];
                        void 0 === f61.globals.seriesX[i476][P13 + 1] && (M11 = f61.globals.seriesX[i476][L14 - 1]), s323 = (M11 - f61.globals.minX) / this.xRatio;
                    } else s323 += this.xDivision;
                    if (f61.config.chart.stacked) {
                        if (a391 > 0 && f61.globals.collapsedSeries.length < f61.config.series.length - 1) g97 = this.prevSeriesY[function(t785) {
                            for(var e613 = t785, i477 = 0; i477 < f61.globals.series.length; i477++)if (f61.globals.collapsedSeriesIndices.indexOf(t785) > -1) {
                                e613--;
                                break;
                            }
                            return e613 >= 0 ? e613 : 0;
                        }(a391 - 1)][P13 + 1];
                        else g97 = this.zeroY;
                    } else g97 = this.zeroY;
                    r276 = T8 ? g97 - C15 / v36[this.yaxisIndex] + 2 * (this.isReversed ? C15 / v36[this.yaxisIndex] : 0) : g97 - e612[a391][P13 + 1] / v36[this.yaxisIndex] + 2 * (this.isReversed ? e612[a391][P13 + 1] / v36[this.yaxisIndex] : 0), u79.push(s323), p66.push(r276);
                    var I8 = this.lineHelpers.calculatePoints({
                        series: e612,
                        x: s323,
                        y: r276,
                        realIndex: i476,
                        i: a391,
                        j: P13,
                        prevY: y38
                    }), z6 = this._createPaths({
                        series: e612,
                        i: a391,
                        realIndex: i476,
                        j: P13,
                        x: s323,
                        y: r276,
                        pX: o242,
                        pY: n209,
                        linePath: w33,
                        areaPath: k31,
                        linePaths: h155,
                        areaPaths: c133,
                        seriesIndex: d120
                    });
                    c133 = z6.areaPaths, h155 = z6.linePaths, o242 = z6.pX, n209 = z6.pY, k31 = z6.areaPath, w33 = z6.linePath, this.appendPathFrom && (A24 += b50.line(s323, this.zeroY), S16 += b50.line(s323, this.zeroY)), this.handleNullDataPoints(e612, I8, a391, P13, i476), this._handleMarkersAndLabels({
                        pointsPos: I8,
                        series: e612,
                        x: s323,
                        y: r276,
                        prevY: y38,
                        i: a391,
                        j: P13,
                        realIndex: i476
                    });
                }
                return {
                    yArrj: p66,
                    xArrj: u79,
                    pathFromArea: S16,
                    areaPaths: c133,
                    pathFromLine: A24,
                    linePaths: h155
                };
            }
        },
        {
            key: "_handleMarkersAndLabels",
            value: function(t786) {
                var e614 = t786.pointsPos;
                t786.series, t786.x, t786.y, t786.prevY;
                var i478 = t786.i, a392 = t786.j, s324 = t786.realIndex, r277 = this.w, o243 = new z(this.ctx);
                if (this.pointsChart) this.scatter.draw(this.elSeries, a392, {
                    realIndex: s324,
                    pointsPos: e614,
                    zRatio: this.zRatio,
                    elParent: this.elPointsMain
                });
                else {
                    r277.globals.series[i478].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
                    var n210 = this.markers.plotChartMarkers(e614, s324, a392 + 1);
                    null !== n210 && this.elPointsMain.add(n210);
                }
                var l179 = o243.drawDataLabel(e614, s324, a392 + 1, null);
                null !== l179 && this.elDataLabelsWrap.add(l179);
            }
        },
        {
            key: "_createPaths",
            value: function(t787) {
                var e615 = t787.series, i479 = t787.i, a393 = t787.realIndex, s325 = t787.j, r278 = t787.x, o244 = t787.y, n211 = t787.pX, l180 = t787.pY, h156 = t787.linePath, c134 = t787.areaPath, d121 = t787.linePaths, g98 = t787.areaPaths, u80 = t787.seriesIndex, p67 = this.w, f62 = new m(this.ctx), x39 = p67.config.stroke.curve, b51 = this.areaBottomY;
                if (Array.isArray(p67.config.stroke.curve) && (x39 = Array.isArray(u80) ? p67.config.stroke.curve[u80[i479]] : p67.config.stroke.curve[i479]), "smooth" === x39) {
                    var v37 = .35 * (r278 - n211);
                    p67.globals.hasNullValues ? (null !== e615[i479][s325] && (null !== e615[i479][s325 + 1] ? (h156 = f62.move(n211, l180) + f62.curve(n211 + v37, l180, r278 - v37, o244, r278 + 1, o244), c134 = f62.move(n211 + 1, l180) + f62.curve(n211 + v37, l180, r278 - v37, o244, r278 + 1, o244) + f62.line(r278, b51) + f62.line(n211, b51) + "z") : (h156 = f62.move(n211, l180), c134 = f62.move(n211, l180) + "z")), d121.push(h156), g98.push(c134)) : (h156 += f62.curve(n211 + v37, l180, r278 - v37, o244, r278, o244), c134 += f62.curve(n211 + v37, l180, r278 - v37, o244, r278, o244)), n211 = r278, l180 = o244, s325 === e615[i479].length - 2 && (c134 = c134 + f62.curve(n211, l180, r278, o244, r278, b51) + f62.move(r278, o244) + "z", p67.globals.hasNullValues || (d121.push(h156), g98.push(c134)));
                } else {
                    if (null === e615[i479][s325 + 1]) {
                        h156 += f62.move(r278, o244);
                        var y39 = p67.globals.isXNumeric ? (p67.globals.seriesX[a393][s325] - p67.globals.minX) / this.xRatio : r278 - this.xDivision;
                        c134 = c134 + f62.line(y39, b51) + f62.move(r278, o244) + "z";
                    }
                    null === e615[i479][s325] && (h156 += f62.move(r278, o244), c134 += f62.move(r278, b51)), "stepline" === x39 ? (h156 = h156 + f62.line(r278, null, "H") + f62.line(null, o244, "V"), c134 = c134 + f62.line(r278, null, "H") + f62.line(null, o244, "V")) : "straight" === x39 && (h156 += f62.line(r278, o244), c134 += f62.line(r278, o244)), s325 === e615[i479].length - 2 && (c134 = c134 + f62.line(r278, b51) + f62.move(r278, o244) + "z", d121.push(h156), g98.push(c134));
                }
                return {
                    linePaths: d121,
                    areaPaths: g98,
                    pX: n211,
                    pY: l180,
                    linePath: h156,
                    areaPath: c134
                };
            }
        },
        {
            key: "handleNullDataPoints",
            value: function(t788, e616, i480, a394, s326) {
                var r279 = this.w;
                if (null === t788[i480][a394] && r279.config.markers.showNullDataPoints || 1 === t788[i480].length) {
                    var o245 = this.markers.plotChartMarkers(e616, s326, a394 + 1, this.strokeWidth - r279.config.markers.strokeWidth / 2, !0);
                    null !== o245 && this.elPointsMain.add(o245);
                }
            }
        }
    ]), t779;
}();
window.TreemapSquared = {}, window.TreemapSquared.generate = function() {
    function t789(e618, i482, a396, s328) {
        this.xoffset = e618, this.yoffset = i482, this.height = s328, this.width = a396, this.shortestEdge = function() {
            return Math.min(this.height, this.width);
        }, this.getCoordinates = function(t790) {
            var e619, i483 = [], a397 = this.xoffset, s329 = this.yoffset, o247 = r280(t790) / this.height, n212 = r280(t790) / this.width;
            if (this.width >= this.height) for(e619 = 0; e619 < t790.length; e619++)i483.push([
                a397,
                s329,
                a397 + o247,
                s329 + t790[e619] / o247
            ]), s329 += t790[e619] / o247;
            else for(e619 = 0; e619 < t790.length; e619++)i483.push([
                a397,
                s329,
                a397 + t790[e619] / n212,
                s329 + n212
            ]), a397 += t790[e619] / n212;
            return i483;
        }, this.cutArea = function(e620) {
            var i484;
            if (this.width >= this.height) {
                var a398 = e620 / this.height, s330 = this.width - a398;
                i484 = new t789(this.xoffset + a398, this.yoffset, s330, this.height);
            } else {
                var r281 = e620 / this.width, o248 = this.height - r281;
                i484 = new t789(this.xoffset, this.yoffset + r281, this.width, o248);
            }
            return i484;
        };
    }
    function e617(e621, a399, s331, o249, n213) {
        return o249 = void 0 === o249 ? 0 : o249, n213 = void 0 === n213 ? 0 : n213, function(t791) {
            var e622, i485, a400 = [];
            for(e622 = 0; e622 < t791.length; e622++)for(i485 = 0; i485 < t791[e622].length; i485++)a400.push(t791[e622][i485]);
            return a400;
        }(i481(function(t792, e623) {
            var i486, a401 = [], s332 = e623 / r280(t792);
            for(i486 = 0; i486 < t792.length; i486++)a401[i486] = t792[i486] * s332;
            return a401;
        }(e621, a399 * s331), [], new t789(o249, n213, a399, s331), []));
    }
    function i481(t793, e624, s333, o250) {
        var n214, l181, h157;
        if (0 !== t793.length) return n214 = s333.shortestEdge(), function(t794, e625, i487) {
            var s334;
            if (0 === t794.length) return !0;
            (s334 = t794.slice()).push(e625);
            var r282 = a395(t794, i487), o251 = a395(s334, i487);
            return r282 >= o251;
        }(e624, l181 = t793[0], n214) ? (e624.push(l181), i481(t793.slice(1), e624, s333, o250)) : (h157 = s333.cutArea(r280(e624), o250), o250.push(s333.getCoordinates(e624)), i481(t793, [], h157, o250)), o250;
        o250.push(s333.getCoordinates(e624));
    }
    function a395(t795, e626) {
        var i488 = Math.min.apply(Math, t795), a402 = Math.max.apply(Math, t795), s335 = r280(t795);
        return Math.max(Math.pow(e626, 2) * a402 / Math.pow(s335, 2), Math.pow(s335, 2) / (Math.pow(e626, 2) * i488));
    }
    function s327(t796) {
        return t796 && t796.constructor === Array;
    }
    function r280(t797) {
        var e627, i489 = 0;
        for(e627 = 0; e627 < t797.length; e627++)i489 += t797[e627];
        return i489;
    }
    function o246(t798) {
        var e628, i490 = 0;
        if (s327(t798[0])) for(e628 = 0; e628 < t798.length; e628++)i490 += o246(t798[e628]);
        else i490 = r280(t798);
        return i490;
    }
    return function t799(i491, a403, r283, n215, l182) {
        n215 = void 0 === n215 ? 0 : n215, l182 = void 0 === l182 ? 0 : l182;
        var h158, c135, d122 = [], g99 = [];
        if (s327(i491[0])) {
            for(c135 = 0; c135 < i491.length; c135++)d122[c135] = o246(i491[c135]);
            for(h158 = e617(d122, a403, r283, n215, l182), c135 = 0; c135 < i491.length; c135++)g99.push(t799(i491[c135], h158[c135][2] - h158[c135][0], h158[c135][3] - h158[c135][1], h158[c135][0], h158[c135][1]));
        } else g99 = e617(i491, a403, r283, n215, l182);
        return g99;
    };
}();
var It, zt, Xt = function() {
    function t800(e629, i) {
        a(this, t800), this.ctx = e629, this.w = e629.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new kt(e629), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
    }
    return r(t800, [
        {
            key: "draw",
            value: function(t801) {
                var e630 = this, i492 = this.w, a404 = new m(this.ctx), s336 = new T(this.ctx), r284 = a404.group({
                    class: "apexcharts-treemap"
                });
                if (i492.globals.noData) return r284;
                var o252 = [];
                return t801.forEach(function(t802) {
                    var e631 = t802.map(function(t803) {
                        return Math.abs(t803);
                    });
                    o252.push(e631);
                }), this.negRange = this.helpers.checkColorRange(), i492.config.series.forEach(function(t804, i493) {
                    t804.data.forEach(function(t805) {
                        Array.isArray(e630.labels[i493]) || (e630.labels[i493] = []), e630.labels[i493].push(t805.x);
                    });
                }), window.TreemapSquared.generate(o252, i492.globals.gridWidth, i492.globals.gridHeight).forEach(function(o253, n216) {
                    var l183 = a404.group({
                        class: "apexcharts-series apexcharts-treemap-series",
                        seriesName: x.escapeString(i492.globals.seriesNames[n216]),
                        rel: n216 + 1,
                        "data:realIndex": n216
                    });
                    if (i492.config.chart.dropShadow.enabled) {
                        var h159 = i492.config.chart.dropShadow;
                        new v(e630.ctx).dropShadow(r284, h159, n216);
                    }
                    var c136 = a404.group({
                        class: "apexcharts-data-labels"
                    });
                    o253.forEach(function(r285, o254) {
                        var h160 = r285[0], c137 = r285[1], d123 = r285[2], g100 = r285[3], u81 = a404.drawRect(h160, c137, d123 - h160, g100 - c137, 0, "#fff", 1, e630.strokeWidth, i492.config.plotOptions.treemap.useFillColorAsStroke ? f63 : i492.globals.stroke.colors[n216]);
                        u81.attr({
                            cx: h160,
                            cy: c137,
                            index: n216,
                            i: n216,
                            j: o254,
                            width: d123 - h160,
                            height: g100 - c137
                        });
                        var p68 = e630.helpers.getShadeColor(i492.config.chart.type, n216, o254, e630.negRange), f63 = p68.color;
                        void 0 !== i492.config.series[n216].data[o254] && i492.config.series[n216].data[o254].fillColor && (f63 = i492.config.series[n216].data[o254].fillColor);
                        var x40 = s336.fillPath({
                            color: f63,
                            seriesNumber: n216,
                            dataPointIndex: o254
                        });
                        u81.node.classList.add("apexcharts-treemap-rect"), u81.attr({
                            fill: x40
                        }), e630.helpers.addListeners(u81);
                        var b52 = {
                            x: h160 + (d123 - h160) / 2,
                            y: c137 + (g100 - c137) / 2,
                            width: 0,
                            height: 0
                        }, v38 = {
                            x: h160,
                            y: c137,
                            width: d123 - h160,
                            height: g100 - c137
                        };
                        if (i492.config.chart.animations.enabled && !i492.globals.dataChanged) {
                            var m17 = 1;
                            i492.globals.resized || (m17 = i492.config.chart.animations.speed), e630.animateTreemap(u81, b52, v38, m17);
                        }
                        if (i492.globals.dataChanged) {
                            var y40 = 1;
                            e630.dynamicAnim.enabled && i492.globals.shouldAnimate && (y40 = e630.dynamicAnim.speed, i492.globals.previousPaths[n216] && i492.globals.previousPaths[n216][o254] && i492.globals.previousPaths[n216][o254].rect && (b52 = i492.globals.previousPaths[n216][o254].rect), e630.animateTreemap(u81, b52, v38, y40));
                        }
                        var w34 = e630.getFontSize(r285), k32 = i492.config.dataLabels.formatter(e630.labels[n216][o254], {
                            value: i492.globals.series[n216][o254],
                            seriesIndex: n216,
                            dataPointIndex: o254,
                            w: i492
                        }), A25 = e630.helpers.calculateDataLabels({
                            text: k32,
                            x: (h160 + d123) / 2,
                            y: (c137 + g100) / 2 + e630.strokeWidth / 2 + w34 / 3,
                            i: n216,
                            j: o254,
                            colorProps: p68,
                            fontSize: w34,
                            series: t801
                        });
                        i492.config.dataLabels.enabled && A25 && e630.rotateToFitLabel(A25, k32, h160, c137, d123, g100), l183.add(u81), null !== A25 && l183.add(A25);
                    }), l183.add(c136), r284.add(l183);
                }), r284;
            }
        },
        {
            key: "getFontSize",
            value: function(t806) {
                var e632 = this.w;
                var i494, a405, s337, r286, o255 = function t807(e633) {
                    var i495, a406 = 0;
                    if (Array.isArray(e633[0])) for(i495 = 0; i495 < e633.length; i495++)a406 += t807(e633[i495]);
                    else for(i495 = 0; i495 < e633.length; i495++)a406 += e633[i495].length;
                    return a406;
                }(this.labels) / function t808(e634) {
                    var i496, a407 = 0;
                    if (Array.isArray(e634[0])) for(i496 = 0; i496 < e634.length; i496++)a407 += t808(e634[i496]);
                    else for(i496 = 0; i496 < e634.length; i496++)a407 += 1;
                    return a407;
                }(this.labels);
                return i494 = t806[2] - t806[0], a405 = t806[3] - t806[1], s337 = i494 * a405, r286 = Math.pow(s337, .5), Math.min(r286 / o255, parseInt(e632.config.dataLabels.style.fontSize, 10));
            }
        },
        {
            key: "rotateToFitLabel",
            value: function(t809, e635, i497, a408, s338, r287) {
                var o256 = new m(this.ctx), n217 = o256.getTextRects(e635);
                if (n217.width + 5 > s338 - i497 && n217.width <= r287 - a408) {
                    var l184 = o256.rotateAroundCenter(t809.node);
                    t809.node.setAttribute("transform", "rotate(-90 ".concat(l184.x, " ").concat(l184.y, ")"));
                }
            }
        },
        {
            key: "animateTreemap",
            value: function(t810, e636, i498, a409) {
                var s339 = new b(this.ctx);
                s339.animateRect(t810, {
                    x: e636.x,
                    y: e636.y,
                    width: e636.width,
                    height: e636.height
                }, {
                    x: i498.x,
                    y: i498.y,
                    width: i498.width,
                    height: i498.height
                }, a409, function() {
                    s339.animationCompleted(t810);
                });
            }
        }
    ]), t800;
}(), Et = function() {
    function t811(e637) {
        a(this, t811), this.ctx = e637, this.w = e637.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
    }
    return r(t811, [
        {
            key: "calculateTimeScaleTicks",
            value: function(t812, i499) {
                var a410 = this, s340 = this.w;
                if (s340.globals.allSeriesCollapsed) return s340.globals.labels = [], s340.globals.timescaleLabels = [], [];
                var r288 = new R(this.ctx), o257 = (i499 - t812) / 864e5;
                this.determineInterval(o257), s340.globals.disableZoomIn = !1, s340.globals.disableZoomOut = !1, o257 < .00011574074074074075 ? s340.globals.disableZoomIn = !0 : o257 > 5e4 && (s340.globals.disableZoomOut = !0);
                var n218 = r288.getTimeUnitsfromTimestamp(t812, i499, this.utc), l185 = s340.globals.gridWidth / o257, h161 = l185 / 24, c138 = h161 / 60, d124 = c138 / 60, g101 = Math.floor(24 * o257), u82 = Math.floor(1440 * o257), p69 = Math.floor(86400 * o257), f64 = Math.floor(o257), x41 = Math.floor(o257 / 30), b53 = Math.floor(o257 / 365), v39 = {
                    minMillisecond: n218.minMillisecond,
                    minSecond: n218.minSecond,
                    minMinute: n218.minMinute,
                    minHour: n218.minHour,
                    minDate: n218.minDate,
                    minMonth: n218.minMonth,
                    minYear: n218.minYear
                }, m18 = {
                    firstVal: v39,
                    currentMillisecond: v39.minMillisecond,
                    currentSecond: v39.minSecond,
                    currentMinute: v39.minMinute,
                    currentHour: v39.minHour,
                    currentMonthDate: v39.minDate,
                    currentDate: v39.minDate,
                    currentMonth: v39.minMonth,
                    currentYear: v39.minYear,
                    daysWidthOnXAxis: l185,
                    hoursWidthOnXAxis: h161,
                    minutesWidthOnXAxis: c138,
                    secondsWidthOnXAxis: d124,
                    numberOfSeconds: p69,
                    numberOfMinutes: u82,
                    numberOfHours: g101,
                    numberOfDays: f64,
                    numberOfMonths: x41,
                    numberOfYears: b53
                };
                switch(this.tickInterval){
                    case "years":
                        this.generateYearScale(m18);
                        break;
                    case "months":
                    case "half_year":
                        this.generateMonthScale(m18);
                        break;
                    case "months_days":
                    case "months_fortnight":
                    case "days":
                    case "week_days":
                        this.generateDayScale(m18);
                        break;
                    case "hours":
                        this.generateHourScale(m18);
                        break;
                    case "minutes_fives":
                    case "minutes":
                        this.generateMinuteScale(m18);
                        break;
                    case "seconds_tens":
                    case "seconds_fives":
                    case "seconds":
                        this.generateSecondScale(m18);
                }
                var y41 = this.timeScaleArray.map(function(t813) {
                    var i500 = {
                        position: t813.position,
                        unit: t813.unit,
                        year: t813.year,
                        day: t813.day ? t813.day : 1,
                        hour: t813.hour ? t813.hour : 0,
                        month: t813.month + 1
                    };
                    return "month" === t813.unit ? e(e({}, i500), {}, {
                        day: 1,
                        value: t813.value + 1
                    }) : "day" === t813.unit || "hour" === t813.unit ? e(e({}, i500), {}, {
                        value: t813.value
                    }) : "minute" === t813.unit ? e(e({}, i500), {}, {
                        value: t813.value,
                        minute: t813.value
                    }) : "second" === t813.unit ? e(e({}, i500), {}, {
                        value: t813.value,
                        minute: t813.minute,
                        second: t813.second
                    }) : t813;
                });
                return y41.filter(function(t814) {
                    var e638 = 1, i501 = Math.ceil(s340.globals.gridWidth / 120), r289 = t814.value;
                    void 0 !== s340.config.xaxis.tickAmount && (i501 = s340.config.xaxis.tickAmount), y41.length > i501 && (e638 = Math.floor(y41.length / i501));
                    var o258 = !1, n219 = !1;
                    switch(a410.tickInterval){
                        case "years":
                            "year" === t814.unit && (o258 = !0);
                            break;
                        case "half_year":
                            e638 = 7, "year" === t814.unit && (o258 = !0);
                            break;
                        case "months":
                            e638 = 1, "year" === t814.unit && (o258 = !0);
                            break;
                        case "months_fortnight":
                            e638 = 15, "year" !== t814.unit && "month" !== t814.unit || (o258 = !0), 30 === r289 && (n219 = !0);
                            break;
                        case "months_days":
                            e638 = 10, "month" === t814.unit && (o258 = !0), 30 === r289 && (n219 = !0);
                            break;
                        case "week_days":
                            e638 = 8, "month" === t814.unit && (o258 = !0);
                            break;
                        case "days":
                            e638 = 1, "month" === t814.unit && (o258 = !0);
                            break;
                        case "hours":
                            "day" === t814.unit && (o258 = !0);
                            break;
                        case "minutes_fives":
                            r289 % 5 != 0 && (n219 = !0);
                            break;
                        case "seconds_tens":
                            r289 % 10 != 0 && (n219 = !0);
                            break;
                        case "seconds_fives":
                            r289 % 5 != 0 && (n219 = !0);
                    }
                    if ("hours" === a410.tickInterval || "minutes_fives" === a410.tickInterval || "seconds_tens" === a410.tickInterval || "seconds_fives" === a410.tickInterval) {
                        if (!n219) return !0;
                    } else if ((r289 % e638 == 0 || o258) && !n219) return !0;
                });
            }
        },
        {
            key: "recalcDimensionsBasedOnFormat",
            value: function(t815, e) {
                var i502 = this.w, a411 = this.formatDates(t815), s341 = this.removeOverlappingTS(a411);
                i502.globals.timescaleLabels = s341.slice(), new lt(this.ctx).plotCoords();
            }
        },
        {
            key: "determineInterval",
            value: function(t816) {
                var e639 = 24 * t816, i503 = 60 * e639;
                switch(!0){
                    case t816 / 365 > 5:
                        this.tickInterval = "years";
                        break;
                    case t816 > 800:
                        this.tickInterval = "half_year";
                        break;
                    case t816 > 180:
                        this.tickInterval = "months";
                        break;
                    case t816 > 90:
                        this.tickInterval = "months_fortnight";
                        break;
                    case t816 > 60:
                        this.tickInterval = "months_days";
                        break;
                    case t816 > 30:
                        this.tickInterval = "week_days";
                        break;
                    case t816 > 2:
                        this.tickInterval = "days";
                        break;
                    case e639 > 2.4:
                        this.tickInterval = "hours";
                        break;
                    case i503 > 15:
                        this.tickInterval = "minutes_fives";
                        break;
                    case i503 > 5:
                        this.tickInterval = "minutes";
                        break;
                    case i503 > 1:
                        this.tickInterval = "seconds_tens";
                        break;
                    case 60 * i503 > 20:
                        this.tickInterval = "seconds_fives";
                        break;
                    default:
                        this.tickInterval = "seconds";
                }
            }
        },
        {
            key: "generateYearScale",
            value: function(t817) {
                var e640 = t817.firstVal, i504 = t817.currentMonth, a412 = t817.currentYear, s342 = t817.daysWidthOnXAxis, r290 = t817.numberOfYears, o259 = e640.minYear, n220 = 0, l186 = new R(this.ctx), h162 = "year";
                if (e640.minDate > 1 || e640.minMonth > 0) {
                    var c139 = l186.determineRemainingDaysOfYear(e640.minYear, e640.minMonth, e640.minDate);
                    n220 = (l186.determineDaysOfYear(e640.minYear) - c139 + 1) * s342, o259 = e640.minYear + 1, this.timeScaleArray.push({
                        position: n220,
                        value: o259,
                        unit: h162,
                        year: o259,
                        month: x.monthMod(i504 + 1)
                    });
                } else 1 === e640.minDate && 0 === e640.minMonth && this.timeScaleArray.push({
                    position: n220,
                    value: o259,
                    unit: h162,
                    year: a412,
                    month: x.monthMod(i504 + 1)
                });
                for(var d125 = o259, g102 = n220, u83 = 0; u83 < r290; u83++)d125++, g102 = l186.determineDaysOfYear(d125 - 1) * s342 + g102, this.timeScaleArray.push({
                    position: g102,
                    value: d125,
                    unit: h162,
                    year: d125,
                    month: 1
                });
            }
        },
        {
            key: "generateMonthScale",
            value: function(t818) {
                var e641 = t818.firstVal, i505 = t818.currentMonthDate, a413 = t818.currentMonth, s343 = t818.currentYear, r291 = t818.daysWidthOnXAxis, o260 = t818.numberOfMonths, n221 = a413, l187 = 0, h163 = new R(this.ctx), c140 = "month", d126 = 0;
                if (e641.minDate > 1) {
                    l187 = (h163.determineDaysOfMonths(a413 + 1, e641.minYear) - i505 + 1) * r291, n221 = x.monthMod(a413 + 1);
                    var g103 = s343 + d126, u84 = x.monthMod(n221), p70 = n221;
                    0 === n221 && (c140 = "year", p70 = g103, u84 = 1, g103 += d126 += 1), this.timeScaleArray.push({
                        position: l187,
                        value: p70,
                        unit: c140,
                        year: g103,
                        month: u84
                    });
                } else this.timeScaleArray.push({
                    position: l187,
                    value: n221,
                    unit: c140,
                    year: s343,
                    month: x.monthMod(a413)
                });
                for(var f65 = n221 + 1, b54 = l187, v40 = 0, m19 = 1; v40 < o260; v40++, m19++){
                    0 === (f65 = x.monthMod(f65)) ? (c140 = "year", d126 += 1) : c140 = "month";
                    var y42 = this._getYear(s343, f65, d126);
                    b54 = h163.determineDaysOfMonths(f65, y42) * r291 + b54;
                    var w35 = 0 === f65 ? y42 : f65;
                    this.timeScaleArray.push({
                        position: b54,
                        value: w35,
                        unit: c140,
                        year: y42,
                        month: 0 === f65 ? 1 : f65
                    }), f65++;
                }
            }
        },
        {
            key: "generateDayScale",
            value: function(t819) {
                var e642 = t819.firstVal, i506 = t819.currentMonth, a414 = t819.currentYear, s344 = t819.hoursWidthOnXAxis, r292 = t819.numberOfDays, o261 = new R(this.ctx), n222 = "day", l188 = e642.minDate + 1, h164 = l188, c141 = function(t820, e643, i507) {
                    return t820 > o261.determineDaysOfMonths(e643 + 1, i507) ? (h164 = 1, n222 = "month", g104 = e643 += 1, e643) : e643;
                }, d127 = (24 - e642.minHour) * s344, g104 = l188, u85 = c141(h164, i506, a414);
                0 === e642.minHour && 1 === e642.minDate ? (d127 = 0, g104 = x.monthMod(e642.minMonth), n222 = "month", h164 = e642.minDate, r292++) : 1 !== e642.minDate && 0 === e642.minHour && 0 === e642.minMinute && (d127 = 0, l188 = e642.minDate, g104 = l188, u85 = c141(h164 = l188, i506, a414)), this.timeScaleArray.push({
                    position: d127,
                    value: g104,
                    unit: n222,
                    year: this._getYear(a414, u85, 0),
                    month: x.monthMod(u85),
                    day: h164
                });
                for(var p71 = d127, f66 = 0; f66 < r292; f66++){
                    n222 = "day", u85 = c141(h164 += 1, u85, this._getYear(a414, u85, 0));
                    var b55 = this._getYear(a414, u85, 0);
                    p71 = 24 * s344 + p71;
                    var v41 = 1 === h164 ? x.monthMod(u85) : h164;
                    this.timeScaleArray.push({
                        position: p71,
                        value: v41,
                        unit: n222,
                        year: b55,
                        month: x.monthMod(u85),
                        day: v41
                    });
                }
            }
        },
        {
            key: "generateHourScale",
            value: function(t821) {
                var e644 = t821.firstVal, i508 = t821.currentDate, a415 = t821.currentMonth, s345 = t821.currentYear, r293 = t821.minutesWidthOnXAxis, o262 = t821.numberOfHours, n223 = new R(this.ctx), l189 = "hour", h165 = function(t822, e645) {
                    return t822 > n223.determineDaysOfMonths(e645 + 1, s345) && (f67 = 1, e645 += 1), {
                        month: e645,
                        date: f67
                    };
                }, c142 = function(t823, e646) {
                    return t823 > n223.determineDaysOfMonths(e646 + 1, s345) ? e646 += 1 : e646;
                }, d128 = 60 - (e644.minMinute + e644.minSecond / 60), g105 = d128 * r293, u86 = e644.minHour + 1, p72 = u86 + 1;
                60 === d128 && (g105 = 0, p72 = (u86 = e644.minHour) + 1);
                var f67 = i508, b56 = c142(f67, a415);
                this.timeScaleArray.push({
                    position: g105,
                    value: u86,
                    unit: l189,
                    day: f67,
                    hour: p72,
                    year: s345,
                    month: x.monthMod(b56)
                });
                for(var v42 = g105, m20 = 0; m20 < o262; m20++){
                    if (l189 = "hour", p72 >= 24) p72 = 0, l189 = "day", b56 = h165(f67 += 1, b56).month, b56 = c142(f67, b56);
                    var y43 = this._getYear(s345, b56, 0);
                    v42 = 0 === p72 && 0 === m20 ? d128 * r293 : 60 * r293 + v42;
                    var w36 = 0 === p72 ? f67 : p72;
                    this.timeScaleArray.push({
                        position: v42,
                        value: w36,
                        unit: l189,
                        hour: p72,
                        day: f67,
                        year: y43,
                        month: x.monthMod(b56)
                    }), p72++;
                }
            }
        },
        {
            key: "generateMinuteScale",
            value: function(t824) {
                for(var e647 = t824.currentMillisecond, i509 = t824.currentSecond, a416 = t824.currentMinute, s346 = t824.currentHour, r294 = t824.currentDate, o263 = t824.currentMonth, n224 = t824.currentYear, l190 = t824.minutesWidthOnXAxis, h166 = t824.secondsWidthOnXAxis, c143 = t824.numberOfMinutes, d129 = a416 + 1, g106 = r294, u87 = o263, p73 = n224, f68 = s346, b57 = (60 - i509 - e647 / 1e3) * h166, v43 = 0; v43 < c143; v43++)d129 >= 60 && (d129 = 0, 24 === (f68 += 1) && (f68 = 0)), this.timeScaleArray.push({
                    position: b57,
                    value: d129,
                    unit: "minute",
                    hour: f68,
                    minute: d129,
                    day: g106,
                    year: this._getYear(p73, u87, 0),
                    month: x.monthMod(u87)
                }), b57 += l190, d129++;
            }
        },
        {
            key: "generateSecondScale",
            value: function(t825) {
                for(var e648 = t825.currentMillisecond, i510 = t825.currentSecond, a417 = t825.currentMinute, s347 = t825.currentHour, r295 = t825.currentDate, o264 = t825.currentMonth, n225 = t825.currentYear, l191 = t825.secondsWidthOnXAxis, h167 = t825.numberOfSeconds, c144 = i510 + 1, d130 = a417, g107 = r295, u88 = o264, p74 = n225, f69 = s347, b58 = (1e3 - e648) / 1e3 * l191, v44 = 0; v44 < h167; v44++)c144 >= 60 && (c144 = 0, ++d130 >= 60 && (d130 = 0, 24 === ++f69 && (f69 = 0))), this.timeScaleArray.push({
                    position: b58,
                    value: c144,
                    unit: "second",
                    hour: f69,
                    minute: d130,
                    second: c144,
                    day: g107,
                    year: this._getYear(p74, u88, 0),
                    month: x.monthMod(u88)
                }), b58 += l191, c144++;
            }
        },
        {
            key: "createRawDateString",
            value: function(t826, e649) {
                var i511 = t826.year;
                return 0 === t826.month && (t826.month = 1), i511 += "-" + ("0" + t826.month.toString()).slice(-2), "day" === t826.unit ? i511 += "day" === t826.unit ? "-" + ("0" + e649).slice(-2) : "-01" : i511 += "-" + ("0" + (t826.day ? t826.day : "1")).slice(-2), "hour" === t826.unit ? i511 += "hour" === t826.unit ? "T" + ("0" + e649).slice(-2) : "T00" : i511 += "T" + ("0" + (t826.hour ? t826.hour : "0")).slice(-2), "minute" === t826.unit ? i511 += ":" + ("0" + e649).slice(-2) : i511 += ":" + (t826.minute ? ("0" + t826.minute).slice(-2) : "00"), "second" === t826.unit ? i511 += ":" + ("0" + e649).slice(-2) : i511 += ":00", this.utc && (i511 += ".000Z"), i511;
            }
        },
        {
            key: "formatDates",
            value: function(t827) {
                var e650 = this, i512 = this.w;
                return t827.map(function(t828) {
                    var a418 = t828.value.toString(), s348 = new R(e650.ctx), r296 = e650.createRawDateString(t828, a418), o265 = s348.getDate(s348.parseDate(r296));
                    if (e650.utc || (o265 = s348.getDate(s348.parseDateWithTimezone(r296))), void 0 === i512.config.xaxis.labels.format) {
                        var n226 = "dd MMM", l192 = i512.config.xaxis.labels.datetimeFormatter;
                        "year" === t828.unit && (n226 = l192.year), "month" === t828.unit && (n226 = l192.month), "day" === t828.unit && (n226 = l192.day), "hour" === t828.unit && (n226 = l192.hour), "minute" === t828.unit && (n226 = l192.minute), "second" === t828.unit && (n226 = l192.second), a418 = s348.formatDate(o265, n226);
                    } else a418 = s348.formatDate(o265, i512.config.xaxis.labels.format);
                    return {
                        dateString: r296,
                        position: t828.position,
                        value: a418,
                        unit: t828.unit,
                        year: t828.year,
                        month: t828.month
                    };
                });
            }
        },
        {
            key: "removeOverlappingTS",
            value: function(t829) {
                var e651, i513 = this, a419 = new m(this.ctx), s349 = !1;
                t829.length > 0 && t829[0].value && t829.every(function(e652) {
                    return e652.value.length === t829[0].value.length;
                }) && (s349 = !0, e651 = a419.getTextRects(t829[0].value).width);
                var r297 = 0, o266 = t829.map(function(o267, n227) {
                    if (n227 > 0 && i513.w.config.xaxis.labels.hideOverlappingLabels) {
                        var l193 = s349 ? e651 : a419.getTextRects(t829[r297].value).width, h168 = t829[r297].position;
                        return o267.position > h168 + l193 + 10 ? (r297 = n227, o267) : null;
                    }
                    return o267;
                });
                return o266 = o266.filter(function(t830) {
                    return null !== t830;
                });
            }
        },
        {
            key: "_getYear",
            value: function(t831, e653, i514) {
                return t831 + Math.floor(e653 / 12) + i514;
            }
        }
    ]), t811;
}(), Yt = function() {
    function t832(e654, i515) {
        a(this, t832), this.ctx = i515, this.w = i515.w, this.el = e654;
    }
    return r(t832, [
        {
            key: "setupElements",
            value: function() {
                var t833 = this.w.globals, e655 = this.w.config, i516 = e655.chart.type;
                t833.axisCharts = [
                    "line",
                    "area",
                    "bar",
                    "rangeBar",
                    "candlestick",
                    "boxPlot",
                    "scatter",
                    "bubble",
                    "radar",
                    "heatmap",
                    "treemap"
                ].indexOf(i516) > -1, t833.xyCharts = [
                    "line",
                    "area",
                    "bar",
                    "rangeBar",
                    "candlestick",
                    "boxPlot",
                    "scatter",
                    "bubble"
                ].indexOf(i516) > -1, t833.isBarHorizontal = ("bar" === e655.chart.type || "rangeBar" === e655.chart.type || "boxPlot" === e655.chart.type) && e655.plotOptions.bar.horizontal, t833.chartClass = ".apexcharts" + t833.chartID, t833.dom.baseEl = this.el, t833.dom.elWrap = document.createElement("div"), m.setAttrs(t833.dom.elWrap, {
                    id: t833.chartClass.substring(1),
                    class: "apexcharts-canvas " + t833.chartClass.substring(1)
                }), this.el.appendChild(t833.dom.elWrap), t833.dom.Paper = new window.SVG.Doc(t833.dom.elWrap), t833.dom.Paper.attr({
                    class: "apexcharts-svg",
                    "xmlns:data": "ApexChartsNS",
                    transform: "translate(".concat(e655.chart.offsetX, ", ").concat(e655.chart.offsetY, ")")
                }), t833.dom.Paper.node.style.background = e655.chart.background, this.setSVGDimensions(), t833.dom.elGraphical = t833.dom.Paper.group().attr({
                    class: "apexcharts-inner apexcharts-graphical"
                }), t833.dom.elAnnotations = t833.dom.Paper.group().attr({
                    class: "apexcharts-annotations"
                }), t833.dom.elDefs = t833.dom.Paper.defs(), t833.dom.elLegendWrap = document.createElement("div"), t833.dom.elLegendWrap.classList.add("apexcharts-legend"), t833.dom.elWrap.appendChild(t833.dom.elLegendWrap), t833.dom.Paper.add(t833.dom.elGraphical), t833.dom.elGraphical.add(t833.dom.elDefs);
            }
        },
        {
            key: "plotChartType",
            value: function(t834, e656) {
                var i517 = this.w, a420 = i517.config, s350 = i517.globals, r298 = {
                    series: [],
                    i: []
                }, o268 = {
                    series: [],
                    i: []
                }, n228 = {
                    series: [],
                    i: []
                }, l194 = {
                    series: [],
                    i: []
                }, h169 = {
                    series: [],
                    i: []
                }, c145 = {
                    series: [],
                    i: []
                }, d131 = {
                    series: [],
                    i: []
                };
                s350.series.map(function(e657, g109) {
                    var u90 = 0;
                    void 0 !== t834[g109].type ? ("column" === t834[g109].type || "bar" === t834[g109].type ? (s350.series.length > 1 && a420.plotOptions.bar.horizontal && console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"), h169.series.push(e657), h169.i.push(g109), u90++, i517.globals.columnSeries = h169.series) : "area" === t834[g109].type ? (o268.series.push(e657), o268.i.push(g109), u90++) : "line" === t834[g109].type ? (r298.series.push(e657), r298.i.push(g109), u90++) : "scatter" === t834[g109].type ? (n228.series.push(e657), n228.i.push(g109)) : "bubble" === t834[g109].type ? (l194.series.push(e657), l194.i.push(g109), u90++) : "candlestick" === t834[g109].type ? (c145.series.push(e657), c145.i.push(g109), u90++) : "boxPlot" === t834[g109].type ? (d131.series.push(e657), d131.i.push(g109), u90++) : console.warn("You have specified an unrecognized chart type. Available types for this property are line/area/column/bar/scatter/bubble"), u90 > 1 && (s350.comboCharts = !0)) : (r298.series.push(e657), r298.i.push(g109));
                });
                var g108 = new Mt(this.ctx, e656), u89 = new wt(this.ctx, e656);
                this.ctx.pie = new Ct(this.ctx);
                var p75 = new Pt(this.ctx);
                this.ctx.rangeBar = new H(this.ctx, e656);
                var f70 = new Lt(this.ctx), x42 = [];
                if (s350.comboCharts) {
                    if (o268.series.length > 0 && x42.push(g108.draw(o268.series, "area", o268.i)), h169.series.length > 0) {
                        if (i517.config.chart.stacked) {
                            var b59 = new yt(this.ctx, e656);
                            x42.push(b59.draw(h169.series, h169.i));
                        } else this.ctx.bar = new F(this.ctx, e656), x42.push(this.ctx.bar.draw(h169.series, h169.i));
                    }
                    if (r298.series.length > 0 && x42.push(g108.draw(r298.series, "line", r298.i)), c145.series.length > 0 && x42.push(u89.draw(c145.series, c145.i)), d131.series.length > 0 && x42.push(u89.draw(d131.series, d131.i)), n228.series.length > 0) {
                        var v45 = new Mt(this.ctx, e656, !0);
                        x42.push(v45.draw(n228.series, "scatter", n228.i));
                    }
                    if (l194.series.length > 0) {
                        var m21 = new Mt(this.ctx, e656, !0);
                        x42.push(m21.draw(l194.series, "bubble", l194.i));
                    }
                } else switch(a420.chart.type){
                    case "line":
                        x42 = g108.draw(s350.series, "line");
                        break;
                    case "area":
                        x42 = g108.draw(s350.series, "area");
                        break;
                    case "bar":
                        if (a420.chart.stacked) x42 = new yt(this.ctx, e656).draw(s350.series);
                        else this.ctx.bar = new F(this.ctx, e656), x42 = this.ctx.bar.draw(s350.series);
                        break;
                    case "candlestick":
                        x42 = new wt(this.ctx, e656).draw(s350.series);
                        break;
                    case "boxPlot":
                        x42 = new wt(this.ctx, e656).draw(s350.series);
                        break;
                    case "rangeBar":
                        x42 = this.ctx.rangeBar.draw(s350.series);
                        break;
                    case "heatmap":
                        x42 = new At(this.ctx, e656).draw(s350.series);
                        break;
                    case "treemap":
                        x42 = new Xt(this.ctx, e656).draw(s350.series);
                        break;
                    case "pie":
                    case "donut":
                    case "polarArea":
                        x42 = this.ctx.pie.draw(s350.series);
                        break;
                    case "radialBar":
                        x42 = p75.draw(s350.series);
                        break;
                    case "radar":
                        x42 = f70.draw(s350.series);
                        break;
                    default:
                        x42 = g108.draw(s350.series);
                }
                return x42;
            }
        },
        {
            key: "setSVGDimensions",
            value: function() {
                var t835 = this.w.globals, e658 = this.w.config;
                t835.svgWidth = e658.chart.width, t835.svgHeight = e658.chart.height;
                var i518 = x.getDimensions(this.el), a421 = e658.chart.width.toString().split(/[0-9]+/g).pop();
                "%" === a421 ? x.isNumber(i518[0]) && (0 === i518[0].width && (i518 = x.getDimensions(this.el.parentNode)), t835.svgWidth = i518[0] * parseInt(e658.chart.width, 10) / 100) : "px" !== a421 && "" !== a421 || (t835.svgWidth = parseInt(e658.chart.width, 10));
                var s351 = e658.chart.height.toString().split(/[0-9]+/g).pop();
                if ("auto" !== t835.svgHeight && "" !== t835.svgHeight) {
                    if ("%" === s351) {
                        var r299 = x.getDimensions(this.el.parentNode);
                        t835.svgHeight = r299[1] * parseInt(e658.chart.height, 10) / 100;
                    } else t835.svgHeight = parseInt(e658.chart.height, 10);
                } else t835.axisCharts ? t835.svgHeight = t835.svgWidth / 1.61 : t835.svgHeight = t835.svgWidth / 1.2;
                if (t835.svgWidth < 0 && (t835.svgWidth = 0), t835.svgHeight < 0 && (t835.svgHeight = 0), m.setAttrs(t835.dom.Paper.node, {
                    width: t835.svgWidth,
                    height: t835.svgHeight
                }), "%" !== s351) {
                    var o269 = e658.chart.sparkline.enabled ? 0 : t835.axisCharts ? e658.chart.parentHeightOffset : 0;
                    t835.dom.Paper.node.parentNode.parentNode.style.minHeight = t835.svgHeight + o269 + "px";
                }
                t835.dom.elWrap.style.width = t835.svgWidth + "px", t835.dom.elWrap.style.height = t835.svgHeight + "px";
            }
        },
        {
            key: "shiftGraphPosition",
            value: function() {
                var t836 = this.w.globals, e659 = t836.translateY, i519 = {
                    transform: "translate(" + t836.translateX + ", " + e659 + ")"
                };
                m.setAttrs(t836.dom.elGraphical.node, i519);
            }
        },
        {
            key: "resizeNonAxisCharts",
            value: function() {
                var t837 = this.w, e660 = t837.globals, i520 = 0, a422 = t837.config.chart.sparkline.enabled ? 1 : 15;
                a422 += t837.config.grid.padding.bottom, "top" !== t837.config.legend.position && "bottom" !== t837.config.legend.position || !t837.config.legend.show || t837.config.legend.floating || (i520 = new ct(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
                var s352 = t837.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"), r300 = 2.05 * t837.globals.radialSize;
                if (s352 && !t837.config.chart.sparkline.enabled && 0 !== t837.config.plotOptions.radialBar.startAngle) {
                    var o270 = x.getBoundingClientRect(s352);
                    r300 = o270.bottom;
                    var n229 = o270.bottom - o270.top;
                    r300 = Math.max(2.05 * t837.globals.radialSize, n229);
                }
                var l195 = r300 + e660.translateY + i520 + a422;
                e660.dom.elLegendForeign && e660.dom.elLegendForeign.setAttribute("height", l195), e660.dom.elWrap.style.height = l195 + "px", m.setAttrs(e660.dom.Paper.node, {
                    height: l195
                }), e660.dom.Paper.node.parentNode.parentNode.style.minHeight = l195 + "px";
            }
        },
        {
            key: "coreCalculations",
            value: function() {
                new Z(this.ctx).init();
            }
        },
        {
            key: "resetGlobals",
            value: function() {
                var t838 = this, e661 = function() {
                    return t838.w.config.series.map(function(t) {
                        return [];
                    });
                }, i521 = new O, a423 = this.w.globals;
                i521.initGlobalVars(a423), a423.seriesXvalues = e661(), a423.seriesYvalues = e661();
            }
        },
        {
            key: "isMultipleY",
            value: function() {
                if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1) return this.w.globals.isMultipleYAxis = !0, !0;
            }
        },
        {
            key: "xySettings",
            value: function() {
                var t839 = null, e662 = this.w;
                if (e662.globals.axisCharts) {
                    if ("back" === e662.config.xaxis.crosshairs.position) new tt(this.ctx).drawXCrosshairs();
                    if ("back" === e662.config.yaxis[0].crosshairs.position) new tt(this.ctx).drawYCrosshairs();
                    if ("datetime" === e662.config.xaxis.type && void 0 === e662.config.xaxis.labels.formatter) {
                        this.ctx.timeScale = new Et(this.ctx);
                        var i522 = [];
                        isFinite(e662.globals.minX) && isFinite(e662.globals.maxX) && !e662.globals.isBarHorizontal ? i522 = this.ctx.timeScale.calculateTimeScaleTicks(e662.globals.minX, e662.globals.maxX) : e662.globals.isBarHorizontal && (i522 = this.ctx.timeScale.calculateTimeScaleTicks(e662.globals.minY, e662.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i522);
                    }
                    t839 = new y(this.ctx).getCalculatedRatios();
                }
                return t839;
            }
        },
        {
            key: "updateSourceChart",
            value: function(t840) {
                this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({
                    chart: {
                        selection: {
                            xaxis: {
                                min: t840.w.globals.minX,
                                max: t840.w.globals.maxX
                            }
                        }
                    }
                }, !1, !1);
            }
        },
        {
            key: "setupBrushHandler",
            value: function() {
                var t841 = this, i523 = this.w;
                if (i523.config.chart.brush.enabled && "function" != typeof i523.config.chart.events.selection) {
                    var a424 = i523.config.chart.brush.targets || [
                        i523.config.chart.brush.target
                    ];
                    a424.forEach(function(e663) {
                        var i524 = ApexCharts.getChartByID(e663);
                        i524.w.globals.brushSource = t841.ctx, "function" != typeof i524.w.config.chart.events.zoomed && (i524.w.config.chart.events.zoomed = function() {
                            t841.updateSourceChart(i524);
                        }), "function" != typeof i524.w.config.chart.events.scrolled && (i524.w.config.chart.events.scrolled = function() {
                            t841.updateSourceChart(i524);
                        });
                    }), i523.config.chart.events.selection = function(t842, s353) {
                        a424.forEach(function(t843) {
                            var a425 = ApexCharts.getChartByID(t843), r301 = x.clone(i523.config.yaxis);
                            if (i523.config.chart.brush.autoScaleYaxis && 1 === a425.w.globals.series.length) {
                                var o271 = new q(a425);
                                r301 = o271.autoScaleY(a425, r301, s353);
                            }
                            var n230 = a425.w.config.yaxis.reduce(function(t844, i, s354) {
                                return [].concat(u(t844), [
                                    e(e({}, a425.w.config.yaxis[s354]), {}, {
                                        min: r301[0].min,
                                        max: r301[0].max
                                    })
                                ]);
                            }, []);
                            a425.ctx.updateHelpers._updateOptions({
                                xaxis: {
                                    min: s353.xaxis.min,
                                    max: s353.xaxis.max
                                },
                                yaxis: n230
                            }, !1, !1, !1, !1);
                        });
                    };
                }
            }
        }
    ]), t832;
}(), Ft = function() {
    function t845(e664) {
        a(this, t845), this.ctx = e664, this.w = e664.w;
    }
    return r(t845, [
        {
            key: "_updateOptions",
            value: function(t846) {
                var e665 = this, a426 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], s355 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], r302 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], o272 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                return new Promise(function(n231) {
                    var l196 = [
                        e665.ctx
                    ];
                    r302 && (l196 = e665.ctx.getSyncedCharts()), e665.ctx.w.globals.isExecCalled && (l196 = [
                        e665.ctx
                    ], e665.ctx.w.globals.isExecCalled = !1), l196.forEach(function(r303, h170) {
                        var c146 = r303.w;
                        if (c146.globals.shouldAnimate = s355, a426 || (c146.globals.resized = !0, c146.globals.dataChanged = !0, s355 && r303.series.getPreviousPaths()), t846 && "object" === i(t846) && (r303.config = new N(t846), t846 = y.extendArrayProps(r303.config, t846, c146), r303.w.globals.chartID !== e665.ctx.w.globals.chartID && delete t846.series, c146.config = x.extend(c146.config, t846), o272 && (c146.globals.lastXAxis = t846.xaxis ? x.clone(t846.xaxis) : [], c146.globals.lastYAxis = t846.yaxis ? x.clone(t846.yaxis) : [], c146.globals.initialConfig = x.extend({}, c146.config), c146.globals.initialSeries = x.clone(c146.config.series), t846.series))) {
                            for(var d132 = 0; d132 < c146.globals.collapsedSeriesIndices.length; d132++){
                                var g110 = c146.config.series[c146.globals.collapsedSeriesIndices[d132]];
                                c146.globals.collapsedSeries[d132].data = c146.globals.axisCharts ? g110.data.slice() : g110;
                            }
                            for(var u91 = 0; u91 < c146.globals.ancillaryCollapsedSeriesIndices.length; u91++){
                                var p76 = c146.config.series[c146.globals.ancillaryCollapsedSeriesIndices[u91]];
                                c146.globals.ancillaryCollapsedSeries[u91].data = c146.globals.axisCharts ? p76.data.slice() : p76;
                            }
                            r303.series.emptyCollapsedSeries(c146.config.series);
                        }
                        return r303.update(t846).then(function() {
                            h170 === l196.length - 1 && n231(r303);
                        });
                    });
                });
            }
        },
        {
            key: "_updateSeries",
            value: function(t847, e666) {
                var i525 = this, a427 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                return new Promise(function(s356) {
                    var r304, o273 = i525.w;
                    return o273.globals.shouldAnimate = e666, o273.globals.dataChanged = !0, e666 && i525.ctx.series.getPreviousPaths(), o273.globals.axisCharts ? (0 === (r304 = t847.map(function(t848, e667) {
                        return i525._extendSeries(t848, e667);
                    })).length && (r304 = [
                        {
                            data: []
                        }
                    ]), o273.config.series = r304) : o273.config.series = t847.slice(), a427 && (o273.globals.initialSeries = x.clone(o273.config.series)), i525.ctx.update().then(function() {
                        s356(i525.ctx);
                    });
                });
            }
        },
        {
            key: "_extendSeries",
            value: function(t849, i526) {
                var a428 = this.w, s357 = a428.config.series[i526];
                return e(e({}, a428.config.series[i526]), {}, {
                    name: t849.name ? t849.name : s357 && s357.name,
                    color: t849.color ? t849.color : s357 && s357.color,
                    type: t849.type ? t849.type : s357 && s357.type,
                    data: t849.data ? t849.data : s357 && s357.data
                });
            }
        },
        {
            key: "toggleDataPointSelection",
            value: function(t850, e668) {
                var i527 = this.w, a429 = null, s358 = ".apexcharts-series[data\\:realIndex='".concat(t850, "']");
                return i527.globals.axisCharts ? a429 = i527.globals.dom.Paper.select("".concat(s358, " path[j='").concat(e668, "'], ").concat(s358, " circle[j='").concat(e668, "'], ").concat(s358, " rect[j='").concat(e668, "']")).members[0] : void 0 === e668 && (a429 = i527.globals.dom.Paper.select("".concat(s358, " path[j='").concat(t850, "']")).members[0], "pie" !== i527.config.chart.type && "polarArea" !== i527.config.chart.type && "donut" !== i527.config.chart.type || this.ctx.pie.pieClicked(t850)), a429 ? (new m(this.ctx).pathMouseDown(a429, null), a429.node ? a429.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
            }
        },
        {
            key: "forceXAxisUpdate",
            value: function(t851) {
                var e669 = this.w;
                if ([
                    "min",
                    "max"
                ].forEach(function(i529) {
                    void 0 !== t851.xaxis[i529] && (e669.config.xaxis[i529] = t851.xaxis[i529], e669.globals.lastXAxis[i529] = t851.xaxis[i529]);
                }), t851.xaxis.categories && t851.xaxis.categories.length && (e669.config.xaxis.categories = t851.xaxis.categories), e669.config.xaxis.convertedCatToNumeric) {
                    var i528 = new D(t851);
                    t851 = i528.convertCatToNumericXaxis(t851, this.ctx);
                }
                return t851;
            }
        },
        {
            key: "forceYAxisUpdate",
            value: function(t852) {
                var e670 = this.w;
                return e670.config.chart.stacked && "100%" === e670.config.chart.stackType && (Array.isArray(t852.yaxis) ? t852.yaxis.forEach(function(e, i530) {
                    t852.yaxis[i530].min = 0, t852.yaxis[i530].max = 100;
                }) : (t852.yaxis.min = 0, t852.yaxis.max = 100)), t852;
            }
        },
        {
            key: "revertDefaultAxisMinMax",
            value: function(t853) {
                var e671 = this, i531 = this.w, a430 = i531.globals.lastXAxis, s359 = i531.globals.lastYAxis;
                t853 && t853.xaxis && (a430 = t853.xaxis), t853 && t853.yaxis && (s359 = t853.yaxis), i531.config.xaxis.min = a430.min, i531.config.xaxis.max = a430.max;
                var r305 = function(t854) {
                    void 0 !== s359[t854] && (i531.config.yaxis[t854].min = s359[t854].min, i531.config.yaxis[t854].max = s359[t854].max);
                };
                i531.config.yaxis.map(function(t855, a431) {
                    i531.globals.zoomed || void 0 !== s359[a431] ? r305(a431) : void 0 !== e671.ctx.opts.yaxis[a431] && (t855.min = e671.ctx.opts.yaxis[a431].min, t855.max = e671.ctx.opts.yaxis[a431].max);
                });
            }
        }
    ]), t845;
}();
It = "undefined" != typeof window ? window : void 0, zt = function(t856, e672) {
    var a432 = (void 0 !== this ? this : t856).SVG = function(t857) {
        if (a432.supported) return t857 = new a432.Doc(t857), a432.parser.draw || a432.prepare(), t857;
    };
    if (a432.ns = "http://www.w3.org/2000/svg", a432.xmlns = "http://www.w3.org/2000/xmlns/", a432.xlink = "http://www.w3.org/1999/xlink", a432.svgjs = "http://svgjs.dev", a432.supported = !0, !a432.supported) return !1;
    a432.did = 1e3, a432.eid = function(t858) {
        return "Svgjs" + d133(t858) + a432.did++;
    }, a432.create = function(t859) {
        var i532 = e672.createElementNS(this.ns, t859);
        return i532.setAttribute("id", this.eid(t859)), i532;
    }, a432.extend = function() {
        var t860, e673;
        e673 = (t860 = [].slice.call(arguments)).pop();
        for(var i533 = t860.length - 1; i533 >= 0; i533--)if (t860[i533]) for(var s361 in e673)t860[i533].prototype[s361] = e673[s361];
        a432.Set && a432.Set.inherit && a432.Set.inherit();
    }, a432.invent = function(t861) {
        var e674 = "function" == typeof t861.create ? t861.create : function() {
            this.constructor.call(this, a432.create(t861.create));
        };
        return t861.inherit && (e674.prototype = new t861.inherit), t861.extend && a432.extend(e674, t861.extend), t861.construct && a432.extend(t861.parent || a432.Container, t861.construct), e674;
    }, a432.adopt = function(e675) {
        var i534;
        return e675 ? e675.instance ? e675.instance : ((i534 = "svg" == e675.nodeName ? e675.parentNode instanceof t856.SVGElement ? new a432.Nested : new a432.Doc : "linearGradient" == e675.nodeName ? new a432.Gradient("linear") : "radialGradient" == e675.nodeName ? new a432.Gradient("radial") : a432[d133(e675.nodeName)] ? new a432[d133(e675.nodeName)] : new a432.Element(e675)).type = e675.nodeName, i534.node = e675, e675.instance = i534, i534 instanceof a432.Doc && i534.namespace().defs(), i534.setData(JSON.parse(e675.getAttribute("svgjs:data")) || {}), i534) : null;
    }, a432.prepare = function() {
        var t862 = e672.getElementsByTagName("body")[0], i535 = (t862 ? new a432.Doc(t862) : a432.adopt(e672.documentElement).nested()).size(2, 0);
        a432.parser = {
            body: t862 || e672.documentElement,
            draw: i535.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node,
            poly: i535.polyline().node,
            path: i535.path().node,
            native: a432.create("svg")
        };
    }, a432.parser = {
        native: a432.create("svg")
    }, e672.addEventListener("DOMContentLoaded", function() {
        a432.parser.draw || a432.prepare();
    }, !1), a432.regex = {
        numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,
        hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
        rgb: /rgb\((\d+),(\d+),(\d+)\)/,
        reference: /#([a-z0-9\-_]+)/i,
        transforms: /\)\s*,?\s*/,
        whitespace: /\s/g,
        isHex: /^#[a-f0-9]{3,6}$/i,
        isRgb: /^rgb\(/,
        isCss: /[^:]+:[^;]+;?/,
        isBlank: /^(\s+)?$/,
        isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
        isPercent: /^-?[\d\.]+%$/,
        isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,
        delimiter: /[\s,]+/,
        hyphen: /([^e])\-/gi,
        pathLetters: /[MLHVCSQTAZ]/gi,
        isPathLetter: /[MLHVCSQTAZ]/i,
        numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,
        dots: /\./g
    }, a432.utils = {
        map: function(t863, e676) {
            for(var i536 = t863.length, a433 = [], s362 = 0; s362 < i536; s362++)a433.push(e676(t863[s362]));
            return a433;
        },
        filter: function(t864, e677) {
            for(var i537 = t864.length, a434 = [], s363 = 0; s363 < i537; s363++)e677(t864[s363]) && a434.push(t864[s363]);
            return a434;
        },
        filterSVGElements: function(e678) {
            return this.filter(e678, function(e679) {
                return e679 instanceof t856.SVGElement;
            });
        }
    }, a432.defaults = {
        attrs: {
            "fill-opacity": 1,
            "stroke-opacity": 1,
            "stroke-width": 0,
            "stroke-linejoin": "miter",
            "stroke-linecap": "butt",
            fill: "#000000",
            stroke: "#000000",
            opacity: 1,
            x: 0,
            y: 0,
            cx: 0,
            cy: 0,
            width: 0,
            height: 0,
            r: 0,
            rx: 0,
            ry: 0,
            offset: 0,
            "stop-opacity": 1,
            "stop-color": "#000000",
            "font-size": 16,
            "font-family": "Helvetica, Arial, sans-serif",
            "text-anchor": "start"
        }
    }, a432.Color = function(t865) {
        var e680, s364;
        this.r = 0, this.g = 0, this.b = 0, t865 && ("string" == typeof t865 ? a432.regex.isRgb.test(t865) ? (e680 = a432.regex.rgb.exec(t865.replace(a432.regex.whitespace, "")), this.r = parseInt(e680[1]), this.g = parseInt(e680[2]), this.b = parseInt(e680[3])) : a432.regex.isHex.test(t865) && (e680 = a432.regex.hex.exec(4 == (s364 = t865).length ? [
            "#",
            s364.substring(1, 2),
            s364.substring(1, 2),
            s364.substring(2, 3),
            s364.substring(2, 3),
            s364.substring(3, 4),
            s364.substring(3, 4)
        ].join("") : s364), this.r = parseInt(e680[1], 16), this.g = parseInt(e680[2], 16), this.b = parseInt(e680[3], 16)) : "object" === i(t865) && (this.r = t865.r, this.g = t865.g, this.b = t865.b));
    }, a432.extend(a432.Color, {
        toString: function() {
            return this.toHex();
        },
        toHex: function() {
            return "#" + g111(this.r) + g111(this.g) + g111(this.b);
        },
        toRgb: function() {
            return "rgb(" + [
                this.r,
                this.g,
                this.b
            ].join() + ")";
        },
        brightness: function() {
            return this.r / 255 * .3 + this.g / 255 * .59 + this.b / 255 * .11;
        },
        morph: function(t866) {
            return this.destination = new a432.Color(t866), this;
        },
        at: function(t867) {
            return this.destination ? (t867 = t867 < 0 ? 0 : t867 > 1 ? 1 : t867, new a432.Color({
                r: ~~(this.r + (this.destination.r - this.r) * t867),
                g: ~~(this.g + (this.destination.g - this.g) * t867),
                b: ~~(this.b + (this.destination.b - this.b) * t867)
            })) : this;
        }
    }), a432.Color.test = function(t868) {
        return t868 += "", a432.regex.isHex.test(t868) || a432.regex.isRgb.test(t868);
    }, a432.Color.isRgb = function(t869) {
        return t869 && "number" == typeof t869.r && "number" == typeof t869.g && "number" == typeof t869.b;
    }, a432.Color.isColor = function(t870) {
        return a432.Color.isRgb(t870) || a432.Color.test(t870);
    }, a432.Array = function(t871, e681) {
        0 == (t871 = (t871 || []).valueOf()).length && e681 && (t871 = e681.valueOf()), this.value = this.parse(t871);
    }, a432.extend(a432.Array, {
        toString: function() {
            return this.value.join(" ");
        },
        valueOf: function() {
            return this.value;
        },
        parse: function(t872) {
            return t872 = t872.valueOf(), Array.isArray(t872) ? t872 : this.split(t872);
        }
    }), a432.PointArray = function(t873, e682) {
        a432.Array.call(this, t873, e682 || [
            [
                0,
                0
            ]
        ]);
    }, a432.PointArray.prototype = new a432.Array, a432.PointArray.prototype.constructor = a432.PointArray;
    for(var s360 = {
        M: function(t874, e683, i538) {
            return e683.x = i538.x = t874[0], e683.y = i538.y = t874[1], [
                "M",
                e683.x,
                e683.y
            ];
        },
        L: function(t875, e684) {
            return e684.x = t875[0], e684.y = t875[1], [
                "L",
                t875[0],
                t875[1]
            ];
        },
        H: function(t876, e685) {
            return e685.x = t876[0], [
                "H",
                t876[0]
            ];
        },
        V: function(t877, e686) {
            return e686.y = t877[0], [
                "V",
                t877[0]
            ];
        },
        C: function(t878, e687) {
            return e687.x = t878[4], e687.y = t878[5], [
                "C",
                t878[0],
                t878[1],
                t878[2],
                t878[3],
                t878[4],
                t878[5]
            ];
        },
        Q: function(t879, e688) {
            return e688.x = t879[2], e688.y = t879[3], [
                "Q",
                t879[0],
                t879[1],
                t879[2],
                t879[3]
            ];
        },
        Z: function(t, e689, i539) {
            return e689.x = i539.x, e689.y = i539.y, [
                "Z"
            ];
        }
    }, r306 = "mlhvqtcsaz".split(""), o274 = 0, n232 = r306.length; o274 < n232; ++o274)s360[r306[o274]] = function(t880) {
        return function(e690, i540, a435) {
            if ("H" == t880) e690[0] = e690[0] + i540.x;
            else if ("V" == t880) e690[0] = e690[0] + i540.y;
            else if ("A" == t880) e690[5] = e690[5] + i540.x, e690[6] = e690[6] + i540.y;
            else for(var r307 = 0, o275 = e690.length; r307 < o275; ++r307)e690[r307] = e690[r307] + (r307 % 2 ? i540.y : i540.x);
            if (s360 && "function" == typeof s360[t880]) return s360[t880](e690, i540, a435);
        };
    }(r306[o274].toUpperCase());
    a432.PathArray = function(t881, e691) {
        a432.Array.call(this, t881, e691 || [
            [
                "M",
                0,
                0
            ]
        ]);
    }, a432.PathArray.prototype = new a432.Array, a432.PathArray.prototype.constructor = a432.PathArray, a432.extend(a432.PathArray, {
        toString: function() {
            return function(t882) {
                for(var e692 = 0, i541 = t882.length, a436 = ""; e692 < i541; e692++)a436 += t882[e692][0], null != t882[e692][1] && (a436 += t882[e692][1], null != t882[e692][2] && (a436 += " ", a436 += t882[e692][2], null != t882[e692][3] && (a436 += " ", a436 += t882[e692][3], a436 += " ", a436 += t882[e692][4], null != t882[e692][5] && (a436 += " ", a436 += t882[e692][5], a436 += " ", a436 += t882[e692][6], null != t882[e692][7] && (a436 += " ", a436 += t882[e692][7])))));
                return a436 + " ";
            }(this.value);
        },
        move: function(t, e) {
            var i542 = this.bbox();
            return i542.x, i542.y, this;
        },
        at: function(t883) {
            if (!this.destination) return this;
            for(var e693 = this.value, i543 = this.destination.value, s365 = [], r308 = new a432.PathArray, o276 = 0, n233 = e693.length; o276 < n233; o276++){
                s365[o276] = [
                    e693[o276][0]
                ];
                for(var l198 = 1, h172 = e693[o276].length; l198 < h172; l198++)s365[o276][l198] = e693[o276][l198] + (i543[o276][l198] - e693[o276][l198]) * t883;
                "A" === s365[o276][0] && (s365[o276][4] = +(0 != s365[o276][4]), s365[o276][5] = +(0 != s365[o276][5]));
            }
            return r308.value = s365, r308;
        },
        parse: function(t884) {
            if (t884 instanceof a432.PathArray) return t884.valueOf();
            var e694, i544 = {
                M: 2,
                L: 2,
                H: 1,
                V: 1,
                C: 6,
                S: 4,
                Q: 4,
                T: 2,
                A: 7,
                Z: 0
            };
            t884 = "string" == typeof t884 ? t884.replace(a432.regex.numbersWithDots, h171).replace(a432.regex.pathLetters, " $& ").replace(a432.regex.hyphen, "$1 -").trim().split(a432.regex.delimiter) : t884.reduce(function(t885, e695) {
                return [].concat.call(t885, e695);
            }, []);
            var r309 = [], o277 = new a432.Point, n234 = new a432.Point, l199 = 0, c148 = t884.length;
            do a432.regex.isPathLetter.test(t884[l199]) ? (e694 = t884[l199], ++l199) : "M" == e694 ? e694 = "L" : "m" == e694 && (e694 = "l"), r309.push(s360[e694].call(null, t884.slice(l199, l199 += i544[e694.toUpperCase()]).map(parseFloat), o277, n234));
            while (c148 > l199)
            return r309;
        },
        bbox: function() {
            return a432.parser.draw || a432.prepare(), a432.parser.path.setAttribute("d", this.toString()), a432.parser.path.getBBox();
        }
    }), a432.Number = a432.invent({
        create: function(t886, e696) {
            this.value = 0, this.unit = e696 || "", "number" == typeof t886 ? this.value = isNaN(t886) ? 0 : isFinite(t886) ? t886 : t886 < 0 ? -340000000000000000000000000000000000000 : 34e37 : "string" == typeof t886 ? (e696 = t886.match(a432.regex.numberAndUnit)) && (this.value = parseFloat(e696[1]), "%" == e696[5] ? this.value /= 100 : "s" == e696[5] && (this.value *= 1e3), this.unit = e696[5]) : t886 instanceof a432.Number && (this.value = t886.valueOf(), this.unit = t886.unit);
        },
        extend: {
            toString: function() {
                return ("%" == this.unit ? ~~(1e8 * this.value) / 1e6 : "s" == this.unit ? this.value / 1e3 : this.value) + this.unit;
            },
            toJSON: function() {
                return this.toString();
            },
            valueOf: function() {
                return this.value;
            },
            plus: function(t887) {
                return t887 = new a432.Number(t887), new a432.Number(this + t887, this.unit || t887.unit);
            },
            minus: function(t888) {
                return t888 = new a432.Number(t888), new a432.Number(this - t888, this.unit || t888.unit);
            },
            times: function(t889) {
                return t889 = new a432.Number(t889), new a432.Number(this * t889, this.unit || t889.unit);
            },
            divide: function(t890) {
                return t890 = new a432.Number(t890), new a432.Number(this / t890, this.unit || t890.unit);
            },
            to: function(t891) {
                var e697 = new a432.Number(this);
                return "string" == typeof t891 && (e697.unit = t891), e697;
            },
            morph: function(t892) {
                return this.destination = new a432.Number(t892), t892.relative && (this.destination.value += this.value), this;
            },
            at: function(t893) {
                return this.destination ? new a432.Number(this.destination).minus(this).times(t893).plus(this) : this;
            }
        }
    }), a432.Element = a432.invent({
        create: function(t894) {
            this._stroke = a432.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = t894) && (this.type = t894.nodeName, this.node.instance = this, this._stroke = t894.getAttribute("stroke") || this._stroke);
        },
        extend: {
            x: function(t895) {
                return this.attr("x", t895);
            },
            y: function(t896) {
                return this.attr("y", t896);
            },
            cx: function(t897) {
                return null == t897 ? this.x() + this.width() / 2 : this.x(t897 - this.width() / 2);
            },
            cy: function(t898) {
                return null == t898 ? this.y() + this.height() / 2 : this.y(t898 - this.height() / 2);
            },
            move: function(t899, e698) {
                return this.x(t899).y(e698);
            },
            center: function(t900, e699) {
                return this.cx(t900).cy(e699);
            },
            width: function(t901) {
                return this.attr("width", t901);
            },
            height: function(t902) {
                return this.attr("height", t902);
            },
            size: function(t903, e700) {
                var i545 = u92(this, t903, e700);
                return this.width(new a432.Number(i545.width)).height(new a432.Number(i545.height));
            },
            clone: function(t904) {
                this.writeDataToDom();
                var e701 = x43(this.node.cloneNode(!0));
                return t904 ? t904.add(e701) : this.after(e701), e701;
            },
            remove: function() {
                return this.parent() && this.parent().removeElement(this), this;
            },
            replace: function(t905) {
                return this.after(t905).remove(), t905;
            },
            addTo: function(t906) {
                return t906.put(this);
            },
            putIn: function(t907) {
                return t907.add(this);
            },
            id: function(t908) {
                return this.attr("id", t908);
            },
            show: function() {
                return this.style("display", "");
            },
            hide: function() {
                return this.style("display", "none");
            },
            visible: function() {
                return "none" != this.style("display");
            },
            toString: function() {
                return this.attr("id");
            },
            classes: function() {
                var t909 = this.attr("class");
                return null == t909 ? [] : t909.trim().split(a432.regex.delimiter);
            },
            hasClass: function(t910) {
                return -1 != this.classes().indexOf(t910);
            },
            addClass: function(t911) {
                if (!this.hasClass(t911)) {
                    var e702 = this.classes();
                    e702.push(t911), this.attr("class", e702.join(" "));
                }
                return this;
            },
            removeClass: function(t912) {
                return this.hasClass(t912) && this.attr("class", this.classes().filter(function(e703) {
                    return e703 != t912;
                }).join(" ")), this;
            },
            toggleClass: function(t913) {
                return this.hasClass(t913) ? this.removeClass(t913) : this.addClass(t913);
            },
            reference: function(t914) {
                return a432.get(this.attr(t914));
            },
            parent: function(e704) {
                var i546 = this;
                if (!i546.node.parentNode) return null;
                if (i546 = a432.adopt(i546.node.parentNode), !e704) return i546;
                for(; i546 && i546.node instanceof t856.SVGElement;){
                    if ("string" == typeof e704 ? i546.matches(e704) : i546 instanceof e704) return i546;
                    if (!i546.node.parentNode || "#document" == i546.node.parentNode.nodeName) return null;
                    i546 = a432.adopt(i546.node.parentNode);
                }
            },
            doc: function() {
                return this instanceof a432.Doc ? this : this.parent(a432.Doc);
            },
            parents: function(t915) {
                var e705 = [], i547 = this;
                do {
                    if (!(i547 = i547.parent(t915)) || !i547.node) break;
                    e705.push(i547);
                }while (i547.parent)
                return e705;
            },
            matches: function(t916) {
                return function(t917, e706) {
                    return (t917.matches || t917.matchesSelector || t917.msMatchesSelector || t917.mozMatchesSelector || t917.webkitMatchesSelector || t917.oMatchesSelector).call(t917, e706);
                }(this.node, t916);
            },
            native: function() {
                return this.node;
            },
            svg: function(t918) {
                var i548 = e672.createElement("svg");
                if (!(t918 && this instanceof a432.Parent)) return i548.appendChild(t918 = e672.createElement("svg")), this.writeDataToDom(), t918.appendChild(this.node.cloneNode(!0)), i548.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
                i548.innerHTML = "<svg>" + t918.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
                for(var s366 = 0, r310 = i548.firstChild.childNodes.length; s366 < r310; s366++)this.node.appendChild(i548.firstChild.firstChild);
                return this;
            },
            writeDataToDom: function() {
                return (this.each || this.lines) && (this.each ? this : this.lines()).each(function() {
                    this.writeDataToDom();
                }), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this;
            },
            setData: function(t919) {
                return this.dom = t919, this;
            },
            is: function(t920) {
                return function(t921, e707) {
                    return t921 instanceof e707;
                }(this, t920);
            }
        }
    }), a432.easing = {
        "-": function(t922) {
            return t922;
        },
        "<>": function(t923) {
            return -Math.cos(t923 * Math.PI) / 2 + .5;
        },
        ">": function(t924) {
            return Math.sin(t924 * Math.PI / 2);
        },
        "<": function(t925) {
            return 1 - Math.cos(t925 * Math.PI / 2);
        }
    }, a432.morph = function(t926) {
        return function(e708, i549) {
            return new a432.MorphObj(e708, i549).at(t926);
        };
    }, a432.Situation = a432.invent({
        create: function(t927) {
            this.init = !1, this.reversed = !1, this.reversing = !1, this.duration = new a432.Number(t927.duration).valueOf(), this.delay = new a432.Number(t927.delay).valueOf(), this.start = +new Date + this.delay, this.finish = this.start + this.duration, this.ease = t927.ease, this.loop = 0, this.loops = !1, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {};
        }
    }), a432.FX = a432.invent({
        create: function(t928) {
            this._target = t928, this.situations = [], this.active = !1, this.situation = null, this.paused = !1, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1;
        },
        extend: {
            animate: function(t929, e709, s367) {
                "object" === i(t929) && (e709 = t929.ease, s367 = t929.delay, t929 = t929.duration);
                var r311 = new a432.Situation({
                    duration: t929 || 1e3,
                    delay: s367 || 0,
                    ease: a432.easing[e709 || "-"] || e709
                });
                return this.queue(r311), this;
            },
            target: function(t930) {
                return t930 && t930 instanceof a432.Element ? (this._target = t930, this) : this._target;
            },
            timeToAbsPos: function(t931) {
                return (t931 - this.situation.start) / (this.situation.duration / this._speed);
            },
            absPosToTime: function(t932) {
                return this.situation.duration / this._speed * t932 + this.situation.start;
            },
            startAnimFrame: function() {
                this.stopAnimFrame(), this.animationFrame = t856.requestAnimationFrame((function() {
                    this.step();
                }).bind(this));
            },
            stopAnimFrame: function() {
                t856.cancelAnimationFrame(this.animationFrame);
            },
            start: function() {
                return !this.active && this.situation && (this.active = !0, this.startCurrent()), this;
            },
            startCurrent: function() {
                return this.situation.start = +new Date + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step();
            },
            queue: function(t933) {
                return ("function" == typeof t933 || t933 instanceof a432.Situation) && this.situations.push(t933), this.situation || (this.situation = this.situations.shift()), this;
            },
            dequeue: function() {
                return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof a432.Situation ? this.start() : this.situation.call(this)), this;
            },
            initAnimations: function() {
                var t934, e710 = this.situation;
                if (e710.init) return this;
                for(var i550 in e710.animations){
                    t934 = this.target()[i550](), Array.isArray(t934) || (t934 = [
                        t934
                    ]), Array.isArray(e710.animations[i550]) || (e710.animations[i550] = [
                        e710.animations[i550]
                    ]);
                    for(var s368 = t934.length; s368--;)e710.animations[i550][s368] instanceof a432.Number && (t934[s368] = new a432.Number(t934[s368])), e710.animations[i550][s368] = t934[s368].morph(e710.animations[i550][s368]);
                }
                for(var i550 in e710.attrs)e710.attrs[i550] = new a432.MorphObj(this.target().attr(i550), e710.attrs[i550]);
                for(var i550 in e710.styles)e710.styles[i550] = new a432.MorphObj(this.target().style(i550), e710.styles[i550]);
                return e710.initialTransformation = this.target().matrixify(), e710.init = !0, this;
            },
            clearQueue: function() {
                return this.situations = [], this;
            },
            clearCurrent: function() {
                return this.situation = null, this;
            },
            stop: function(t935, e711) {
                var i551 = this.active;
                return this.active = !1, e711 && this.clearQueue(), t935 && this.situation && (!i551 && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent();
            },
            after: function(t936) {
                var e712 = this.last();
                return this.target().on("finished.fx", function i552(a437) {
                    a437.detail.situation == e712 && (t936.call(this, e712), this.off("finished.fx", i552));
                }), this._callStart();
            },
            during: function(t937) {
                var e713 = this.last(), i553 = function(i554) {
                    i554.detail.situation == e713 && t937.call(this, i554.detail.pos, a432.morph(i554.detail.pos), i554.detail.eased, e713);
                };
                return this.target().off("during.fx", i553).on("during.fx", i553), this.after(function() {
                    this.off("during.fx", i553);
                }), this._callStart();
            },
            afterAll: function(t938) {
                var e714 = function e715(i) {
                    t938.call(this), this.off("allfinished.fx", e715);
                };
                return this.target().off("allfinished.fx", e714).on("allfinished.fx", e714), this._callStart();
            },
            last: function() {
                return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;
            },
            add: function(t939, e716, i555) {
                return this.last()[i555 || "animations"][t939] = e716, this._callStart();
            },
            step: function(t940) {
                var e717, i556, a438;
                t940 || (this.absPos = this.timeToAbsPos(+new Date)), !1 !== this.situation.loops ? (e717 = Math.max(this.absPos, 0), i556 = Math.floor(e717), !0 === this.situation.loops || i556 < this.situation.loops ? (this.pos = e717 - i556, a438 = this.situation.loop, this.situation.loop = i556) : (this.absPos = this.situation.loops, this.pos = 1, a438 = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - a438) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
                var s369 = this.situation.ease(this.pos);
                for(var r312 in this.situation.once)r312 > this.lastPos && r312 <= s369 && (this.situation.once[r312].call(this.target(), this.pos, s369), delete this.situation.once[r312]);
                return this.active && this.target().fire("during", {
                    pos: this.pos,
                    eased: s369,
                    fx: this,
                    situation: this.situation
                }), this.situation ? (this.eachAt(), 1 == this.pos && !this.situation.reversed || this.situation.reversed && 0 == this.pos ? (this.stopAnimFrame(), this.target().fire("finished", {
                    fx: this,
                    situation: this.situation
                }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = !1)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = s369, this) : this;
            },
            eachAt: function() {
                var t941, e718 = this, i557 = this.target(), s370 = this.situation;
                for(var r313 in s370.animations)t941 = [].concat(s370.animations[r313]).map(function(t942) {
                    return "string" != typeof t942 && t942.at ? t942.at(s370.ease(e718.pos), e718.pos) : t942;
                }), i557[r313].apply(i557, t941);
                for(var r313 in s370.attrs)t941 = [
                    r313
                ].concat(s370.attrs[r313]).map(function(t943) {
                    return "string" != typeof t943 && t943.at ? t943.at(s370.ease(e718.pos), e718.pos) : t943;
                }), i557.attr.apply(i557, t941);
                for(var r313 in s370.styles)t941 = [
                    r313
                ].concat(s370.styles[r313]).map(function(t944) {
                    return "string" != typeof t944 && t944.at ? t944.at(s370.ease(e718.pos), e718.pos) : t944;
                }), i557.style.apply(i557, t941);
                if (s370.transforms.length) {
                    t941 = s370.initialTransformation, r313 = 0;
                    for(var o278 = s370.transforms.length; r313 < o278; r313++){
                        var n235 = s370.transforms[r313];
                        n235 instanceof a432.Matrix ? t941 = n235.relative ? t941.multiply((new a432.Matrix).morph(n235).at(s370.ease(this.pos))) : t941.morph(n235).at(s370.ease(this.pos)) : (n235.relative || n235.undo(t941.extract()), t941 = t941.multiply(n235.at(s370.ease(this.pos))));
                    }
                    i557.matrix(t941);
                }
                return this;
            },
            once: function(t945, e719, i558) {
                var a439 = this.last();
                return i558 || (t945 = a439.ease(t945)), a439.once[t945] = e719, this;
            },
            _callStart: function() {
                return setTimeout((function() {
                    this.start();
                }).bind(this), 0), this;
            }
        },
        parent: a432.Element,
        construct: {
            animate: function(t946, e720, i559) {
                return (this.fx || (this.fx = new a432.FX(this))).animate(t946, e720, i559);
            },
            delay: function(t947) {
                return (this.fx || (this.fx = new a432.FX(this))).delay(t947);
            },
            stop: function(t948, e721) {
                return this.fx && this.fx.stop(t948, e721), this;
            },
            finish: function() {
                return this.fx && this.fx.finish(), this;
            }
        }
    }), a432.MorphObj = a432.invent({
        create: function(t949, e722) {
            return a432.Color.isColor(e722) ? new a432.Color(t949).morph(e722) : a432.regex.delimiter.test(t949) ? a432.regex.pathLetters.test(t949) ? new a432.PathArray(t949).morph(e722) : new a432.Array(t949).morph(e722) : a432.regex.numberAndUnit.test(e722) ? new a432.Number(t949).morph(e722) : (this.value = t949, void (this.destination = e722));
        },
        extend: {
            at: function(t, e723) {
                return e723 < 1 ? this.value : this.destination;
            },
            valueOf: function() {
                return this.value;
            }
        }
    }), a432.extend(a432.FX, {
        attr: function(t950, e724, a) {
            if ("object" === i(t950)) for(var s371 in t950)this.attr(s371, t950[s371]);
            else this.add(t950, e724, "attrs");
            return this;
        },
        plot: function(t951, e725, i560, a440) {
            return 4 == arguments.length ? this.plot([
                t951,
                e725,
                i560,
                a440
            ]) : this.add("plot", new (this.target()).morphArray(t951));
        }
    }), a432.Box = a432.invent({
        create: function(t952, e726, s372, r314) {
            if (!("object" !== i(t952) || t952 instanceof a432.Element)) return a432.Box.call(this, null != t952.left ? t952.left : t952.x, null != t952.top ? t952.top : t952.y, t952.width, t952.height);
            4 == arguments.length && (this.x = t952, this.y = e726, this.width = s372, this.height = r314), b60(this);
        }
    }), a432.BBox = a432.invent({
        create: function(t953) {
            if (a432.Box.apply(this, [].slice.call(arguments)), t953 instanceof a432.Element) {
                var i561;
                try {
                    if (!e672.documentElement.contains) {
                        for(var s373 = t953.node; s373.parentNode;)s373 = s373.parentNode;
                        if (s373 != e672) throw new Error("Element not in the dom");
                    }
                    i561 = t953.node.getBBox();
                } catch (e) {
                    if (t953 instanceof a432.Shape) {
                        a432.parser.draw || a432.prepare();
                        var r315 = t953.clone(a432.parser.draw.instance).show();
                        r315 && r315.node && "function" == typeof r315.node.getBBox && (i561 = r315.node.getBBox()), r315 && "function" == typeof r315.remove && r315.remove();
                    } else i561 = {
                        x: t953.node.clientLeft,
                        y: t953.node.clientTop,
                        width: t953.node.clientWidth,
                        height: t953.node.clientHeight
                    };
                }
                a432.Box.call(this, i561);
            }
        },
        inherit: a432.Box,
        parent: a432.Element,
        construct: {
            bbox: function() {
                return new a432.BBox(this);
            }
        }
    }), a432.BBox.prototype.constructor = a432.BBox, a432.Matrix = a432.invent({
        create: function(t954) {
            var e727 = f71([
                1,
                0,
                0,
                1,
                0,
                0
            ]);
            t954 = null === t954 ? e727 : t954 instanceof a432.Element ? t954.matrixify() : "string" == typeof t954 ? f71(t954.split(a432.regex.delimiter).map(parseFloat)) : 6 == arguments.length ? f71([].slice.call(arguments)) : Array.isArray(t954) ? f71(t954) : t954 && "object" === i(t954) ? t954 : e727;
            for(var s374 = m22.length - 1; s374 >= 0; --s374)this[m22[s374]] = null != t954[m22[s374]] ? t954[m22[s374]] : e727[m22[s374]];
        },
        extend: {
            extract: function() {
                var t955 = p77(this, 0, 1);
                p77(this, 1, 0);
                var e728 = 180 / Math.PI * Math.atan2(t955.y, t955.x) - 90;
                return {
                    x: this.e,
                    y: this.f,
                    transformedX: (this.e * Math.cos(e728 * Math.PI / 180) + this.f * Math.sin(e728 * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),
                    transformedY: (this.f * Math.cos(e728 * Math.PI / 180) + this.e * Math.sin(-e728 * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d),
                    rotation: e728,
                    a: this.a,
                    b: this.b,
                    c: this.c,
                    d: this.d,
                    e: this.e,
                    f: this.f,
                    matrix: new a432.Matrix(this)
                };
            },
            clone: function() {
                return new a432.Matrix(this);
            },
            morph: function(t956) {
                return this.destination = new a432.Matrix(t956), this;
            },
            multiply: function(t957) {
                return new a432.Matrix(this.native().multiply((function(t958) {
                    return t958 instanceof a432.Matrix || (t958 = new a432.Matrix(t958)), t958;
                })(t957).native()));
            },
            inverse: function() {
                return new a432.Matrix(this.native().inverse());
            },
            translate: function(t959, e729) {
                return new a432.Matrix(this.native().translate(t959 || 0, e729 || 0));
            },
            native: function() {
                for(var t960 = a432.parser.native.createSVGMatrix(), e730 = m22.length - 1; e730 >= 0; e730--)t960[m22[e730]] = this[m22[e730]];
                return t960;
            },
            toString: function() {
                return "matrix(" + v46(this.a) + "," + v46(this.b) + "," + v46(this.c) + "," + v46(this.d) + "," + v46(this.e) + "," + v46(this.f) + ")";
            }
        },
        parent: a432.Element,
        construct: {
            ctm: function() {
                return new a432.Matrix(this.node.getCTM());
            },
            screenCTM: function() {
                if (this instanceof a432.Nested) {
                    var t961 = this.rect(1, 1), e731 = t961.node.getScreenCTM();
                    return t961.remove(), new a432.Matrix(e731);
                }
                return new a432.Matrix(this.node.getScreenCTM());
            }
        }
    }), a432.Point = a432.invent({
        create: function(t962, e732) {
            var a441;
            a441 = Array.isArray(t962) ? {
                x: t962[0],
                y: t962[1]
            } : "object" === i(t962) ? {
                x: t962.x,
                y: t962.y
            } : null != t962 ? {
                x: t962,
                y: null != e732 ? e732 : t962
            } : {
                x: 0,
                y: 0
            }, this.x = a441.x, this.y = a441.y;
        },
        extend: {
            clone: function() {
                return new a432.Point(this);
            },
            morph: function(t963, e733) {
                return this.destination = new a432.Point(t963, e733), this;
            }
        }
    }), a432.extend(a432.Element, {
        point: function(t964, e734) {
            return new a432.Point(t964, e734).transform(this.screenCTM().inverse());
        }
    }), a432.extend(a432.Element, {
        attr: function(t965, e735, s375) {
            if (null == t965) {
                for(t965 = {}, s375 = (e735 = this.node.attributes).length - 1; s375 >= 0; s375--)t965[e735[s375].nodeName] = a432.regex.isNumber.test(e735[s375].nodeValue) ? parseFloat(e735[s375].nodeValue) : e735[s375].nodeValue;
                return t965;
            }
            if ("object" === i(t965)) for(var r316 in t965)this.attr(r316, t965[r316]);
            else if (null === e735) this.node.removeAttribute(t965);
            else {
                if (null == e735) return null == (e735 = this.node.getAttribute(t965)) ? a432.defaults.attrs[t965] : a432.regex.isNumber.test(e735) ? parseFloat(e735) : e735;
                "stroke-width" == t965 ? this.attr("stroke", parseFloat(e735) > 0 ? this._stroke : null) : "stroke" == t965 && (this._stroke = e735), "fill" != t965 && "stroke" != t965 || (a432.regex.isImage.test(e735) && (e735 = this.doc().defs().image(e735, 0, 0)), e735 instanceof a432.Image && (e735 = this.doc().defs().pattern(0, 0, function() {
                    this.add(e735);
                }))), "number" == typeof e735 ? e735 = new a432.Number(e735) : a432.Color.isColor(e735) ? e735 = new a432.Color(e735) : Array.isArray(e735) && (e735 = new a432.Array(e735)), "leading" == t965 ? this.leading && this.leading(e735) : "string" == typeof s375 ? this.node.setAttributeNS(s375, t965, e735.toString()) : this.node.setAttribute(t965, e735.toString()), !this.rebuild || "font-size" != t965 && "x" != t965 || this.rebuild(t965, e735);
            }
            return this;
        }
    }), a432.extend(a432.Element, {
        transform: function(t966, e736) {
            var s376;
            return "object" !== i(t966) ? (s376 = new a432.Matrix(this).extract(), "string" == typeof t966 ? s376[t966] : s376) : (s376 = new a432.Matrix(this), e736 = !!e736 || !!t966.relative, null != t966.a && (s376 = e736 ? s376.multiply(new a432.Matrix(t966)) : new a432.Matrix(t966)), this.attr("transform", s376));
        }
    }), a432.extend(a432.Element, {
        untransform: function() {
            return this.attr("transform", null);
        },
        matrixify: function() {
            return (this.attr("transform") || "").split(a432.regex.transforms).slice(0, -1).map(function(t967) {
                var e737 = t967.trim().split("(");
                return [
                    e737[0],
                    e737[1].split(a432.regex.delimiter).map(function(t968) {
                        return parseFloat(t968);
                    })
                ];
            }).reduce(function(t969, e738) {
                return "matrix" == e738[0] ? t969.multiply(f71(e738[1])) : t969[e738[0]].apply(t969, e738[1]);
            }, new a432.Matrix);
        },
        toParent: function(t970) {
            if (this == t970) return this;
            var e739 = this.screenCTM(), i562 = t970.screenCTM().inverse();
            return this.addTo(t970).untransform().transform(i562.multiply(e739)), this;
        },
        toDoc: function() {
            return this.toParent(this.doc());
        }
    }), a432.Transformation = a432.invent({
        create: function(t971, e740) {
            if (arguments.length > 1 && "boolean" != typeof e740) return this.constructor.call(this, [].slice.call(arguments));
            if (Array.isArray(t971)) for(var a442 = 0, s377 = this.arguments.length; a442 < s377; ++a442)this[this.arguments[a442]] = t971[a442];
            else if (t971 && "object" === i(t971)) for(a442 = 0, s377 = this.arguments.length; a442 < s377; ++a442)this[this.arguments[a442]] = t971[this.arguments[a442]];
            this.inversed = !1, !0 === e740 && (this.inversed = !0);
        }
    }), a432.Translate = a432.invent({
        parent: a432.Matrix,
        inherit: a432.Transformation,
        create: function(t, e) {
            this.constructor.apply(this, [].slice.call(arguments));
        },
        extend: {
            arguments: [
                "transformedX",
                "transformedY"
            ],
            method: "translate"
        }
    }), a432.extend(a432.Element, {
        style: function(t972, e741) {
            if (0 == arguments.length) return this.node.style.cssText || "";
            if (arguments.length < 2) {
                if ("object" === i(t972)) for(var s378 in t972)this.style(s378, t972[s378]);
                else {
                    if (!a432.regex.isCss.test(t972)) return this.node.style[c147(t972)];
                    for(t972 = t972.split(/\s*;\s*/).filter(function(t973) {
                        return !!t973;
                    }).map(function(t974) {
                        return t974.split(/\s*:\s*/);
                    }); e741 = t972.pop();)this.style(e741[0], e741[1]);
                }
            } else this.node.style[c147(t972)] = null === e741 || a432.regex.isBlank.test(e741) ? "" : e741;
            return this;
        }
    }), a432.Parent = a432.invent({
        create: function(t975) {
            this.constructor.call(this, t975);
        },
        inherit: a432.Element,
        extend: {
            children: function() {
                return a432.utils.map(a432.utils.filterSVGElements(this.node.childNodes), function(t976) {
                    return a432.adopt(t976);
                });
            },
            add: function(t977, e742) {
                return null == e742 ? this.node.appendChild(t977.node) : t977.node != this.node.childNodes[e742] && this.node.insertBefore(t977.node, this.node.childNodes[e742]), this;
            },
            put: function(t978, e743) {
                return this.add(t978, e743), t978;
            },
            has: function(t979) {
                return this.index(t979) >= 0;
            },
            index: function(t980) {
                return [].slice.call(this.node.childNodes).indexOf(t980.node);
            },
            get: function(t981) {
                return a432.adopt(this.node.childNodes[t981]);
            },
            first: function() {
                return this.get(0);
            },
            last: function() {
                return this.get(this.node.childNodes.length - 1);
            },
            each: function(t982, e744) {
                for(var i563 = this.children(), s379 = 0, r317 = i563.length; s379 < r317; s379++)i563[s379] instanceof a432.Element && t982.apply(i563[s379], [
                    s379,
                    i563
                ]), e744 && i563[s379] instanceof a432.Container && i563[s379].each(t982, e744);
                return this;
            },
            removeElement: function(t983) {
                return this.node.removeChild(t983.node), this;
            },
            clear: function() {
                for(; this.node.hasChildNodes();)this.node.removeChild(this.node.lastChild);
                return delete this._defs, this;
            },
            defs: function() {
                return this.doc().defs();
            }
        }
    }), a432.extend(a432.Parent, {
        ungroup: function(t984, e745) {
            return 0 === e745 || this instanceof a432.Defs || this.node == a432.parser.draw || (t984 = t984 || (this instanceof a432.Doc ? this : this.parent(a432.Parent)), e745 = e745 || 1 / 0, this.each(function() {
                return this instanceof a432.Defs ? this : this instanceof a432.Parent ? this.ungroup(t984, e745 - 1) : this.toParent(t984);
            }), this.node.firstChild || this.remove()), this;
        },
        flatten: function(t985, e746) {
            return this.ungroup(t985, e746);
        }
    }), a432.Container = a432.invent({
        create: function(t986) {
            this.constructor.call(this, t986);
        },
        inherit: a432.Parent
    }), a432.ViewBox = a432.invent({
        parent: a432.Container,
        construct: {}
    }), [
        "click",
        "dblclick",
        "mousedown",
        "mouseup",
        "mouseover",
        "mouseout",
        "mousemove",
        "touchstart",
        "touchmove",
        "touchleave",
        "touchend",
        "touchcancel"
    ].forEach(function(t987) {
        a432.Element.prototype[t987] = function(e747) {
            return a432.on(this.node, t987, e747), this;
        };
    }), a432.listeners = [], a432.handlerMap = [], a432.listenerId = 0, a432.on = function(t988, e748, i564, s380, r318) {
        var o279 = i564.bind(s380 || t988.instance || t988), n236 = (a432.handlerMap.indexOf(t988) + 1 || a432.handlerMap.push(t988)) - 1, l200 = e748.split(".")[0], h173 = e748.split(".")[1] || "*";
        a432.listeners[n236] = a432.listeners[n236] || {}, a432.listeners[n236][l200] = a432.listeners[n236][l200] || {}, a432.listeners[n236][l200][h173] = a432.listeners[n236][l200][h173] || {}, i564._svgjsListenerId || (i564._svgjsListenerId = ++a432.listenerId), a432.listeners[n236][l200][h173][i564._svgjsListenerId] = o279, t988.addEventListener(l200, o279, r318 || {
            passive: !0
        });
    }, a432.off = function(t989, e749, i565) {
        var s381 = a432.handlerMap.indexOf(t989), r319 = e749 && e749.split(".")[0], o280 = e749 && e749.split(".")[1], n237 = "";
        if (-1 != s381) {
            if (i565) {
                if ("function" == typeof i565 && (i565 = i565._svgjsListenerId), !i565) return;
                a432.listeners[s381][r319] && a432.listeners[s381][r319][o280 || "*"] && (t989.removeEventListener(r319, a432.listeners[s381][r319][o280 || "*"][i565], !1), delete a432.listeners[s381][r319][o280 || "*"][i565]);
            } else if (o280 && r319) {
                if (a432.listeners[s381][r319] && a432.listeners[s381][r319][o280]) {
                    for(var l201 in a432.listeners[s381][r319][o280])a432.off(t989, [
                        r319,
                        o280
                    ].join("."), l201);
                    delete a432.listeners[s381][r319][o280];
                }
            } else if (o280) for(var h174 in a432.listeners[s381])for(var n237 in a432.listeners[s381][h174])o280 === n237 && a432.off(t989, [
                h174,
                o280
            ].join("."));
            else if (r319) {
                if (a432.listeners[s381][r319]) {
                    for(var n237 in a432.listeners[s381][r319])a432.off(t989, [
                        r319,
                        n237
                    ].join("."));
                    delete a432.listeners[s381][r319];
                }
            } else {
                for(var h174 in a432.listeners[s381])a432.off(t989, h174);
                delete a432.listeners[s381], delete a432.handlerMap[s381];
            }
        }
    }, a432.extend(a432.Element, {
        on: function(t990, e750, i566, s382) {
            return a432.on(this.node, t990, e750, i566, s382), this;
        },
        off: function(t991, e751) {
            return a432.off(this.node, t991, e751), this;
        },
        fire: function(e752, i567) {
            return e752 instanceof t856.Event ? this.node.dispatchEvent(e752) : this.node.dispatchEvent(e752 = new a432.CustomEvent(e752, {
                detail: i567,
                cancelable: !0
            })), this._event = e752, this;
        },
        event: function() {
            return this._event;
        }
    }), a432.Defs = a432.invent({
        create: "defs",
        inherit: a432.Container
    }), a432.G = a432.invent({
        create: "g",
        inherit: a432.Container,
        extend: {
            x: function(t992) {
                return null == t992 ? this.transform("x") : this.transform({
                    x: t992 - this.x()
                }, !0);
            }
        },
        construct: {
            group: function() {
                return this.put(new a432.G);
            }
        }
    }), a432.Doc = a432.invent({
        create: function(t993) {
            t993 && ("svg" == (t993 = "string" == typeof t993 ? e672.getElementById(t993) : t993).nodeName ? this.constructor.call(this, t993) : (this.constructor.call(this, a432.create("svg")), t993.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs());
        },
        inherit: a432.Container,
        extend: {
            namespace: function() {
                return this.attr({
                    xmlns: a432.ns,
                    version: "1.1"
                }).attr("xmlns:xlink", a432.xlink, a432.xmlns).attr("xmlns:svgjs", a432.svgjs, a432.xmlns);
            },
            defs: function() {
                var t994;
                return this._defs || ((t994 = this.node.getElementsByTagName("defs")[0]) ? this._defs = a432.adopt(t994) : this._defs = new a432.Defs, this.node.appendChild(this._defs.node)), this._defs;
            },
            parent: function() {
                return this.node.parentNode && "#document" != this.node.parentNode.nodeName ? this.node.parentNode : null;
            },
            remove: function() {
                return this.parent() && this.parent().removeChild(this.node), this;
            },
            clear: function() {
                for(; this.node.hasChildNodes();)this.node.removeChild(this.node.lastChild);
                return delete this._defs, a432.parser.draw && !a432.parser.draw.parentNode && this.node.appendChild(a432.parser.draw), this;
            },
            clone: function(t995) {
                this.writeDataToDom();
                var e753 = this.node, i568 = x43(e753.cloneNode(!0));
                return t995 ? (t995.node || t995).appendChild(i568.node) : e753.parentNode.insertBefore(i568.node, e753.nextSibling), i568;
            }
        }
    }), a432.extend(a432.Element, {}), a432.Gradient = a432.invent({
        create: function(t996) {
            this.constructor.call(this, a432.create(t996 + "Gradient")), this.type = t996;
        },
        inherit: a432.Container,
        extend: {
            at: function(t997, e754, i569) {
                return this.put(new a432.Stop).update(t997, e754, i569);
            },
            update: function(t998) {
                return this.clear(), "function" == typeof t998 && t998.call(this, this), this;
            },
            fill: function() {
                return "url(#" + this.id() + ")";
            },
            toString: function() {
                return this.fill();
            },
            attr: function(t999, e755, i570) {
                return "transform" == t999 && (t999 = "gradientTransform"), a432.Container.prototype.attr.call(this, t999, e755, i570);
            }
        },
        construct: {
            gradient: function(t1000, e756) {
                return this.defs().gradient(t1000, e756);
            }
        }
    }), a432.extend(a432.Gradient, a432.FX, {
        from: function(t1001, e757) {
            return "radial" == (this._target || this).type ? this.attr({
                fx: new a432.Number(t1001),
                fy: new a432.Number(e757)
            }) : this.attr({
                x1: new a432.Number(t1001),
                y1: new a432.Number(e757)
            });
        },
        to: function(t1002, e758) {
            return "radial" == (this._target || this).type ? this.attr({
                cx: new a432.Number(t1002),
                cy: new a432.Number(e758)
            }) : this.attr({
                x2: new a432.Number(t1002),
                y2: new a432.Number(e758)
            });
        }
    }), a432.extend(a432.Defs, {
        gradient: function(t1003, e759) {
            return this.put(new a432.Gradient(t1003)).update(e759);
        }
    }), a432.Stop = a432.invent({
        create: "stop",
        inherit: a432.Element,
        extend: {
            update: function(t1004) {
                return ("number" == typeof t1004 || t1004 instanceof a432.Number) && (t1004 = {
                    offset: arguments[0],
                    color: arguments[1],
                    opacity: arguments[2]
                }), null != t1004.opacity && this.attr("stop-opacity", t1004.opacity), null != t1004.color && this.attr("stop-color", t1004.color), null != t1004.offset && this.attr("offset", new a432.Number(t1004.offset)), this;
            }
        }
    }), a432.Pattern = a432.invent({
        create: "pattern",
        inherit: a432.Container,
        extend: {
            fill: function() {
                return "url(#" + this.id() + ")";
            },
            update: function(t1005) {
                return this.clear(), "function" == typeof t1005 && t1005.call(this, this), this;
            },
            toString: function() {
                return this.fill();
            },
            attr: function(t1006, e760, i571) {
                return "transform" == t1006 && (t1006 = "patternTransform"), a432.Container.prototype.attr.call(this, t1006, e760, i571);
            }
        },
        construct: {
            pattern: function(t1007, e761, i572) {
                return this.defs().pattern(t1007, e761, i572);
            }
        }
    }), a432.extend(a432.Defs, {
        pattern: function(t1008, e762, i573) {
            return this.put(new a432.Pattern).update(i573).attr({
                x: 0,
                y: 0,
                width: t1008,
                height: e762,
                patternUnits: "userSpaceOnUse"
            });
        }
    }), a432.Shape = a432.invent({
        create: function(t1009) {
            this.constructor.call(this, t1009);
        },
        inherit: a432.Element
    }), a432.Symbol = a432.invent({
        create: "symbol",
        inherit: a432.Container,
        construct: {
            symbol: function() {
                return this.put(new a432.Symbol);
            }
        }
    }), a432.Use = a432.invent({
        create: "use",
        inherit: a432.Shape,
        extend: {
            element: function(t1010, e763) {
                return this.attr("href", (e763 || "") + "#" + t1010, a432.xlink);
            }
        },
        construct: {
            use: function(t1011, e764) {
                return this.put(new a432.Use).element(t1011, e764);
            }
        }
    }), a432.Rect = a432.invent({
        create: "rect",
        inherit: a432.Shape,
        construct: {
            rect: function(t1012, e765) {
                return this.put(new a432.Rect).size(t1012, e765);
            }
        }
    }), a432.Circle = a432.invent({
        create: "circle",
        inherit: a432.Shape,
        construct: {
            circle: function(t1013) {
                return this.put(new a432.Circle).rx(new a432.Number(t1013).divide(2)).move(0, 0);
            }
        }
    }), a432.extend(a432.Circle, a432.FX, {
        rx: function(t1014) {
            return this.attr("r", t1014);
        },
        ry: function(t1015) {
            return this.rx(t1015);
        }
    }), a432.Ellipse = a432.invent({
        create: "ellipse",
        inherit: a432.Shape,
        construct: {
            ellipse: function(t1016, e766) {
                return this.put(new a432.Ellipse).size(t1016, e766).move(0, 0);
            }
        }
    }), a432.extend(a432.Ellipse, a432.Rect, a432.FX, {
        rx: function(t1017) {
            return this.attr("rx", t1017);
        },
        ry: function(t1018) {
            return this.attr("ry", t1018);
        }
    }), a432.extend(a432.Circle, a432.Ellipse, {
        x: function(t1019) {
            return null == t1019 ? this.cx() - this.rx() : this.cx(t1019 + this.rx());
        },
        y: function(t1020) {
            return null == t1020 ? this.cy() - this.ry() : this.cy(t1020 + this.ry());
        },
        cx: function(t1021) {
            return null == t1021 ? this.attr("cx") : this.attr("cx", t1021);
        },
        cy: function(t1022) {
            return null == t1022 ? this.attr("cy") : this.attr("cy", t1022);
        },
        width: function(t1023) {
            return null == t1023 ? 2 * this.rx() : this.rx(new a432.Number(t1023).divide(2));
        },
        height: function(t1024) {
            return null == t1024 ? 2 * this.ry() : this.ry(new a432.Number(t1024).divide(2));
        },
        size: function(t1025, e767) {
            var i574 = u92(this, t1025, e767);
            return this.rx(new a432.Number(i574.width).divide(2)).ry(new a432.Number(i574.height).divide(2));
        }
    }), a432.Line = a432.invent({
        create: "line",
        inherit: a432.Shape,
        extend: {
            array: function() {
                return new a432.PointArray([
                    [
                        this.attr("x1"),
                        this.attr("y1")
                    ],
                    [
                        this.attr("x2"),
                        this.attr("y2")
                    ]
                ]);
            },
            plot: function(t1026, e768, i575, s383) {
                return null == t1026 ? this.array() : (t1026 = void 0 !== e768 ? {
                    x1: t1026,
                    y1: e768,
                    x2: i575,
                    y2: s383
                } : new a432.PointArray(t1026).toLine(), this.attr(t1026));
            },
            move: function(t1027, e769) {
                return this.attr(this.array().move(t1027, e769).toLine());
            },
            size: function(t1028, e770) {
                var i576 = u92(this, t1028, e770);
                return this.attr(this.array().size(i576.width, i576.height).toLine());
            }
        },
        construct: {
            line: function(t1029, e771, i577, s384) {
                return a432.Line.prototype.plot.apply(this.put(new a432.Line), null != t1029 ? [
                    t1029,
                    e771,
                    i577,
                    s384
                ] : [
                    0,
                    0,
                    0,
                    0
                ]);
            }
        }
    }), a432.Polyline = a432.invent({
        create: "polyline",
        inherit: a432.Shape,
        construct: {
            polyline: function(t1030) {
                return this.put(new a432.Polyline).plot(t1030 || new a432.PointArray);
            }
        }
    }), a432.Polygon = a432.invent({
        create: "polygon",
        inherit: a432.Shape,
        construct: {
            polygon: function(t1031) {
                return this.put(new a432.Polygon).plot(t1031 || new a432.PointArray);
            }
        }
    }), a432.extend(a432.Polyline, a432.Polygon, {
        array: function() {
            return this._array || (this._array = new a432.PointArray(this.attr("points")));
        },
        plot: function(t1032) {
            return null == t1032 ? this.array() : this.clear().attr("points", "string" == typeof t1032 ? t1032 : this._array = new a432.PointArray(t1032));
        },
        clear: function() {
            return delete this._array, this;
        },
        move: function(t1033, e772) {
            return this.attr("points", this.array().move(t1033, e772));
        },
        size: function(t1034, e773) {
            var i578 = u92(this, t1034, e773);
            return this.attr("points", this.array().size(i578.width, i578.height));
        }
    }), a432.extend(a432.Line, a432.Polyline, a432.Polygon, {
        morphArray: a432.PointArray,
        x: function(t1035) {
            return null == t1035 ? this.bbox().x : this.move(t1035, this.bbox().y);
        },
        y: function(t1036) {
            return null == t1036 ? this.bbox().y : this.move(this.bbox().x, t1036);
        },
        width: function(t1037) {
            var e774 = this.bbox();
            return null == t1037 ? e774.width : this.size(t1037, e774.height);
        },
        height: function(t1038) {
            var e775 = this.bbox();
            return null == t1038 ? e775.height : this.size(e775.width, t1038);
        }
    }), a432.Path = a432.invent({
        create: "path",
        inherit: a432.Shape,
        extend: {
            morphArray: a432.PathArray,
            array: function() {
                return this._array || (this._array = new a432.PathArray(this.attr("d")));
            },
            plot: function(t1039) {
                return null == t1039 ? this.array() : this.clear().attr("d", "string" == typeof t1039 ? t1039 : this._array = new a432.PathArray(t1039));
            },
            clear: function() {
                return delete this._array, this;
            }
        },
        construct: {
            path: function(t1040) {
                return this.put(new a432.Path).plot(t1040 || new a432.PathArray);
            }
        }
    }), a432.Image = a432.invent({
        create: "image",
        inherit: a432.Shape,
        extend: {
            load: function(e776) {
                if (!e776) return this;
                var i579 = this, s385 = new t856.Image;
                return a432.on(s385, "load", function() {
                    a432.off(s385);
                    var t1041 = i579.parent(a432.Pattern);
                    null !== t1041 && (0 == i579.width() && 0 == i579.height() && i579.size(s385.width, s385.height), t1041 && 0 == t1041.width() && 0 == t1041.height() && t1041.size(i579.width(), i579.height()), "function" == typeof i579._loaded && i579._loaded.call(i579, {
                        width: s385.width,
                        height: s385.height,
                        ratio: s385.width / s385.height,
                        url: e776
                    }));
                }), a432.on(s385, "error", function(t1042) {
                    a432.off(s385), "function" == typeof i579._error && i579._error.call(i579, t1042);
                }), this.attr("href", s385.src = this.src = e776, a432.xlink);
            },
            loaded: function(t1043) {
                return this._loaded = t1043, this;
            },
            error: function(t1044) {
                return this._error = t1044, this;
            }
        },
        construct: {
            image: function(t1045, e777, i580) {
                return this.put(new a432.Image).load(t1045).size(e777 || 0, i580 || e777 || 0);
            }
        }
    }), a432.Text = a432.invent({
        create: function() {
            this.constructor.call(this, a432.create("text")), this.dom.leading = new a432.Number(1.3), this._rebuild = !0, this._build = !1, this.attr("font-family", a432.defaults.attrs["font-family"]);
        },
        inherit: a432.Shape,
        extend: {
            x: function(t1046) {
                return null == t1046 ? this.attr("x") : this.attr("x", t1046);
            },
            text: function(t1047) {
                if (void 0 === t1047) {
                    t1047 = "";
                    for(var e778 = this.node.childNodes, i581 = 0, s386 = e778.length; i581 < s386; ++i581)0 != i581 && 3 != e778[i581].nodeType && 1 == a432.adopt(e778[i581]).dom.newLined && (t1047 += "\n"), t1047 += e778[i581].textContent;
                    return t1047;
                }
                if (this.clear().build(!0), "function" == typeof t1047) t1047.call(this, this);
                else {
                    i581 = 0;
                    for(var r320 = (t1047 = t1047.split("\n")).length; i581 < r320; i581++)this.tspan(t1047[i581]).newLine();
                }
                return this.build(!1).rebuild();
            },
            size: function(t1048) {
                return this.attr("font-size", t1048).rebuild();
            },
            leading: function(t1049) {
                return null == t1049 ? this.dom.leading : (this.dom.leading = new a432.Number(t1049), this.rebuild());
            },
            lines: function() {
                var t1050 = (this.textPath && this.textPath() || this).node, e779 = a432.utils.map(a432.utils.filterSVGElements(t1050.childNodes), function(t1051) {
                    return a432.adopt(t1051);
                });
                return new a432.Set(e779);
            },
            rebuild: function(t1052) {
                if ("boolean" == typeof t1052 && (this._rebuild = t1052), this._rebuild) {
                    var e780 = this, i582 = 0, s387 = this.dom.leading * new a432.Number(this.attr("font-size"));
                    this.lines().each(function() {
                        this.dom.newLined && (e780.textPath() || this.attr("x", e780.attr("x")), "\n" == this.text() ? i582 += s387 : (this.attr("dy", s387 + i582), i582 = 0));
                    }), this.fire("rebuild");
                }
                return this;
            },
            build: function(t1053) {
                return this._build = !!t1053, this;
            },
            setData: function(t1054) {
                return this.dom = t1054, this.dom.leading = new a432.Number(t1054.leading || 1.3), this;
            }
        },
        construct: {
            text: function(t1055) {
                return this.put(new a432.Text).text(t1055);
            },
            plain: function(t1056) {
                return this.put(new a432.Text).plain(t1056);
            }
        }
    }), a432.Tspan = a432.invent({
        create: "tspan",
        inherit: a432.Shape,
        extend: {
            text: function(t1057) {
                return null == t1057 ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof t1057 ? t1057.call(this, this) : this.plain(t1057), this);
            },
            dx: function(t1058) {
                return this.attr("dx", t1058);
            },
            dy: function(t1059) {
                return this.attr("dy", t1059);
            },
            newLine: function() {
                var t1060 = this.parent(a432.Text);
                return this.dom.newLined = !0, this.dy(t1060.dom.leading * t1060.attr("font-size")).attr("x", t1060.x());
            }
        }
    }), a432.extend(a432.Text, a432.Tspan, {
        plain: function(t1061) {
            return !1 === this._build && this.clear(), this.node.appendChild(e672.createTextNode(t1061)), this;
        },
        tspan: function(t1062) {
            var e781 = (this.textPath && this.textPath() || this).node, i583 = new a432.Tspan;
            return !1 === this._build && this.clear(), e781.appendChild(i583.node), i583.text(t1062);
        },
        clear: function() {
            for(var t1063 = (this.textPath && this.textPath() || this).node; t1063.hasChildNodes();)t1063.removeChild(t1063.lastChild);
            return this;
        },
        length: function() {
            return this.node.getComputedTextLength();
        }
    }), a432.TextPath = a432.invent({
        create: "textPath",
        inherit: a432.Parent,
        parent: a432.Text,
        construct: {
            morphArray: a432.PathArray,
            array: function() {
                var t1064 = this.track();
                return t1064 ? t1064.array() : null;
            },
            plot: function(t1065) {
                var e782 = this.track(), i584 = null;
                return e782 && (i584 = e782.plot(t1065)), null == t1065 ? i584 : this;
            },
            track: function() {
                var t1066 = this.textPath();
                if (t1066) return t1066.reference("href");
            },
            textPath: function() {
                if (this.node.firstChild && "textPath" == this.node.firstChild.nodeName) return a432.adopt(this.node.firstChild);
            }
        }
    }), a432.Nested = a432.invent({
        create: function() {
            this.constructor.call(this, a432.create("svg")), this.style("overflow", "visible");
        },
        inherit: a432.Container,
        construct: {
            nested: function() {
                return this.put(new a432.Nested);
            }
        }
    });
    var l197 = {
        stroke: [
            "color",
            "width",
            "opacity",
            "linecap",
            "linejoin",
            "miterlimit",
            "dasharray",
            "dashoffset"
        ],
        fill: [
            "color",
            "opacity",
            "rule"
        ],
        prefix: function(t1067, e783) {
            return "color" == e783 ? t1067 : t1067 + "-" + e783;
        }
    };
    function h171(t, e, i585, s388) {
        return i585 + s388.replace(a432.regex.dots, " .");
    }
    function c147(t1068) {
        return t1068.toLowerCase().replace(/-(.)/g, function(t, e784) {
            return e784.toUpperCase();
        });
    }
    function d133(t1069) {
        return t1069.charAt(0).toUpperCase() + t1069.slice(1);
    }
    function g111(t1070) {
        var e785 = t1070.toString(16);
        return 1 == e785.length ? "0" + e785 : e785;
    }
    function u92(t1071, e786, i586) {
        if (null == e786 || null == i586) {
            var a443 = t1071.bbox();
            null == e786 ? e786 = a443.width / a443.height * i586 : null == i586 && (i586 = a443.height / a443.width * e786);
        }
        return {
            width: e786,
            height: i586
        };
    }
    function p77(t1072, e787, i587) {
        return {
            x: e787 * t1072.a + i587 * t1072.c + 0,
            y: e787 * t1072.b + i587 * t1072.d + 0
        };
    }
    function f71(t1073) {
        return {
            a: t1073[0],
            b: t1073[1],
            c: t1073[2],
            d: t1073[3],
            e: t1073[4],
            f: t1073[5]
        };
    }
    function x43(e788) {
        for(var i588 = e788.childNodes.length - 1; i588 >= 0; i588--)e788.childNodes[i588] instanceof t856.SVGElement && x43(e788.childNodes[i588]);
        return a432.adopt(e788).id(a432.eid(e788.nodeName));
    }
    function b60(t1074) {
        return null == t1074.x && (t1074.x = 0, t1074.y = 0, t1074.width = 0, t1074.height = 0), t1074.w = t1074.width, t1074.h = t1074.height, t1074.x2 = t1074.x + t1074.width, t1074.y2 = t1074.y + t1074.height, t1074.cx = t1074.x + t1074.width / 2, t1074.cy = t1074.y + t1074.height / 2, t1074;
    }
    function v46(t1075) {
        return Math.abs(t1075) > 1e-37 ? t1075 : 0;
    }
    [
        "fill",
        "stroke"
    ].forEach(function(t1076) {
        var e789 = {};
        e789[t1076] = function(e790) {
            if (void 0 === e790) return this;
            if ("string" == typeof e790 || a432.Color.isRgb(e790) || e790 && "function" == typeof e790.fill) this.attr(t1076, e790);
            else for(var i589 = l197[t1076].length - 1; i589 >= 0; i589--)null != e790[l197[t1076][i589]] && this.attr(l197.prefix(t1076, l197[t1076][i589]), e790[l197[t1076][i589]]);
            return this;
        }, a432.extend(a432.Element, a432.FX, e789);
    }), a432.extend(a432.Element, a432.FX, {
        translate: function(t1077, e791) {
            return this.transform({
                x: t1077,
                y: e791
            });
        },
        matrix: function(t1078) {
            return this.attr("transform", new a432.Matrix(6 == arguments.length ? [].slice.call(arguments) : t1078));
        },
        opacity: function(t1079) {
            return this.attr("opacity", t1079);
        },
        dx: function(t1080) {
            return this.x(new a432.Number(t1080).plus(this instanceof a432.FX ? 0 : this.x()), !0);
        },
        dy: function(t1081) {
            return this.y(new a432.Number(t1081).plus(this instanceof a432.FX ? 0 : this.y()), !0);
        }
    }), a432.extend(a432.Path, {
        length: function() {
            return this.node.getTotalLength();
        },
        pointAt: function(t1082) {
            return this.node.getPointAtLength(t1082);
        }
    }), a432.Set = a432.invent({
        create: function(t1083) {
            Array.isArray(t1083) ? this.members = t1083 : this.clear();
        },
        extend: {
            add: function() {
                for(var t1084 = [].slice.call(arguments), e792 = 0, i590 = t1084.length; e792 < i590; e792++)this.members.push(t1084[e792]);
                return this;
            },
            remove: function(t1085) {
                var e793 = this.index(t1085);
                return e793 > -1 && this.members.splice(e793, 1), this;
            },
            each: function(t1086) {
                for(var e794 = 0, i591 = this.members.length; e794 < i591; e794++)t1086.apply(this.members[e794], [
                    e794,
                    this.members
                ]);
                return this;
            },
            clear: function() {
                return this.members = [], this;
            },
            length: function() {
                return this.members.length;
            },
            has: function(t1087) {
                return this.index(t1087) >= 0;
            },
            index: function(t1088) {
                return this.members.indexOf(t1088);
            },
            get: function(t1089) {
                return this.members[t1089];
            },
            first: function() {
                return this.get(0);
            },
            last: function() {
                return this.get(this.members.length - 1);
            },
            valueOf: function() {
                return this.members;
            }
        },
        construct: {
            set: function(t1090) {
                return new a432.Set(t1090);
            }
        }
    }), a432.FX.Set = a432.invent({
        create: function(t1091) {
            this.set = t1091;
        }
    }), a432.Set.inherit = function() {
        var t1092 = [];
        for(var e795 in a432.Shape.prototype)"function" == typeof a432.Shape.prototype[e795] && "function" != typeof a432.Set.prototype[e795] && t1092.push(e795);
        for(var e795 in t1092.forEach(function(t1093) {
            a432.Set.prototype[t1093] = function() {
                for(var e796 = 0, i592 = this.members.length; e796 < i592; e796++)this.members[e796] && "function" == typeof this.members[e796][t1093] && this.members[e796][t1093].apply(this.members[e796], arguments);
                return "animate" == t1093 ? this.fx || (this.fx = new a432.FX.Set(this)) : this;
            };
        }), t1092 = [], a432.FX.prototype)"function" == typeof a432.FX.prototype[e795] && "function" != typeof a432.FX.Set.prototype[e795] && t1092.push(e795);
        t1092.forEach(function(t1094) {
            a432.FX.Set.prototype[t1094] = function() {
                for(var e797 = 0, i593 = this.set.members.length; e797 < i593; e797++)this.set.members[e797].fx[t1094].apply(this.set.members[e797].fx, arguments);
                return this;
            };
        });
    }, a432.extend(a432.Element, {}), a432.extend(a432.Element, {
        remember: function(t1095, e798) {
            if ("object" === i(arguments[0])) for(var a444 in t1095)this.remember(a444, t1095[a444]);
            else {
                if (1 == arguments.length) return this.memory()[t1095];
                this.memory()[t1095] = e798;
            }
            return this;
        },
        forget: function() {
            if (0 == arguments.length) this._memory = {};
            else for(var t1096 = arguments.length - 1; t1096 >= 0; t1096--)delete this.memory()[arguments[t1096]];
            return this;
        },
        memory: function() {
            return this._memory || (this._memory = {});
        }
    }), a432.get = function(t1097) {
        var i594 = e672.getElementById(function(t1098) {
            var e799 = (t1098 || "").toString().match(a432.regex.reference);
            if (e799) return e799[1];
        }(t1097) || t1097);
        return a432.adopt(i594);
    }, a432.select = function(t1099, i595) {
        return new a432.Set(a432.utils.map((i595 || e672).querySelectorAll(t1099), function(t1100) {
            return a432.adopt(t1100);
        }));
    }, a432.extend(a432.Parent, {
        select: function(t1101) {
            return a432.select(t1101, this.node);
        }
    });
    var m22 = "abcdef".split("");
    if ("function" != typeof t856.CustomEvent) {
        var y44 = function(t1102, i596) {
            i596 = i596 || {
                bubbles: !1,
                cancelable: !1,
                detail: void 0
            };
            var a445 = e672.createEvent("CustomEvent");
            return a445.initCustomEvent(t1102, i596.bubbles, i596.cancelable, i596.detail), a445;
        };
        y44.prototype = t856.Event.prototype, a432.CustomEvent = y44;
    } else a432.CustomEvent = t856.CustomEvent;
    return a432;
}, "function" == typeof define && define.amd ? define(function() {
    return zt(It, It.document);
}) : "object" === i(exports) && true ? module.exports = It.document ? zt(It, It.document) : function(t1103) {
    return zt(t1103, t1103.document);
} : It.SVG = zt(It, It.document), /*! svg.filter.js - v2.0.2 - 2016-02-24
* https://github.com/wout/svg.filter.js
* Copyright (c) 2016 Wout Fierens; Licensed MIT */ (function() {
    SVG.Filter = SVG.invent({
        create: "filter",
        inherit: SVG.Parent,
        extend: {
            source: "SourceGraphic",
            sourceAlpha: "SourceAlpha",
            background: "BackgroundImage",
            backgroundAlpha: "BackgroundAlpha",
            fill: "FillPaint",
            stroke: "StrokePaint",
            autoSetIn: !0,
            put: function(t1105, e801) {
                return this.add(t1105, e801), !t1105.attr("in") && this.autoSetIn && t1105.attr("in", this.source), t1105.attr("result") || t1105.attr("result", t1105), t1105;
            },
            blend: function(t1106, e802, i598) {
                return this.put(new SVG.BlendEffect(t1106, e802, i598));
            },
            colorMatrix: function(t1107, e803) {
                return this.put(new SVG.ColorMatrixEffect(t1107, e803));
            },
            convolveMatrix: function(t1108) {
                return this.put(new SVG.ConvolveMatrixEffect(t1108));
            },
            componentTransfer: function(t1109) {
                return this.put(new SVG.ComponentTransferEffect(t1109));
            },
            composite: function(t1110, e804, i599) {
                return this.put(new SVG.CompositeEffect(t1110, e804, i599));
            },
            flood: function(t1111, e805) {
                return this.put(new SVG.FloodEffect(t1111, e805));
            },
            offset: function(t1112, e806) {
                return this.put(new SVG.OffsetEffect(t1112, e806));
            },
            image: function(t1113) {
                return this.put(new SVG.ImageEffect(t1113));
            },
            merge: function() {
                var t1114 = [
                    void 0
                ];
                for(var e807 in arguments)t1114.push(arguments[e807]);
                return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, t1114)));
            },
            gaussianBlur: function(t1115, e808) {
                return this.put(new SVG.GaussianBlurEffect(t1115, e808));
            },
            morphology: function(t1116, e809) {
                return this.put(new SVG.MorphologyEffect(t1116, e809));
            },
            diffuseLighting: function(t1117, e810, i600) {
                return this.put(new SVG.DiffuseLightingEffect(t1117, e810, i600));
            },
            displacementMap: function(t1118, e811, i601, a447, s390) {
                return this.put(new SVG.DisplacementMapEffect(t1118, e811, i601, a447, s390));
            },
            specularLighting: function(t1119, e812, i602, a448) {
                return this.put(new SVG.SpecularLightingEffect(t1119, e812, i602, a448));
            },
            tile: function() {
                return this.put(new SVG.TileEffect);
            },
            turbulence: function(t1120, e813, i603, a449, s391) {
                return this.put(new SVG.TurbulenceEffect(t1120, e813, i603, a449, s391));
            },
            toString: function() {
                return "url(#" + this.attr("id") + ")";
            }
        }
    }), SVG.extend(SVG.Defs, {
        filter: function(t1121) {
            var e814 = this.put(new SVG.Filter);
            return "function" == typeof t1121 && t1121.call(e814, e814), e814;
        }
    }), SVG.extend(SVG.Container, {
        filter: function(t1122) {
            return this.defs().filter(t1122);
        }
    }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, {
        filter: function(t1123) {
            return this.filterer = t1123 instanceof SVG.Element ? t1123 : this.doc().filter(t1123), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer;
        },
        unfilter: function(t1124) {
            return this.filterer && !0 === t1124 && this.filterer.remove(), delete this.filterer, this.attr("filter", null);
        }
    }), SVG.Effect = SVG.invent({
        create: function() {
            this.constructor.call(this);
        },
        inherit: SVG.Element,
        extend: {
            in: function(t1125) {
                return null == t1125 ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t1125);
            },
            result: function(t1126) {
                return null == t1126 ? this.attr("result") : this.attr("result", t1126);
            },
            toString: function() {
                return this.result();
            }
        }
    }), SVG.ParentEffect = SVG.invent({
        create: function() {
            this.constructor.call(this);
        },
        inherit: SVG.Parent,
        extend: {
            in: function(t1127) {
                return null == t1127 ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t1127);
            },
            result: function(t1128) {
                return null == t1128 ? this.attr("result") : this.attr("result", t1128);
            },
            toString: function() {
                return this.result();
            }
        }
    });
    var t1104 = {
        blend: function(t1129, e815) {
            return this.parent() && this.parent().blend(this, t1129, e815);
        },
        colorMatrix: function(t1130, e816) {
            return this.parent() && this.parent().colorMatrix(t1130, e816).in(this);
        },
        convolveMatrix: function(t1131) {
            return this.parent() && this.parent().convolveMatrix(t1131).in(this);
        },
        componentTransfer: function(t1132) {
            return this.parent() && this.parent().componentTransfer(t1132).in(this);
        },
        composite: function(t1133, e817) {
            return this.parent() && this.parent().composite(this, t1133, e817);
        },
        flood: function(t1134, e818) {
            return this.parent() && this.parent().flood(t1134, e818);
        },
        offset: function(t1135, e819) {
            return this.parent() && this.parent().offset(t1135, e819).in(this);
        },
        image: function(t1136) {
            return this.parent() && this.parent().image(t1136);
        },
        merge: function() {
            return this.parent() && this.parent().merge.apply(this.parent(), [
                this
            ].concat(arguments));
        },
        gaussianBlur: function(t1137, e820) {
            return this.parent() && this.parent().gaussianBlur(t1137, e820).in(this);
        },
        morphology: function(t1138, e821) {
            return this.parent() && this.parent().morphology(t1138, e821).in(this);
        },
        diffuseLighting: function(t1139, e822, i604) {
            return this.parent() && this.parent().diffuseLighting(t1139, e822, i604).in(this);
        },
        displacementMap: function(t1140, e823, i605, a450) {
            return this.parent() && this.parent().displacementMap(this, t1140, e823, i605, a450);
        },
        specularLighting: function(t1141, e824, i606, a451) {
            return this.parent() && this.parent().specularLighting(t1141, e824, i606, a451).in(this);
        },
        tile: function() {
            return this.parent() && this.parent().tile().in(this);
        },
        turbulence: function(t1142, e825, i607, a452, s392) {
            return this.parent() && this.parent().turbulence(t1142, e825, i607, a452, s392).in(this);
        }
    };
    SVG.extend(SVG.Effect, t1104), SVG.extend(SVG.ParentEffect, t1104), SVG.ChildEffect = SVG.invent({
        create: function() {
            this.constructor.call(this);
        },
        inherit: SVG.Element,
        extend: {
            in: function(t1143) {
                this.attr("in", t1143);
            }
        }
    });
    var e800 = {
        blend: function(t1144, e826, i608) {
            this.attr({
                in: t1144,
                in2: e826,
                mode: i608 || "normal"
            });
        },
        colorMatrix: function(t1145, e827) {
            "matrix" == t1145 && (e827 = s389(e827)), this.attr({
                type: t1145,
                values: void 0 === e827 ? null : e827
            });
        },
        convolveMatrix: function(t1146) {
            t1146 = s389(t1146), this.attr({
                order: Math.sqrt(t1146.split(" ").length),
                kernelMatrix: t1146
            });
        },
        composite: function(t1147, e828, i609) {
            this.attr({
                in: t1147,
                in2: e828,
                operator: i609
            });
        },
        flood: function(t1148, e829) {
            this.attr("flood-color", t1148), null != e829 && this.attr("flood-opacity", e829);
        },
        offset: function(t1149, e830) {
            this.attr({
                dx: t1149,
                dy: e830
            });
        },
        image: function(t1150) {
            this.attr("href", t1150, SVG.xlink);
        },
        displacementMap: function(t1151, e831, i610, a453, s393) {
            this.attr({
                in: t1151,
                in2: e831,
                scale: i610,
                xChannelSelector: a453,
                yChannelSelector: s393
            });
        },
        gaussianBlur: function(t1152, e832) {
            null != t1152 || null != e832 ? this.attr("stdDeviation", r321(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0");
        },
        morphology: function(t1153, e833) {
            this.attr({
                operator: t1153,
                radius: e833
            });
        },
        tile: function() {},
        turbulence: function(t1154, e834, i611, a454, s394) {
            this.attr({
                numOctaves: e834,
                seed: i611,
                stitchTiles: a454,
                baseFrequency: t1154,
                type: s394
            });
        }
    }, i597 = {
        merge: function() {
            var t1155;
            if (arguments[0] instanceof SVG.Set) {
                var e835 = this;
                arguments[0].each(function(t) {
                    this instanceof SVG.MergeNode ? e835.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && e835.put(new SVG.MergeNode(this));
                });
            } else {
                t1155 = Array.isArray(arguments[0]) ? arguments[0] : arguments;
                for(var i612 = 0; i612 < t1155.length; i612++)t1155[i612] instanceof SVG.MergeNode ? this.put(t1155[i612]) : this.put(new SVG.MergeNode(t1155[i612]));
            }
        },
        componentTransfer: function(t1156) {
            if (this.rgb = new SVG.Set, [
                "r",
                "g",
                "b",
                "a"
            ].forEach((function(t1157) {
                this[t1157] = new SVG["Func" + t1157.toUpperCase()]("identity"), this.rgb.add(this[t1157]), this.node.appendChild(this[t1157].node);
            }).bind(this)), t1156) for(var e836 in t1156.rgb && ([
                "r",
                "g",
                "b"
            ].forEach((function(e837) {
                this[e837].attr(t1156.rgb);
            }).bind(this)), delete t1156.rgb), t1156)this[e836].attr(t1156[e836]);
        },
        diffuseLighting: function(t1158, e838, i613) {
            this.attr({
                surfaceScale: t1158,
                diffuseConstant: e838,
                kernelUnitLength: i613
            });
        },
        specularLighting: function(t1159, e839, i614, a455) {
            this.attr({
                surfaceScale: t1159,
                diffuseConstant: e839,
                specularExponent: i614,
                kernelUnitLength: a455
            });
        }
    }, a446 = {
        distantLight: function(t1160, e840) {
            this.attr({
                azimuth: t1160,
                elevation: e840
            });
        },
        pointLight: function(t1161, e841, i615) {
            this.attr({
                x: t1161,
                y: e841,
                z: i615
            });
        },
        spotLight: function(t1162, e842, i616, a456, s395, r322) {
            this.attr({
                x: t1162,
                y: e842,
                z: i616,
                pointsAtX: a456,
                pointsAtY: s395,
                pointsAtZ: r322
            });
        },
        mergeNode: function(t1163) {
            this.attr("in", t1163);
        }
    };
    function s389(t1164) {
        return Array.isArray(t1164) && (t1164 = new SVG.Array(t1164)), t1164.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ");
    }
    function r321(t1165) {
        if (!Array.isArray(t1165)) return t1165;
        for(var e843 = 0, i617 = t1165.length, a457 = []; e843 < i617; e843++)a457.push(t1165[e843]);
        return a457.join(" ");
    }
    function o281() {
        var t1166 = function() {};
        for(var e844 in "function" == typeof arguments[arguments.length - 1] && (t1166 = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments)for(var i618 in arguments[e844])t1166(arguments[e844][i618], i618, arguments[e844]);
    }
    [
        "r",
        "g",
        "b",
        "a"
    ].forEach(function(t1167) {
        a446["Func" + t1167.toUpperCase()] = function(t1168) {
            switch(this.attr("type", t1168), t1168){
                case "table":
                    this.attr("tableValues", arguments[1]);
                    break;
                case "linear":
                    this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
                    break;
                case "gamma":
                    this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2]);
            }
        };
    }), o281(e800, function(t1169, e845) {
        var i619 = e845.charAt(0).toUpperCase() + e845.slice(1);
        SVG[i619 + "Effect"] = SVG.invent({
            create: function() {
                this.constructor.call(this, SVG.create("fe" + i619)), t1169.apply(this, arguments), this.result(this.attr("id") + "Out");
            },
            inherit: SVG.Effect,
            extend: {}
        });
    }), o281(i597, function(t1170, e846) {
        var i620 = e846.charAt(0).toUpperCase() + e846.slice(1);
        SVG[i620 + "Effect"] = SVG.invent({
            create: function() {
                this.constructor.call(this, SVG.create("fe" + i620)), t1170.apply(this, arguments), this.result(this.attr("id") + "Out");
            },
            inherit: SVG.ParentEffect,
            extend: {}
        });
    }), o281(a446, function(t1171, e847) {
        var i621 = e847.charAt(0).toUpperCase() + e847.slice(1);
        SVG[i621] = SVG.invent({
            create: function() {
                this.constructor.call(this, SVG.create("fe" + i621)), t1171.apply(this, arguments);
            },
            inherit: SVG.ChildEffect,
            extend: {}
        });
    }), SVG.extend(SVG.MergeEffect, {
        in: function(t1172) {
            return t1172 instanceof SVG.MergeNode ? this.add(t1172, 0) : this.add(new SVG.MergeNode(t1172), 0), this;
        }
    }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, {
        in2: function(t1173) {
            return null == t1173 ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", t1173);
        }
    }), SVG.filter = {
        sepiatone: [
            .343,
            .669,
            .119,
            0,
            0,
            .249,
            .626,
            .13,
            0,
            0,
            .172,
            .334,
            .111,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    };
}).call(void 0), function() {
    function t1174(t1175, s397, r323, o282, n238, l202, h175) {
        for(var c149 = t1175.slice(s397, r323 || h175), d134 = o282.slice(n238, l202 || h175), g112 = 0, u93 = {
            pos: [
                0,
                0
            ],
            start: [
                0,
                0
            ]
        }, p78 = {
            pos: [
                0,
                0
            ],
            start: [
                0,
                0
            ]
        };;){
            if (c149[g112] = e848.call(u93, c149[g112]), d134[g112] = e848.call(p78, d134[g112]), c149[g112][0] != d134[g112][0] || "M" == c149[g112][0] || "A" == c149[g112][0] && (c149[g112][4] != d134[g112][4] || c149[g112][5] != d134[g112][5]) ? (Array.prototype.splice.apply(c149, [
                g112,
                1
            ].concat(a458.call(u93, c149[g112]))), Array.prototype.splice.apply(d134, [
                g112,
                1
            ].concat(a458.call(p78, d134[g112])))) : (c149[g112] = i622.call(u93, c149[g112]), d134[g112] = i622.call(p78, d134[g112])), ++g112 == c149.length && g112 == d134.length) break;
            g112 == c149.length && c149.push([
                "C",
                u93.pos[0],
                u93.pos[1],
                u93.pos[0],
                u93.pos[1],
                u93.pos[0],
                u93.pos[1]
            ]), g112 == d134.length && d134.push([
                "C",
                p78.pos[0],
                p78.pos[1],
                p78.pos[0],
                p78.pos[1],
                p78.pos[0],
                p78.pos[1]
            ]);
        }
        return {
            start: c149,
            dest: d134
        };
    }
    function e848(t1176) {
        switch(t1176[0]){
            case "z":
            case "Z":
                t1176[0] = "L", t1176[1] = this.start[0], t1176[2] = this.start[1];
                break;
            case "H":
                t1176[0] = "L", t1176[2] = this.pos[1];
                break;
            case "V":
                t1176[0] = "L", t1176[2] = t1176[1], t1176[1] = this.pos[0];
                break;
            case "T":
                t1176[0] = "Q", t1176[3] = t1176[1], t1176[4] = t1176[2], t1176[1] = this.reflection[1], t1176[2] = this.reflection[0];
                break;
            case "S":
                t1176[0] = "C", t1176[6] = t1176[4], t1176[5] = t1176[3], t1176[4] = t1176[2], t1176[3] = t1176[1], t1176[2] = this.reflection[1], t1176[1] = this.reflection[0];
        }
        return t1176;
    }
    function i622(t1177) {
        var e849 = t1177.length;
        return this.pos = [
            t1177[e849 - 2],
            t1177[e849 - 1]
        ], -1 != "SCQT".indexOf(t1177[0]) && (this.reflection = [
            2 * this.pos[0] - t1177[e849 - 4],
            2 * this.pos[1] - t1177[e849 - 3]
        ]), t1177;
    }
    function a458(t1178) {
        var e850 = [
            t1178
        ];
        switch(t1178[0]){
            case "M":
                return this.pos = this.start = [
                    t1178[1],
                    t1178[2]
                ], e850;
            case "L":
                t1178[5] = t1178[3] = t1178[1], t1178[6] = t1178[4] = t1178[2], t1178[1] = this.pos[0], t1178[2] = this.pos[1];
                break;
            case "Q":
                t1178[6] = t1178[4], t1178[5] = t1178[3], t1178[4] = 1 * t1178[4] / 3 + 2 * t1178[2] / 3, t1178[3] = 1 * t1178[3] / 3 + 2 * t1178[1] / 3, t1178[2] = 1 * this.pos[1] / 3 + 2 * t1178[2] / 3, t1178[1] = 1 * this.pos[0] / 3 + 2 * t1178[1] / 3;
                break;
            case "A":
                t1178 = (e850 = function(t1179, e851) {
                    var i623, a459, s398, r324, o283, n239, l203, h176, c150, d135, g113, u94, p79, f72, x44, b61, v47, m23, y45, w37, k33, A26, S17, C16, L15, P14, T9 = Math.abs(e851[1]), M12 = Math.abs(e851[2]), I9 = e851[3] % 360, z7 = e851[4], X4 = e851[5], E3 = e851[6], Y2 = e851[7], F1 = new SVG.Point(t1179), R1 = new SVG.Point(E3, Y2), H1 = [];
                    if (0 === T9 || 0 === M12 || F1.x === R1.x && F1.y === R1.y) return [
                        [
                            "C",
                            F1.x,
                            F1.y,
                            R1.x,
                            R1.y,
                            R1.x,
                            R1.y
                        ]
                    ];
                    i623 = new SVG.Point((F1.x - R1.x) / 2, (F1.y - R1.y) / 2).transform((new SVG.Matrix).rotate(I9)), (a459 = i623.x * i623.x / (T9 * T9) + i623.y * i623.y / (M12 * M12)) > 1 && (T9 *= a459 = Math.sqrt(a459), M12 *= a459);
                    s398 = (new SVG.Matrix).rotate(I9).scale(1 / T9, 1 / M12).rotate(-I9), F1 = F1.transform(s398), R1 = R1.transform(s398), r324 = [
                        R1.x - F1.x,
                        R1.y - F1.y
                    ], n239 = r324[0] * r324[0] + r324[1] * r324[1], o283 = Math.sqrt(n239), r324[0] /= o283, r324[1] /= o283, l203 = n239 < 4 ? Math.sqrt(1 - n239 / 4) : 0, z7 === X4 && (l203 *= -1);
                    h176 = new SVG.Point((R1.x + F1.x) / 2 + l203 * -r324[1], (R1.y + F1.y) / 2 + l203 * r324[0]), c150 = new SVG.Point(F1.x - h176.x, F1.y - h176.y), d135 = new SVG.Point(R1.x - h176.x, R1.y - h176.y), g113 = Math.acos(c150.x / Math.sqrt(c150.x * c150.x + c150.y * c150.y)), c150.y < 0 && (g113 *= -1);
                    u94 = Math.acos(d135.x / Math.sqrt(d135.x * d135.x + d135.y * d135.y)), d135.y < 0 && (u94 *= -1);
                    X4 && g113 > u94 && (u94 += 2 * Math.PI);
                    !X4 && g113 < u94 && (u94 -= 2 * Math.PI);
                    for(f72 = Math.ceil(2 * Math.abs(g113 - u94) / Math.PI), b61 = [], v47 = g113, p79 = (u94 - g113) / f72, x44 = 4 * Math.tan(p79 / 4) / 3, k33 = 0; k33 <= f72; k33++)y45 = Math.cos(v47), m23 = Math.sin(v47), w37 = new SVG.Point(h176.x + y45, h176.y + m23), b61[k33] = [
                        new SVG.Point(w37.x + x44 * m23, w37.y - x44 * y45),
                        w37,
                        new SVG.Point(w37.x - x44 * m23, w37.y + x44 * y45)
                    ], v47 += p79;
                    for(b61[0][0] = b61[0][1].clone(), b61[b61.length - 1][2] = b61[b61.length - 1][1].clone(), s398 = (new SVG.Matrix).rotate(I9).scale(T9, M12).rotate(-I9), k33 = 0, A26 = b61.length; k33 < A26; k33++)b61[k33][0] = b61[k33][0].transform(s398), b61[k33][1] = b61[k33][1].transform(s398), b61[k33][2] = b61[k33][2].transform(s398);
                    for(k33 = 1, A26 = b61.length; k33 < A26; k33++)S17 = (w37 = b61[k33 - 1][2]).x, C16 = w37.y, L15 = (w37 = b61[k33][0]).x, P14 = w37.y, E3 = (w37 = b61[k33][1]).x, Y2 = w37.y, H1.push([
                        "C",
                        S17,
                        C16,
                        L15,
                        P14,
                        E3,
                        Y2
                    ]);
                    return H1;
                }(this.pos, t1178))[0];
        }
        return t1178[0] = "C", this.pos = [
            t1178[5],
            t1178[6]
        ], this.reflection = [
            2 * t1178[5] - t1178[3],
            2 * t1178[6] - t1178[4]
        ], e850;
    }
    function s396(t1180, e852) {
        if (!1 === e852) return !1;
        for(var i624 = e852, a460 = t1180.length; i624 < a460; ++i624)if ("M" == t1180[i624][0]) return i624;
        return !1;
    }
    SVG.extend(SVG.PathArray, {
        morph: function(e853) {
            for(var i625 = this.value, a461 = this.parse(e853), r325 = 0, o284 = 0, n240 = !1, l204 = !1; !1 !== r325 || !1 !== o284;){
                var h177;
                n240 = s396(i625, !1 !== r325 && r325 + 1), l204 = s396(a461, !1 !== o284 && o284 + 1), !1 === r325 && (r325 = 0 == (h177 = new SVG.PathArray(c151.start).bbox()).height || 0 == h177.width ? i625.push(i625[0]) - 1 : i625.push([
                    "M",
                    h177.x + h177.width / 2,
                    h177.y + h177.height / 2
                ]) - 1), !1 === o284 && (o284 = 0 == (h177 = new SVG.PathArray(c151.dest).bbox()).height || 0 == h177.width ? a461.push(a461[0]) - 1 : a461.push([
                    "M",
                    h177.x + h177.width / 2,
                    h177.y + h177.height / 2
                ]) - 1);
                var c151 = t1174(i625, r325, n240, a461, o284, l204);
                i625 = i625.slice(0, r325).concat(c151.start, !1 === n240 ? [] : i625.slice(n240)), a461 = a461.slice(0, o284).concat(c151.dest, !1 === l204 ? [] : a461.slice(l204)), r325 = !1 !== n240 && r325 + c151.start.length, o284 = !1 !== l204 && o284 + c151.dest.length;
            }
            return this.value = i625, this.destination = new SVG.PathArray, this.destination.value = a461, this;
        }
    });
}(), /*! svg.draggable.js - v2.2.2 - 2019-01-08
* https://github.com/svgdotjs/svg.draggable.js
* Copyright (c) 2019 Wout Fierens; Licensed MIT */ (function() {
    function t1181(t1182) {
        t1182.remember("_draggable", this), this.el = t1182;
    }
    t1181.prototype.init = function(t1183, e854) {
        var i626 = this;
        this.constraint = t1183, this.value = e854, this.el.on("mousedown.drag", function(t1184) {
            i626.start(t1184);
        }), this.el.on("touchstart.drag", function(t1185) {
            i626.start(t1185);
        });
    }, t1181.prototype.transformPoint = function(t1186, e855) {
        var i627 = (t1186 = t1186 || window.event).changedTouches && t1186.changedTouches[0] || t1186;
        return this.p.x = i627.clientX - (e855 || 0), this.p.y = i627.clientY, this.p.matrixTransform(this.m);
    }, t1181.prototype.getBBox = function() {
        var t1187 = this.el.bbox();
        return this.el instanceof SVG.Nested && (t1187 = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t1187.x = this.el.x(), t1187.y = this.el.y()), t1187;
    }, t1181.prototype.start = function(t1188) {
        if ("click" != t1188.type && "mousedown" != t1188.type && "mousemove" != t1188.type || 1 == (t1188.which || t1188.buttons)) {
            var e856 = this;
            if (this.el.fire("beforedrag", {
                event: t1188,
                handler: this
            }), !this.el.event().defaultPrevented) {
                t1188.preventDefault(), t1188.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
                var i628, a462 = this.getBBox();
                if (this.el instanceof SVG.Text) switch(i628 = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")){
                    case "middle":
                        i628 /= 2;
                        break;
                    case "start":
                        i628 = 0;
                }
                this.startPoints = {
                    point: this.transformPoint(t1188, i628),
                    box: a462,
                    transform: this.el.transform()
                }, SVG.on(window, "mousemove.drag", function(t1189) {
                    e856.drag(t1189);
                }), SVG.on(window, "touchmove.drag", function(t1190) {
                    e856.drag(t1190);
                }), SVG.on(window, "mouseup.drag", function(t1191) {
                    e856.end(t1191);
                }), SVG.on(window, "touchend.drag", function(t1192) {
                    e856.end(t1192);
                }), this.el.fire("dragstart", {
                    event: t1188,
                    p: this.startPoints.point,
                    m: this.m,
                    handler: this
                });
            }
        }
    }, t1181.prototype.drag = function(t1193) {
        var e857 = this.getBBox(), i629 = this.transformPoint(t1193), a463 = this.startPoints.box.x + i629.x - this.startPoints.point.x, s399 = this.startPoints.box.y + i629.y - this.startPoints.point.y, r326 = this.constraint, o285 = i629.x - this.startPoints.point.x, n241 = i629.y - this.startPoints.point.y;
        if (this.el.fire("dragmove", {
            event: t1193,
            p: i629,
            m: this.m,
            handler: this
        }), this.el.event().defaultPrevented) return i629;
        if ("function" == typeof r326) {
            var l205 = r326.call(this.el, a463, s399, this.m);
            "boolean" == typeof l205 && (l205 = {
                x: l205,
                y: l205
            }), !0 === l205.x ? this.el.x(a463) : !1 !== l205.x && this.el.x(l205.x), !0 === l205.y ? this.el.y(s399) : !1 !== l205.y && this.el.y(l205.y);
        } else "object" == typeof r326 && (null != r326.minX && a463 < r326.minX ? o285 = (a463 = r326.minX) - this.startPoints.box.x : null != r326.maxX && a463 > r326.maxX - e857.width && (o285 = (a463 = r326.maxX - e857.width) - this.startPoints.box.x), null != r326.minY && s399 < r326.minY ? n241 = (s399 = r326.minY) - this.startPoints.box.y : null != r326.maxY && s399 > r326.maxY - e857.height && (n241 = (s399 = r326.maxY - e857.height) - this.startPoints.box.y), null != r326.snapToGrid && (a463 -= a463 % r326.snapToGrid, s399 -= s399 % r326.snapToGrid, o285 -= o285 % r326.snapToGrid, n241 -= n241 % r326.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({
            x: o285,
            y: n241
        }, !0) : this.el.move(a463, s399));
        return i629;
    }, t1181.prototype.end = function(t1194) {
        var e858 = this.drag(t1194);
        this.el.fire("dragend", {
            event: t1194,
            p: e858,
            m: this.m,
            handler: this
        }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag");
    }, SVG.extend(SVG.Element, {
        draggable: function(e859, i630) {
            "function" != typeof e859 && "object" != typeof e859 || (i630 = e859, e859 = !0);
            var a464 = this.remember("_draggable") || new t1181(this);
            return (e859 = void 0 === e859 || e859) ? a464.init(i630 || {}, e859) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this;
        }
    });
}).call(void 0), function() {
    function t1195(t1196) {
        this.el = t1196, t1196.remember("_selectHandler", this), this.pointSelection = {
            isSelected: !1
        }, this.rectSelection = {
            isSelected: !1
        }, this.pointsList = {
            lt: [
                0,
                0
            ],
            rt: [
                "width",
                0
            ],
            rb: [
                "width",
                "height"
            ],
            lb: [
                0,
                "height"
            ],
            t: [
                "width",
                0
            ],
            r: [
                "width",
                "height"
            ],
            b: [
                "width",
                "height"
            ],
            l: [
                0,
                "height"
            ]
        }, this.pointCoord = function(t1197, e860, i631) {
            var a465 = "string" != typeof t1197 ? t1197 : e860[t1197];
            return i631 ? a465 / 2 : a465;
        }, this.pointCoords = function(t1198, e861) {
            var i632 = this.pointsList[t1198];
            return {
                x: this.pointCoord(i632[0], e861, "t" === t1198 || "b" === t1198),
                y: this.pointCoord(i632[1], e861, "r" === t1198 || "l" === t1198)
            };
        };
    }
    t1195.prototype.init = function(t1199, e862) {
        var i633 = this.el.bbox();
        this.options = {};
        var a466 = this.el.selectize.defaults.points;
        for(var s400 in this.el.selectize.defaults)this.options[s400] = this.el.selectize.defaults[s400], void 0 !== e862[s400] && (this.options[s400] = e862[s400]);
        var r327 = [
            "points",
            "pointsExclude"
        ];
        for(var s400 in r327){
            var o286 = this.options[r327[s400]];
            "string" == typeof o286 ? o286 = o286.length > 0 ? o286.split(/\s*,\s*/i) : [] : "boolean" == typeof o286 && "points" === r327[s400] && (o286 = o286 ? a466 : []), this.options[r327[s400]] = o286;
        }
        this.options.points = [
            a466,
            this.options.points
        ].reduce(function(t1200, e863) {
            return t1200.filter(function(t1201) {
                return e863.indexOf(t1201) > -1;
            });
        }), this.options.points = [
            this.options.points,
            this.options.pointsExclude
        ].reduce(function(t1202, e864) {
            return t1202.filter(function(t1203) {
                return e864.indexOf(t1203) < 0;
            });
        }), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i633.x, i633.y)), this.options.deepSelect && -1 !== [
            "line",
            "polyline",
            "polygon"
        ].indexOf(this.el.type) ? this.selectPoints(t1199) : this.selectRect(t1199), this.observe(), this.cleanup();
    }, t1195.prototype.selectPoints = function(t1204) {
        return this.pointSelection.isSelected = t1204, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this;
    }, t1195.prototype.getPointArray = function() {
        var t1205 = this.el.bbox();
        return this.el.array().valueOf().map(function(e865) {
            return [
                e865[0] - t1205.x,
                e865[1] - t1205.y
            ];
        });
    }, t1195.prototype.drawPoints = function() {
        for(var t1206 = this, e866 = this.getPointArray(), i634 = 0, a467 = e866.length; i634 < a467; ++i634){
            var s401 = function(e867) {
                return function(i635) {
                    (i635 = i635 || window.event).preventDefault ? i635.preventDefault() : i635.returnValue = !1, i635.stopPropagation();
                    var a468 = i635.pageX || i635.touches[0].pageX, s403 = i635.pageY || i635.touches[0].pageY;
                    t1206.el.fire("point", {
                        x: a468,
                        y: s403,
                        i: e867,
                        event: i635
                    });
                };
            }(i634), r328 = this.drawPoint(e866[i634][0], e866[i634][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", s401).on("mousedown", s401);
            this.pointSelection.set.add(r328);
        }
    }, t1195.prototype.drawPoint = function(t1207, e868) {
        var i636 = this.options.pointType;
        switch(i636){
            case "circle":
                return this.drawCircle(t1207, e868);
            case "rect":
                return this.drawRect(t1207, e868);
            default:
                if ("function" == typeof i636) return i636.call(this, t1207, e868);
                throw new Error("Unknown " + i636 + " point type!");
        }
    }, t1195.prototype.drawCircle = function(t1208, e869) {
        return this.nested.circle(this.options.pointSize).center(t1208, e869);
    }, t1195.prototype.drawRect = function(t1209, e870) {
        return this.nested.rect(this.options.pointSize, this.options.pointSize).center(t1209, e870);
    }, t1195.prototype.updatePointSelection = function() {
        var t1210 = this.getPointArray();
        this.pointSelection.set.each(function(e871) {
            this.cx() === t1210[e871][0] && this.cy() === t1210[e871][1] || this.center(t1210[e871][0], t1210[e871][1]);
        });
    }, t1195.prototype.updateRectSelection = function() {
        var t1211 = this, e872 = this.el.bbox();
        if (this.rectSelection.set.get(0).attr({
            width: e872.width,
            height: e872.height
        }), this.options.points.length && this.options.points.map(function(i638, a469) {
            var s404 = t1211.pointCoords(i638, e872);
            t1211.rectSelection.set.get(a469 + 1).center(s404.x, s404.y);
        }), this.options.rotationPoint) {
            var i637 = this.rectSelection.set.length();
            this.rectSelection.set.get(i637 - 1).center(e872.width / 2, 20);
        }
    }, t1195.prototype.selectRect = function(t1212) {
        var e873 = this, i639 = this.el.bbox();
        function a470(t1213) {
            return function(i640) {
                (i640 = i640 || window.event).preventDefault ? i640.preventDefault() : i640.returnValue = !1, i640.stopPropagation();
                var a471 = i640.pageX || i640.touches[0].pageX, s406 = i640.pageY || i640.touches[0].pageY;
                e873.el.fire(t1213, {
                    x: a471,
                    y: s406,
                    event: i640
                });
            };
        }
        if (this.rectSelection.isSelected = t1212, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i639.width, i639.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2) this.options.points.map(function(t1214, s) {
            var r330 = e873.pointCoords(t1214, i639), o287 = e873.drawPoint(r330.x, r330.y).attr("class", e873.options.classPoints + "_" + t1214).on("mousedown", a470(t1214)).on("touchstart", a470(t1214));
            e873.rectSelection.set.add(o287);
        }), this.rectSelection.set.each(function() {
            this.addClass(e873.options.classPoints);
        });
        if (this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
            var s405 = function(t1215) {
                (t1215 = t1215 || window.event).preventDefault ? t1215.preventDefault() : t1215.returnValue = !1, t1215.stopPropagation();
                var i641 = t1215.pageX || t1215.touches[0].pageX, a472 = t1215.pageY || t1215.touches[0].pageY;
                e873.el.fire("rot", {
                    x: i641,
                    y: a472,
                    event: t1215
                });
            }, r329 = this.drawPoint(i639.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", s405).on("mousedown", s405);
            this.rectSelection.set.add(r329);
        }
    }, t1195.prototype.handler = function() {
        var t1216 = this.el.bbox();
        this.nested.matrix(new SVG.Matrix(this.el).translate(t1216.x, t1216.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection();
    }, t1195.prototype.observe = function() {
        var t1217 = this;
        if (MutationObserver) {
            if (this.rectSelection.isSelected || this.pointSelection.isSelected) this.observerInst = this.observerInst || new MutationObserver(function() {
                t1217.handler();
            }), this.observerInst.observe(this.el.node, {
                attributes: !0
            });
            else try {
                this.observerInst.disconnect(), delete this.observerInst;
            } catch (t) {}
        } else this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function() {
            t1217.handler();
        });
    }, t1195.prototype.cleanup = function() {
        !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function() {
            this.remove();
        }), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function() {
            this.remove();
        }), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested);
    }, SVG.extend(SVG.Element, {
        selectize: function(e874, i642) {
            return "object" == typeof e874 && (i642 = e874, e874 = !0), (this.remember("_selectHandler") || new t1195(this)).init(void 0 === e874 || e874, i642 || {}), this;
        }
    }), SVG.Element.prototype.selectize.defaults = {
        points: [
            "lt",
            "rt",
            "rb",
            "lb",
            "t",
            "r",
            "b",
            "l"
        ],
        pointsExclude: [],
        classRect: "svg_select_boundingRect",
        classPoints: "svg_select_points",
        pointSize: 7,
        rotationPoint: !0,
        deepSelect: !1,
        pointType: "circle"
    };
}(), function() {
    (function() {
        function t1218(t1219) {
            t1219.remember("_resizeHandler", this), this.el = t1219, this.parameters = {}, this.lastUpdateCall = null, this.p = t1219.doc().node.createSVGPoint();
        }
        t1218.prototype.transformPoint = function(t1220, e875, i643) {
            return this.p.x = t1220 - (this.offset.x - window.pageXOffset), this.p.y = e875 - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i643 || this.m);
        }, t1218.prototype._extractPosition = function(t1221) {
            return {
                x: null != t1221.clientX ? t1221.clientX : t1221.touches[0].clientX,
                y: null != t1221.clientY ? t1221.clientY : t1221.touches[0].clientY
            };
        }, t1218.prototype.init = function(t1222) {
            var e876 = this;
            if (this.stop(), "stop" !== t1222) {
                for(var i644 in this.options = {}, this.el.resize.defaults)this.options[i644] = this.el.resize.defaults[i644], void 0 !== t1222[i644] && (this.options[i644] = t1222[i644]);
                this.el.on("lt.resize", function(t1223) {
                    e876.resize(t1223 || window.event);
                }), this.el.on("rt.resize", function(t1224) {
                    e876.resize(t1224 || window.event);
                }), this.el.on("rb.resize", function(t1225) {
                    e876.resize(t1225 || window.event);
                }), this.el.on("lb.resize", function(t1226) {
                    e876.resize(t1226 || window.event);
                }), this.el.on("t.resize", function(t1227) {
                    e876.resize(t1227 || window.event);
                }), this.el.on("r.resize", function(t1228) {
                    e876.resize(t1228 || window.event);
                }), this.el.on("b.resize", function(t1229) {
                    e876.resize(t1229 || window.event);
                }), this.el.on("l.resize", function(t1230) {
                    e876.resize(t1230 || window.event);
                }), this.el.on("rot.resize", function(t1231) {
                    e876.resize(t1231 || window.event);
                }), this.el.on("point.resize", function(t1232) {
                    e876.resize(t1232 || window.event);
                }), this.update();
            }
        }, t1218.prototype.stop = function() {
            return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this;
        }, t1218.prototype.resize = function(t1233) {
            var e877 = this;
            this.m = this.el.node.getScreenCTM().inverse(), this.offset = {
                x: window.pageXOffset,
                y: window.pageYOffset
            };
            var i645 = this._extractPosition(t1233.detail.event);
            if (this.parameters = {
                type: this.el.type,
                p: this.transformPoint(i645.x, i645.y),
                x: t1233.detail.x,
                y: t1233.detail.y,
                box: this.el.bbox(),
                rotation: this.el.transform().rotation
            }, "text" === this.el.type && (this.parameters.fontSize = this.el.attr()["font-size"]), void 0 !== t1233.detail.i) {
                var a473 = this.el.array().valueOf();
                this.parameters.i = t1233.detail.i, this.parameters.pointCoords = [
                    a473[t1233.detail.i][0],
                    a473[t1233.detail.i][1]
                ];
            }
            switch(t1233.type){
                case "lt":
                    this.calc = function(t1234, e878) {
                        var i646 = this.snapToGrid(t1234, e878);
                        if (this.parameters.box.width - i646[0] > 0 && this.parameters.box.height - i646[1] > 0) {
                            if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + i646[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i646[0]);
                            i646 = this.checkAspectRatio(i646), this.el.move(this.parameters.box.x + i646[0], this.parameters.box.y + i646[1]).size(this.parameters.box.width - i646[0], this.parameters.box.height - i646[1]);
                        }
                    };
                    break;
                case "rt":
                    this.calc = function(t1235, e879) {
                        var i647 = this.snapToGrid(t1235, e879, 2);
                        if (this.parameters.box.width + i647[0] > 0 && this.parameters.box.height - i647[1] > 0) {
                            if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - i647[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i647[0]);
                            i647 = this.checkAspectRatio(i647, !0), this.el.move(this.parameters.box.x, this.parameters.box.y + i647[1]).size(this.parameters.box.width + i647[0], this.parameters.box.height - i647[1]);
                        }
                    };
                    break;
                case "rb":
                    this.calc = function(t1236, e880) {
                        var i648 = this.snapToGrid(t1236, e880, 0);
                        if (this.parameters.box.width + i648[0] > 0 && this.parameters.box.height + i648[1] > 0) {
                            if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - i648[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i648[0]);
                            i648 = this.checkAspectRatio(i648), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + i648[0], this.parameters.box.height + i648[1]);
                        }
                    };
                    break;
                case "lb":
                    this.calc = function(t1237, e881) {
                        var i649 = this.snapToGrid(t1237, e881, 1);
                        if (this.parameters.box.width - i649[0] > 0 && this.parameters.box.height + i649[1] > 0) {
                            if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + i649[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i649[0]);
                            i649 = this.checkAspectRatio(i649, !0), this.el.move(this.parameters.box.x + i649[0], this.parameters.box.y).size(this.parameters.box.width - i649[0], this.parameters.box.height + i649[1]);
                        }
                    };
                    break;
                case "t":
                    this.calc = function(t1238, e882) {
                        var i650 = this.snapToGrid(t1238, e882, 2);
                        if (this.parameters.box.height - i650[1] > 0) {
                            if ("text" === this.parameters.type) return;
                            this.el.move(this.parameters.box.x, this.parameters.box.y + i650[1]).height(this.parameters.box.height - i650[1]);
                        }
                    };
                    break;
                case "r":
                    this.calc = function(t1239, e883) {
                        var i651 = this.snapToGrid(t1239, e883, 0);
                        if (this.parameters.box.width + i651[0] > 0) {
                            if ("text" === this.parameters.type) return;
                            this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + i651[0]);
                        }
                    };
                    break;
                case "b":
                    this.calc = function(t1240, e884) {
                        var i652 = this.snapToGrid(t1240, e884, 0);
                        if (this.parameters.box.height + i652[1] > 0) {
                            if ("text" === this.parameters.type) return;
                            this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + i652[1]);
                        }
                    };
                    break;
                case "l":
                    this.calc = function(t1241, e885) {
                        var i653 = this.snapToGrid(t1241, e885, 1);
                        if (this.parameters.box.width - i653[0] > 0) {
                            if ("text" === this.parameters.type) return;
                            this.el.move(this.parameters.box.x + i653[0], this.parameters.box.y).width(this.parameters.box.width - i653[0]);
                        }
                    };
                    break;
                case "rot":
                    this.calc = function(t1242, e886) {
                        var i654 = t1242 + this.parameters.p.x, a474 = e886 + this.parameters.p.y, s407 = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2), r331 = Math.atan2(a474 - this.parameters.box.y - this.parameters.box.height / 2, i654 - this.parameters.box.x - this.parameters.box.width / 2), o288 = this.parameters.rotation + 180 * (r331 - s407) / Math.PI + this.options.snapToAngle / 2;
                        this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(o288 - o288 % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);
                    };
                    break;
                case "point":
                    this.calc = function(t1243, e887) {
                        var i655 = this.snapToGrid(t1243, e887, this.parameters.pointCoords[0], this.parameters.pointCoords[1]), a475 = this.el.array().valueOf();
                        a475[this.parameters.i][0] = this.parameters.pointCoords[0] + i655[0], a475[this.parameters.i][1] = this.parameters.pointCoords[1] + i655[1], this.el.plot(a475);
                    };
            }
            this.el.fire("resizestart", {
                dx: this.parameters.x,
                dy: this.parameters.y,
                event: t1233
            }), SVG.on(window, "touchmove.resize", function(t1244) {
                e877.update(t1244 || window.event);
            }), SVG.on(window, "touchend.resize", function() {
                e877.done();
            }), SVG.on(window, "mousemove.resize", function(t1245) {
                e877.update(t1245 || window.event);
            }), SVG.on(window, "mouseup.resize", function() {
                e877.done();
            });
        }, t1218.prototype.update = function(t1246) {
            if (t1246) {
                var e888 = this._extractPosition(t1246), i656 = this.transformPoint(e888.x, e888.y), a476 = i656.x - this.parameters.p.x, s408 = i656.y - this.parameters.p.y;
                this.lastUpdateCall = [
                    a476,
                    s408
                ], this.calc(a476, s408), this.el.fire("resizing", {
                    dx: a476,
                    dy: s408,
                    event: t1246
                });
            } else this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
        }, t1218.prototype.done = function() {
            this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone");
        }, t1218.prototype.snapToGrid = function(t1247, e889, i657, a477) {
            var s409;
            return void 0 !== a477 ? s409 = [
                (i657 + t1247) % this.options.snapToGrid,
                (a477 + e889) % this.options.snapToGrid
            ] : (i657 = null == i657 ? 3 : i657, s409 = [
                (this.parameters.box.x + t1247 + (1 & i657 ? 0 : this.parameters.box.width)) % this.options.snapToGrid,
                (this.parameters.box.y + e889 + (2 & i657 ? 0 : this.parameters.box.height)) % this.options.snapToGrid
            ]), t1247 < 0 && (s409[0] -= this.options.snapToGrid), e889 < 0 && (s409[1] -= this.options.snapToGrid), t1247 -= Math.abs(s409[0]) < this.options.snapToGrid / 2 ? s409[0] : s409[0] - (t1247 < 0 ? -this.options.snapToGrid : this.options.snapToGrid), e889 -= Math.abs(s409[1]) < this.options.snapToGrid / 2 ? s409[1] : s409[1] - (e889 < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t1247, e889, i657, a477);
        }, t1218.prototype.constraintToBox = function(t1248, e890, i658, a478) {
            var s410, r332, o289 = this.options.constraint || {};
            return void 0 !== a478 ? (s410 = i658, r332 = a478) : (s410 = this.parameters.box.x + (1 & i658 ? 0 : this.parameters.box.width), r332 = this.parameters.box.y + (2 & i658 ? 0 : this.parameters.box.height)), void 0 !== o289.minX && s410 + t1248 < o289.minX && (t1248 = o289.minX - s410), void 0 !== o289.maxX && s410 + t1248 > o289.maxX && (t1248 = o289.maxX - s410), void 0 !== o289.minY && r332 + e890 < o289.minY && (e890 = o289.minY - r332), void 0 !== o289.maxY && r332 + e890 > o289.maxY && (e890 = o289.maxY - r332), [
                t1248,
                e890
            ];
        }, t1218.prototype.checkAspectRatio = function(t1249, e891) {
            if (!this.options.saveAspectRatio) return t1249;
            var i659 = t1249.slice(), a479 = this.parameters.box.width / this.parameters.box.height, s411 = this.parameters.box.width + t1249[0], r333 = this.parameters.box.height - t1249[1], o290 = s411 / r333;
            return o290 < a479 ? (i659[1] = s411 / a479 - this.parameters.box.height, e891 && (i659[1] = -i659[1])) : o290 > a479 && (i659[0] = this.parameters.box.width - r333 * a479, e891 && (i659[0] = -i659[0])), i659;
        }, SVG.extend(SVG.Element, {
            resize: function(e892) {
                return (this.remember("_resizeHandler") || new t1218(this)).init(e892 || {}), this;
            }
        }), SVG.Element.prototype.resize.defaults = {
            snapToAngle: .1,
            snapToGrid: 1,
            constraint: {},
            saveAspectRatio: !1
        };
    }).call(this);
}(), void 0 === window.Apex && (window.Apex = {});
var Rt = function() {
    function t1250(e893) {
        a(this, t1250), this.ctx = e893, this.w = e893.w;
    }
    return r(t1250, [
        {
            key: "initModules",
            value: function() {
                this.ctx.publicMethods = [
                    "updateOptions",
                    "updateSeries",
                    "appendData",
                    "appendSeries",
                    "toggleSeries",
                    "showSeries",
                    "hideSeries",
                    "setLocale",
                    "resetSeries",
                    "zoomX",
                    "toggleDataPointSelection",
                    "dataURI",
                    "addXaxisAnnotation",
                    "addYaxisAnnotation",
                    "addPointAnnotation",
                    "clearAnnotations",
                    "removeAnnotation",
                    "paper",
                    "destroy"
                ], this.ctx.eventList = [
                    "click",
                    "mousedown",
                    "mousemove",
                    "mouseleave",
                    "touchstart",
                    "touchmove",
                    "touchleave",
                    "mouseup",
                    "touchend"
                ], this.ctx.animations = new b(this.ctx), this.ctx.axes = new K(this.ctx), this.ctx.core = new Yt(this.ctx.el, this.ctx), this.ctx.config = new N({}), this.ctx.data = new B(this.ctx), this.ctx.grid = new U(this.ctx), this.ctx.graphics = new m(this.ctx), this.ctx.coreUtils = new y(this.ctx), this.ctx.crosshairs = new tt(this.ctx), this.ctx.events = new J(this.ctx), this.ctx.exports = new j(this.ctx), this.ctx.localization = new Q(this.ctx), this.ctx.options = new L, this.ctx.responsive = new et(this.ctx), this.ctx.series = new E(this.ctx), this.ctx.theme = new it(this.ctx), this.ctx.formatters = new V(this.ctx), this.ctx.titleSubtitle = new at(this.ctx), this.ctx.legend = new ct(this.ctx), this.ctx.toolbar = new dt(this.ctx), this.ctx.dimensions = new lt(this.ctx), this.ctx.updateHelpers = new Ft(this.ctx), this.ctx.zoomPanSelection = new gt(this.ctx), this.ctx.w.globals.tooltip = new mt(this.ctx);
            }
        }
    ]), t1250;
}(), Ht = function() {
    function t1251(e894) {
        a(this, t1251), this.ctx = e894, this.w = e894.w;
    }
    return r(t1251, [
        {
            key: "clear",
            value: function(t1252) {
                var e895 = t1252.isUpdating;
                this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({
                    isUpdating: e895
                });
            }
        },
        {
            key: "killSVG",
            value: function(t1253) {
                t1253.each(function(t, e) {
                    this.removeClass("*"), this.off(), this.stop();
                }, !0), t1253.ungroup(), t1253.clear();
            }
        },
        {
            key: "clearDomElements",
            value: function(t1254) {
                var e896 = this, i660 = t1254.isUpdating, a480 = this.w.globals.dom.Paper.node;
                a480.parentNode && a480.parentNode.parentNode && !i660 && (a480.parentNode.parentNode.style.minHeight = "unset");
                var s412 = this.w.globals.dom.baseEl;
                s412 && this.ctx.eventList.forEach(function(t1255) {
                    s412.removeEventListener(t1255, e896.ctx.events.documentEvent);
                });
                var r334 = this.w.globals.dom;
                if (null !== this.ctx.el) for(; this.ctx.el.firstChild;)this.ctx.el.removeChild(this.ctx.el.firstChild);
                this.killSVG(r334.Paper), r334.Paper.remove(), r334.elWrap = null, r334.elGraphical = null, r334.elAnnotations = null, r334.elLegendWrap = null, r334.baseEl = null, r334.elGridRect = null, r334.elGridRectMask = null, r334.elGridRectMarkerMask = null, r334.elForecastMask = null, r334.elNonForecastMask = null, r334.elDefs = null;
            }
        }
    ]), t1251;
}(), Dt = new WeakMap;
var Nt = function() {
    function t1256(e897, i661) {
        a(this, t1256), this.opts = i661, this.ctx = this, this.w = new W(i661).init(), this.el = e897, this.w.globals.cuid = x.randomId(), this.w.globals.chartID = this.w.config.chart.id ? x.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new Rt(this).initModules(), this.create = x.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
    }
    return r(t1256, [
        {
            key: "render",
            value: function() {
                var t1257 = this;
                return new Promise(function(e898, i662) {
                    if (null !== t1257.el) {
                        void 0 === Apex._chartInstances && (Apex._chartInstances = []), t1257.w.config.chart.id && Apex._chartInstances.push({
                            id: t1257.w.globals.chartID,
                            group: t1257.w.config.chart.group,
                            chart: t1257
                        }), t1257.setLocale(t1257.w.config.chart.defaultLocale);
                        var a481 = t1257.w.config.chart.events.beforeMount;
                        if ("function" == typeof a481 && a481(t1257, t1257.w), t1257.events.fireEvent("beforeMount", [
                            t1257,
                            t1257.w
                        ]), window.addEventListener("resize", t1257.windowResizeHandler), function(t1258, e899) {
                            var i663 = !1, a482 = t1258.getBoundingClientRect();
                            "none" !== t1258.style.display && 0 !== a482.width || (i663 = !0);
                            var s415 = new ResizeObserver(function(a483) {
                                i663 && e899.call(t1258, a483), i663 = !0;
                            });
                            t1258.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(t1258.children).forEach(function(t1259) {
                                return s415.observe(t1259);
                            }) : s415.observe(t1258), Dt.set(e899, s415);
                        }(t1257.el.parentNode, t1257.parentResizeHandler), !t1257.css) {
                            var s413 = t1257.el.getRootNode && t1257.el.getRootNode(), r335 = x.is("ShadowRoot", s413), o291 = t1257.el.ownerDocument, n242 = o291.getElementById("apexcharts-css");
                            !r335 && n242 || (t1257.css = document.createElement("style"), t1257.css.id = "apexcharts-css", t1257.css.textContent = '.apexcharts-canvas {\n  position: relative;\n  user-select: none;\n  /* cannot give overflow: hidden as it will crop tooltips which overflow outside chart area */\n}\n\n\n/* scrollbar is not visible by default for legend, hence forcing the visibility */\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px;\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n}\n\n\n.apexcharts-inner {\n  position: relative;\n}\n\n.apexcharts-text tspan {\n  font-family: inherit;\n}\n\n.legend-mouseover-inactive {\n  transition: 0.15s ease all;\n  opacity: 0.20;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0;\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, 0.96);\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, 0.8);\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit;\n}\n\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px;\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #ECEFF1;\n  border-bottom: 1px solid #ddd;\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, 0.7);\n  border-bottom: 1px solid #333;\n}\n\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  font-weight: 600;\n  margin-left: 5px;\n}\n\n.apexcharts-tooltip-title:empty,\n.apexcharts-tooltip-text-y-label:empty,\n.apexcharts-tooltip-text-y-value:empty,\n.apexcharts-tooltip-text-goals-label:empty,\n.apexcharts-tooltip-text-goals-value:empty,\n.apexcharts-tooltip-text-z-value:empty {\n  display: none;\n}\n\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-z-value {\n  font-weight: 600;\n}\n\n.apexcharts-tooltip-text-goals-label, \n.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px;\n}\n\n.apexcharts-tooltip-goals-group, \n.apexcharts-tooltip-text-goals-label, \n.apexcharts-tooltip-text-goals-value {\n  display: flex;\n}\n.apexcharts-tooltip-text-goals-label:not(:empty),\n.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px;\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0px;\n  margin-right: 10px;\n  border-radius: 50%;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px;\n}\n\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0 !important;\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px;\n}\n\n.apexcharts-tooltip-box, .apexcharts-custom-tooltip {\n  padding: 4px 8px;\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse;\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0;\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: bold;\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px;\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777;\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: bold;\n  display: block;\n  margin-bottom: 5px;\n}\n\n.apexcharts-xaxistooltip {\n  opacity: 0;\n  padding: 9px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-left: -6px;\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-left: -7px;\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%;\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%;\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #ECEFF1;\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #ECEFF1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  padding: 4px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-top: -6px;\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-top: -7px;\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%;\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%;\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #ECEFF1;\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #ECEFF1;\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1;\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none;\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0;\n}\n\n.apexcharts-selection-rect {\n  cursor: move;\n}\n\n.svg_select_boundingRect, .svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden;\n}\n.apexcharts-selection-rect + g .svg_select_boundingRect,\n.apexcharts-selection-rect + g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden;\n}\n\n.apexcharts-selection-rect + g .svg_select_points_l,\n.apexcharts-selection-rect + g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible;\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2;\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon,\n.apexcharts-reset-icon,\n.apexcharts-pan-icon,\n.apexcharts-selection-icon,\n.apexcharts-menu-icon,\n.apexcharts-toolbar-custom-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6E8192;\n  text-align: center;\n}\n\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-menu-icon svg {\n  fill: #6E8192;\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(0.76)\n}\n\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg {\n  fill: #f3f4f5;\n}\n\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg {\n  fill: #008FFB;\n}\n\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg {\n  fill: #333;\n}\n\n.apexcharts-selection-icon,\n.apexcharts-menu-icon {\n  position: relative;\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px;\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-reset-icon,\n.apexcharts-menu-icon {\n  transform: scale(0.85);\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(0.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px;\n}\n\n.apexcharts-pan-icon {\n  transform: scale(0.62);\n  position: relative;\n  left: 1px;\n  top: 0px;\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6E8192;\n  stroke-width: 2;\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008FFB;\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333;\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0px 6px 2px 6px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: 0.15s ease all;\n  pointer-events: none;\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer;\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee;\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, 0.7);\n  color: #fff;\n}\n\n@media screen and (min-width: 768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1;\n  }\n}\n\n.apexcharts-datalabel.apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-pie-label,\n.apexcharts-datalabels,\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value {\n  cursor: default;\n  pointer-events: none;\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: 0.3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease;\n}\n\n.apexcharts-canvas .apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-gridline,\n.apexcharts-annotation-rect,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-line,\n.apexcharts-zoom-rect,\n.apexcharts-toolbar svg,\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-radar-series path,\n.apexcharts-radar-series polygon {\n  pointer-events: none;\n}\n\n\n/* markers */\n\n.apexcharts-marker {\n  transition: 0.15s ease all;\n}\n\n@keyframes opaque {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n\n\n/* Resize generated styles */\n\n@keyframes resizeanim {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n}\n\n.resize-triggers,\n.resize-triggers>div,\n.contract-trigger:before {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden;\n}\n\n.resize-triggers>div {\n  background: #eee;\n  overflow: auto;\n}\n\n.contract-trigger:before {\n  width: 200%;\n  height: 200%;\n}', r335 ? s413.prepend(t1257.css) : o291.head.appendChild(t1257.css));
                        }
                        var l206 = t1257.create(t1257.w.config.series, {});
                        if (!l206) return e898(t1257);
                        t1257.mount(l206).then(function() {
                            "function" == typeof t1257.w.config.chart.events.mounted && t1257.w.config.chart.events.mounted(t1257, t1257.w), t1257.events.fireEvent("mounted", [
                                t1257,
                                t1257.w
                            ]), e898(l206);
                        }).catch(function(t1260) {
                            i662(t1260);
                        });
                    } else i662(new Error("Element not found"));
                });
            }
        },
        {
            key: "create",
            value: function(t1261, e900) {
                var i664 = this.w;
                new Rt(this).initModules();
                var a484 = this.w.globals;
                (a484.noData = !1, a484.animationEnded = !1, this.responsive.checkResponsiveConfig(e900), i664.config.xaxis.convertedCatToNumeric) && new D(i664.config).convertCatToNumericXaxis(i664.config, this.ctx);
                if (null === this.el) return a484.animationEnded = !0, null;
                if (this.core.setupElements(), "treemap" === i664.config.chart.type && (i664.config.grid.show = !1, i664.config.yaxis[0].show = !1), 0 === a484.svgWidth) return a484.animationEnded = !0, null;
                var s416 = y.checkComboSeries(t1261);
                a484.comboCharts = s416.comboCharts, a484.comboBarCount = s416.comboBarCount;
                var r336 = t1261.every(function(t1262) {
                    return t1262.data && 0 === t1262.data.length;
                });
                (0 === t1261.length || r336) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(t1261), this.theme.init(), new M(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), a484.noData && a484.collapsedSeries.length !== a484.series.length && !i664.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), a484.axisCharts && (this.core.coreCalculations(), "category" !== i664.config.xaxis.type && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = i664.globals.minX, this.ctx.toolbar.maxX = i664.globals.maxX), this.formatters.heatmapLabelFormatters(), new y(this).getLargestMarkerSize(), this.dimensions.plotCoords();
                var o292 = this.core.xySettings();
                this.grid.createGridMask();
                var n243 = this.core.plotChartType(t1261, o292), l207 = new z(this);
                l207.bringForward(), i664.config.dataLabels.background.enabled && l207.dataLabelsBackground(), this.core.shiftGraphPosition();
                var h178 = {
                    plot: {
                        left: i664.globals.translateX,
                        top: i664.globals.translateY,
                        width: i664.globals.gridWidth,
                        height: i664.globals.gridHeight
                    }
                };
                return {
                    elGraph: n243,
                    xyRatios: o292,
                    elInner: i664.globals.dom.elGraphical,
                    dimensions: h178
                };
            }
        },
        {
            key: "mount",
            value: function() {
                var t1263 = this, e901 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, i665 = this, a485 = i665.w;
                return new Promise(function(s417, r337) {
                    if (null === i665.el) return r337(new Error("Not enough data to display or target element not found"));
                    (null === e901 || a485.globals.allSeriesCollapsed) && i665.series.handleNoData(), "treemap" !== a485.config.chart.type && i665.axes.drawAxis(a485.config.chart.type, e901.xyRatios), i665.grid = new U(i665);
                    var o293 = i665.grid.drawGrid();
                    i665.annotations = new P(i665), i665.annotations.drawImageAnnos(), i665.annotations.drawTextAnnos(), "back" === a485.config.grid.position && o293 && a485.globals.dom.elGraphical.add(o293.el);
                    var n244 = new _(t1263.ctx), l208 = new $(t1263.ctx);
                    if (null !== o293 && (n244.xAxisLabelCorrections(o293.xAxisTickWidth), l208.setYAxisTextAlignments(), a485.config.yaxis.map(function(t1264, e902) {
                        -1 === a485.globals.ignoreYAxisIndexes.indexOf(e902) && l208.yAxisTitleRotate(e902, t1264.opposite);
                    })), "back" === a485.config.annotations.position && (a485.globals.dom.Paper.add(a485.globals.dom.elAnnotations), i665.annotations.drawAxesAnnotations()), Array.isArray(e901.elGraph)) for(var h179 = 0; h179 < e901.elGraph.length; h179++)a485.globals.dom.elGraphical.add(e901.elGraph[h179]);
                    else a485.globals.dom.elGraphical.add(e901.elGraph);
                    if ("front" === a485.config.grid.position && o293 && a485.globals.dom.elGraphical.add(o293.el), "front" === a485.config.xaxis.crosshairs.position && i665.crosshairs.drawXCrosshairs(), "front" === a485.config.yaxis[0].crosshairs.position && i665.crosshairs.drawYCrosshairs(), "front" === a485.config.annotations.position && (a485.globals.dom.Paper.add(a485.globals.dom.elAnnotations), i665.annotations.drawAxesAnnotations()), !a485.globals.noData) {
                        if (a485.config.tooltip.enabled && !a485.globals.noData && i665.w.globals.tooltip.drawTooltip(e901.xyRatios), a485.globals.axisCharts && (a485.globals.isXNumeric || a485.config.xaxis.convertedCatToNumeric || a485.globals.isRangeBar)) (a485.config.chart.zoom.enabled || a485.config.chart.selection && a485.config.chart.selection.enabled || a485.config.chart.pan && a485.config.chart.pan.enabled) && i665.zoomPanSelection.init({
                            xyRatios: e901.xyRatios
                        });
                        else {
                            var c152 = a485.config.chart.toolbar.tools;
                            [
                                "zoom",
                                "zoomin",
                                "zoomout",
                                "selection",
                                "pan",
                                "reset"
                            ].forEach(function(t1265) {
                                c152[t1265] = !1;
                            });
                        }
                        a485.config.chart.toolbar.show && !a485.globals.allSeriesCollapsed && i665.toolbar.createToolbar();
                    }
                    a485.globals.memory.methodsToExec.length > 0 && a485.globals.memory.methodsToExec.forEach(function(t1266) {
                        t1266.method(t1266.params, !1, t1266.context);
                    }), a485.globals.axisCharts || a485.globals.noData || i665.core.resizeNonAxisCharts(), s417(i665);
                });
            }
        },
        {
            key: "destroy",
            value: function() {
                var t1267, e903;
                window.removeEventListener("resize", this.windowResizeHandler), this.el.parentNode, t1267 = this.parentResizeHandler, (e903 = Dt.get(t1267)) && (e903.disconnect(), Dt.delete(t1267));
                var i666 = this.w.config.chart.id;
                i666 && Apex._chartInstances.forEach(function(t1268, e904) {
                    t1268.id === x.escapeString(i666) && Apex._chartInstances.splice(e904, 1);
                }), new Ht(this.ctx).clear({
                    isUpdating: !1
                });
            }
        },
        {
            key: "updateOptions",
            value: function(t1269) {
                var e905 = this, i667 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], a486 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s418 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], r338 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], o294 = this.w;
                return o294.globals.selection = void 0, t1269.series && (this.series.resetSeries(!1, !0, !1), t1269.series.length && t1269.series[0].data && (t1269.series = t1269.series.map(function(t1270, i668) {
                    return e905.updateHelpers._extendSeries(t1270, i668);
                })), this.updateHelpers.revertDefaultAxisMinMax()), t1269.xaxis && (t1269 = this.updateHelpers.forceXAxisUpdate(t1269)), t1269.yaxis && (t1269 = this.updateHelpers.forceYAxisUpdate(t1269)), o294.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t1269.theme && (t1269 = this.theme.updateThemeOptions(t1269)), this.updateHelpers._updateOptions(t1269, i667, a486, s418, r338);
            }
        },
        {
            key: "updateSeries",
            value: function() {
                var t1271 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e906 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i669 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                return this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t1271, e906, i669);
            }
        },
        {
            key: "appendSeries",
            value: function(t1272) {
                var e907 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i670 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a487 = this.w.config.series.slice();
                return a487.push(t1272), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a487, e907, i670);
            }
        },
        {
            key: "appendData",
            value: function(t1273) {
                var e908 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i671 = this;
                i671.w.globals.dataChanged = !0, i671.series.getPreviousPaths();
                for(var a488 = i671.w.config.series.slice(), s419 = 0; s419 < a488.length; s419++)if (null !== t1273[s419] && void 0 !== t1273[s419]) for(var r339 = 0; r339 < t1273[s419].data.length; r339++)a488[s419].data.push(t1273[s419].data[r339]);
                return i671.w.config.series = a488, e908 && (i671.w.globals.initialSeries = x.clone(i671.w.config.series)), this.update();
            }
        },
        {
            key: "update",
            value: function(t1274) {
                var e909 = this;
                return new Promise(function(i672, a489) {
                    new Ht(e909.ctx).clear({
                        isUpdating: !0
                    });
                    var s420 = e909.create(e909.w.config.series, t1274);
                    if (!s420) return i672(e909);
                    e909.mount(s420).then(function() {
                        "function" == typeof e909.w.config.chart.events.updated && e909.w.config.chart.events.updated(e909, e909.w), e909.events.fireEvent("updated", [
                            e909,
                            e909.w
                        ]), e909.w.globals.isDirty = !0, i672(e909);
                    }).catch(function(t1275) {
                        a489(t1275);
                    });
                });
            }
        },
        {
            key: "getSyncedCharts",
            value: function() {
                var t1276 = this.getGroupedCharts(), e910 = [
                    this
                ];
                return t1276.length && (e910 = [], t1276.forEach(function(t1277) {
                    e910.push(t1277);
                })), e910;
            }
        },
        {
            key: "getGroupedCharts",
            value: function() {
                var t1278 = this;
                return Apex._chartInstances.filter(function(t1279) {
                    if (t1279.group) return !0;
                }).map(function(e911) {
                    return t1278.w.config.chart.group === e911.group ? e911.chart : t1278;
                });
            }
        },
        {
            key: "toggleSeries",
            value: function(t1280) {
                return this.series.toggleSeries(t1280);
            }
        },
        {
            key: "highlightSeriesOnLegendHover",
            value: function(t1281, e912) {
                return this.series.toggleSeriesOnHover(t1281, e912);
            }
        },
        {
            key: "showSeries",
            value: function(t1282) {
                this.series.showSeries(t1282);
            }
        },
        {
            key: "hideSeries",
            value: function(t1283) {
                this.series.hideSeries(t1283);
            }
        },
        {
            key: "resetSeries",
            value: function() {
                var t1284 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e913 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                this.series.resetSeries(t1284, e913);
            }
        },
        {
            key: "addEventListener",
            value: function(t1285, e914) {
                this.events.addEventListener(t1285, e914);
            }
        },
        {
            key: "removeEventListener",
            value: function(t1286, e915) {
                this.events.removeEventListener(t1286, e915);
            }
        },
        {
            key: "addXaxisAnnotation",
            value: function(t1287) {
                var e916 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i673 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a490 = this;
                i673 && (a490 = i673), a490.annotations.addXaxisAnnotationExternal(t1287, e916, a490);
            }
        },
        {
            key: "addYaxisAnnotation",
            value: function(t1288) {
                var e917 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i674 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a491 = this;
                i674 && (a491 = i674), a491.annotations.addYaxisAnnotationExternal(t1288, e917, a491);
            }
        },
        {
            key: "addPointAnnotation",
            value: function(t1289) {
                var e918 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i675 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a492 = this;
                i675 && (a492 = i675), a492.annotations.addPointAnnotationExternal(t1289, e918, a492);
            }
        },
        {
            key: "clearAnnotations",
            value: function() {
                var t1290 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0, e919 = this;
                t1290 && (e919 = t1290), e919.annotations.clearAnnotations(e919);
            }
        },
        {
            key: "removeAnnotation",
            value: function(t1291) {
                var e920 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, i676 = this;
                e920 && (i676 = e920), i676.annotations.removeAnnotation(i676, t1291);
            }
        },
        {
            key: "getChartArea",
            value: function() {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
            }
        },
        {
            key: "getSeriesTotalXRange",
            value: function(t1292, e921) {
                return this.coreUtils.getSeriesTotalsXRange(t1292, e921);
            }
        },
        {
            key: "getHighestValueInSeries",
            value: function() {
                var t1293 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e922 = new Z(this.ctx);
                return e922.getMinYMaxY(t1293).highestY;
            }
        },
        {
            key: "getLowestValueInSeries",
            value: function() {
                var t1294 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e923 = new Z(this.ctx);
                return e923.getMinYMaxY(t1294).lowestY;
            }
        },
        {
            key: "getSeriesTotal",
            value: function() {
                return this.w.globals.seriesTotals;
            }
        },
        {
            key: "toggleDataPointSelection",
            value: function(t1295, e924) {
                return this.updateHelpers.toggleDataPointSelection(t1295, e924);
            }
        },
        {
            key: "zoomX",
            value: function(t1296, e925) {
                this.ctx.toolbar.zoomUpdateOptions(t1296, e925);
            }
        },
        {
            key: "setLocale",
            value: function(t1297) {
                this.localization.setCurrentLocaleValues(t1297);
            }
        },
        {
            key: "dataURI",
            value: function(t1298) {
                return new j(this.ctx).dataURI(t1298);
            }
        },
        {
            key: "paper",
            value: function() {
                return this.w.globals.dom.Paper;
            }
        },
        {
            key: "_parentResizeCallback",
            value: function() {
                this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
            }
        },
        {
            key: "_windowResize",
            value: function() {
                var t1299 = this;
                clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
                    t1299.w.globals.resized = !0, t1299.w.globals.dataChanged = !1, t1299.ctx.update();
                }, 150);
            }
        },
        {
            key: "_windowResizeHandler",
            value: function() {
                var t1300 = this.w.config.chart.redrawOnWindowResize;
                "function" == typeof t1300 && (t1300 = t1300()), t1300 && this._windowResize();
            }
        }
    ], [
        {
            key: "getChartByID",
            value: function(t1301) {
                var e926 = x.escapeString(t1301), i677 = Apex._chartInstances.filter(function(t1302) {
                    return t1302.id === e926;
                })[0];
                return i677 && i677.chart;
            }
        },
        {
            key: "initOnLoad",
            value: function() {
                for(var e927 = document.querySelectorAll("[data-apexcharts]"), i678 = 0; i678 < e927.length; i678++)new t1256(e927[i678], JSON.parse(e927[i678].getAttribute("data-options"))).render();
            }
        },
        {
            key: "exec",
            value: function(t1303, e928) {
                var i679 = this.getChartByID(t1303);
                if (i679) {
                    i679.w.globals.isExecCalled = !0;
                    var a493 = null;
                    if (-1 !== i679.publicMethods.indexOf(e928)) {
                        for(var s421 = arguments.length, r340 = new Array(s421 > 2 ? s421 - 2 : 0), o295 = 2; o295 < s421; o295++)r340[o295 - 2] = arguments[o295];
                        a493 = i679[e928].apply(i679, r340);
                    }
                    return a493;
                }
            }
        },
        {
            key: "merge",
            value: function(t1304, e929) {
                return x.extend(t1304, e929);
            }
        }
    ]), t1256;
}();
module.exports = Nt;

},{}],"kqb2N":[function(require,module,exports) {
//
// Get computed styles
//
'use strict';
function themeStyles() {
    // API
    this.style = function(property) {
        var style = getComputedStyle(document.body);
        var propertyValye = style.getPropertyValue(property);
        if (propertyValye) return propertyValye.trim();
        else return 'undefined';
    };
    this.colors = function() {
        var colors = {
            gray: {
                50: this.style('--x-gray-50'),
                100: this.style('--x-gray-100'),
                200: this.style('--x-gray-200'),
                300: this.style('--x-gray-300'),
                400: this.style('--x-gray-400'),
                500: this.style('--x-gray-500'),
                600: this.style('--x-gray-600'),
                700: this.style('--x-gray-700'),
                800: this.style('--x-gray-800'),
                900: this.style('--x-gray-900')
            },
            theme: {
                'primary': this.style('--x-primary'),
                'secondary': this.style('--x-secondary'),
                'tertiary': this.style('--x-tertiary'),
                'info': this.style('--x-info'),
                'success': this.style('--x-success'),
                'danger': this.style('--x-danger'),
                'warning': this.style('--x-warning'),
                'dark': this.style('--x-dark')
            },
            transparent: 'transparent'
        };
        return colors;
    };
    this.fonts = function() {
        var fonts = {
            base: this.style('--x-font-sans-serif'),
            code: this.style('--x-font-monospace'),
            serif: this.style('--x-font-serif')
        };
        return fonts;
    };
}
module.exports = themeStyles;

},{}],"eBeiv":[function(require,module,exports) {
//
// Apex bar chart
//
'use strict';
var apexCharts = require('apexcharts');
var themeStyles = require('../theme-styles');
function apexBarChart() {
    this.init = function(chartEl) {
        var styles = new themeStyles();
        var colorPalette = [
            styles.colors().theme.primary,
            styles.colors().theme.tertiary,
            styles.colors().theme.warning
        ];
        function init($this) {
            var options = {
                chart: {
                    type: 'line',
                    stacked: false,
                    zoom: {
                        enabled: false
                    },
                    toolbar: {
                        show: false
                    },
                    shadow: {
                        enabled: false
                    },
                    offsetX: 0,
                    animations: {
                        enabled: true,
                        easing: 'easeinout',
                        speed: 800,
                        animateGradually: {
                            enabled: true,
                            delay: 150
                        },
                        dynamicAnimation: {
                            enabled: true,
                            speed: 350
                        }
                    },
                    fontFamily: styles.fonts().base
                },
                colors: colorPalette,
                plotOptions: {
                    bar: {
                        columnWidth: '26%',
                        borderRadius: 5
                    }
                },
                stroke: {
                    colors: [
                        'transparent'
                    ],
                    width: 4,
                    curve: 'smooth'
                },
                series: [
                    {
                        name: 'Delivered',
                        type: 'bar',
                        data: [
                            10,
                            17,
                            12,
                            8,
                            10,
                            10,
                            20
                        ]
                    },
                    {
                        name: 'Rejected',
                        type: 'bar',
                        data: [
                            20,
                            10,
                            14,
                            20,
                            10,
                            14,
                            15
                        ]
                    },
                    {
                        name: 'Rejected',
                        type: 'bar',
                        data: [
                            15,
                            8,
                            16,
                            15,
                            15,
                            18,
                            10
                        ]
                    }
                ],
                markers: {
                    size: 0
                },
                xaxis: {
                    axisBorder: {
                        show: false
                    },
                    axisTicks: {
                        show: false
                    },
                    categories: [
                        'Mon',
                        'Tue',
                        'Wed',
                        'Thu',
                        'Fri',
                        'Sat',
                        'Sun'
                    ],
                    labels: {
                        style: {
                            colors: '#999',
                            fontSize: '13px',
                            cssClass: 'apexcharts-xaxis-label'
                        }
                    }
                },
                yaxis: {
                    axisBorder: {
                        show: false
                    },
                    axisTicks: {
                        show: false
                    },
                    labels: {
                        style: {
                            colors: [
                                '#999'
                            ],
                            fontSize: '13px',
                            cssClass: 'apexcharts-xaxis-label'
                        }
                    }
                },
                legend: {
                    show: false
                },
                grid: {
                    borderColor: '#e3ebf6',
                    strokeDashArray: 3
                },
                dataLabels: {
                    enabled: false
                },
                tooltip: {
                    shared: true,
                    intersect: false,
                    y: {
                        formatter: function(y) {
                            if (typeof y !== "undefined") return y.toFixed(0) + " orders";
                            return y;
                        }
                    }
                }
            };
            // Get data from data attributes
            var height = $this.dataset.height;
            // Inject dynamic properties
            options.colors = colorPalette;
            options.chart.height = height ? height : 350;
            // Create chart
            new apexCharts($this, options).render();
        }
        if (chartEl) init(chartEl);
    };
}
module.exports = apexBarChart;

},{"apexcharts":"Hm9hE","../theme-styles":"kqb2N"}],"6kPXv":[function(require,module,exports) {
//
// Apex bar chart
//
'use strict';
var apexCharts = require('apexcharts');
var themeStyles = require('../theme-styles');
function apexUsersChart() {
    this.init = function(chartEl) {
        var styles = new themeStyles();
        var colorPalette = [
            styles.colors().theme.primary,
            styles.colors().theme.secondary
        ];
        function init($this) {
            var options = {
                chart: {
                    type: 'line',
                    stacked: false,
                    zoom: {
                        enabled: false
                    },
                    toolbar: {
                        show: false
                    },
                    shadow: {
                        enabled: false
                    },
                    offsetX: 0,
                    animations: {
                        enabled: true,
                        easing: 'easeinout',
                        speed: 800,
                        animateGradually: {
                            enabled: true,
                            delay: 150
                        },
                        dynamicAnimation: {
                            enabled: true,
                            speed: 350
                        }
                    },
                    fontFamily: styles.fonts().base
                },
                colors: colorPalette,
                plotOptions: {
                    bar: {
                        columnWidth: '22px',
                        borderRadius: 5
                    }
                },
                stroke: {
                    colors: [
                        'transparent'
                    ],
                    width: 4,
                    curve: 'smooth'
                },
                series: [
                    {
                        name: 'Registered',
                        type: 'bar',
                        data: [
                            10,
                            17,
                            12,
                            8,
                            10,
                            10,
                            20,
                            10,
                            17,
                            12,
                            8,
                            10
                        ]
                    },
                    {
                        name: 'Subscribed',
                        type: 'bar',
                        data: [
                            20,
                            10,
                            14,
                            20,
                            10,
                            14,
                            15,
                            20,
                            10,
                            14,
                            20,
                            10
                        ]
                    }
                ],
                markers: {
                    size: 0
                },
                xaxis: {
                    axisBorder: {
                        show: false
                    },
                    axisTicks: {
                        show: false
                    },
                    categories: [
                        'Jan',
                        'Feb',
                        'Mar',
                        'Apr',
                        'May',
                        'Jun',
                        'Jul',
                        'Aug',
                        'Sep',
                        'Oct',
                        'Nov',
                        'Dec'
                    ],
                    labels: {
                        style: {
                            colors: '#999',
                            fontSize: '13px',
                            cssClass: 'apexcharts-xaxis-label'
                        }
                    }
                },
                yaxis: {
                    axisBorder: {
                        show: false
                    },
                    axisTicks: {
                        show: false
                    },
                    labels: {
                        style: {
                            colors: [
                                '#999'
                            ],
                            fontSize: '13px',
                            cssClass: 'apexcharts-xaxis-label'
                        }
                    }
                },
                legend: {
                    show: false
                },
                grid: {
                    borderColor: '#e3ebf6',
                    strokeDashArray: 3
                },
                dataLabels: {
                    enabled: false
                },
                tooltip: {
                    shared: true,
                    intersect: false,
                    y: {
                        formatter: function(y) {
                            if (typeof y !== "undefined") return y.toFixed(0) + " orders";
                            return y;
                        }
                    }
                },
                responsive: [
                    {
                        breakpoint: 1300,
                        options: {
                            plotOptions: {
                                bar: {
                                    columnWidth: '30px',
                                    borderRadius: 4
                                }
                            }
                        }
                    }
                ]
            };
            // Get data from data attributes
            var height = $this.dataset.height;
            // Inject dynamic properties
            options.colors = colorPalette;
            options.chart.height = height ? height : 350;
            // Create chart
            new apexCharts($this, options).render();
        }
        if (chartEl) init(chartEl);
    };
}
module.exports = apexUsersChart;

},{"apexcharts":"Hm9hE","../theme-styles":"kqb2N"}],"beBa7":[function(require,module,exports) {
//
// Apex spark chart
//
'use strict';
var apexCharts = require('apexcharts');
var themeStyles = require('../theme-styles');
function apexSparkChart() {
    this.init = function(chartEl1) {
        var styles = new themeStyles();
        function init(chartEl) {
            // Options
            var options = {
                chart: {
                    width: '100%',
                    sparkline: {
                        enabled: true
                    }
                },
                series: [],
                labels: [],
                plotOptions: {
                    bar: {
                        columnWidth: '40%',
                        endingShape: 'rounded'
                    }
                },
                stroke: {
                    curve: "smooth"
                },
                markers: {
                    size: 0
                },
                colors: [],
                tooltip: {
                    fixed: {
                        enabled: false
                    },
                    x: {
                        show: false
                    },
                    y: {
                        title: {
                            formatter: function(e) {
                                return "";
                            }
                        }
                    },
                    marker: {
                        show: !1
                    }
                }
            };
            // Get data from data attributes
            var dataset = chartEl.dataset.dataset, labels = chartEl.dataset.labels, color = chartEl.dataset.color, height = chartEl.dataset.height, type = chartEl.dataset.type, stroke = chartEl.dataset.stroke;
            // Inject synamic properties
            options.series = [
                {
                    data: dataset.split(',')
                }
            ];
            if (labels) options.labels = [
                labels
            ];
            options.colors = [
                styles.colors().theme[color]
            ];
            options.chart.height = height ? height : 35;
            options.chart.type = type ? type : 'line';
            options.stroke.width = stroke ? stroke : 2;
            // Create chart
            setTimeout(function() {
                new apexCharts(chartEl, options).render();
            }, 300);
        }
        if (chartEl1) init(chartEl1);
    };
}
module.exports = apexSparkChart;

},{"apexcharts":"Hm9hE","../theme-styles":"kqb2N"}],"dvEkG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _flatpickr = require("flatpickr");
var _flatpickrDefault = parcelHelpers.interopDefault(_flatpickr);
//
// Datepicker
// using the Flatpickr plugin
//
'use strict';
module.exports = function datepicker() {
    this.init = function(el) {
        var options = {
            enableTime: false,
            allowInput: true,
            wrap: true,
            dateFormat: 'M d, Y',
            position: 'right'
        };
        _flatpickrDefault.default(el, options);
    };
    this.range = function(el) {
        var options = {
            enableTime: false,
            allowInput: true,
            wrap: true,
            dateFormat: 'M d, Y',
            mode: 'range',
            defaultDate: [
                "Jan 23, 2022",
                "Jan 30, 2022"
            ]
        };
        _flatpickrDefault.default(el, options);
    };
};

},{"flatpickr":"4MQGV","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"4MQGV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _options = require("./types/options");
var _default = require("./l10n/default");
var _defaultDefault = parcelHelpers.interopDefault(_default);
var _utils = require("./utils");
var _dom = require("./utils/dom");
var _dates = require("./utils/dates");
var _formatting = require("./utils/formatting");
var _polyfills = require("./utils/polyfills");
var __assign = undefined && undefined.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = undefined && undefined.__spreadArrays || function() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
};
var DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element1, instanceConfig) {
    var self = {
        config: __assign(__assign({}, _options.defaults), flatpickr.defaultConfig),
        l10n: _defaultDefault.default
    };
    self.parseDate = _dates.createDateParser({
        config: self.config,
        l10n: self.l10n
    });
    self._handlers = [];
    self.pluginElements = [];
    self.loadedPlugins = [];
    self._bind = bind;
    self._setHoursFromDate = setHoursFromDate;
    self._positionCalendar = positionCalendar;
    self.changeMonth = changeMonth;
    self.changeYear = changeYear;
    self.clear = clear;
    self.close = close;
    self.onMouseOver = onMouseOver;
    self._createElement = _dom.createElement;
    self.createDay = createDay;
    self.destroy = destroy;
    self.isEnabled = isEnabled;
    self.jumpToDate = jumpToDate;
    self.updateValue = updateValue;
    self.open = open;
    self.redraw = redraw;
    self.set = set;
    self.setDate = setDate;
    self.toggle = toggle;
    function setupHelperFunctions() {
        self.utils = {
            getDaysInMonth: function(month, yr) {
                if (month === void 0) month = self.currentMonth;
                if (yr === void 0) yr = self.currentYear;
                if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0)) return 29;
                return self.l10n.daysInMonth[month];
            }
        };
    }
    function init() {
        self.element = self.input = element1;
        self.isOpen = false;
        parseConfig();
        setupLocale();
        setupInputs();
        setupDates();
        setupHelperFunctions();
        if (!self.isMobile) build();
        bindEvents();
        if (self.selectedDates.length || self.config.noCalendar) {
            if (self.config.enableTime) setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj : undefined);
            updateValue(false);
        }
        setCalendarWidth();
        var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        if (!self.isMobile && isSafari) positionCalendar();
        triggerEvent("onReady");
    }
    function getClosestActiveElement() {
        var _a;
        return ((_a = self.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
    }
    function bindToInstance(fn) {
        return fn.bind(self);
    }
    function setCalendarWidth() {
        var config = self.config;
        if (config.weekNumbers === false && config.showMonths === 1) return;
        else if (config.noCalendar !== true) window.requestAnimationFrame(function() {
            if (self.calendarContainer !== undefined) {
                self.calendarContainer.style.visibility = "hidden";
                self.calendarContainer.style.display = "block";
            }
            if (self.daysContainer !== undefined) {
                var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
                self.daysContainer.style.width = daysWidth + "px";
                self.calendarContainer.style.width = daysWidth + (self.weekWrapper !== undefined ? self.weekWrapper.offsetWidth : 0) + "px";
                self.calendarContainer.style.removeProperty("visibility");
                self.calendarContainer.style.removeProperty("display");
            }
        });
    }
    function updateTime(e) {
        if (self.selectedDates.length === 0) {
            var defaultDate = self.config.minDate === undefined || _dates.compareDates(new Date(), self.config.minDate) >= 0 ? new Date() : new Date(self.config.minDate.getTime());
            var defaults = _dates.getDefaultHours(self.config);
            defaultDate.setHours(defaults.hours, defaults.minutes, defaults.seconds, defaultDate.getMilliseconds());
            self.selectedDates = [
                defaultDate
            ];
            self.latestSelectedDateObj = defaultDate;
        }
        if (e !== undefined && e.type !== "blur") timeWrapper(e);
        var prevValue = self._input.value;
        setHoursFromInputs();
        updateValue();
        if (self._input.value !== prevValue) self._debouncedChange();
    }
    function ampm2military(hour, amPM) {
        return hour % 12 + 12 * _utils.int(amPM === self.l10n.amPM[1]);
    }
    function military2ampm(hour) {
        switch(hour % 24){
            case 0:
            case 12:
                return 12;
            default:
                return hour % 12;
        }
    }
    function setHoursFromInputs() {
        if (self.hourElement === undefined || self.minuteElement === undefined) return;
        var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = self.secondElement !== undefined ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;
        if (self.amPM !== undefined) hours = ampm2military(hours, self.amPM.textContent);
        var limitMinHours = self.config.minTime !== undefined || self.config.minDate && self.minDateHasTime && self.latestSelectedDateObj && _dates.compareDates(self.latestSelectedDateObj, self.config.minDate, true) === 0;
        var limitMaxHours = self.config.maxTime !== undefined || self.config.maxDate && self.maxDateHasTime && self.latestSelectedDateObj && _dates.compareDates(self.latestSelectedDateObj, self.config.maxDate, true) === 0;
        if (self.config.maxTime !== undefined && self.config.minTime !== undefined && self.config.minTime > self.config.maxTime) {
            var minBound = _dates.calculateSecondsSinceMidnight(self.config.minTime.getHours(), self.config.minTime.getMinutes(), self.config.minTime.getSeconds());
            var maxBound = _dates.calculateSecondsSinceMidnight(self.config.maxTime.getHours(), self.config.maxTime.getMinutes(), self.config.maxTime.getSeconds());
            var currentTime = _dates.calculateSecondsSinceMidnight(hours, minutes, seconds);
            if (currentTime > maxBound && currentTime < minBound) {
                var result = _dates.parseSeconds(minBound);
                hours = result[0];
                minutes = result[1];
                seconds = result[2];
            }
        } else {
            if (limitMaxHours) {
                var maxTime = self.config.maxTime !== undefined ? self.config.maxTime : self.config.maxDate;
                hours = Math.min(hours, maxTime.getHours());
                if (hours === maxTime.getHours()) minutes = Math.min(minutes, maxTime.getMinutes());
                if (minutes === maxTime.getMinutes()) seconds = Math.min(seconds, maxTime.getSeconds());
            }
            if (limitMinHours) {
                var minTime = self.config.minTime !== undefined ? self.config.minTime : self.config.minDate;
                hours = Math.max(hours, minTime.getHours());
                if (hours === minTime.getHours() && minutes < minTime.getMinutes()) minutes = minTime.getMinutes();
                if (minutes === minTime.getMinutes()) seconds = Math.max(seconds, minTime.getSeconds());
            }
        }
        setHours(hours, minutes, seconds);
    }
    function setHoursFromDate(dateObj) {
        var date = dateObj || self.latestSelectedDateObj;
        if (date && date instanceof Date) setHours(date.getHours(), date.getMinutes(), date.getSeconds());
    }
    function setHours(hours, minutes, seconds) {
        if (self.latestSelectedDateObj !== undefined) self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
        if (!self.hourElement || !self.minuteElement || self.isMobile) return;
        self.hourElement.value = _utils.pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * _utils.int(hours % 12 === 0) : hours);
        self.minuteElement.value = _utils.pad(minutes);
        if (self.amPM !== undefined) self.amPM.textContent = self.l10n.amPM[_utils.int(hours >= 12)];
        if (self.secondElement !== undefined) self.secondElement.value = _utils.pad(seconds);
    }
    function onYearInput(event) {
        var eventTarget = _dom.getEventTarget(event);
        var year = parseInt(eventTarget.value) + (event.delta || 0);
        if (year / 1000 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) changeYear(year);
    }
    function bind(element, event, handler, options) {
        if (event instanceof Array) return event.forEach(function(ev) {
            return bind(element, ev, handler, options);
        });
        if (element instanceof Array) return element.forEach(function(el) {
            return bind(el, event, handler, options);
        });
        element.addEventListener(event, handler, options);
        self._handlers.push({
            remove: function() {
                return element.removeEventListener(event, handler, options);
            }
        });
    }
    function triggerChange1() {
        triggerEvent("onChange");
    }
    function bindEvents() {
        if (self.config.wrap) [
            "open",
            "close",
            "toggle",
            "clear"
        ].forEach(function(evt) {
            Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function(el) {
                return bind(el, "click", self[evt]);
            });
        });
        if (self.isMobile) {
            setupMobile();
            return;
        }
        var debouncedResize = _utils.debounce(onResize, 50);
        self._debouncedChange = _utils.debounce(triggerChange1, DEBOUNCED_CHANGE_MS);
        if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent)) bind(self.daysContainer, "mouseover", function(e) {
            if (self.config.mode === "range") onMouseOver(_dom.getEventTarget(e));
        });
        bind(self._input, "keydown", onKeyDown);
        if (self.calendarContainer !== undefined) bind(self.calendarContainer, "keydown", onKeyDown);
        if (!self.config.inline && !self.config.static) bind(window, "resize", debouncedResize);
        if (window.ontouchstart !== undefined) bind(window.document, "touchstart", documentClick);
        else bind(window.document, "mousedown", documentClick);
        bind(window.document, "focus", documentClick, {
            capture: true
        });
        if (self.config.clickOpens === true) {
            bind(self._input, "focus", self.open);
            bind(self._input, "click", self.open);
        }
        if (self.daysContainer !== undefined) {
            bind(self.monthNav, "click", onMonthNavClick);
            bind(self.monthNav, [
                "keyup",
                "increment"
            ], onYearInput);
            bind(self.daysContainer, "click", selectDate);
        }
        if (self.timeContainer !== undefined && self.minuteElement !== undefined && self.hourElement !== undefined) {
            var selText = function(e) {
                return _dom.getEventTarget(e).select();
            };
            bind(self.timeContainer, [
                "increment"
            ], updateTime);
            bind(self.timeContainer, "blur", updateTime, {
                capture: true
            });
            bind(self.timeContainer, "click", timeIncrement);
            bind([
                self.hourElement,
                self.minuteElement
            ], [
                "focus",
                "click"
            ], selText);
            if (self.secondElement !== undefined) bind(self.secondElement, "focus", function() {
                return self.secondElement && self.secondElement.select();
            });
            if (self.amPM !== undefined) bind(self.amPM, "click", function(e) {
                updateTime(e);
            });
        }
        if (self.config.allowInput) bind(self._input, "blur", onBlur);
    }
    function jumpToDate(jumpDate, triggerChange) {
        var jumpTo = jumpDate !== undefined ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate && self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);
        var oldYear = self.currentYear;
        var oldMonth = self.currentMonth;
        try {
            if (jumpTo !== undefined) {
                self.currentYear = jumpTo.getFullYear();
                self.currentMonth = jumpTo.getMonth();
            }
        } catch (e) {
            e.message = "Invalid date supplied: " + jumpTo;
            self.config.errorHandler(e);
        }
        if (triggerChange && self.currentYear !== oldYear) {
            triggerEvent("onYearChange");
            buildMonthSwitch();
        }
        if (triggerChange && (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) triggerEvent("onMonthChange");
        self.redraw();
    }
    function timeIncrement(e) {
        var eventTarget = _dom.getEventTarget(e);
        if (~eventTarget.className.indexOf("arrow")) incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
    }
    function incrementNumInput(e, delta, inputElem) {
        var target = e && _dom.getEventTarget(e);
        var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
        var event = createEvent("increment");
        event.delta = delta;
        input && input.dispatchEvent(event);
    }
    function build() {
        var fragment = window.document.createDocumentFragment();
        self.calendarContainer = _dom.createElement("div", "flatpickr-calendar");
        self.calendarContainer.tabIndex = -1;
        if (!self.config.noCalendar) {
            fragment.appendChild(buildMonthNav());
            self.innerContainer = _dom.createElement("div", "flatpickr-innerContainer");
            if (self.config.weekNumbers) {
                var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
                self.innerContainer.appendChild(weekWrapper);
                self.weekNumbers = weekNumbers;
                self.weekWrapper = weekWrapper;
            }
            self.rContainer = _dom.createElement("div", "flatpickr-rContainer");
            self.rContainer.appendChild(buildWeekdays());
            if (!self.daysContainer) {
                self.daysContainer = _dom.createElement("div", "flatpickr-days");
                self.daysContainer.tabIndex = -1;
            }
            buildDays();
            self.rContainer.appendChild(self.daysContainer);
            self.innerContainer.appendChild(self.rContainer);
            fragment.appendChild(self.innerContainer);
        }
        if (self.config.enableTime) fragment.appendChild(buildTime());
        _dom.toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
        _dom.toggleClass(self.calendarContainer, "animate", self.config.animate === true);
        _dom.toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
        self.calendarContainer.appendChild(fragment);
        var customAppend = self.config.appendTo !== undefined && self.config.appendTo.nodeType !== undefined;
        if (self.config.inline || self.config.static) {
            self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
            if (self.config.inline) {
                if (!customAppend && self.element.parentNode) self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
                else if (self.config.appendTo !== undefined) self.config.appendTo.appendChild(self.calendarContainer);
            }
            if (self.config.static) {
                var wrapper = _dom.createElement("div", "flatpickr-wrapper");
                if (self.element.parentNode) self.element.parentNode.insertBefore(wrapper, self.element);
                wrapper.appendChild(self.element);
                if (self.altInput) wrapper.appendChild(self.altInput);
                wrapper.appendChild(self.calendarContainer);
            }
        }
        if (!self.config.static && !self.config.inline) (self.config.appendTo !== undefined ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);
    }
    function createDay(className, date, _dayNumber, i) {
        var dateIsEnabled = isEnabled(date, true), dayElement = _dom.createElement("span", className, date.getDate().toString());
        dayElement.dateObj = date;
        dayElement.$i = i;
        dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
        if (className.indexOf("hidden") === -1 && _dates.compareDates(date, self.now) === 0) {
            self.todayDateElem = dayElement;
            dayElement.classList.add("today");
            dayElement.setAttribute("aria-current", "date");
        }
        if (dateIsEnabled) {
            dayElement.tabIndex = -1;
            if (isDateSelected(date)) {
                dayElement.classList.add("selected");
                self.selectedDateElem = dayElement;
                if (self.config.mode === "range") {
                    _dom.toggleClass(dayElement, "startRange", self.selectedDates[0] && _dates.compareDates(date, self.selectedDates[0], true) === 0);
                    _dom.toggleClass(dayElement, "endRange", self.selectedDates[1] && _dates.compareDates(date, self.selectedDates[1], true) === 0);
                    if (className === "nextMonthDay") dayElement.classList.add("inRange");
                }
            }
        } else dayElement.classList.add("flatpickr-disabled");
        if (self.config.mode === "range") {
            if (isDateInRange(date) && !isDateSelected(date)) dayElement.classList.add("inRange");
        }
        if (self.weekNumbers && self.config.showMonths === 1 && className !== "prevMonthDay" && i % 7 === 6) self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
        triggerEvent("onDayCreate", dayElement);
        return dayElement;
    }
    function focusOnDayElem(targetNode) {
        targetNode.focus();
        if (self.config.mode === "range") onMouseOver(targetNode);
    }
    function getFirstAvailableDay(delta) {
        var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
        var endMonth = delta > 0 ? self.config.showMonths : -1;
        for(var m = startMonth; m != endMonth; m += delta){
            var month = self.daysContainer.children[m];
            var startIndex = delta > 0 ? 0 : month.children.length - 1;
            var endIndex = delta > 0 ? month.children.length : -1;
            for(var i = startIndex; i != endIndex; i += delta){
                var c = month.children[i];
                if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj)) return c;
            }
        }
        return undefined;
    }
    function getNextAvailableDay(current, delta) {
        var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self.currentMonth;
        var endMonth = delta > 0 ? self.config.showMonths : -1;
        var loopDelta = delta > 0 ? 1 : -1;
        for(var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta){
            var month = self.daysContainer.children[m];
            var startIndex = givenMonth - self.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
            var numMonthDays = month.children.length;
            for(var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta){
                var c = month.children[i];
                if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta)) return focusOnDayElem(c);
            }
        }
        self.changeMonth(loopDelta);
        focusOnDay(getFirstAvailableDay(loopDelta), 0);
        return undefined;
    }
    function focusOnDay(current, offset) {
        var activeElement = getClosestActiveElement();
        var dayFocused = isInView(activeElement || document.body);
        var startElem = current !== undefined ? current : dayFocused ? activeElement : self.selectedDateElem !== undefined && isInView(self.selectedDateElem) ? self.selectedDateElem : self.todayDateElem !== undefined && isInView(self.todayDateElem) ? self.todayDateElem : getFirstAvailableDay(offset > 0 ? 1 : -1);
        if (startElem === undefined) self._input.focus();
        else if (!dayFocused) focusOnDayElem(startElem);
        else getNextAvailableDay(startElem, offset);
    }
    function buildMonthDays(year, month) {
        var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
        var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12, year);
        var daysInMonth = self.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
        var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
        for(; dayNumber <= prevMonthDays; dayNumber++, dayIndex++)days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
        for(dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++)days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
        for(var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++)days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
        var dayContainer = _dom.createElement("div", "dayContainer");
        dayContainer.appendChild(days);
        return dayContainer;
    }
    function buildDays() {
        if (self.daysContainer === undefined) return;
        _dom.clearNode(self.daysContainer);
        if (self.weekNumbers) _dom.clearNode(self.weekNumbers);
        var frag = document.createDocumentFragment();
        for(var i = 0; i < self.config.showMonths; i++){
            var d = new Date(self.currentYear, self.currentMonth, 1);
            d.setMonth(self.currentMonth + i);
            frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
        }
        self.daysContainer.appendChild(frag);
        self.days = self.daysContainer.firstChild;
        if (self.config.mode === "range" && self.selectedDates.length === 1) onMouseOver();
    }
    function buildMonthSwitch() {
        if (self.config.showMonths > 1 || self.config.monthSelectorType !== "dropdown") return;
        var shouldBuildMonth = function(month) {
            if (self.config.minDate !== undefined && self.currentYear === self.config.minDate.getFullYear() && month < self.config.minDate.getMonth()) return false;
            return !(self.config.maxDate !== undefined && self.currentYear === self.config.maxDate.getFullYear() && month > self.config.maxDate.getMonth());
        };
        self.monthsDropdownContainer.tabIndex = -1;
        self.monthsDropdownContainer.innerHTML = "";
        for(var i = 0; i < 12; i++){
            if (!shouldBuildMonth(i)) continue;
            var month1 = _dom.createElement("option", "flatpickr-monthDropdown-month");
            month1.value = new Date(self.currentYear, i).getMonth().toString();
            month1.textContent = _formatting.monthToStr(i, self.config.shorthandCurrentMonth, self.l10n);
            month1.tabIndex = -1;
            if (self.currentMonth === i) month1.selected = true;
            self.monthsDropdownContainer.appendChild(month1);
        }
    }
    function buildMonth() {
        var container = _dom.createElement("div", "flatpickr-month");
        var monthNavFragment = window.document.createDocumentFragment();
        var monthElement;
        if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") monthElement = _dom.createElement("span", "cur-month");
        else {
            self.monthsDropdownContainer = _dom.createElement("select", "flatpickr-monthDropdown-months");
            self.monthsDropdownContainer.setAttribute("aria-label", self.l10n.monthAriaLabel);
            bind(self.monthsDropdownContainer, "change", function(e) {
                var target = _dom.getEventTarget(e);
                var selectedMonth = parseInt(target.value, 10);
                self.changeMonth(selectedMonth - self.currentMonth);
                triggerEvent("onMonthChange");
            });
            buildMonthSwitch();
            monthElement = self.monthsDropdownContainer;
        }
        var yearInput = _dom.createNumberInput("cur-year", {
            tabindex: "-1"
        });
        var yearElement = yearInput.getElementsByTagName("input")[0];
        yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
        if (self.config.minDate) yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
        if (self.config.maxDate) {
            yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
            yearElement.disabled = !!self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
        }
        var currentMonth = _dom.createElement("div", "flatpickr-current-month");
        currentMonth.appendChild(monthElement);
        currentMonth.appendChild(yearInput);
        monthNavFragment.appendChild(currentMonth);
        container.appendChild(monthNavFragment);
        return {
            container: container,
            yearElement: yearElement,
            monthElement: monthElement
        };
    }
    function buildMonths() {
        _dom.clearNode(self.monthNav);
        self.monthNav.appendChild(self.prevMonthNav);
        if (self.config.showMonths) {
            self.yearElements = [];
            self.monthElements = [];
        }
        for(var m = self.config.showMonths; m--;){
            var month = buildMonth();
            self.yearElements.push(month.yearElement);
            self.monthElements.push(month.monthElement);
            self.monthNav.appendChild(month.container);
        }
        self.monthNav.appendChild(self.nextMonthNav);
    }
    function buildMonthNav() {
        self.monthNav = _dom.createElement("div", "flatpickr-months");
        self.yearElements = [];
        self.monthElements = [];
        self.prevMonthNav = _dom.createElement("span", "flatpickr-prev-month");
        self.prevMonthNav.innerHTML = self.config.prevArrow;
        self.nextMonthNav = _dom.createElement("span", "flatpickr-next-month");
        self.nextMonthNav.innerHTML = self.config.nextArrow;
        buildMonths();
        Object.defineProperty(self, "_hidePrevMonthArrow", {
            get: function() {
                return self.__hidePrevMonthArrow;
            },
            set: function(bool) {
                if (self.__hidePrevMonthArrow !== bool) {
                    _dom.toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
                    self.__hidePrevMonthArrow = bool;
                }
            }
        });
        Object.defineProperty(self, "_hideNextMonthArrow", {
            get: function() {
                return self.__hideNextMonthArrow;
            },
            set: function(bool) {
                if (self.__hideNextMonthArrow !== bool) {
                    _dom.toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
                    self.__hideNextMonthArrow = bool;
                }
            }
        });
        self.currentYearElement = self.yearElements[0];
        updateNavigationCurrentMonth();
        return self.monthNav;
    }
    function buildTime() {
        self.calendarContainer.classList.add("hasTime");
        if (self.config.noCalendar) self.calendarContainer.classList.add("noCalendar");
        var defaults = _dates.getDefaultHours(self.config);
        self.timeContainer = _dom.createElement("div", "flatpickr-time");
        self.timeContainer.tabIndex = -1;
        var separator = _dom.createElement("span", "flatpickr-time-separator", ":");
        var hourInput = _dom.createNumberInput("flatpickr-hour", {
            "aria-label": self.l10n.hourAriaLabel
        });
        self.hourElement = hourInput.getElementsByTagName("input")[0];
        var minuteInput = _dom.createNumberInput("flatpickr-minute", {
            "aria-label": self.l10n.minuteAriaLabel
        });
        self.minuteElement = minuteInput.getElementsByTagName("input")[0];
        self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
        self.hourElement.value = _utils.pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.time_24hr ? defaults.hours : military2ampm(defaults.hours));
        self.minuteElement.value = _utils.pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : defaults.minutes);
        self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
        self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
        self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
        self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
        self.hourElement.setAttribute("maxlength", "2");
        self.minuteElement.setAttribute("min", "0");
        self.minuteElement.setAttribute("max", "59");
        self.minuteElement.setAttribute("maxlength", "2");
        self.timeContainer.appendChild(hourInput);
        self.timeContainer.appendChild(separator);
        self.timeContainer.appendChild(minuteInput);
        if (self.config.time_24hr) self.timeContainer.classList.add("time24hr");
        if (self.config.enableSeconds) {
            self.timeContainer.classList.add("hasSeconds");
            var secondInput = _dom.createNumberInput("flatpickr-second");
            self.secondElement = secondInput.getElementsByTagName("input")[0];
            self.secondElement.value = _utils.pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getSeconds() : defaults.seconds);
            self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
            self.secondElement.setAttribute("min", "0");
            self.secondElement.setAttribute("max", "59");
            self.secondElement.setAttribute("maxlength", "2");
            self.timeContainer.appendChild(_dom.createElement("span", "flatpickr-time-separator", ":"));
            self.timeContainer.appendChild(secondInput);
        }
        if (!self.config.time_24hr) {
            self.amPM = _dom.createElement("span", "flatpickr-am-pm", self.l10n.amPM[_utils.int((self.latestSelectedDateObj ? self.hourElement.value : self.config.defaultHour) > 11)]);
            self.amPM.title = self.l10n.toggleTitle;
            self.amPM.tabIndex = -1;
            self.timeContainer.appendChild(self.amPM);
        }
        return self.timeContainer;
    }
    function buildWeekdays() {
        if (!self.weekdayContainer) self.weekdayContainer = _dom.createElement("div", "flatpickr-weekdays");
        else _dom.clearNode(self.weekdayContainer);
        for(var i = self.config.showMonths; i--;){
            var container = _dom.createElement("div", "flatpickr-weekdaycontainer");
            self.weekdayContainer.appendChild(container);
        }
        updateWeekdays();
        return self.weekdayContainer;
    }
    function updateWeekdays() {
        if (!self.weekdayContainer) return;
        var firstDayOfWeek = self.l10n.firstDayOfWeek;
        var weekdays = __spreadArrays(self.l10n.weekdays.shorthand);
        if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
        for(var i = self.config.showMonths; i--;)self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
    }
    function buildWeeks() {
        self.calendarContainer.classList.add("hasWeeks");
        var weekWrapper = _dom.createElement("div", "flatpickr-weekwrapper");
        weekWrapper.appendChild(_dom.createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
        var weekNumbers = _dom.createElement("div", "flatpickr-weeks");
        weekWrapper.appendChild(weekNumbers);
        return {
            weekWrapper: weekWrapper,
            weekNumbers: weekNumbers
        };
    }
    function changeMonth(value, isOffset) {
        if (isOffset === void 0) isOffset = true;
        var delta = isOffset ? value : value - self.currentMonth;
        if (delta < 0 && self._hidePrevMonthArrow === true || delta > 0 && self._hideNextMonthArrow === true) return;
        self.currentMonth += delta;
        if (self.currentMonth < 0 || self.currentMonth > 11) {
            self.currentYear += self.currentMonth > 11 ? 1 : -1;
            self.currentMonth = (self.currentMonth + 12) % 12;
            triggerEvent("onYearChange");
            buildMonthSwitch();
        }
        buildDays();
        triggerEvent("onMonthChange");
        updateNavigationCurrentMonth();
    }
    function clear(triggerChangeEvent, toInitial) {
        if (triggerChangeEvent === void 0) triggerChangeEvent = true;
        if (toInitial === void 0) toInitial = true;
        self.input.value = "";
        if (self.altInput !== undefined) self.altInput.value = "";
        if (self.mobileInput !== undefined) self.mobileInput.value = "";
        self.selectedDates = [];
        self.latestSelectedDateObj = undefined;
        if (toInitial === true) {
            self.currentYear = self._initialDate.getFullYear();
            self.currentMonth = self._initialDate.getMonth();
        }
        if (self.config.enableTime === true) {
            var _a = _dates.getDefaultHours(self.config), hours = _a.hours, minutes = _a.minutes, seconds = _a.seconds;
            setHours(hours, minutes, seconds);
        }
        self.redraw();
        if (triggerChangeEvent) triggerEvent("onChange");
    }
    function close() {
        self.isOpen = false;
        if (!self.isMobile) {
            if (self.calendarContainer !== undefined) self.calendarContainer.classList.remove("open");
            if (self._input !== undefined) self._input.classList.remove("active");
        }
        triggerEvent("onClose");
    }
    function destroy() {
        if (self.config !== undefined) triggerEvent("onDestroy");
        for(var i = self._handlers.length; i--;)self._handlers[i].remove();
        self._handlers = [];
        if (self.mobileInput) {
            if (self.mobileInput.parentNode) self.mobileInput.parentNode.removeChild(self.mobileInput);
            self.mobileInput = undefined;
        } else if (self.calendarContainer && self.calendarContainer.parentNode) {
            if (self.config.static && self.calendarContainer.parentNode) {
                var wrapper = self.calendarContainer.parentNode;
                wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
                if (wrapper.parentNode) {
                    while(wrapper.firstChild)wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                    wrapper.parentNode.removeChild(wrapper);
                }
            } else self.calendarContainer.parentNode.removeChild(self.calendarContainer);
        }
        if (self.altInput) {
            self.input.type = "text";
            if (self.altInput.parentNode) self.altInput.parentNode.removeChild(self.altInput);
            delete self.altInput;
        }
        if (self.input) {
            self.input.type = self.input._type;
            self.input.classList.remove("flatpickr-input");
            self.input.removeAttribute("readonly");
        }
        [
            "_showTimeInput",
            "latestSelectedDateObj",
            "_hideNextMonthArrow",
            "_hidePrevMonthArrow",
            "__hideNextMonthArrow",
            "__hidePrevMonthArrow",
            "isMobile",
            "isOpen",
            "selectedDateElem",
            "minDateHasTime",
            "maxDateHasTime",
            "days",
            "daysContainer",
            "_input",
            "_positionElement",
            "innerContainer",
            "rContainer",
            "monthNav",
            "todayDateElem",
            "calendarContainer",
            "weekdayContainer",
            "prevMonthNav",
            "nextMonthNav",
            "monthsDropdownContainer",
            "currentMonthElement",
            "currentYearElement",
            "navigationCurrentMonth",
            "selectedDateElem",
            "config", 
        ].forEach(function(k) {
            try {
                delete self[k];
            } catch (_) {}
        });
    }
    function isCalendarElem(elem) {
        return self.calendarContainer.contains(elem);
    }
    function documentClick(e) {
        if (self.isOpen && !self.config.inline) {
            var eventTarget_1 = _dom.getEventTarget(e);
            var isCalendarElement = isCalendarElem(eventTarget_1);
            var isInput = eventTarget_1 === self.input || eventTarget_1 === self.altInput || self.element.contains(eventTarget_1) || e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));
            var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget);
            var isIgnored = !self.config.ignoredFocusElements.some(function(elem) {
                return elem.contains(eventTarget_1);
            });
            if (lostFocus && isIgnored) {
                if (self.config.allowInput) self.setDate(self._input.value, false, self.config.altInput ? self.config.altFormat : self.config.dateFormat);
                if (self.timeContainer !== undefined && self.minuteElement !== undefined && self.hourElement !== undefined && self.input.value !== "" && self.input.value !== undefined) updateTime();
                self.close();
                if (self.config && self.config.mode === "range" && self.selectedDates.length === 1) self.clear(false);
            }
        }
    }
    function changeYear(newYear) {
        if (!newYear || self.config.minDate && newYear < self.config.minDate.getFullYear() || self.config.maxDate && newYear > self.config.maxDate.getFullYear()) return;
        var newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;
        self.currentYear = newYearNum || self.currentYear;
        if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
        else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
        if (isNewYear) {
            self.redraw();
            triggerEvent("onYearChange");
            buildMonthSwitch();
        }
    }
    function isEnabled(date, timeless) {
        var _a;
        if (timeless === void 0) timeless = true;
        var dateToCheck = self.parseDate(date, undefined, timeless);
        if (self.config.minDate && dateToCheck && _dates.compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && dateToCheck && _dates.compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0) return false;
        if (!self.config.enable && self.config.disable.length === 0) return true;
        if (dateToCheck === undefined) return false;
        var bool = !!self.config.enable, array = (_a = self.config.enable) !== null && _a !== void 0 ? _a : self.config.disable;
        for(var i = 0, d = void 0; i < array.length; i++){
            d = array[i];
            if (typeof d === "function" && d(dateToCheck)) return bool;
            else if (d instanceof Date && dateToCheck !== undefined && d.getTime() === dateToCheck.getTime()) return bool;
            else if (typeof d === "string") {
                var parsed = self.parseDate(d, undefined, true);
                return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
            } else if (typeof d === "object" && dateToCheck !== undefined && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime()) return bool;
        }
        return !bool;
    }
    function isInView(elem) {
        if (self.daysContainer !== undefined) return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self.daysContainer.contains(elem);
        return false;
    }
    function onBlur(e) {
        var isInput = e.target === self._input;
        var valueChanged = self._input.value.trimEnd() !== getDateStr();
        if (isInput && valueChanged && !(e.relatedTarget && isCalendarElem(e.relatedTarget))) self.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);
    }
    function onKeyDown(e) {
        var eventTarget = _dom.getEventTarget(e);
        var isInput = self.config.wrap ? element1.contains(eventTarget) : eventTarget === self._input;
        var allowInput = self.config.allowInput;
        var allowKeydown = self.isOpen && (!allowInput || !isInput);
        var allowInlineKeydown = self.config.inline && isInput && !allowInput;
        if (e.keyCode === 13 && isInput) {
            if (allowInput) {
                self.setDate(self._input.value, true, eventTarget === self.altInput ? self.config.altFormat : self.config.dateFormat);
                self.close();
                return eventTarget.blur();
            } else self.open();
        } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
            var isTimeObj = !!self.timeContainer && self.timeContainer.contains(eventTarget);
            switch(e.keyCode){
                case 13:
                    if (isTimeObj) {
                        e.preventDefault();
                        updateTime();
                        focusAndClose();
                    } else selectDate(e);
                    break;
                case 27:
                    e.preventDefault();
                    focusAndClose();
                    break;
                case 8:
                case 46:
                    if (isInput && !self.config.allowInput) {
                        e.preventDefault();
                        self.clear();
                    }
                    break;
                case 37:
                case 39:
                    if (!isTimeObj && !isInput) {
                        e.preventDefault();
                        var activeElement = getClosestActiveElement();
                        if (self.daysContainer !== undefined && (allowInput === false || activeElement && isInView(activeElement))) {
                            var delta_1 = e.keyCode === 39 ? 1 : -1;
                            if (!e.ctrlKey) focusOnDay(undefined, delta_1);
                            else {
                                e.stopPropagation();
                                changeMonth(delta_1);
                                focusOnDay(getFirstAvailableDay(1), 0);
                            }
                        }
                    } else if (self.hourElement) self.hourElement.focus();
                    break;
                case 38:
                case 40:
                    e.preventDefault();
                    var delta = e.keyCode === 40 ? 1 : -1;
                    if (self.daysContainer && eventTarget.$i !== undefined || eventTarget === self.input || eventTarget === self.altInput) {
                        if (e.ctrlKey) {
                            e.stopPropagation();
                            changeYear(self.currentYear - delta);
                            focusOnDay(getFirstAvailableDay(1), 0);
                        } else if (!isTimeObj) focusOnDay(undefined, delta * 7);
                    } else if (eventTarget === self.currentYearElement) changeYear(self.currentYear - delta);
                    else if (self.config.enableTime) {
                        if (!isTimeObj && self.hourElement) self.hourElement.focus();
                        updateTime(e);
                        self._debouncedChange();
                    }
                    break;
                case 9:
                    if (isTimeObj) {
                        var elems = [
                            self.hourElement,
                            self.minuteElement,
                            self.secondElement,
                            self.amPM, 
                        ].concat(self.pluginElements).filter(function(x) {
                            return x;
                        });
                        var i = elems.indexOf(eventTarget);
                        if (i !== -1) {
                            var target = elems[i + (e.shiftKey ? -1 : 1)];
                            e.preventDefault();
                            (target || self._input).focus();
                        }
                    } else if (!self.config.noCalendar && self.daysContainer && self.daysContainer.contains(eventTarget) && e.shiftKey) {
                        e.preventDefault();
                        self._input.focus();
                    }
                    break;
                default:
                    break;
            }
        }
        if (self.amPM !== undefined && eventTarget === self.amPM) switch(e.key){
            case self.l10n.amPM[0].charAt(0):
            case self.l10n.amPM[0].charAt(0).toLowerCase():
                self.amPM.textContent = self.l10n.amPM[0];
                setHoursFromInputs();
                updateValue();
                break;
            case self.l10n.amPM[1].charAt(0):
            case self.l10n.amPM[1].charAt(0).toLowerCase():
                self.amPM.textContent = self.l10n.amPM[1];
                setHoursFromInputs();
                updateValue();
                break;
        }
        if (isInput || isCalendarElem(eventTarget)) triggerEvent("onKeyDown", e);
    }
    function onMouseOver(elem, cellClass) {
        if (cellClass === void 0) cellClass = "flatpickr-day";
        if (self.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled"))) return;
        var hoverDate = elem ? elem.dateObj.getTime() : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
        var containsDisabled = false;
        var minRange = 0, maxRange = 0;
        for(var t = rangeStartDate; t < rangeEndDate; t += _dates.duration.DAY)if (!isEnabled(new Date(t), true)) {
            containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;
            if (t < initialDate && (!minRange || t > minRange)) minRange = t;
            else if (t > initialDate && (!maxRange || t < maxRange)) maxRange = t;
        }
        var hoverableCells = Array.from(self.rContainer.querySelectorAll("*:nth-child(-n+" + self.config.showMonths + ") > ." + cellClass));
        hoverableCells.forEach(function(dayElem) {
            var date = dayElem.dateObj;
            var timestamp = date.getTime();
            var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
            if (outOfRange) {
                dayElem.classList.add("notAllowed");
                [
                    "inRange",
                    "startRange",
                    "endRange"
                ].forEach(function(c) {
                    dayElem.classList.remove(c);
                });
                return;
            } else if (containsDisabled && !outOfRange) return;
            [
                "startRange",
                "inRange",
                "endRange",
                "notAllowed"
            ].forEach(function(c) {
                dayElem.classList.remove(c);
            });
            if (elem !== undefined) {
                elem.classList.add(hoverDate <= self.selectedDates[0].getTime() ? "startRange" : "endRange");
                if (initialDate < hoverDate && timestamp === initialDate) dayElem.classList.add("startRange");
                else if (initialDate > hoverDate && timestamp === initialDate) dayElem.classList.add("endRange");
                if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && _dates.isBetween(timestamp, initialDate, hoverDate)) dayElem.classList.add("inRange");
            }
        });
    }
    function onResize() {
        if (self.isOpen && !self.config.static && !self.config.inline) positionCalendar();
    }
    function open(e, positionElement) {
        if (positionElement === void 0) positionElement = self._positionElement;
        if (self.isMobile === true) {
            if (e) {
                e.preventDefault();
                var eventTarget = _dom.getEventTarget(e);
                if (eventTarget) eventTarget.blur();
            }
            if (self.mobileInput !== undefined) {
                self.mobileInput.focus();
                self.mobileInput.click();
            }
            triggerEvent("onOpen");
            return;
        } else if (self._input.disabled || self.config.inline) return;
        var wasOpen = self.isOpen;
        self.isOpen = true;
        if (!wasOpen) {
            self.calendarContainer.classList.add("open");
            self._input.classList.add("active");
            triggerEvent("onOpen");
            positionCalendar(positionElement);
        }
        if (self.config.enableTime === true && self.config.noCalendar === true) {
            if (self.config.allowInput === false && (e === undefined || !self.timeContainer.contains(e.relatedTarget))) setTimeout(function() {
                return self.hourElement.select();
            }, 50);
        }
    }
    function minMaxDateSetter(type) {
        return function(date) {
            var dateObj = self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat);
            var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
            if (dateObj !== undefined) self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
            if (self.selectedDates) {
                self.selectedDates = self.selectedDates.filter(function(d) {
                    return isEnabled(d);
                });
                if (!self.selectedDates.length && type === "min") setHoursFromDate(dateObj);
                updateValue();
            }
            if (self.daysContainer) {
                redraw();
                if (dateObj !== undefined) self.currentYearElement[type] = dateObj.getFullYear().toString();
                else self.currentYearElement.removeAttribute(type);
                self.currentYearElement.disabled = !!inverseDateObj && dateObj !== undefined && inverseDateObj.getFullYear() === dateObj.getFullYear();
            }
        };
    }
    function parseConfig() {
        var boolOpts = [
            "wrap",
            "weekNumbers",
            "allowInput",
            "allowInvalidPreload",
            "clickOpens",
            "time_24hr",
            "enableTime",
            "noCalendar",
            "altInput",
            "shorthandCurrentMonth",
            "inline",
            "static",
            "enableSeconds",
            "disableMobile", 
        ];
        var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element1.dataset || {}))), instanceConfig);
        var formats = {};
        self.config.parseDate = userConfig.parseDate;
        self.config.formatDate = userConfig.formatDate;
        Object.defineProperty(self.config, "enable", {
            get: function() {
                return self.config._enable;
            },
            set: function(dates) {
                self.config._enable = parseDateRules(dates);
            }
        });
        Object.defineProperty(self.config, "disable", {
            get: function() {
                return self.config._disable;
            },
            set: function(dates) {
                self.config._disable = parseDateRules(dates);
            }
        });
        var timeMode = userConfig.mode === "time";
        if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
            var defaultDateFormat = flatpickr.defaultConfig.dateFormat || _options.defaults.dateFormat;
            formats.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
        }
        if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
            var defaultAltFormat = flatpickr.defaultConfig.altFormat || _options.defaults.altFormat;
            formats.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
        }
        Object.defineProperty(self.config, "minDate", {
            get: function() {
                return self.config._minDate;
            },
            set: minMaxDateSetter("min")
        });
        Object.defineProperty(self.config, "maxDate", {
            get: function() {
                return self.config._maxDate;
            },
            set: minMaxDateSetter("max")
        });
        var minMaxTimeSetter = function(type) {
            return function(val) {
                self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i:S");
            };
        };
        Object.defineProperty(self.config, "minTime", {
            get: function() {
                return self.config._minTime;
            },
            set: minMaxTimeSetter("min")
        });
        Object.defineProperty(self.config, "maxTime", {
            get: function() {
                return self.config._maxTime;
            },
            set: minMaxTimeSetter("max")
        });
        if (userConfig.mode === "time") {
            self.config.noCalendar = true;
            self.config.enableTime = true;
        }
        Object.assign(self.config, formats, userConfig);
        for(var i = 0; i < boolOpts.length; i++)self.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === "true";
        _options.HOOKS.filter(function(hook) {
            return self.config[hook] !== undefined;
        }).forEach(function(hook) {
            self.config[hook] = _utils.arrayify(self.config[hook] || []).map(bindToInstance);
        });
        self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === "single" && !self.config.disable.length && !self.config.enable && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        for(var i = 0; i < self.config.plugins.length; i++){
            var pluginConf = self.config.plugins[i](self) || {};
            for(var key in pluginConf){
                if (_options.HOOKS.indexOf(key) > -1) self.config[key] = _utils.arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);
                else if (typeof userConfig[key] === "undefined") self.config[key] = pluginConf[key];
            }
        }
        if (!userConfig.altInputClass) self.config.altInputClass = getInputElem().className + " " + self.config.altInputClass;
        triggerEvent("onParseConfig");
    }
    function getInputElem() {
        return self.config.wrap ? element1.querySelector("[data-input]") : element1;
    }
    function setupLocale() {
        if (typeof self.config.locale !== "object" && typeof flatpickr.l10ns[self.config.locale] === "undefined") self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
        self.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self.config.locale === "object" ? self.config.locale : self.config.locale !== "default" ? flatpickr.l10ns[self.config.locale] : undefined);
        _formatting.tokenRegex.D = "(" + self.l10n.weekdays.shorthand.join("|") + ")";
        _formatting.tokenRegex.l = "(" + self.l10n.weekdays.longhand.join("|") + ")";
        _formatting.tokenRegex.M = "(" + self.l10n.months.shorthand.join("|") + ")";
        _formatting.tokenRegex.F = "(" + self.l10n.months.longhand.join("|") + ")";
        _formatting.tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";
        var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element1.dataset || {})));
        if (userConfig.time_24hr === undefined && flatpickr.defaultConfig.time_24hr === undefined) self.config.time_24hr = self.l10n.time_24hr;
        self.formatDate = _dates.createDateFormatter(self);
        self.parseDate = _dates.createDateParser({
            config: self.config,
            l10n: self.l10n
        });
    }
    function positionCalendar(customPositionElement) {
        if (typeof self.config.position === "function") return void self.config.position(self, customPositionElement);
        if (self.calendarContainer === undefined) return;
        triggerEvent("onPreCalendarPosition");
        var positionElement = customPositionElement || self._positionElement;
        var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, function(acc, child) {
            return acc + child.offsetHeight;
        }, 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
        var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
        _dom.toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
        _dom.toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
        if (self.config.inline) return;
        var left = window.pageXOffset + inputBounds.left;
        var isCenter = false;
        var isRight = false;
        if (configPosHorizontal === "center") {
            left -= (calendarWidth - inputBounds.width) / 2;
            isCenter = true;
        } else if (configPosHorizontal === "right") {
            left -= calendarWidth - inputBounds.width;
            isRight = true;
        }
        _dom.toggleClass(self.calendarContainer, "arrowLeft", !isCenter && !isRight);
        _dom.toggleClass(self.calendarContainer, "arrowCenter", isCenter);
        _dom.toggleClass(self.calendarContainer, "arrowRight", isRight);
        var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
        var rightMost = left + calendarWidth > window.document.body.offsetWidth;
        var centerMost = right + calendarWidth > window.document.body.offsetWidth;
        _dom.toggleClass(self.calendarContainer, "rightMost", rightMost);
        if (self.config.static) return;
        self.calendarContainer.style.top = top + "px";
        if (!rightMost) {
            self.calendarContainer.style.left = left + "px";
            self.calendarContainer.style.right = "auto";
        } else if (!centerMost) {
            self.calendarContainer.style.left = "auto";
            self.calendarContainer.style.right = right + "px";
        } else {
            var doc = getDocumentStyleSheet();
            if (doc === undefined) return;
            var bodyWidth = window.document.body.offsetWidth;
            var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
            var centerBefore = ".flatpickr-calendar.centerMost:before";
            var centerAfter = ".flatpickr-calendar.centerMost:after";
            var centerIndex = doc.cssRules.length;
            var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
            _dom.toggleClass(self.calendarContainer, "rightMost", false);
            _dom.toggleClass(self.calendarContainer, "centerMost", true);
            doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
            self.calendarContainer.style.left = centerLeft + "px";
            self.calendarContainer.style.right = "auto";
        }
    }
    function getDocumentStyleSheet() {
        var editableSheet = null;
        for(var i = 0; i < document.styleSheets.length; i++){
            var sheet = document.styleSheets[i];
            if (!sheet.cssRules) continue;
            try {
                sheet.cssRules;
            } catch (err) {
                continue;
            }
            editableSheet = sheet;
            break;
        }
        return editableSheet != null ? editableSheet : createStyleSheet();
    }
    function createStyleSheet() {
        var style = document.createElement("style");
        document.head.appendChild(style);
        return style.sheet;
    }
    function redraw() {
        if (self.config.noCalendar || self.isMobile) return;
        buildMonthSwitch();
        updateNavigationCurrentMonth();
        buildDays();
    }
    function focusAndClose() {
        self._input.focus();
        if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== undefined) setTimeout(self.close, 0);
        else self.close();
    }
    function selectDate(e) {
        e.preventDefault();
        e.stopPropagation();
        var isSelectable = function(day) {
            return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
        };
        var t = _dom.findParent(_dom.getEventTarget(e), isSelectable);
        if (t === undefined) return;
        var target = t;
        var selectedDate = self.latestSelectedDateObj = new Date(target.dateObj.getTime());
        var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth || selectedDate.getMonth() > self.currentMonth + self.config.showMonths - 1) && self.config.mode !== "range";
        self.selectedDateElem = target;
        if (self.config.mode === "single") self.selectedDates = [
            selectedDate
        ];
        else if (self.config.mode === "multiple") {
            var selectedIndex = isDateSelected(selectedDate);
            if (selectedIndex) self.selectedDates.splice(parseInt(selectedIndex), 1);
            else self.selectedDates.push(selectedDate);
        } else if (self.config.mode === "range") {
            if (self.selectedDates.length === 2) self.clear(false, false);
            self.latestSelectedDateObj = selectedDate;
            self.selectedDates.push(selectedDate);
            if (_dates.compareDates(selectedDate, self.selectedDates[0], true) !== 0) self.selectedDates.sort(function(a, b) {
                return a.getTime() - b.getTime();
            });
        }
        setHoursFromInputs();
        if (shouldChangeMonth) {
            var isNewYear = self.currentYear !== selectedDate.getFullYear();
            self.currentYear = selectedDate.getFullYear();
            self.currentMonth = selectedDate.getMonth();
            if (isNewYear) {
                triggerEvent("onYearChange");
                buildMonthSwitch();
            }
            triggerEvent("onMonthChange");
        }
        updateNavigationCurrentMonth();
        buildDays();
        updateValue();
        if (!shouldChangeMonth && self.config.mode !== "range" && self.config.showMonths === 1) focusOnDayElem(target);
        else if (self.selectedDateElem !== undefined && self.hourElement === undefined) self.selectedDateElem && self.selectedDateElem.focus();
        if (self.hourElement !== undefined) self.hourElement !== undefined && self.hourElement.focus();
        if (self.config.closeOnSelect) {
            var single = self.config.mode === "single" && !self.config.enableTime;
            var range = self.config.mode === "range" && self.selectedDates.length === 2 && !self.config.enableTime;
            if (single || range) focusAndClose();
        }
        triggerChange1();
    }
    var CALLBACKS = {
        locale: [
            setupLocale,
            updateWeekdays
        ],
        showMonths: [
            buildMonths,
            setCalendarWidth,
            buildWeekdays
        ],
        minDate: [
            jumpToDate
        ],
        maxDate: [
            jumpToDate
        ],
        positionElement: [
            updatePositionElement
        ],
        clickOpens: [
            function() {
                if (self.config.clickOpens === true) {
                    bind(self._input, "focus", self.open);
                    bind(self._input, "click", self.open);
                } else {
                    self._input.removeEventListener("focus", self.open);
                    self._input.removeEventListener("click", self.open);
                }
            }, 
        ]
    };
    function set(option, value) {
        if (option !== null && typeof option === "object") {
            Object.assign(self.config, option);
            for(var key in option)if (CALLBACKS[key] !== undefined) CALLBACKS[key].forEach(function(x) {
                return x();
            });
        } else {
            self.config[option] = value;
            if (CALLBACKS[option] !== undefined) CALLBACKS[option].forEach(function(x) {
                return x();
            });
            else if (_options.HOOKS.indexOf(option) > -1) self.config[option] = _utils.arrayify(value);
        }
        self.redraw();
        updateValue(true);
    }
    function setSelectedDate(inputDate, format) {
        var dates = [];
        if (inputDate instanceof Array) dates = inputDate.map(function(d) {
            return self.parseDate(d, format);
        });
        else if (inputDate instanceof Date || typeof inputDate === "number") dates = [
            self.parseDate(inputDate, format)
        ];
        else if (typeof inputDate === "string") switch(self.config.mode){
            case "single":
            case "time":
                dates = [
                    self.parseDate(inputDate, format)
                ];
                break;
            case "multiple":
                dates = inputDate.split(self.config.conjunction).map(function(date) {
                    return self.parseDate(date, format);
                });
                break;
            case "range":
                dates = inputDate.split(self.l10n.rangeSeparator).map(function(date) {
                    return self.parseDate(date, format);
                });
                break;
            default:
                break;
        }
        else self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
        self.selectedDates = self.config.allowInvalidPreload ? dates : dates.filter(function(d) {
            return d instanceof Date && isEnabled(d, false);
        });
        if (self.config.mode === "range") self.selectedDates.sort(function(a, b) {
            return a.getTime() - b.getTime();
        });
    }
    function setDate(date, triggerChange, format) {
        if (triggerChange === void 0) triggerChange = false;
        if (format === void 0) format = self.config.dateFormat;
        if (date !== 0 && !date || date instanceof Array && date.length === 0) return self.clear(triggerChange);
        setSelectedDate(date, format);
        self.latestSelectedDateObj = self.selectedDates[self.selectedDates.length - 1];
        self.redraw();
        jumpToDate(undefined, triggerChange);
        setHoursFromDate();
        if (self.selectedDates.length === 0) self.clear(false);
        updateValue(triggerChange);
        if (triggerChange) triggerEvent("onChange");
    }
    function parseDateRules(arr) {
        return arr.slice().map(function(rule) {
            if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) return self.parseDate(rule, undefined, true);
            else if (rule && typeof rule === "object" && rule.from && rule.to) return {
                from: self.parseDate(rule.from, undefined),
                to: self.parseDate(rule.to, undefined)
            };
            return rule;
        }).filter(function(x) {
            return x;
        });
    }
    function setupDates() {
        self.selectedDates = [];
        self.now = self.parseDate(self.config.now) || new Date();
        var preloadedDate = self.config.defaultDate || ((self.input.nodeName === "INPUT" || self.input.nodeName === "TEXTAREA") && self.input.placeholder && self.input.value === self.input.placeholder ? null : self.input.value);
        if (preloadedDate) setSelectedDate(preloadedDate, self.config.dateFormat);
        self._initialDate = self.selectedDates.length > 0 ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now.getTime() ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now.getTime() ? self.config.maxDate : self.now;
        self.currentYear = self._initialDate.getFullYear();
        self.currentMonth = self._initialDate.getMonth();
        if (self.selectedDates.length > 0) self.latestSelectedDateObj = self.selectedDates[0];
        if (self.config.minTime !== undefined) self.config.minTime = self.parseDate(self.config.minTime, "H:i");
        if (self.config.maxTime !== undefined) self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
        self.minDateHasTime = !!self.config.minDate && (self.config.minDate.getHours() > 0 || self.config.minDate.getMinutes() > 0 || self.config.minDate.getSeconds() > 0);
        self.maxDateHasTime = !!self.config.maxDate && (self.config.maxDate.getHours() > 0 || self.config.maxDate.getMinutes() > 0 || self.config.maxDate.getSeconds() > 0);
    }
    function setupInputs() {
        self.input = getInputElem();
        if (!self.input) {
            self.config.errorHandler(new Error("Invalid input element specified"));
            return;
        }
        self.input._type = self.input.type;
        self.input.type = "text";
        self.input.classList.add("flatpickr-input");
        self._input = self.input;
        if (self.config.altInput) {
            self.altInput = _dom.createElement(self.input.nodeName, self.config.altInputClass);
            self._input = self.altInput;
            self.altInput.placeholder = self.input.placeholder;
            self.altInput.disabled = self.input.disabled;
            self.altInput.required = self.input.required;
            self.altInput.tabIndex = self.input.tabIndex;
            self.altInput.type = "text";
            self.input.setAttribute("type", "hidden");
            if (!self.config.static && self.input.parentNode) self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
        }
        if (!self.config.allowInput) self._input.setAttribute("readonly", "readonly");
        updatePositionElement();
    }
    function updatePositionElement() {
        self._positionElement = self.config.positionElement || self._input;
    }
    function setupMobile() {
        var inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";
        self.mobileInput = _dom.createElement("input", self.input.className + " flatpickr-mobile");
        self.mobileInput.tabIndex = 1;
        self.mobileInput.type = inputType;
        self.mobileInput.disabled = self.input.disabled;
        self.mobileInput.required = self.input.required;
        self.mobileInput.placeholder = self.input.placeholder;
        self.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
        if (self.selectedDates.length > 0) self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
        if (self.config.minDate) self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
        if (self.config.maxDate) self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
        if (self.input.getAttribute("step")) self.mobileInput.step = String(self.input.getAttribute("step"));
        self.input.type = "hidden";
        if (self.altInput !== undefined) self.altInput.type = "hidden";
        try {
            if (self.input.parentNode) self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
        } catch (_a) {}
        bind(self.mobileInput, "change", function(e) {
            self.setDate(_dom.getEventTarget(e).value, false, self.mobileFormatStr);
            triggerEvent("onChange");
            triggerEvent("onClose");
        });
    }
    function toggle(e) {
        if (self.isOpen === true) return self.close();
        self.open(e);
    }
    function triggerEvent(event, data) {
        if (self.config === undefined) return;
        var hooks = self.config[event];
        if (hooks !== undefined && hooks.length > 0) for(var i = 0; hooks[i] && i < hooks.length; i++)hooks[i](self.selectedDates, self.input.value, self, data);
        if (event === "onChange") {
            self.input.dispatchEvent(createEvent("change"));
            self.input.dispatchEvent(createEvent("input"));
        }
    }
    function createEvent(name) {
        var e = document.createEvent("Event");
        e.initEvent(name, true, true);
        return e;
    }
    function isDateSelected(date) {
        for(var i = 0; i < self.selectedDates.length; i++){
            var selectedDate = self.selectedDates[i];
            if (selectedDate instanceof Date && _dates.compareDates(selectedDate, date) === 0) return "" + i;
        }
        return false;
    }
    function isDateInRange(date) {
        if (self.config.mode !== "range" || self.selectedDates.length < 2) return false;
        return _dates.compareDates(date, self.selectedDates[0]) >= 0 && _dates.compareDates(date, self.selectedDates[1]) <= 0;
    }
    function updateNavigationCurrentMonth() {
        if (self.config.noCalendar || self.isMobile || !self.monthNav) return;
        self.yearElements.forEach(function(yearElement, i) {
            var d = new Date(self.currentYear, self.currentMonth, 1);
            d.setMonth(self.currentMonth + i);
            if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") self.monthElements[i].textContent = _formatting.monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
            else self.monthsDropdownContainer.value = d.getMonth().toString();
            yearElement.value = d.getFullYear().toString();
        });
        self._hidePrevMonthArrow = self.config.minDate !== undefined && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());
        self._hideNextMonthArrow = self.config.maxDate !== undefined && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());
    }
    function getDateStr(specificFormat) {
        var format = specificFormat || (self.config.altInput ? self.config.altFormat : self.config.dateFormat);
        return self.selectedDates.map(function(dObj) {
            return self.formatDate(dObj, format);
        }).filter(function(d, i, arr) {
            return self.config.mode !== "range" || self.config.enableTime || arr.indexOf(d) === i;
        }).join(self.config.mode !== "range" ? self.config.conjunction : self.l10n.rangeSeparator);
    }
    function updateValue(triggerChange) {
        if (triggerChange === void 0) triggerChange = true;
        if (self.mobileInput !== undefined && self.mobileFormatStr) self.mobileInput.value = self.latestSelectedDateObj !== undefined ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : "";
        self.input.value = getDateStr(self.config.dateFormat);
        if (self.altInput !== undefined) self.altInput.value = getDateStr(self.config.altFormat);
        if (triggerChange !== false) triggerEvent("onValueUpdate");
    }
    function onMonthNavClick(e) {
        var eventTarget = _dom.getEventTarget(e);
        var isPrevMonth = self.prevMonthNav.contains(eventTarget);
        var isNextMonth = self.nextMonthNav.contains(eventTarget);
        if (isPrevMonth || isNextMonth) changeMonth(isPrevMonth ? -1 : 1);
        else if (self.yearElements.indexOf(eventTarget) >= 0) eventTarget.select();
        else if (eventTarget.classList.contains("arrowUp")) self.changeYear(self.currentYear + 1);
        else if (eventTarget.classList.contains("arrowDown")) self.changeYear(self.currentYear - 1);
    }
    function timeWrapper(e) {
        e.preventDefault();
        var isKeyDown = e.type === "keydown", eventTarget = _dom.getEventTarget(e), input = eventTarget;
        if (self.amPM !== undefined && eventTarget === self.amPM) self.amPM.textContent = self.l10n.amPM[_utils.int(self.amPM.textContent === self.l10n.amPM[0])];
        var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);
        var newValue = curValue + step * delta;
        if (typeof input.value !== "undefined" && input.value.length === 2) {
            var isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;
            if (newValue < min) {
                newValue = max + newValue + _utils.int(!isHourElem) + (_utils.int(isHourElem) && _utils.int(!self.amPM));
                if (isMinuteElem) incrementNumInput(undefined, -1, self.hourElement);
            } else if (newValue > max) {
                newValue = input === self.hourElement ? newValue - max - _utils.int(!self.amPM) : min;
                if (isMinuteElem) incrementNumInput(undefined, 1, self.hourElement);
            }
            if (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) self.amPM.textContent = self.l10n.amPM[_utils.int(self.amPM.textContent === self.l10n.amPM[0])];
            input.value = _utils.pad(newValue);
        }
    }
    init();
    return self;
}
function _flatpickr(nodeList, config) {
    var nodes = Array.prototype.slice.call(nodeList).filter(function(x) {
        return x instanceof HTMLElement;
    });
    var instances = [];
    for(var i = 0; i < nodes.length; i++){
        var node = nodes[i];
        try {
            if (node.getAttribute("data-fp-omit") !== null) continue;
            if (node._flatpickr !== undefined) {
                node._flatpickr.destroy();
                node._flatpickr = undefined;
            }
            node._flatpickr = FlatpickrInstance(node, config || {});
            instances.push(node._flatpickr);
        } catch (e) {
            console.error(e);
        }
    }
    return instances.length === 1 ? instances[0] : instances;
}
if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
    HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config) {
        return _flatpickr(this, config);
    };
    HTMLElement.prototype.flatpickr = function(config) {
        return _flatpickr([
            this
        ], config);
    };
}
var flatpickr = function(selector, config) {
    if (typeof selector === "string") return _flatpickr(window.document.querySelectorAll(selector), config);
    else if (selector instanceof Node) return _flatpickr([
        selector
    ], config);
    else return _flatpickr(selector, config);
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
    en: __assign({}, _defaultDefault.default),
    default: __assign({}, _defaultDefault.default)
};
flatpickr.localize = function(l10n) {
    flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
};
flatpickr.setDefaults = function(config) {
    flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config);
};
flatpickr.parseDate = _dates.createDateParser({});
flatpickr.formatDate = _dates.createDateFormatter({});
flatpickr.compareDates = _dates.compareDates;
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") jQuery.fn.flatpickr = function(config) {
    return _flatpickr(this, config);
};
Date.prototype.fp_incr = function(days) {
    return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
};
if (typeof window !== "undefined") window.flatpickr = flatpickr;
exports.default = flatpickr;

},{"./types/options":"h2gY4","./l10n/default":"eDgV1","./utils":"c6tm8","./utils/dom":"8YAED","./utils/dates":"83MCj","./utils/formatting":"jt8kP","./utils/polyfills":"2PQGv","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"h2gY4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HOOKS", ()=>HOOKS
);
parcelHelpers.export(exports, "defaults", ()=>defaults
);
var HOOKS = [
    "onChange",
    "onClose",
    "onDayCreate",
    "onDestroy",
    "onKeyDown",
    "onMonthChange",
    "onOpen",
    "onParseConfig",
    "onReady",
    "onValueUpdate",
    "onYearChange",
    "onPreCalendarPosition", 
];
var defaults = {
    _disable: [],
    allowInput: false,
    allowInvalidPreload: false,
    altFormat: "F j, Y",
    altInput: false,
    altInputClass: "form-control input",
    animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
    ariaDateFormat: "F j, Y",
    autoFillDefaultTime: true,
    clickOpens: true,
    closeOnSelect: true,
    conjunction: ", ",
    dateFormat: "Y-m-d",
    defaultHour: 12,
    defaultMinute: 0,
    defaultSeconds: 0,
    disable: [],
    disableMobile: false,
    enableSeconds: false,
    enableTime: false,
    errorHandler: function(err) {
        return typeof console !== "undefined" && console.warn(err);
    },
    getWeek: function(givenDate) {
        var date = new Date(givenDate.getTime());
        date.setHours(0, 0, 0, 0);
        date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
        var week1 = new Date(date.getFullYear(), 0, 4);
        return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
    },
    hourIncrement: 1,
    ignoredFocusElements: [],
    inline: false,
    locale: "default",
    minuteIncrement: 5,
    mode: "single",
    monthSelectorType: "dropdown",
    nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
    noCalendar: false,
    now: new Date(),
    onChange: [],
    onClose: [],
    onDayCreate: [],
    onDestroy: [],
    onKeyDown: [],
    onMonthChange: [],
    onOpen: [],
    onParseConfig: [],
    onReady: [],
    onValueUpdate: [],
    onYearChange: [],
    onPreCalendarPosition: [],
    plugins: [],
    position: "auto",
    positionElement: undefined,
    prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
    shorthandCurrentMonth: false,
    showMonths: 1,
    static: false,
    time_24hr: false,
    weekNumbers: false,
    wrap: false
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"eDgV1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "english", ()=>english
);
var english = {
    weekdays: {
        shorthand: [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
        ],
        longhand: [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday", 
        ]
    },
    months: {
        shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec", 
        ],
        longhand: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December", 
        ]
    },
    daysInMonth: [
        31,
        28,
        31,
        30,
        31,
        30,
        31,
        31,
        30,
        31,
        30,
        31
    ],
    firstDayOfWeek: 0,
    ordinal: function(nth) {
        var s = nth % 100;
        if (s > 3 && s < 21) return "th";
        switch(s % 10){
            case 1:
                return "st";
            case 2:
                return "nd";
            case 3:
                return "rd";
            default:
                return "th";
        }
    },
    rangeSeparator: " to ",
    weekAbbreviation: "Wk",
    scrollTitle: "Scroll to increment",
    toggleTitle: "Click to toggle",
    amPM: [
        "AM",
        "PM"
    ],
    yearAriaLabel: "Year",
    monthAriaLabel: "Month",
    hourAriaLabel: "Hour",
    minuteAriaLabel: "Minute",
    time_24hr: false
};
exports.default = english;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"c6tm8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pad", ()=>pad
);
parcelHelpers.export(exports, "int", ()=>int
);
parcelHelpers.export(exports, "debounce", ()=>debounce
);
parcelHelpers.export(exports, "arrayify", ()=>arrayify
);
var pad = function(number, length) {
    if (length === void 0) length = 2;
    return ("000" + number).slice(length * -1);
};
var int = function(bool) {
    return bool === true ? 1 : 0;
};
function debounce(fn, wait) {
    var t;
    return function() {
        var _this = this;
        var args = arguments;
        clearTimeout(t);
        t = setTimeout(function() {
            return fn.apply(_this, args);
        }, wait);
    };
}
var arrayify = function(obj) {
    return obj instanceof Array ? obj : [
        obj
    ];
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"8YAED":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toggleClass", ()=>toggleClass
);
parcelHelpers.export(exports, "createElement", ()=>createElement
);
parcelHelpers.export(exports, "clearNode", ()=>clearNode
);
parcelHelpers.export(exports, "findParent", ()=>findParent
);
parcelHelpers.export(exports, "createNumberInput", ()=>createNumberInput
);
parcelHelpers.export(exports, "getEventTarget", ()=>getEventTarget
);
function toggleClass(elem, className, bool) {
    if (bool === true) return elem.classList.add(className);
    elem.classList.remove(className);
}
function createElement(tag, className, content) {
    var e = window.document.createElement(tag);
    className = className || "";
    content = content || "";
    e.className = className;
    if (content !== undefined) e.textContent = content;
    return e;
}
function clearNode(node) {
    while(node.firstChild)node.removeChild(node.firstChild);
}
function findParent(node, condition) {
    if (condition(node)) return node;
    else if (node.parentNode) return findParent(node.parentNode, condition);
    return undefined;
}
function createNumberInput(inputClassName, opts) {
    var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
    if (navigator.userAgent.indexOf("MSIE 9.0") === -1) numInput.type = "number";
    else {
        numInput.type = "text";
        numInput.pattern = "\\d*";
    }
    if (opts !== undefined) for(var key in opts)numInput.setAttribute(key, opts[key]);
    wrapper.appendChild(numInput);
    wrapper.appendChild(arrowUp);
    wrapper.appendChild(arrowDown);
    return wrapper;
}
function getEventTarget(event) {
    try {
        if (typeof event.composedPath === "function") {
            var path = event.composedPath();
            return path[0];
        }
        return event.target;
    } catch (error) {
        return event.target;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"83MCj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createDateFormatter", ()=>createDateFormatter
);
parcelHelpers.export(exports, "createDateParser", ()=>createDateParser
);
parcelHelpers.export(exports, "compareDates", ()=>compareDates
);
parcelHelpers.export(exports, "compareTimes", ()=>compareTimes
);
parcelHelpers.export(exports, "isBetween", ()=>isBetween
);
parcelHelpers.export(exports, "calculateSecondsSinceMidnight", ()=>calculateSecondsSinceMidnight
);
parcelHelpers.export(exports, "parseSeconds", ()=>parseSeconds
);
parcelHelpers.export(exports, "duration", ()=>duration
);
parcelHelpers.export(exports, "getDefaultHours", ()=>getDefaultHours
);
var _formatting = require("./formatting");
var _options = require("../types/options");
var _default = require("../l10n/default");
var createDateFormatter = function(_a) {
    var _b = _a.config, config = _b === void 0 ? _options.defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? _default.english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
    return function(dateObj, frmt, overrideLocale) {
        var locale = overrideLocale || l10n;
        if (config.formatDate !== undefined && !isMobile) return config.formatDate(dateObj, frmt, locale);
        return frmt.split("").map(function(c, i, arr) {
            return _formatting.formats[c] && arr[i - 1] !== "\\" ? _formatting.formats[c](dateObj, locale, config) : c !== "\\" ? c : "";
        }).join("");
    };
};
var createDateParser = function(_a1) {
    var _b = _a1.config, config = _b === void 0 ? _options.defaults : _b, _c = _a1.l10n, l10n = _c === void 0 ? _default.english : _c;
    return function(date, givenFormat, timeless, customLocale) {
        if (date !== 0 && !date) return undefined;
        var locale = customLocale || l10n;
        var parsedDate;
        var dateOrig = date;
        if (date instanceof Date) parsedDate = new Date(date.getTime());
        else if (typeof date !== "string" && date.toFixed !== undefined) parsedDate = new Date(date);
        else if (typeof date === "string") {
            var format = givenFormat || (config || _options.defaults).dateFormat;
            var datestr = String(date).trim();
            if (datestr === "today") {
                parsedDate = new Date();
                timeless = true;
            } else if (config && config.parseDate) parsedDate = config.parseDate(date, format);
            else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) parsedDate = new Date(date);
            else {
                var matched = void 0, ops = [];
                for(var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++){
                    var token = format[i];
                    var isBackSlash = token === "\\";
                    var escaped = format[i - 1] === "\\" || isBackSlash;
                    if (_formatting.tokenRegex[token] && !escaped) {
                        regexStr += _formatting.tokenRegex[token];
                        var match = new RegExp(regexStr).exec(date);
                        if (match && (matched = true)) ops[token !== "Y" ? "push" : "unshift"]({
                            fn: _formatting.revFormat[token],
                            val: match[++matchIndex]
                        });
                    } else if (!isBackSlash) regexStr += ".";
                }
                parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
                ops.forEach(function(_a) {
                    var fn = _a.fn, val = _a.val;
                    return parsedDate = fn(parsedDate, val, locale) || parsedDate;
                });
                parsedDate = matched ? parsedDate : undefined;
            }
        }
        if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
            config.errorHandler(new Error("Invalid date provided: " + dateOrig));
            return undefined;
        }
        if (timeless === true) parsedDate.setHours(0, 0, 0, 0);
        return parsedDate;
    };
};
function compareDates(date1, date2, timeless) {
    if (timeless === void 0) timeless = true;
    if (timeless !== false) return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
    return date1.getTime() - date2.getTime();
}
function compareTimes(date1, date2) {
    return 3600 * (date1.getHours() - date2.getHours()) + 60 * (date1.getMinutes() - date2.getMinutes()) + date1.getSeconds() - date2.getSeconds();
}
var isBetween = function(ts, ts1, ts2) {
    return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
var calculateSecondsSinceMidnight = function(hours, minutes, seconds) {
    return hours * 3600 + minutes * 60 + seconds;
};
var parseSeconds = function(secondsSinceMidnight) {
    var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
    return [
        hours,
        minutes,
        secondsSinceMidnight - hours * 3600 - minutes * 60
    ];
};
var duration = {
    DAY: 86400000
};
function getDefaultHours(config) {
    var hours = config.defaultHour;
    var minutes = config.defaultMinute;
    var seconds = config.defaultSeconds;
    if (config.minDate !== undefined) {
        var minHour = config.minDate.getHours();
        var minMinutes = config.minDate.getMinutes();
        var minSeconds = config.minDate.getSeconds();
        if (hours < minHour) hours = minHour;
        if (hours === minHour && minutes < minMinutes) minutes = minMinutes;
        if (hours === minHour && minutes === minMinutes && seconds < minSeconds) seconds = config.minDate.getSeconds();
    }
    if (config.maxDate !== undefined) {
        var maxHr = config.maxDate.getHours();
        var maxMinutes = config.maxDate.getMinutes();
        hours = Math.min(hours, maxHr);
        if (hours === maxHr) minutes = Math.min(maxMinutes, minutes);
        if (hours === maxHr && minutes === maxMinutes) seconds = config.maxDate.getSeconds();
    }
    return {
        hours: hours,
        minutes: minutes,
        seconds: seconds
    };
}

},{"./formatting":"jt8kP","../types/options":"h2gY4","../l10n/default":"eDgV1","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"jt8kP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "monthToStr", ()=>monthToStr
);
parcelHelpers.export(exports, "revFormat", ()=>revFormat
);
parcelHelpers.export(exports, "tokenRegex", ()=>tokenRegex
);
parcelHelpers.export(exports, "formats", ()=>formats
);
var _utils = require("../utils");
var doNothing = function() {
    return undefined;
};
var monthToStr = function(monthNumber, shorthand, locale) {
    return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
};
var revFormat = {
    D: doNothing,
    F: function(dateObj, monthName, locale) {
        dateObj.setMonth(locale.months.longhand.indexOf(monthName));
    },
    G: function(dateObj, hour) {
        dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
    },
    H: function(dateObj, hour) {
        dateObj.setHours(parseFloat(hour));
    },
    J: function(dateObj, day) {
        dateObj.setDate(parseFloat(day));
    },
    K: function(dateObj, amPM, locale) {
        dateObj.setHours(dateObj.getHours() % 12 + 12 * _utils.int(new RegExp(locale.amPM[1], "i").test(amPM)));
    },
    M: function(dateObj, shortMonth, locale) {
        dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
    },
    S: function(dateObj, seconds) {
        dateObj.setSeconds(parseFloat(seconds));
    },
    U: function(_, unixSeconds) {
        return new Date(parseFloat(unixSeconds) * 1000);
    },
    W: function(dateObj, weekNum, locale) {
        var weekNumber = parseInt(weekNum);
        var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
        date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
        return date;
    },
    Y: function(dateObj, year) {
        dateObj.setFullYear(parseFloat(year));
    },
    Z: function(_, ISODate) {
        return new Date(ISODate);
    },
    d: function(dateObj, day) {
        dateObj.setDate(parseFloat(day));
    },
    h: function(dateObj, hour) {
        dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
    },
    i: function(dateObj, minutes) {
        dateObj.setMinutes(parseFloat(minutes));
    },
    j: function(dateObj, day) {
        dateObj.setDate(parseFloat(day));
    },
    l: doNothing,
    m: function(dateObj, month) {
        dateObj.setMonth(parseFloat(month) - 1);
    },
    n: function(dateObj, month) {
        dateObj.setMonth(parseFloat(month) - 1);
    },
    s: function(dateObj, seconds) {
        dateObj.setSeconds(parseFloat(seconds));
    },
    u: function(_, unixMillSeconds) {
        return new Date(parseFloat(unixMillSeconds));
    },
    w: doNothing,
    y: function(dateObj, year) {
        dateObj.setFullYear(2000 + parseFloat(year));
    }
};
var tokenRegex = {
    D: "",
    F: "",
    G: "(\\d\\d|\\d)",
    H: "(\\d\\d|\\d)",
    J: "(\\d\\d|\\d)\\w+",
    K: "",
    M: "",
    S: "(\\d\\d|\\d)",
    U: "(.+)",
    W: "(\\d\\d|\\d)",
    Y: "(\\d{4})",
    Z: "(.+)",
    d: "(\\d\\d|\\d)",
    h: "(\\d\\d|\\d)",
    i: "(\\d\\d|\\d)",
    j: "(\\d\\d|\\d)",
    l: "",
    m: "(\\d\\d|\\d)",
    n: "(\\d\\d|\\d)",
    s: "(\\d\\d|\\d)",
    u: "(.+)",
    w: "(\\d\\d|\\d)",
    y: "(\\d{2})"
};
var formats = {
    Z: function(date) {
        return date.toISOString();
    },
    D: function(date, locale, options) {
        return locale.weekdays.shorthand[formats.w(date, locale, options)];
    },
    F: function(date, locale, options) {
        return monthToStr(formats.n(date, locale, options) - 1, false, locale);
    },
    G: function(date, locale, options) {
        return _utils.pad(formats.h(date, locale, options));
    },
    H: function(date) {
        return _utils.pad(date.getHours());
    },
    J: function(date, locale) {
        return locale.ordinal !== undefined ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
    },
    K: function(date, locale) {
        return locale.amPM[_utils.int(date.getHours() > 11)];
    },
    M: function(date, locale) {
        return monthToStr(date.getMonth(), true, locale);
    },
    S: function(date) {
        return _utils.pad(date.getSeconds());
    },
    U: function(date) {
        return date.getTime() / 1000;
    },
    W: function(date, _, options) {
        return options.getWeek(date);
    },
    Y: function(date) {
        return _utils.pad(date.getFullYear(), 4);
    },
    d: function(date) {
        return _utils.pad(date.getDate());
    },
    h: function(date) {
        return date.getHours() % 12 ? date.getHours() % 12 : 12;
    },
    i: function(date) {
        return _utils.pad(date.getMinutes());
    },
    j: function(date) {
        return date.getDate();
    },
    l: function(date, locale) {
        return locale.weekdays.longhand[date.getDay()];
    },
    m: function(date) {
        return _utils.pad(date.getMonth() + 1);
    },
    n: function(date) {
        return date.getMonth() + 1;
    },
    s: function(date) {
        return date.getSeconds();
    },
    u: function(date) {
        return date.getTime();
    },
    w: function(date) {
        return date.getDay();
    },
    y: function(date) {
        return String(date.getFullYear()).substring(2);
    }
};

},{"../utils":"c6tm8","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"2PQGv":[function(require,module,exports) {
"use strict";
if (typeof Object.assign !== "function") Object.assign = function(target) {
    var args = [];
    for(var _i = 1; _i < arguments.length; _i++)args[_i - 1] = arguments[_i];
    if (!target) throw TypeError("Cannot convert undefined or null to object");
    var _loop_1 = function(source) {
        if (source) Object.keys(source).forEach(function(key) {
            return target[key] = source[key];
        });
    };
    for(var _a = 0, args_1 = args; _a < args_1.length; _a++){
        var source1 = args_1[_a];
        _loop_1(source1);
    }
    return target;
};

},{}],"5UuDO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Calendar", ()=>Calendar
);
/*!
FullCalendar v5.10.2
Docs & License: https://fullcalendar.io/
(c) 2021 Adam Shaw
*/ var _vdomJs = require("./vdom.js");
var _tslib = require("tslib");
var _common = require("@fullcalendar/common");
parcelHelpers.exportAll(_common, exports);
var Calendar = /** @class */ function(_super) {
    _tslib.__extends(Calendar1, _super);
    function Calendar1(el, optionOverrides) {
        if (optionOverrides === void 0) optionOverrides = {};
        var _this = _super.call(this) || this;
        _this.isRendering = false;
        _this.isRendered = false;
        _this.currentClassNames = [];
        _this.customContentRenderId = 0; // will affect custom generated classNames?
        _this.handleAction = function(action) {
            // actions we know we want to render immediately
            switch(action.type){
                case 'SET_EVENT_DRAG':
                case 'SET_EVENT_RESIZE':
                    _this.renderRunner.tryDrain();
            }
        };
        _this.handleData = function(data) {
            _this.currentData = data;
            _this.renderRunner.request(data.calendarOptions.rerenderDelay);
        };
        _this.handleRenderRequest = function() {
            if (_this.isRendering) {
                _this.isRendered = true;
                var currentData_1 = _this.currentData;
                _common.flushSync(function() {
                    _common.render(_common.createElement(_common.CalendarRoot, {
                        options: currentData_1.calendarOptions,
                        theme: currentData_1.theme,
                        emitter: currentData_1.emitter
                    }, function(classNames, height, isHeightAuto, forPrint) {
                        _this.setClassNames(classNames);
                        _this.setHeight(height);
                        return _common.createElement(_common.CustomContentRenderContext.Provider, {
                            value: _this.customContentRenderId
                        }, _common.createElement(_common.CalendarContent, _tslib.__assign({
                            isHeightAuto: isHeightAuto,
                            forPrint: forPrint
                        }, currentData_1)));
                    }), _this.el);
                });
            } else if (_this.isRendered) {
                _this.isRendered = false;
                _common.unmountComponentAtNode(_this.el);
                _this.setClassNames([]);
                _this.setHeight('');
            }
        };
        _this.el = el;
        _this.renderRunner = new _common.DelayedRunner(_this.handleRenderRequest);
        new _common.CalendarDataManager({
            optionOverrides: optionOverrides,
            calendarApi: _this,
            onAction: _this.handleAction,
            onData: _this.handleData
        });
        return _this;
    }
    Object.defineProperty(Calendar1.prototype, "view", {
        get: function() {
            return this.currentData.viewApi;
        } // for public API
        ,
        enumerable: false,
        configurable: true
    });
    Calendar1.prototype.render = function() {
        var wasRendering = this.isRendering;
        if (!wasRendering) this.isRendering = true;
        else this.customContentRenderId += 1;
        this.renderRunner.request();
        if (wasRendering) this.updateSize();
    };
    Calendar1.prototype.destroy = function() {
        if (this.isRendering) {
            this.isRendering = false;
            this.renderRunner.request();
        }
    };
    Calendar1.prototype.updateSize = function() {
        var _this = this;
        _common.flushSync(function() {
            _super.prototype.updateSize.call(_this);
        });
    };
    Calendar1.prototype.batchRendering = function(func) {
        this.renderRunner.pause('batchRendering');
        func();
        this.renderRunner.resume('batchRendering');
    };
    Calendar1.prototype.pauseRendering = function() {
        this.renderRunner.pause('pauseRendering');
    };
    Calendar1.prototype.resumeRendering = function() {
        this.renderRunner.resume('pauseRendering', true);
    };
    Calendar1.prototype.resetOptions = function(optionOverrides, append) {
        this.currentDataManager.resetOptions(optionOverrides, append);
    };
    Calendar1.prototype.setClassNames = function(classNames) {
        if (!_common.isArraysEqual(classNames, this.currentClassNames)) {
            var classList = this.el.classList;
            for(var _i = 0, _a = this.currentClassNames; _i < _a.length; _i++){
                var className = _a[_i];
                classList.remove(className);
            }
            for(var _b = 0, classNames_1 = classNames; _b < classNames_1.length; _b++){
                var className = classNames_1[_b];
                classList.add(className);
            }
            this.currentClassNames = classNames;
        }
    };
    Calendar1.prototype.setHeight = function(height) {
        _common.applyStyleProp(this.el, 'height', height);
    };
    return Calendar1;
}(_common.CalendarApi);

},{"./vdom.js":"9LfNX","tslib":"5i9Vz","@fullcalendar/common":"cnjgQ","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"9LfNX":[function(require,module,exports) {
var _tslib = require("tslib");
var _preact = require("preact");
var _compat = require("preact/compat");
var globalObj = typeof globalThis !== 'undefined' ? globalThis : window; // // TODO: streamline when killing IE11 support
if (globalObj.FullCalendarVDom) console.warn('FullCalendar VDOM already loaded');
else globalObj.FullCalendarVDom = {
    Component: _preact.Component,
    createElement: _preact.createElement,
    render: _preact.render,
    createRef: _preact.createRef,
    Fragment: _preact.Fragment,
    createContext: createContext,
    createPortal: _compat.createPortal,
    flushSync: flushSync,
    unmountComponentAtNode: unmountComponentAtNode
};
// HACKS...
// TODO: lock version
// TODO: link gh issues
function flushSync(runBeforeFlush) {
    runBeforeFlush();
    var oldDebounceRendering = _preact.options.debounceRendering; // orig
    var callbackQ = [];
    function execCallbackSync(callback) {
        callbackQ.push(callback);
    }
    _preact.options.debounceRendering = execCallbackSync;
    _preact.render(_preact.createElement(FakeComponent, {}), document.createElement('div'));
    while(callbackQ.length)callbackQ.shift()();
    _preact.options.debounceRendering = oldDebounceRendering;
}
var FakeComponent = /** @class */ function(_super) {
    _tslib.__extends(FakeComponent1, _super);
    function FakeComponent1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FakeComponent1.prototype.render = function() {
        return _preact.createElement('div', {});
    };
    FakeComponent1.prototype.componentDidMount = function() {
        this.setState({});
    };
    return FakeComponent1;
}(_preact.Component);
function createContext(defaultValue) {
    var ContextType = _preact.createContext(defaultValue);
    var origProvider = ContextType.Provider;
    ContextType.Provider = function() {
        var _this = this;
        var isNew = !this.getChildContext;
        var children = origProvider.apply(this, arguments); // eslint-disable-line prefer-rest-params
        if (isNew) {
            var subs_1 = [];
            this.shouldComponentUpdate = function(_props) {
                if (_this.props.value !== _props.value) subs_1.forEach(function(c) {
                    c.context = _props.value;
                    c.forceUpdate();
                });
            };
            this.sub = function(c) {
                subs_1.push(c);
                var old = c.componentWillUnmount;
                c.componentWillUnmount = function() {
                    subs_1.splice(subs_1.indexOf(c), 1);
                    old && old.call(c);
                };
            };
        }
        return children;
    };
    return ContextType;
}
function unmountComponentAtNode(node) {
    _preact.render(null, node);
}

},{"tslib":"5i9Vz","preact":"kjBEj","preact/compat":"b7Buf"}],"5i9Vz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "__extends", ()=>__extends
);
parcelHelpers.export(exports, "__assign", ()=>__assign
);
parcelHelpers.export(exports, "__rest", ()=>__rest
);
parcelHelpers.export(exports, "__decorate", ()=>__decorate
);
parcelHelpers.export(exports, "__param", ()=>__param
);
parcelHelpers.export(exports, "__metadata", ()=>__metadata
);
parcelHelpers.export(exports, "__awaiter", ()=>__awaiter
);
parcelHelpers.export(exports, "__generator", ()=>__generator
);
parcelHelpers.export(exports, "__createBinding", ()=>__createBinding
);
parcelHelpers.export(exports, "__exportStar", ()=>__exportStar
);
parcelHelpers.export(exports, "__values", ()=>__values
);
parcelHelpers.export(exports, "__read", ()=>__read
);
/** @deprecated */ parcelHelpers.export(exports, "__spread", ()=>__spread
);
/** @deprecated */ parcelHelpers.export(exports, "__spreadArrays", ()=>__spreadArrays
);
parcelHelpers.export(exports, "__spreadArray", ()=>__spreadArray
);
parcelHelpers.export(exports, "__await", ()=>__await
);
parcelHelpers.export(exports, "__asyncGenerator", ()=>__asyncGenerator
);
parcelHelpers.export(exports, "__asyncDelegator", ()=>__asyncDelegator
);
parcelHelpers.export(exports, "__asyncValues", ()=>__asyncValues
);
parcelHelpers.export(exports, "__makeTemplateObject", ()=>__makeTemplateObject
);
parcelHelpers.export(exports, "__importStar", ()=>__importStar
);
parcelHelpers.export(exports, "__importDefault", ()=>__importDefault
);
parcelHelpers.export(exports, "__classPrivateFieldGet", ()=>__classPrivateFieldGet
);
parcelHelpers.export(exports, "__classPrivateFieldSet", ()=>__classPrivateFieldSet
);
parcelHelpers.export(exports, "__classPrivateFieldIn", ()=>__classPrivateFieldIn
);
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d1, b1) {
    extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return extendStatics(d1, b1);
};
function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __rest(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var __createBinding = Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
};
function __exportStar(m, o) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
function __spread() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
}
function __spreadArrays() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    function verb(n) {
        if (g[n]) i[n] = function(v) {
            return new Promise(function(a, b) {
                q.push([
                    n,
                    v,
                    a,
                    b
                ]) > 1 || resume(n, v);
            });
        };
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}
function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
        return this;
    }, i;
    function verb(n, f) {
        i[n] = o[n] ? function(v) {
            return (p = !p) ? {
                value: __await(o[n](v)),
                done: n === "return"
            } : f ? f(v) : v;
        } : f;
    }
}
function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v1) {
        Promise.resolve(v1).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
}
function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) Object.defineProperty(cooked, "raw", {
        value: raw
    });
    else cooked.raw = raw;
    return cooked;
}
var __setModuleDefault = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
};
function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
}
function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"kjBEj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>S
);
parcelHelpers.export(exports, "hydrate", ()=>q
);
parcelHelpers.export(exports, "createElement", ()=>v
);
parcelHelpers.export(exports, "h", ()=>v
);
parcelHelpers.export(exports, "Fragment", ()=>d
);
parcelHelpers.export(exports, "createRef", ()=>p
);
parcelHelpers.export(exports, "isValidElement", ()=>i
);
parcelHelpers.export(exports, "Component", ()=>_
);
parcelHelpers.export(exports, "cloneElement", ()=>B
);
parcelHelpers.export(exports, "createContext", ()=>D
);
parcelHelpers.export(exports, "toChildArray", ()=>A
);
parcelHelpers.export(exports, "options", ()=>l
);
var n, l, u, i, t, o, r, f, e = {}, c = [], s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function a(n1, l1) {
    for(var u1 in l1)n1[u1] = l1[u1];
    return n1;
}
function h(n2) {
    var l2 = n2.parentNode;
    l2 && l2.removeChild(n2);
}
function v(l3, u2, i1) {
    var t1, o1, r1, f1 = {};
    for(r1 in u2)"key" == r1 ? t1 = u2[r1] : "ref" == r1 ? o1 = u2[r1] : f1[r1] = u2[r1];
    if (arguments.length > 2 && (f1.children = arguments.length > 3 ? n.call(arguments, 2) : i1), "function" == typeof l3 && null != l3.defaultProps) for(r1 in l3.defaultProps)void 0 === f1[r1] && (f1[r1] = l3.defaultProps[r1]);
    return y(l3, f1, t1, o1, null);
}
function y(n3, i2, t2, o2, r2) {
    var f2 = {
        type: n3,
        props: i2,
        key: t2,
        ref: o2,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: null == r2 ? ++u : r2
    };
    return null == r2 && null != l.vnode && l.vnode(f2), f2;
}
function p() {
    return {
        current: null
    };
}
function d(n4) {
    return n4.children;
}
function _(n5, l4) {
    this.props = n5, this.context = l4;
}
function k(n6, l5) {
    if (null == l5) return n6.__ ? k(n6.__, n6.__.__k.indexOf(n6) + 1) : null;
    for(var u3; l5 < n6.__k.length; l5++)if (null != (u3 = n6.__k[l5]) && null != u3.__e) return u3.__e;
    return "function" == typeof n6.type ? k(n6) : null;
}
function b(n7) {
    var l6, u4;
    if (null != (n7 = n7.__) && null != n7.__c) {
        for(n7.__e = n7.__c.base = null, l6 = 0; l6 < n7.__k.length; l6++)if (null != (u4 = n7.__k[l6]) && null != u4.__e) {
            n7.__e = n7.__c.base = u4.__e;
            break;
        }
        return b(n7);
    }
}
function m(n8) {
    (!n8.__d && (n8.__d = !0) && t.push(n8) && !g.__r++ || r !== l.debounceRendering) && ((r = l.debounceRendering) || o)(g);
}
function g() {
    for(var n9; g.__r = t.length;)n9 = t.sort(function(n10, l7) {
        return n10.__v.__b - l7.__v.__b;
    }), t = [], n9.some(function(n11) {
        var l8, u5, i3, t3, o3, r3;
        n11.__d && (o3 = (t3 = (l8 = n11).__v).__e, (r3 = l8.__P) && (u5 = [], (i3 = a({}, t3)).__v = t3.__v + 1, j(r3, t3, i3, l8.__n, void 0 !== r3.ownerSVGElement, null != t3.__h ? [
            o3
        ] : null, u5, null == o3 ? k(t3) : o3, t3.__h), z(u5, t3), t3.__e != o3 && b(t3)));
    });
}
function w(n12, l9, u6, i4, t4, o4, r4, f3, s1, a1) {
    var h1, v1, p1, _1, b1, m1, g1, w1 = i4 && i4.__k || c, A1 = w1.length;
    for(u6.__k = [], h1 = 0; h1 < l9.length; h1++)if (null != (_1 = u6.__k[h1] = null == (_1 = l9[h1]) || "boolean" == typeof _1 ? null : "string" == typeof _1 || "number" == typeof _1 || "bigint" == typeof _1 ? y(null, _1, null, null, _1) : Array.isArray(_1) ? y(d, {
        children: _1
    }, null, null, null) : _1.__b > 0 ? y(_1.type, _1.props, _1.key, null, _1.__v) : _1)) {
        if (_1.__ = u6, _1.__b = u6.__b + 1, null === (p1 = w1[h1]) || p1 && _1.key == p1.key && _1.type === p1.type) w1[h1] = void 0;
        else for(v1 = 0; v1 < A1; v1++){
            if ((p1 = w1[v1]) && _1.key == p1.key && _1.type === p1.type) {
                w1[v1] = void 0;
                break;
            }
            p1 = null;
        }
        j(n12, _1, p1 = p1 || e, t4, o4, r4, f3, s1, a1), b1 = _1.__e, (v1 = _1.ref) && p1.ref != v1 && (g1 || (g1 = []), p1.ref && g1.push(p1.ref, null, _1), g1.push(v1, _1.__c || b1, _1)), null != b1 ? (null == m1 && (m1 = b1), "function" == typeof _1.type && _1.__k === p1.__k ? _1.__d = s1 = x(_1, s1, n12) : s1 = P(n12, _1, p1, w1, b1, s1), "function" == typeof u6.type && (u6.__d = s1)) : s1 && p1.__e == s1 && s1.parentNode != n12 && (s1 = k(p1));
    }
    for(u6.__e = m1, h1 = A1; h1--;)null != w1[h1] && ("function" == typeof u6.type && null != w1[h1].__e && w1[h1].__e == u6.__d && (u6.__d = k(i4, h1 + 1)), N(w1[h1], w1[h1]));
    if (g1) for(h1 = 0; h1 < g1.length; h1++)M(g1[h1], g1[++h1], g1[++h1]);
}
function x(n13, l10, u7) {
    for(var i5, t5 = n13.__k, o5 = 0; t5 && o5 < t5.length; o5++)(i5 = t5[o5]) && (i5.__ = n13, l10 = "function" == typeof i5.type ? x(i5, l10, u7) : P(u7, i5, i5, t5, i5.__e, l10));
    return l10;
}
function A(n14, l11) {
    return l11 = l11 || [], null == n14 || "boolean" == typeof n14 || (Array.isArray(n14) ? n14.some(function(n15) {
        A(n15, l11);
    }) : l11.push(n14)), l11;
}
function P(n16, l12, u8, i6, t6, o6) {
    var r5, f4, e1;
    if (void 0 !== l12.__d) r5 = l12.__d, l12.__d = void 0;
    else if (null == u8 || t6 != o6 || null == t6.parentNode) n: if (null == o6 || o6.parentNode !== n16) n16.appendChild(t6), r5 = null;
    else {
        for(f4 = o6, e1 = 0; (f4 = f4.nextSibling) && e1 < i6.length; e1 += 2)if (f4 == t6) break n;
        n16.insertBefore(t6, o6), r5 = o6;
    }
    return void 0 !== r5 ? r5 : t6.nextSibling;
}
function C(n17, l13, u9, i7, t7) {
    var o7;
    for(o7 in u9)"children" === o7 || "key" === o7 || o7 in l13 || H(n17, o7, null, u9[o7], i7);
    for(o7 in l13)t7 && "function" != typeof l13[o7] || "children" === o7 || "key" === o7 || "value" === o7 || "checked" === o7 || u9[o7] === l13[o7] || H(n17, o7, l13[o7], u9[o7], i7);
}
function $(n18, l14, u10) {
    "-" === l14[0] ? n18.setProperty(l14, u10) : n18[l14] = null == u10 ? "" : "number" != typeof u10 || s.test(l14) ? u10 : u10 + "px";
}
function H(n19, l15, u11, i8, t8) {
    var o8;
    n: if ("style" === l15) {
        if ("string" == typeof u11) n19.style.cssText = u11;
        else {
            if ("string" == typeof i8 && (n19.style.cssText = i8 = ""), i8) for(l15 in i8)u11 && l15 in u11 || $(n19.style, l15, "");
            if (u11) for(l15 in u11)i8 && u11[l15] === i8[l15] || $(n19.style, l15, u11[l15]);
        }
    } else if ("o" === l15[0] && "n" === l15[1]) o8 = l15 !== (l15 = l15.replace(/Capture$/, "")), l15 = l15.toLowerCase() in n19 ? l15.toLowerCase().slice(2) : l15.slice(2), n19.l || (n19.l = {}), n19.l[l15 + o8] = u11, u11 ? i8 || n19.addEventListener(l15, o8 ? T : I, o8) : n19.removeEventListener(l15, o8 ? T : I, o8);
    else if ("dangerouslySetInnerHTML" !== l15) {
        if (t8) l15 = l15.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if ("href" !== l15 && "list" !== l15 && "form" !== l15 && "tabIndex" !== l15 && "download" !== l15 && l15 in n19) try {
            n19[l15] = null == u11 ? "" : u11;
            break n;
        } catch (n) {}
        "function" == typeof u11 || (null != u11 && (!1 !== u11 || "a" === l15[0] && "r" === l15[1]) ? n19.setAttribute(l15, u11) : n19.removeAttribute(l15));
    }
}
function I(n20) {
    this.l[n20.type + !1](l.event ? l.event(n20) : n20);
}
function T(n21) {
    this.l[n21.type + !0](l.event ? l.event(n21) : n21);
}
function j(n22, u12, i9, t9, o9, r6, f5, e2, c1) {
    var s2, h2, v2, y1, p2, k1, b2, m2, g2, x1, A2, P1 = u12.type;
    if (void 0 !== u12.constructor) return null;
    null != i9.__h && (c1 = i9.__h, e2 = u12.__e = i9.__e, u12.__h = null, r6 = [
        e2
    ]), (s2 = l.__b) && s2(u12);
    try {
        n: if ("function" == typeof P1) {
            if (m2 = u12.props, g2 = (s2 = P1.contextType) && t9[s2.__c], x1 = s2 ? g2 ? g2.props.value : s2.__ : t9, i9.__c ? b2 = (h2 = u12.__c = i9.__c).__ = h2.__E : ("prototype" in P1 && P1.prototype.render ? u12.__c = h2 = new P1(m2, x1) : (u12.__c = h2 = new _(m2, x1), h2.constructor = P1, h2.render = O), g2 && g2.sub(h2), h2.props = m2, h2.state || (h2.state = {}), h2.context = x1, h2.__n = t9, v2 = h2.__d = !0, h2.__h = []), null == h2.__s && (h2.__s = h2.state), null != P1.getDerivedStateFromProps && (h2.__s == h2.state && (h2.__s = a({}, h2.__s)), a(h2.__s, P1.getDerivedStateFromProps(m2, h2.__s))), y1 = h2.props, p2 = h2.state, v2) null == P1.getDerivedStateFromProps && null != h2.componentWillMount && h2.componentWillMount(), null != h2.componentDidMount && h2.__h.push(h2.componentDidMount);
            else {
                if (null == P1.getDerivedStateFromProps && m2 !== y1 && null != h2.componentWillReceiveProps && h2.componentWillReceiveProps(m2, x1), !h2.__e && null != h2.shouldComponentUpdate && !1 === h2.shouldComponentUpdate(m2, h2.__s, x1) || u12.__v === i9.__v) {
                    h2.props = m2, h2.state = h2.__s, u12.__v !== i9.__v && (h2.__d = !1), h2.__v = u12, u12.__e = i9.__e, u12.__k = i9.__k, u12.__k.forEach(function(n23) {
                        n23 && (n23.__ = u12);
                    }), h2.__h.length && f5.push(h2);
                    break n;
                }
                null != h2.componentWillUpdate && h2.componentWillUpdate(m2, h2.__s, x1), null != h2.componentDidUpdate && h2.__h.push(function() {
                    h2.componentDidUpdate(y1, p2, k1);
                });
            }
            h2.context = x1, h2.props = m2, h2.state = h2.__s, (s2 = l.__r) && s2(u12), h2.__d = !1, h2.__v = u12, h2.__P = n22, s2 = h2.render(h2.props, h2.state, h2.context), h2.state = h2.__s, null != h2.getChildContext && (t9 = a(a({}, t9), h2.getChildContext())), v2 || null == h2.getSnapshotBeforeUpdate || (k1 = h2.getSnapshotBeforeUpdate(y1, p2)), A2 = null != s2 && s2.type === d && null == s2.key ? s2.props.children : s2, w(n22, Array.isArray(A2) ? A2 : [
                A2
            ], u12, i9, t9, o9, r6, f5, e2, c1), h2.base = u12.__e, u12.__h = null, h2.__h.length && f5.push(h2), b2 && (h2.__E = h2.__ = null), h2.__e = !1;
        } else null == r6 && u12.__v === i9.__v ? (u12.__k = i9.__k, u12.__e = i9.__e) : u12.__e = L(i9.__e, u12, i9, t9, o9, r6, f5, c1);
        (s2 = l.diffed) && s2(u12);
    } catch (n24) {
        u12.__v = null, (c1 || null != r6) && (u12.__e = e2, u12.__h = !!c1, r6[r6.indexOf(e2)] = null), l.__e(n24, u12, i9);
    }
}
function z(n25, u13) {
    l.__c && l.__c(u13, n25), n25.some(function(u14) {
        try {
            n25 = u14.__h, u14.__h = [], n25.some(function(n26) {
                n26.call(u14);
            });
        } catch (n27) {
            l.__e(n27, u14.__v);
        }
    });
}
function L(l16, u15, i10, t10, o10, r7, f6, c2) {
    var s3, a2, v3, y2 = i10.props, p3 = u15.props, d1 = u15.type, _2 = 0;
    if ("svg" === d1 && (o10 = !0), null != r7) {
        for(; _2 < r7.length; _2++)if ((s3 = r7[_2]) && "setAttribute" in s3 == !!d1 && (d1 ? s3.localName === d1 : 3 === s3.nodeType)) {
            l16 = s3, r7[_2] = null;
            break;
        }
    }
    if (null == l16) {
        if (null === d1) return document.createTextNode(p3);
        l16 = o10 ? document.createElementNS("http://www.w3.org/2000/svg", d1) : document.createElement(d1, p3.is && p3), r7 = null, c2 = !1;
    }
    if (null === d1) y2 === p3 || c2 && l16.data === p3 || (l16.data = p3);
    else {
        if (r7 = r7 && n.call(l16.childNodes), a2 = (y2 = i10.props || e).dangerouslySetInnerHTML, v3 = p3.dangerouslySetInnerHTML, !c2) {
            if (null != r7) for(y2 = {}, _2 = 0; _2 < l16.attributes.length; _2++)y2[l16.attributes[_2].name] = l16.attributes[_2].value;
            (v3 || a2) && (v3 && (a2 && v3.__html == a2.__html || v3.__html === l16.innerHTML) || (l16.innerHTML = v3 && v3.__html || ""));
        }
        if (C(l16, p3, y2, o10, c2), v3) u15.__k = [];
        else if (_2 = u15.props.children, w(l16, Array.isArray(_2) ? _2 : [
            _2
        ], u15, i10, t10, o10 && "foreignObject" !== d1, r7, f6, r7 ? r7[0] : i10.__k && k(i10, 0), c2), null != r7) for(_2 = r7.length; _2--;)null != r7[_2] && h(r7[_2]);
        c2 || ("value" in p3 && void 0 !== (_2 = p3.value) && (_2 !== l16.value || "progress" === d1 && !_2 || "option" === d1 && _2 !== y2.value) && H(l16, "value", _2, y2.value, !1), "checked" in p3 && void 0 !== (_2 = p3.checked) && _2 !== l16.checked && H(l16, "checked", _2, y2.checked, !1));
    }
    return l16;
}
function M(n28, u16, i11) {
    try {
        "function" == typeof n28 ? n28(u16) : n28.current = u16;
    } catch (n29) {
        l.__e(n29, i11);
    }
}
function N(n30, u17, i12) {
    var t11, o11;
    if (l.unmount && l.unmount(n30), (t11 = n30.ref) && (t11.current && t11.current !== n30.__e || M(t11, null, u17)), null != (t11 = n30.__c)) {
        if (t11.componentWillUnmount) try {
            t11.componentWillUnmount();
        } catch (n31) {
            l.__e(n31, u17);
        }
        t11.base = t11.__P = null;
    }
    if (t11 = n30.__k) for(o11 = 0; o11 < t11.length; o11++)t11[o11] && N(t11[o11], u17, "function" != typeof n30.type);
    i12 || null == n30.__e || h(n30.__e), n30.__e = n30.__d = void 0;
}
function O(n32, l, u18) {
    return this.constructor(n32, u18);
}
function S(u19, i13, t12) {
    var o12, r8, f7;
    l.__ && l.__(u19, i13), r8 = (o12 = "function" == typeof t12) ? null : t12 && t12.__k || i13.__k, f7 = [], j(i13, u19 = (!o12 && t12 || i13).__k = v(d, null, [
        u19
    ]), r8 || e, e, void 0 !== i13.ownerSVGElement, !o12 && t12 ? [
        t12
    ] : r8 ? null : i13.firstChild ? n.call(i13.childNodes) : null, f7, !o12 && t12 ? t12 : r8 ? r8.__e : i13.firstChild, o12), z(f7, u19);
}
function q(n33, l17) {
    S(n33, l17, q);
}
function B(l18, u20, i14) {
    var t13, o13, r9, f8 = a({}, l18.props);
    for(r9 in u20)"key" == r9 ? t13 = u20[r9] : "ref" == r9 ? o13 = u20[r9] : f8[r9] = u20[r9];
    return arguments.length > 2 && (f8.children = arguments.length > 3 ? n.call(arguments, 2) : i14), y(l18.type, f8, t13 || l18.key, o13 || l18.ref, null);
}
function D(n34, l19) {
    var u21 = {
        __c: l19 = "__cC" + f++,
        __: n34,
        Consumer: function(n35, l20) {
            return n35.children(l20);
        },
        Provider: function(n36) {
            var u22, i15;
            return this.getChildContext || (u22 = [], (i15 = {})[l19] = this, this.getChildContext = function() {
                return i15;
            }, this.shouldComponentUpdate = function(n37) {
                this.props.value !== n37.value && u22.some(m);
            }, this.sub = function(n38) {
                u22.push(n38);
                var l21 = n38.componentWillUnmount;
                n38.componentWillUnmount = function() {
                    u22.splice(u22.indexOf(n38), 1), l21 && l21.call(n38);
                };
            }), n36.children;
        }
    };
    return u21.Provider.__ = u21.Consumer.contextType = u21;
}
n = c.slice, l = {
    __e: function(n39, l22, u, i16) {
        for(var t14, o14, r10; l22 = l22.__;)if ((t14 = l22.__c) && !t14.__) try {
            if ((o14 = t14.constructor) && null != o14.getDerivedStateFromError && (t14.setState(o14.getDerivedStateFromError(n39)), r10 = t14.__d), null != t14.componentDidCatch && (t14.componentDidCatch(n39, i16 || {}), r10 = t14.__d), r10) return t14.__E = t14;
        } catch (l23) {
            n39 = l23;
        }
        throw n39;
    }
}, u = 0, i = function(n40) {
    return null != n40 && void 0 === n40.constructor;
}, _.prototype.setState = function(n41, l24) {
    var u23;
    u23 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = a({}, this.state), "function" == typeof n41 && (n41 = n41(a({}, u23), this.props)), n41 && a(u23, n41), null != n41 && this.__v && (l24 && this.__h.push(l24), m(this));
}, _.prototype.forceUpdate = function(n42) {
    this.__v && (this.__e = !0, n42 && this.__h.push(n42), m(this));
}, _.prototype.render = d, t = [], o = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, g.__r = 0, f = 0;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"b7Buf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createElement", ()=>_preact.createElement
);
parcelHelpers.export(exports, "createContext", ()=>_preact.createContext
);
parcelHelpers.export(exports, "createRef", ()=>_preact.createRef
);
parcelHelpers.export(exports, "Fragment", ()=>_preact.Fragment
);
parcelHelpers.export(exports, "Component", ()=>_preact.Component
);
parcelHelpers.export(exports, "version", ()=>nn
);
parcelHelpers.export(exports, "Children", ()=>k
);
parcelHelpers.export(exports, "render", ()=>B
);
parcelHelpers.export(exports, "hydrate", ()=>$
);
parcelHelpers.export(exports, "unmountComponentAtNode", ()=>un
);
parcelHelpers.export(exports, "createPortal", ()=>W
);
parcelHelpers.export(exports, "createFactory", ()=>tn
);
parcelHelpers.export(exports, "cloneElement", ()=>rn
);
parcelHelpers.export(exports, "isValidElement", ()=>en
);
parcelHelpers.export(exports, "findDOMNode", ()=>on
);
parcelHelpers.export(exports, "PureComponent", ()=>E
);
parcelHelpers.export(exports, "memo", ()=>g
);
parcelHelpers.export(exports, "forwardRef", ()=>x
);
parcelHelpers.export(exports, "flushSync", ()=>fn
);
parcelHelpers.export(exports, "unstable_batchedUpdates", ()=>ln
);
parcelHelpers.export(exports, "StrictMode", ()=>cn
);
parcelHelpers.export(exports, "Suspense", ()=>L
);
parcelHelpers.export(exports, "SuspenseList", ()=>M
);
parcelHelpers.export(exports, "lazy", ()=>F
);
parcelHelpers.export(exports, "__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED", ()=>X
);
var _hooks = require("preact/hooks");
var _preact = require("preact");
parcelHelpers.exportAll(_hooks, exports);
function C(n, t) {
    for(var e in t)n[e] = t[e];
    return n;
}
function S(n, t) {
    for(var e in n)if ("__source" !== e && !(e in t)) return !0;
    for(var r in t)if ("__source" !== r && n[r] !== t[r]) return !0;
    return !1;
}
function E(n) {
    this.props = n;
}
function g(n1, t1) {
    function e1(n) {
        var e = this.props.ref, r = e == n.ref;
        return !r && e && (e.call ? e(null) : e.current = null), t1 ? !t1(this.props, n) || !r : S(this.props, n);
    }
    function r1(t) {
        return this.shouldComponentUpdate = e1, _preact.createElement(n1, t);
    }
    return r1.displayName = "Memo(" + (n1.displayName || n1.name) + ")", r1.prototype.isReactComponent = !0, r1.__f = !0, r1;
}
(E.prototype = new _preact.Component).isPureReactComponent = !0, E.prototype.shouldComponentUpdate = function(n, t) {
    return S(this.props, n) || S(this.state, t);
};
var w = _preact.options.__b;
_preact.options.__b = function(n) {
    n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), w && w(n);
};
var R = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
function x(n) {
    function t2(t) {
        var e = C({}, t);
        return delete e.ref, n(e, t.ref || null);
    }
    return t2.$$typeof = R, t2.render = t2, t2.prototype.isReactComponent = t2.__f = !0, t2.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t2;
}
var N = function(n, t) {
    return null == n ? null : _preact.toChildArray(_preact.toChildArray(n).map(t));
}, k = {
    map: N,
    forEach: N,
    count: function(n) {
        return n ? _preact.toChildArray(n).length : 0;
    },
    only: function(n) {
        var t = _preact.toChildArray(n);
        if (1 !== t.length) throw "Children.only";
        return t[0];
    },
    toArray: _preact.toChildArray
}, A = _preact.options.__e;
_preact.options.__e = function(n, t, e, r) {
    if (n.then) {
        for(var u, o = t; o = o.__;)if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
    }
    A(n, t, e, r);
};
var O = _preact.options.unmount;
function L() {
    this.__u = 0, this.t = null, this.__b = null;
}
function U(n) {
    var t = n.__.__c;
    return t && t.__e && t.__e(n);
}
function F(n2) {
    var t, e, r;
    function u1(u) {
        if (t || (t = n2()).then(function(n) {
            e = n.default || n;
        }, function(n) {
            r = n;
        }), r) throw r;
        if (!e) throw t;
        return _preact.createElement(e, u);
    }
    return u1.displayName = "Lazy", u1.__f = !0, u1;
}
function M() {
    this.u = null, this.o = null;
}
_preact.options.unmount = function(n) {
    var t = n.__c;
    t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), O && O(n);
}, (L.prototype = new _preact.Component).__c = function(n3, t3) {
    var e2 = t3.__c, r2 = this;
    null == r2.t && (r2.t = []), r2.t.push(e2);
    var u = U(r2.__v), o = !1, i = function() {
        o || (o = !0, e2.__R = null, u ? u(l) : l());
    };
    e2.__R = i;
    var l = function() {
        if (!--r2.__u) {
            if (r2.state.__e) {
                var n4 = r2.state.__e;
                r2.__v.__k[0] = function n(t6, e, r) {
                    return t6 && (t6.__v = null, t6.__k = t6.__k && t6.__k.map(function(t) {
                        return n(t, e, r);
                    }), t6.__c && t6.__c.__P === e && (t6.__e && r.insertBefore(t6.__e, t6.__d), t6.__c.__e = !0, t6.__c.__P = r)), t6;
                }(n4, n4.__c.__P, n4.__c.__O);
            }
            var t4;
            for(r2.setState({
                __e: r2.__b = null
            }); t4 = r2.t.pop();)t4.forceUpdate();
        }
    }, f = !0 === t3.__h;
    (r2.__u++) || f || r2.setState({
        __e: r2.__b = r2.__v.__k[0]
    }), n3.then(i, i);
}, L.prototype.componentWillUnmount = function() {
    this.t = [];
}, L.prototype.render = function(n7, t7) {
    if (this.__b) {
        if (this.__v.__k) {
            var e3 = document.createElement("div"), r3 = this.__v.__k[0].__c;
            this.__v.__k[0] = function n8(t8, e, r) {
                return t8 && (t8.__c && t8.__c.__H && (t8.__c.__H.__.forEach(function(n) {
                    "function" == typeof n.__c && n.__c();
                }), t8.__c.__H = null), null != (t8 = C({}, t8)).__c && (t8.__c.__P === r && (t8.__c.__P = e), t8.__c = null), t8.__k = t8.__k && t8.__k.map(function(t) {
                    return n8(t, e, r);
                })), t8;
            }(this.__b, e3, r3.__O = r3.__P);
        }
        this.__b = null;
    }
    var u = t7.__e && _preact.createElement(_preact.Fragment, null, n7.fallback);
    return u && (u.__h = null), [
        _preact.createElement(_preact.Fragment, null, t7.__e ? null : n7.children),
        u
    ];
};
var T = function(n, t, e) {
    if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for(e = n.u; e;){
        for(; e.length > 3;)e.pop()();
        if (e[1] < e[0]) break;
        n.u = e = e[2];
    }
};
function D(n) {
    return this.getChildContext = function() {
        return n.context;
    }, n.children;
}
function I(n9) {
    var t = this, e = n9.i;
    t.componentWillUnmount = function() {
        _preact.render(null, t.l), t.l = null, t.i = null;
    }, t.i && t.i !== e && t.componentWillUnmount(), n9.__v ? (t.l || (t.i = e, t.l = {
        nodeType: 1,
        parentNode: e,
        childNodes: [],
        appendChild: function(n) {
            this.childNodes.push(n), t.i.appendChild(n);
        },
        insertBefore: function(n, e) {
            this.childNodes.push(n), t.i.appendChild(n);
        },
        removeChild: function(n) {
            this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), t.i.removeChild(n);
        }
    }), _preact.render(_preact.createElement(D, {
        context: t.context
    }, n9.__v), t.l)) : t.l && t.componentWillUnmount();
}
function W(n, t) {
    return _preact.createElement(I, {
        __v: n,
        i: t
    });
}
(M.prototype = new _preact.Component).__e = function(n) {
    var t = this, e = U(t.__v), r = t.o.get(n);
    return r[0]++, function(u) {
        var o = function() {
            t.props.revealOrder ? (r.push(u), T(t, n, r)) : u();
        };
        e ? e(o) : o();
    };
}, M.prototype.render = function(n) {
    this.u = null, this.o = new Map;
    var t = _preact.toChildArray(n.children);
    n.revealOrder && "b" === n.revealOrder[0] && t.reverse();
    for(var e = t.length; e--;)this.o.set(t[e], this.u = [
        1,
        0,
        this.u
    ]);
    return n.children;
}, M.prototype.componentDidUpdate = M.prototype.componentDidMount = function() {
    var n = this;
    this.o.forEach(function(t, e) {
        T(n, e, t);
    });
};
var P = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103, V = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, j = "undefined" != typeof document, z = function(n) {
    return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);
};
function B(n, t, e) {
    return null == t.__k && (t.textContent = ""), _preact.render(n, t), "function" == typeof e && e(), n ? n.__c : null;
}
function $(n, t, e) {
    return _preact.hydrate(n, t), "function" == typeof e && e(), n ? n.__c : null;
}
_preact.Component.prototype.isReactComponent = {}, [
    "componentWillMount",
    "componentWillReceiveProps",
    "componentWillUpdate"
].forEach(function(n) {
    Object.defineProperty(_preact.Component.prototype, n, {
        configurable: !0,
        get: function() {
            return this["UNSAFE_" + n];
        },
        set: function(t) {
            Object.defineProperty(this, n, {
                configurable: !0,
                writable: !0,
                value: t
            });
        }
    });
});
var H = _preact.options.event;
function Z() {}
function Y() {
    return this.cancelBubble;
}
function q() {
    return this.defaultPrevented;
}
_preact.options.event = function(n) {
    return H && (n = H(n)), n.persist = Z, n.isPropagationStopped = Y, n.isDefaultPrevented = q, n.nativeEvent = n;
};
var G, J = {
    configurable: !0,
    get: function() {
        return this.class;
    }
}, K = _preact.options.vnode;
_preact.options.vnode = function(n10) {
    var t = n10.type, e = n10.props, r = e;
    if ("string" == typeof t) {
        var u = -1 === t.indexOf("-");
        for(var o in r = {}, e){
            var i = e[o];
            j && "children" === o && "noscript" === t || "value" === o && "defaultValue" in e && null == i || ("defaultValue" === o && "value" in e && null == e.value ? o = "value" : "download" === o && !0 === i ? i = "" : /ondoubleclick/i.test(o) ? o = "ondblclick" : /^onchange(textarea|input)/i.test(o + t) && !z(e.type) ? o = "oninput" : /^onfocus$/i.test(o) ? o = "onfocusin" : /^onblur$/i.test(o) ? o = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(o) ? o = o.toLowerCase() : u && V.test(o) ? o = o.replace(/[A-Z0-9]/, "-$&").toLowerCase() : null === i && (i = void 0), r[o] = i);
        }
        "select" == t && r.multiple && Array.isArray(r.value) && (r.value = _preact.toChildArray(e.children).forEach(function(n) {
            n.props.selected = -1 != r.value.indexOf(n.props.value);
        })), "select" == t && null != r.defaultValue && (r.value = _preact.toChildArray(e.children).forEach(function(n) {
            n.props.selected = r.multiple ? -1 != r.defaultValue.indexOf(n.props.value) : r.defaultValue == n.props.value;
        })), n10.props = r, e.class != e.className && (J.enumerable = "className" in e, null != e.className && (r.class = e.className), Object.defineProperty(r, "className", J));
    }
    n10.$$typeof = P, K && K(n10);
};
var Q = _preact.options.__r;
_preact.options.__r = function(n) {
    Q && Q(n), G = n.__c;
};
var X = {
    ReactCurrentDispatcher: {
        current: {
            readContext: function(n) {
                return G.__n[n.__c].props.value;
            }
        }
    }
}, nn = "17.0.2";
function tn(n) {
    return _preact.createElement.bind(null, n);
}
function en(n) {
    return !!n && n.$$typeof === P;
}
function rn(n) {
    return en(n) ? _preact.cloneElement.apply(null, arguments) : n;
}
function un(n) {
    return !!n.__k && (_preact.render(null, n), !0);
}
function on(n) {
    return n && (n.base || 1 === n.nodeType && n) || null;
}
var ln = function(n, t) {
    return n(t);
}, fn = function(n, t) {
    return n(t);
}, cn = _preact.Fragment;
exports.default = {
    useState: _hooks.useState,
    useReducer: _hooks.useReducer,
    useEffect: _hooks.useEffect,
    useLayoutEffect: _hooks.useLayoutEffect,
    useRef: _hooks.useRef,
    useImperativeHandle: _hooks.useImperativeHandle,
    useMemo: _hooks.useMemo,
    useCallback: _hooks.useCallback,
    useContext: _hooks.useContext,
    useDebugValue: _hooks.useDebugValue,
    version: "17.0.2",
    Children: k,
    render: B,
    hydrate: $,
    unmountComponentAtNode: un,
    createPortal: W,
    createElement: _preact.createElement,
    createContext: _preact.createContext,
    createFactory: tn,
    cloneElement: rn,
    createRef: _preact.createRef,
    Fragment: _preact.Fragment,
    isValidElement: en,
    findDOMNode: on,
    Component: _preact.Component,
    PureComponent: E,
    memo: g,
    forwardRef: x,
    flushSync: fn,
    unstable_batchedUpdates: ln,
    StrictMode: _preact.Fragment,
    Suspense: L,
    SuspenseList: M,
    lazy: F,
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: X
};

},{"preact/hooks":"j6DgG","preact":"kjBEj","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"j6DgG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useState", ()=>m
);
parcelHelpers.export(exports, "useReducer", ()=>p
);
parcelHelpers.export(exports, "useEffect", ()=>y
);
parcelHelpers.export(exports, "useLayoutEffect", ()=>d
);
parcelHelpers.export(exports, "useRef", ()=>h
);
parcelHelpers.export(exports, "useImperativeHandle", ()=>s
);
parcelHelpers.export(exports, "useMemo", ()=>_
);
parcelHelpers.export(exports, "useCallback", ()=>A
);
parcelHelpers.export(exports, "useContext", ()=>F
);
parcelHelpers.export(exports, "useDebugValue", ()=>T
);
parcelHelpers.export(exports, "useErrorBoundary", ()=>q
);
var _preact = require("preact");
var t, u, r, o = 0, i = [], c = _preact.options.__b, f = _preact.options.__r, e = _preact.options.diffed, a = _preact.options.__c, v = _preact.options.unmount;
function l(t1, r1) {
    _preact.options.__h && _preact.options.__h(u, t1, o || r1), o = 0;
    var i1 = u.__H || (u.__H = {
        __: [],
        __h: []
    });
    return t1 >= i1.__.length && i1.__.push({}), i1.__[t1];
}
function m(n) {
    return o = 1, p(w, n);
}
function p(n1, r2, o1) {
    var i2 = l(t++, 2);
    return i2.t = n1, i2.__c || (i2.__ = [
        o1 ? o1(r2) : w(void 0, r2),
        function(n) {
            var t2 = i2.t(i2.__[0], n);
            i2.__[0] !== t2 && (i2.__ = [
                t2,
                i2.__[1]
            ], i2.__c.setState({}));
        }
    ], i2.__c = u), i2.__;
}
function y(r3, o2) {
    var i3 = l(t++, 3);
    !_preact.options.__s && k(i3.__H, o2) && (i3.__ = r3, i3.__H = o2, u.__H.__h.push(i3));
}
function d(r4, o3) {
    var i4 = l(t++, 4);
    !_preact.options.__s && k(i4.__H, o3) && (i4.__ = r4, i4.__H = o3, u.__h.push(i4));
}
function h(n) {
    return o = 5, _(function() {
        return {
            current: n
        };
    }, []);
}
function s(n, t3, u1) {
    o = 6, d(function() {
        return "function" == typeof n ? (n(t3()), function() {
            return n(null);
        }) : n ? (n.current = t3(), function() {
            return n.current = null;
        }) : void 0;
    }, null == u1 ? u1 : u1.concat(n));
}
function _(n, u2) {
    var r5 = l(t++, 7);
    return k(r5.__H, u2) && (r5.__ = n(), r5.__H = u2, r5.__h = n), r5.__;
}
function A(n, t4) {
    return o = 8, _(function() {
        return n;
    }, t4);
}
function F(n) {
    var r6 = u.context[n.__c], o4 = l(t++, 9);
    return o4.c = n, r6 ? (null == o4.__ && (o4.__ = !0, r6.sub(u)), r6.props.value) : n.__;
}
function T(t5, u3) {
    _preact.options.useDebugValue && _preact.options.useDebugValue(u3 ? u3(t5) : t5);
}
function q(n2) {
    var r7 = l(t++, 10), o5 = m();
    return r7.__ = n2, u.componentDidCatch || (u.componentDidCatch = function(n) {
        r7.__ && r7.__(n), o5[1](n);
    }), [
        o5[0],
        function() {
            o5[1](void 0);
        }
    ];
}
function x() {
    for(var t6; t6 = i.shift();)if (t6.__P) try {
        t6.__H.__h.forEach(g), t6.__H.__h.forEach(j), t6.__H.__h = [];
    } catch (u4) {
        t6.__H.__h = [], _preact.options.__e(u4, t6.__v);
    }
}
_preact.options.__b = function(n) {
    u = null, c && c(n);
}, _preact.options.__r = function(n) {
    f && f(n), t = 0;
    var r8 = (u = n.__c).__H;
    r8 && (r8.__h.forEach(g), r8.__h.forEach(j), r8.__h = []);
}, _preact.options.diffed = function(t7) {
    e && e(t7);
    var o6 = t7.__c;
    o6 && o6.__H && o6.__H.__h.length && (1 !== i.push(o6) && r === _preact.options.requestAnimationFrame || ((r = _preact.options.requestAnimationFrame) || function(n) {
        var t8, u5 = function() {
            clearTimeout(r9), b && cancelAnimationFrame(t8), setTimeout(n);
        }, r9 = setTimeout(u5, 100);
        b && (t8 = requestAnimationFrame(u5));
    })(x)), u = null;
}, _preact.options.__c = function(t9, u6) {
    u6.some(function(t10) {
        try {
            t10.__h.forEach(g), t10.__h = t10.__h.filter(function(n) {
                return !n.__ || j(n);
            });
        } catch (r10) {
            u6.some(function(n) {
                n.__h && (n.__h = []);
            }), u6 = [], _preact.options.__e(r10, t10.__v);
        }
    }), a && a(t9, u6);
}, _preact.options.unmount = function(t11) {
    v && v(t11);
    var u7, r11 = t11.__c;
    r11 && r11.__H && (r11.__H.__.forEach(function(n) {
        try {
            g(n);
        } catch (n3) {
            u7 = n3;
        }
    }), u7 && _preact.options.__e(u7, r11.__v));
};
var b = "function" == typeof requestAnimationFrame;
function g(n) {
    var t12 = u, r12 = n.__c;
    "function" == typeof r12 && (n.__c = void 0, r12()), u = t12;
}
function j(n) {
    var t13 = u;
    n.__c = n.__(), u = t13;
}
function k(n, t14) {
    return !n || n.length !== t14.length || t14.some(function(t15, u8) {
        return t15 !== n[u8];
    });
}
function w(n, t16) {
    return "function" == typeof t16 ? t16(n) : t16;
}

},{"preact":"kjBEj","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"cnjgQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BASE_OPTION_DEFAULTS", ()=>BASE_OPTION_DEFAULTS
);
parcelHelpers.export(exports, "BASE_OPTION_REFINERS", ()=>BASE_OPTION_REFINERS
);
parcelHelpers.export(exports, "BaseComponent", ()=>BaseComponent
);
parcelHelpers.export(exports, "BgEvent", ()=>BgEvent
);
parcelHelpers.export(exports, "CalendarApi", ()=>CalendarApi
);
parcelHelpers.export(exports, "CalendarContent", ()=>CalendarContent
);
parcelHelpers.export(exports, "CalendarDataManager", ()=>CalendarDataManager
);
parcelHelpers.export(exports, "CalendarDataProvider", ()=>CalendarDataProvider
);
parcelHelpers.export(exports, "CalendarRoot", ()=>CalendarRoot
);
parcelHelpers.export(exports, "ContentHook", ()=>ContentHook
);
parcelHelpers.export(exports, "CustomContentRenderContext", ()=>CustomContentRenderContext
);
parcelHelpers.export(exports, "DateComponent", ()=>DateComponent
);
parcelHelpers.export(exports, "DateEnv", ()=>DateEnv
);
parcelHelpers.export(exports, "DateProfileGenerator", ()=>DateProfileGenerator
);
parcelHelpers.export(exports, "DayCellContent", ()=>DayCellContent
);
parcelHelpers.export(exports, "DayCellRoot", ()=>DayCellRoot
);
parcelHelpers.export(exports, "DayHeader", ()=>DayHeader
);
parcelHelpers.export(exports, "DaySeriesModel", ()=>DaySeriesModel
);
parcelHelpers.export(exports, "DayTableModel", ()=>DayTableModel
);
parcelHelpers.export(exports, "DelayedRunner", ()=>DelayedRunner
);
parcelHelpers.export(exports, "ElementDragging", ()=>ElementDragging
);
parcelHelpers.export(exports, "ElementScrollController", ()=>ElementScrollController
);
parcelHelpers.export(exports, "Emitter", ()=>Emitter
);
parcelHelpers.export(exports, "EventApi", ()=>EventApi
);
parcelHelpers.export(exports, "EventRoot", ()=>EventRoot
);
parcelHelpers.export(exports, "EventSourceApi", ()=>EventSourceApi
);
parcelHelpers.export(exports, "Interaction", ()=>Interaction
);
parcelHelpers.export(exports, "MoreLinkRoot", ()=>MoreLinkRoot
);
parcelHelpers.export(exports, "MountHook", ()=>MountHook
);
parcelHelpers.export(exports, "NamedTimeZoneImpl", ()=>NamedTimeZoneImpl
);
parcelHelpers.export(exports, "NowIndicatorRoot", ()=>NowIndicatorRoot
);
parcelHelpers.export(exports, "NowTimer", ()=>NowTimer
);
parcelHelpers.export(exports, "PositionCache", ()=>PositionCache
);
parcelHelpers.export(exports, "RefMap", ()=>RefMap
);
parcelHelpers.export(exports, "RenderHook", ()=>RenderHook
);
parcelHelpers.export(exports, "ScrollController", ()=>ScrollController
);
parcelHelpers.export(exports, "ScrollResponder", ()=>ScrollResponder
);
parcelHelpers.export(exports, "Scroller", ()=>Scroller
);
parcelHelpers.export(exports, "SegHierarchy", ()=>SegHierarchy
);
parcelHelpers.export(exports, "SimpleScrollGrid", ()=>SimpleScrollGrid
);
parcelHelpers.export(exports, "Slicer", ()=>Slicer
);
parcelHelpers.export(exports, "Splitter", ()=>Splitter
);
parcelHelpers.export(exports, "StandardEvent", ()=>StandardEvent
);
parcelHelpers.export(exports, "TableDateCell", ()=>TableDateCell
);
parcelHelpers.export(exports, "TableDowCell", ()=>TableDowCell
);
parcelHelpers.export(exports, "Theme", ()=>Theme
);
parcelHelpers.export(exports, "ViewApi", ()=>ViewApi
);
parcelHelpers.export(exports, "ViewContextType", ()=>ViewContextType
);
parcelHelpers.export(exports, "ViewRoot", ()=>ViewRoot
);
parcelHelpers.export(exports, "WeekNumberRoot", ()=>WeekNumberRoot
);
parcelHelpers.export(exports, "WindowScrollController", ()=>WindowScrollController
);
parcelHelpers.export(exports, "addDays", ()=>addDays
);
parcelHelpers.export(exports, "addDurations", ()=>addDurations
);
parcelHelpers.export(exports, "addMs", ()=>addMs
);
parcelHelpers.export(exports, "addWeeks", ()=>addWeeks
);
parcelHelpers.export(exports, "allowContextMenu", ()=>allowContextMenu
);
parcelHelpers.export(exports, "allowSelection", ()=>allowSelection
);
parcelHelpers.export(exports, "applyMutationToEventStore", ()=>applyMutationToEventStore
);
parcelHelpers.export(exports, "applyStyle", ()=>applyStyle
);
parcelHelpers.export(exports, "applyStyleProp", ()=>applyStyleProp
);
parcelHelpers.export(exports, "asCleanDays", ()=>asCleanDays
);
parcelHelpers.export(exports, "asRoughMinutes", ()=>asRoughMinutes
);
parcelHelpers.export(exports, "asRoughMs", ()=>asRoughMs
);
parcelHelpers.export(exports, "asRoughSeconds", ()=>asRoughSeconds
);
parcelHelpers.export(exports, "binarySearch", ()=>binarySearch
);
parcelHelpers.export(exports, "buildClassNameNormalizer", ()=>buildClassNameNormalizer
);
parcelHelpers.export(exports, "buildEntryKey", ()=>buildEntryKey
);
parcelHelpers.export(exports, "buildEventApis", ()=>buildEventApis
);
parcelHelpers.export(exports, "buildEventRangeKey", ()=>buildEventRangeKey
);
parcelHelpers.export(exports, "buildHashFromArray", ()=>buildHashFromArray
);
parcelHelpers.export(exports, "buildIsoString", ()=>buildIsoString
);
parcelHelpers.export(exports, "buildNavLinkAttrs", ()=>buildNavLinkAttrs
);
parcelHelpers.export(exports, "buildSegCompareObj", ()=>buildSegCompareObj
);
parcelHelpers.export(exports, "buildSegTimeText", ()=>buildSegTimeText
);
parcelHelpers.export(exports, "collectFromHash", ()=>collectFromHash
);
parcelHelpers.export(exports, "combineEventUis", ()=>combineEventUis
);
parcelHelpers.export(exports, "compareByFieldSpec", ()=>compareByFieldSpec
);
parcelHelpers.export(exports, "compareByFieldSpecs", ()=>compareByFieldSpecs
);
parcelHelpers.export(exports, "compareNumbers", ()=>compareNumbers
);
parcelHelpers.export(exports, "compareObjs", ()=>compareObjs
);
parcelHelpers.export(exports, "computeEarliestSegStart", ()=>computeEarliestSegStart
);
parcelHelpers.export(exports, "computeEdges", ()=>computeEdges
);
parcelHelpers.export(exports, "computeFallbackHeaderFormat", ()=>computeFallbackHeaderFormat
);
parcelHelpers.export(exports, "computeHeightAndMargins", ()=>computeHeightAndMargins
);
parcelHelpers.export(exports, "computeInnerRect", ()=>computeInnerRect
);
parcelHelpers.export(exports, "computeRect", ()=>computeRect
);
parcelHelpers.export(exports, "computeSegDraggable", ()=>computeSegDraggable
);
parcelHelpers.export(exports, "computeSegEndResizable", ()=>computeSegEndResizable
);
parcelHelpers.export(exports, "computeSegStartResizable", ()=>computeSegStartResizable
);
parcelHelpers.export(exports, "computeShrinkWidth", ()=>computeShrinkWidth
);
parcelHelpers.export(exports, "computeSmallestCellWidth", ()=>computeSmallestCellWidth
);
parcelHelpers.export(exports, "computeVisibleDayRange", ()=>computeVisibleDayRange
);
parcelHelpers.export(exports, "config", ()=>config
);
parcelHelpers.export(exports, "constrainPoint", ()=>constrainPoint
);
parcelHelpers.export(exports, "createAriaClickAttrs", ()=>createAriaClickAttrs
);
parcelHelpers.export(exports, "createDuration", ()=>createDuration
);
parcelHelpers.export(exports, "createEmptyEventStore", ()=>createEmptyEventStore
);
parcelHelpers.export(exports, "createEventInstance", ()=>createEventInstance
);
parcelHelpers.export(exports, "createEventUi", ()=>createEventUi
);
parcelHelpers.export(exports, "createFormatter", ()=>createFormatter
);
parcelHelpers.export(exports, "createPlugin", ()=>createPlugin
);
parcelHelpers.export(exports, "diffDates", ()=>diffDates
);
parcelHelpers.export(exports, "diffDayAndTime", ()=>diffDayAndTime
);
parcelHelpers.export(exports, "diffDays", ()=>diffDays
);
parcelHelpers.export(exports, "diffPoints", ()=>diffPoints
);
parcelHelpers.export(exports, "diffWeeks", ()=>diffWeeks
);
parcelHelpers.export(exports, "diffWholeDays", ()=>diffWholeDays
);
parcelHelpers.export(exports, "diffWholeWeeks", ()=>diffWholeWeeks
);
parcelHelpers.export(exports, "disableCursor", ()=>disableCursor
);
parcelHelpers.export(exports, "elementClosest", ()=>elementClosest
);
parcelHelpers.export(exports, "elementMatches", ()=>elementMatches
);
parcelHelpers.export(exports, "enableCursor", ()=>enableCursor
);
parcelHelpers.export(exports, "eventTupleToStore", ()=>eventTupleToStore
);
parcelHelpers.export(exports, "filterEventStoreDefs", ()=>filterEventStoreDefs
);
parcelHelpers.export(exports, "filterHash", ()=>filterHash
);
parcelHelpers.export(exports, "findDirectChildren", ()=>findDirectChildren
);
parcelHelpers.export(exports, "findElements", ()=>findElements
);
parcelHelpers.export(exports, "flexibleCompare", ()=>flexibleCompare
);
parcelHelpers.export(exports, "formatDate", ()=>formatDate
);
parcelHelpers.export(exports, "formatDayString", ()=>formatDayString
);
parcelHelpers.export(exports, "formatIsoTimeString", ()=>formatIsoTimeString
);
parcelHelpers.export(exports, "formatRange", ()=>formatRange
);
parcelHelpers.export(exports, "getAllowYScrolling", ()=>getAllowYScrolling
);
parcelHelpers.export(exports, "getCanVGrowWithinCell", ()=>getCanVGrowWithinCell
);
parcelHelpers.export(exports, "getClippingParents", ()=>getClippingParents
);
parcelHelpers.export(exports, "getDateMeta", ()=>getDateMeta
);
parcelHelpers.export(exports, "getDayClassNames", ()=>getDayClassNames
);
parcelHelpers.export(exports, "getDefaultEventEnd", ()=>getDefaultEventEnd
);
parcelHelpers.export(exports, "getElRoot", ()=>getElRoot
);
parcelHelpers.export(exports, "getElSeg", ()=>getElSeg
);
parcelHelpers.export(exports, "getEntrySpanEnd", ()=>getEntrySpanEnd
);
parcelHelpers.export(exports, "getEventClassNames", ()=>getEventClassNames
);
parcelHelpers.export(exports, "getEventTargetViaRoot", ()=>getEventTargetViaRoot
);
parcelHelpers.export(exports, "getIsRtlScrollbarOnLeft", ()=>getIsRtlScrollbarOnLeft
);
parcelHelpers.export(exports, "getRectCenter", ()=>getRectCenter
);
parcelHelpers.export(exports, "getRelevantEvents", ()=>getRelevantEvents
);
parcelHelpers.export(exports, "getScrollGridClassNames", ()=>getScrollGridClassNames
);
parcelHelpers.export(exports, "getScrollbarWidths", ()=>getScrollbarWidths
);
parcelHelpers.export(exports, "getSectionClassNames", ()=>getSectionClassNames
);
parcelHelpers.export(exports, "getSectionHasLiquidHeight", ()=>getSectionHasLiquidHeight
);
parcelHelpers.export(exports, "getSegAnchorAttrs", ()=>getSegAnchorAttrs
);
parcelHelpers.export(exports, "getSegMeta", ()=>getSegMeta
);
parcelHelpers.export(exports, "getSlotClassNames", ()=>getSlotClassNames
);
parcelHelpers.export(exports, "getStickyFooterScrollbar", ()=>getStickyFooterScrollbar
);
parcelHelpers.export(exports, "getStickyHeaderDates", ()=>getStickyHeaderDates
);
parcelHelpers.export(exports, "getUnequalProps", ()=>getUnequalProps
);
parcelHelpers.export(exports, "getUniqueDomId", ()=>getUniqueDomId
);
parcelHelpers.export(exports, "globalLocales", ()=>globalLocales
);
parcelHelpers.export(exports, "globalPlugins", ()=>globalPlugins
);
parcelHelpers.export(exports, "greatestDurationDenominator", ()=>greatestDurationDenominator
);
parcelHelpers.export(exports, "groupIntersectingEntries", ()=>groupIntersectingEntries
);
parcelHelpers.export(exports, "guid", ()=>guid
);
parcelHelpers.export(exports, "hasBgRendering", ()=>hasBgRendering
);
parcelHelpers.export(exports, "hasShrinkWidth", ()=>hasShrinkWidth
);
parcelHelpers.export(exports, "identity", ()=>identity
);
parcelHelpers.export(exports, "interactionSettingsStore", ()=>interactionSettingsStore
);
parcelHelpers.export(exports, "interactionSettingsToStore", ()=>interactionSettingsToStore
);
parcelHelpers.export(exports, "intersectRanges", ()=>intersectRanges
);
parcelHelpers.export(exports, "intersectRects", ()=>intersectRects
);
parcelHelpers.export(exports, "intersectSpans", ()=>intersectSpans
);
parcelHelpers.export(exports, "isArraysEqual", ()=>isArraysEqual
);
parcelHelpers.export(exports, "isColPropsEqual", ()=>isColPropsEqual
);
parcelHelpers.export(exports, "isDateSelectionValid", ()=>isDateSelectionValid
);
parcelHelpers.export(exports, "isDateSpansEqual", ()=>isDateSpansEqual
);
parcelHelpers.export(exports, "isInt", ()=>isInt
);
parcelHelpers.export(exports, "isInteractionValid", ()=>isInteractionValid
);
parcelHelpers.export(exports, "isMultiDayRange", ()=>isMultiDayRange
);
parcelHelpers.export(exports, "isPropsEqual", ()=>isPropsEqual
);
parcelHelpers.export(exports, "isPropsValid", ()=>isPropsValid
);
parcelHelpers.export(exports, "isValidDate", ()=>isValidDate
);
parcelHelpers.export(exports, "joinSpans", ()=>joinSpans
);
parcelHelpers.export(exports, "listenBySelector", ()=>listenBySelector
);
parcelHelpers.export(exports, "mapHash", ()=>mapHash
);
parcelHelpers.export(exports, "memoize", ()=>memoize
);
parcelHelpers.export(exports, "memoizeArraylike", ()=>memoizeArraylike
);
parcelHelpers.export(exports, "memoizeHashlike", ()=>memoizeHashlike
);
parcelHelpers.export(exports, "memoizeObjArg", ()=>memoizeObjArg
);
parcelHelpers.export(exports, "mergeEventStores", ()=>mergeEventStores
);
parcelHelpers.export(exports, "multiplyDuration", ()=>multiplyDuration
);
parcelHelpers.export(exports, "padStart", ()=>padStart
);
parcelHelpers.export(exports, "parseBusinessHours", ()=>parseBusinessHours
);
parcelHelpers.export(exports, "parseClassNames", ()=>parseClassNames
);
parcelHelpers.export(exports, "parseDragMeta", ()=>parseDragMeta
);
parcelHelpers.export(exports, "parseEventDef", ()=>parseEventDef
);
parcelHelpers.export(exports, "parseFieldSpecs", ()=>parseFieldSpecs
);
parcelHelpers.export(exports, "parseMarker", ()=>parse
);
parcelHelpers.export(exports, "pointInsideRect", ()=>pointInsideRect
);
parcelHelpers.export(exports, "preventContextMenu", ()=>preventContextMenu
);
parcelHelpers.export(exports, "preventDefault", ()=>preventDefault
);
parcelHelpers.export(exports, "preventSelection", ()=>preventSelection
);
parcelHelpers.export(exports, "rangeContainsMarker", ()=>rangeContainsMarker
);
parcelHelpers.export(exports, "rangeContainsRange", ()=>rangeContainsRange
);
parcelHelpers.export(exports, "rangesEqual", ()=>rangesEqual
);
parcelHelpers.export(exports, "rangesIntersect", ()=>rangesIntersect
);
parcelHelpers.export(exports, "refineEventDef", ()=>refineEventDef
);
parcelHelpers.export(exports, "refineProps", ()=>refineProps
);
parcelHelpers.export(exports, "removeElement", ()=>removeElement
);
parcelHelpers.export(exports, "removeExact", ()=>removeExact
);
parcelHelpers.export(exports, "renderChunkContent", ()=>renderChunkContent
);
parcelHelpers.export(exports, "renderFill", ()=>renderFill
);
parcelHelpers.export(exports, "renderMicroColGroup", ()=>renderMicroColGroup
);
parcelHelpers.export(exports, "renderScrollShim", ()=>renderScrollShim
);
parcelHelpers.export(exports, "requestJson", ()=>requestJson
);
parcelHelpers.export(exports, "sanitizeShrinkWidth", ()=>sanitizeShrinkWidth
);
parcelHelpers.export(exports, "setElSeg", ()=>setElSeg
);
parcelHelpers.export(exports, "setRef", ()=>setRef
);
parcelHelpers.export(exports, "sliceEventStore", ()=>sliceEventStore
);
parcelHelpers.export(exports, "sliceEvents", ()=>sliceEvents
);
parcelHelpers.export(exports, "sortEventSegs", ()=>sortEventSegs
);
parcelHelpers.export(exports, "startOfDay", ()=>startOfDay
);
parcelHelpers.export(exports, "translateRect", ()=>translateRect
);
parcelHelpers.export(exports, "triggerDateSelect", ()=>triggerDateSelect
);
parcelHelpers.export(exports, "unpromisify", ()=>unpromisify
);
parcelHelpers.export(exports, "version", ()=>version
);
parcelHelpers.export(exports, "whenTransitionDone", ()=>whenTransitionDone
);
parcelHelpers.export(exports, "wholeDivideDurations", ()=>wholeDivideDurations
);
/*!
FullCalendar v5.10.2
Docs & License: https://fullcalendar.io/
(c) 2021 Adam Shaw
*/ var _mainCss = require("./main.css");
var _tslib = require("tslib");
var _vdomJs = require("./vdom.js");
parcelHelpers.exportAll(_vdomJs, exports);
// no public types yet. when there are, export from:
// import {} from './api-type-deps'
var EventSourceApi = /** @class */ function() {
    function EventSourceApi1(context, internalEventSource) {
        this.context = context;
        this.internalEventSource = internalEventSource;
    }
    EventSourceApi1.prototype.remove = function() {
        this.context.dispatch({
            type: 'REMOVE_EVENT_SOURCE',
            sourceId: this.internalEventSource.sourceId
        });
    };
    EventSourceApi1.prototype.refetch = function() {
        this.context.dispatch({
            type: 'FETCH_EVENT_SOURCES',
            sourceIds: [
                this.internalEventSource.sourceId
            ],
            isRefetch: true
        });
    };
    Object.defineProperty(EventSourceApi1.prototype, "id", {
        get: function() {
            return this.internalEventSource.publicId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventSourceApi1.prototype, "url", {
        get: function() {
            return this.internalEventSource.meta.url;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventSourceApi1.prototype, "format", {
        get: function() {
            return this.internalEventSource.meta.format; // TODO: bad. not guaranteed
        },
        enumerable: false,
        configurable: true
    });
    return EventSourceApi1;
}();
function removeElement(el) {
    if (el.parentNode) el.parentNode.removeChild(el);
}
// Querying
// ----------------------------------------------------------------------------------------------------------------
function elementClosest(el, selector) {
    if (el.closest) return el.closest(selector);
    if (!document.documentElement.contains(el)) return null;
    do {
        if (elementMatches(el, selector)) return el;
        el = el.parentElement || el.parentNode;
    }while (el !== null && el.nodeType === 1)
    return null;
}
function elementMatches(el, selector) {
    var method = el.matches || el.matchesSelector || el.msMatchesSelector;
    return method.call(el, selector);
}
// accepts multiple subject els
// returns a real array. good for methods like forEach
// TODO: accept the document
function findElements(container, selector) {
    var containers = container instanceof HTMLElement ? [
        container
    ] : container;
    var allMatches = [];
    for(var i = 0; i < containers.length; i += 1){
        var matches = containers[i].querySelectorAll(selector);
        for(var j = 0; j < matches.length; j += 1)allMatches.push(matches[j]);
    }
    return allMatches;
}
// accepts multiple subject els
// only queries direct child elements // TODO: rename to findDirectChildren!
function findDirectChildren(parent, selector) {
    var parents = parent instanceof HTMLElement ? [
        parent
    ] : parent;
    var allMatches = [];
    for(var i = 0; i < parents.length; i += 1){
        var childNodes = parents[i].children; // only ever elements
        for(var j = 0; j < childNodes.length; j += 1){
            var childNode = childNodes[j];
            if (!selector || elementMatches(childNode, selector)) allMatches.push(childNode);
        }
    }
    return allMatches;
}
// Style
// ----------------------------------------------------------------------------------------------------------------
var PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;
function applyStyle(el, props) {
    for(var propName in props)applyStyleProp(el, propName, props[propName]);
}
function applyStyleProp(el, name, val) {
    if (val == null) el.style[name] = '';
    else if (typeof val === 'number' && PIXEL_PROP_RE.test(name)) el.style[name] = val + "px";
    else el.style[name] = val;
}
// Event Handling
// ----------------------------------------------------------------------------------------------------------------
// if intercepting bubbled events at the document/window/body level,
// and want to see originating element (the 'target'), use this util instead
// of `ev.target` because it goes within web-component boundaries.
function getEventTargetViaRoot(ev) {
    var _a, _b;
    return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;
}
// Shadow DOM consuderations
// ----------------------------------------------------------------------------------------------------------------
function getElRoot(el) {
    return el.getRootNode ? el.getRootNode() : document;
}
// Unique ID for DOM attribute
var guid$1 = 0;
function getUniqueDomId() {
    guid$1 += 1;
    return 'fc-dom-' + guid$1;
}
// Stops a mouse/touch event from doing it's native browser action
function preventDefault(ev) {
    ev.preventDefault();
}
// Event Delegation
// ----------------------------------------------------------------------------------------------------------------
function buildDelegationHandler(selector, handler) {
    return function(ev) {
        var matchedChild = elementClosest(ev.target, selector);
        if (matchedChild) handler.call(matchedChild, ev, matchedChild);
    };
}
function listenBySelector(container, eventType, selector, handler) {
    var attachedHandler = buildDelegationHandler(selector, handler);
    container.addEventListener(eventType, attachedHandler);
    return function() {
        container.removeEventListener(eventType, attachedHandler);
    };
}
function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {
    var currentMatchedChild;
    return listenBySelector(container, 'mouseover', selector, function(mouseOverEv, matchedChild) {
        if (matchedChild !== currentMatchedChild) {
            currentMatchedChild = matchedChild;
            onMouseEnter(mouseOverEv, matchedChild);
            var realOnMouseLeave_1 = function(mouseLeaveEv) {
                currentMatchedChild = null;
                onMouseLeave(mouseLeaveEv, matchedChild);
                matchedChild.removeEventListener('mouseleave', realOnMouseLeave_1);
            };
            // listen to the next mouseleave, and then unattach
            matchedChild.addEventListener('mouseleave', realOnMouseLeave_1);
        }
    });
}
// Animation
// ----------------------------------------------------------------------------------------------------------------
var transitionEventNames = [
    'webkitTransitionEnd',
    'otransitionend',
    'oTransitionEnd',
    'msTransitionEnd',
    'transitionend', 
];
// triggered only when the next single subsequent transition finishes
function whenTransitionDone(el, callback) {
    var realCallback = function(ev) {
        callback(ev);
        transitionEventNames.forEach(function(eventName) {
            el.removeEventListener(eventName, realCallback);
        });
    };
    transitionEventNames.forEach(function(eventName) {
        el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes
    });
}
// ARIA workarounds
// ----------------------------------------------------------------------------------------------------------------
function createAriaClickAttrs(handler) {
    return _tslib.__assign({
        onClick: handler
    }, createAriaKeyboardAttrs(handler));
}
function createAriaKeyboardAttrs(handler) {
    return {
        tabIndex: 0,
        onKeyDown: function(ev) {
            if (ev.key === 'Enter' || ev.key === ' ') {
                handler(ev);
                ev.preventDefault(); // if space, don't scroll down page
            }
        }
    };
}
var guidNumber = 0;
function guid() {
    guidNumber += 1;
    return String(guidNumber);
}
/* FullCalendar-specific DOM Utilities
----------------------------------------------------------------------------------------------------------------------*/ // Make the mouse cursor express that an event is not allowed in the current area
function disableCursor() {
    document.body.classList.add('fc-not-allowed');
}
// Returns the mouse cursor to its original look
function enableCursor() {
    document.body.classList.remove('fc-not-allowed');
}
/* Selection
----------------------------------------------------------------------------------------------------------------------*/ function preventSelection(el) {
    el.classList.add('fc-unselectable');
    el.addEventListener('selectstart', preventDefault);
}
function allowSelection(el) {
    el.classList.remove('fc-unselectable');
    el.removeEventListener('selectstart', preventDefault);
}
/* Context Menu
----------------------------------------------------------------------------------------------------------------------*/ function preventContextMenu(el) {
    el.addEventListener('contextmenu', preventDefault);
}
function allowContextMenu(el) {
    el.removeEventListener('contextmenu', preventDefault);
}
function parseFieldSpecs(input) {
    var specs = [];
    var tokens = [];
    var i;
    var token;
    if (typeof input === 'string') tokens = input.split(/\s*,\s*/);
    else if (typeof input === 'function') tokens = [
        input
    ];
    else if (Array.isArray(input)) tokens = input;
    for(i = 0; i < tokens.length; i += 1){
        token = tokens[i];
        if (typeof token === 'string') specs.push(token.charAt(0) === '-' ? {
            field: token.substring(1),
            order: -1
        } : {
            field: token,
            order: 1
        });
        else if (typeof token === 'function') specs.push({
            func: token
        });
    }
    return specs;
}
function compareByFieldSpecs(obj0, obj1, fieldSpecs) {
    var i;
    var cmp;
    for(i = 0; i < fieldSpecs.length; i += 1){
        cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);
        if (cmp) return cmp;
    }
    return 0;
}
function compareByFieldSpec(obj0, obj1, fieldSpec) {
    if (fieldSpec.func) return fieldSpec.func(obj0, obj1);
    return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);
}
function flexibleCompare(a, b) {
    if (!a && !b) return 0;
    if (b == null) return -1;
    if (a == null) return 1;
    if (typeof a === 'string' || typeof b === 'string') return String(a).localeCompare(String(b));
    return a - b;
}
/* String Utilities
----------------------------------------------------------------------------------------------------------------------*/ function padStart(val, len) {
    var s = String(val);
    return '000'.substr(0, len - s.length) + s;
}
function formatWithOrdinals(formatter, args, fallbackText) {
    if (typeof formatter === 'function') return formatter.apply(void 0, args);
    if (typeof formatter === 'string') return args.reduce(function(str, arg, index) {
        return str.replace('$' + index, arg || '');
    }, formatter);
    return fallbackText;
}
/* Number Utilities
----------------------------------------------------------------------------------------------------------------------*/ function compareNumbers(a, b) {
    return a - b;
}
function isInt(n) {
    return n % 1 === 0;
}
/* FC-specific DOM dimension stuff
----------------------------------------------------------------------------------------------------------------------*/ function computeSmallestCellWidth(cellEl) {
    var allWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-frame');
    var contentWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-cushion');
    if (!allWidthEl) throw new Error('needs fc-scrollgrid-shrink-frame className'); // TODO: use const
    if (!contentWidthEl) throw new Error('needs fc-scrollgrid-shrink-cushion className');
    return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + contentWidthEl.getBoundingClientRect().width;
}
var DAY_IDS = [
    'sun',
    'mon',
    'tue',
    'wed',
    'thu',
    'fri',
    'sat'
];
// Adding
function addWeeks(m, n) {
    var a = dateToUtcArray(m);
    a[2] += n * 7;
    return arrayToUtcDate(a);
}
function addDays(m, n) {
    var a = dateToUtcArray(m);
    a[2] += n;
    return arrayToUtcDate(a);
}
function addMs(m, n) {
    var a = dateToUtcArray(m);
    a[6] += n;
    return arrayToUtcDate(a);
}
// Diffing (all return floats)
// TODO: why not use ranges?
function diffWeeks(m0, m1) {
    return diffDays(m0, m1) / 7;
}
function diffDays(m0, m1) {
    return (m1.valueOf() - m0.valueOf()) / 86400000;
}
function diffHours(m0, m1) {
    return (m1.valueOf() - m0.valueOf()) / 3600000;
}
function diffMinutes(m0, m1) {
    return (m1.valueOf() - m0.valueOf()) / 60000;
}
function diffSeconds(m0, m1) {
    return (m1.valueOf() - m0.valueOf()) / 1000;
}
function diffDayAndTime(m0, m1) {
    var m0day = startOfDay(m0);
    var m1day = startOfDay(m1);
    return {
        years: 0,
        months: 0,
        days: Math.round(diffDays(m0day, m1day)),
        milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())
    };
}
// Diffing Whole Units
function diffWholeWeeks(m0, m1) {
    var d = diffWholeDays(m0, m1);
    if (d !== null && d % 7 === 0) return d / 7;
    return null;
}
function diffWholeDays(m0, m1) {
    if (timeAsMs(m0) === timeAsMs(m1)) return Math.round(diffDays(m0, m1));
    return null;
}
// Start-Of
function startOfDay(m) {
    return arrayToUtcDate([
        m.getUTCFullYear(),
        m.getUTCMonth(),
        m.getUTCDate(), 
    ]);
}
function startOfHour(m) {
    return arrayToUtcDate([
        m.getUTCFullYear(),
        m.getUTCMonth(),
        m.getUTCDate(),
        m.getUTCHours(), 
    ]);
}
function startOfMinute(m) {
    return arrayToUtcDate([
        m.getUTCFullYear(),
        m.getUTCMonth(),
        m.getUTCDate(),
        m.getUTCHours(),
        m.getUTCMinutes(), 
    ]);
}
function startOfSecond(m) {
    return arrayToUtcDate([
        m.getUTCFullYear(),
        m.getUTCMonth(),
        m.getUTCDate(),
        m.getUTCHours(),
        m.getUTCMinutes(),
        m.getUTCSeconds(), 
    ]);
}
// Week Computation
function weekOfYear(marker, dow, doy) {
    var y = marker.getUTCFullYear();
    var w = weekOfGivenYear(marker, y, dow, doy);
    if (w < 1) return weekOfGivenYear(marker, y - 1, dow, doy);
    var nextW = weekOfGivenYear(marker, y + 1, dow, doy);
    if (nextW >= 1) return Math.min(w, nextW);
    return w;
}
function weekOfGivenYear(marker, year, dow, doy) {
    var firstWeekStart = arrayToUtcDate([
        year,
        0,
        1 + firstWeekOffset(year, dow, doy)
    ]);
    var dayStart = startOfDay(marker);
    var days = Math.round(diffDays(firstWeekStart, dayStart));
    return Math.floor(days / 7) + 1; // zero-indexed
}
// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    // first-week day -- which january is always in the first week (4 for iso, 1 for other)
    var fwd = 7 + dow - doy;
    // first-week day local weekday -- which local weekday is fwd
    var fwdlw = (7 + arrayToUtcDate([
        year,
        0,
        fwd
    ]).getUTCDay() - dow) % 7;
    return -fwdlw + fwd - 1;
}
// Array Conversion
function dateToLocalArray(date) {
    return [
        date.getFullYear(),
        date.getMonth(),
        date.getDate(),
        date.getHours(),
        date.getMinutes(),
        date.getSeconds(),
        date.getMilliseconds(), 
    ];
}
function arrayToLocalDate(a) {
    return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], a[3] || 0, a[4] || 0, a[5] || 0);
}
function dateToUtcArray(date) {
    return [
        date.getUTCFullYear(),
        date.getUTCMonth(),
        date.getUTCDate(),
        date.getUTCHours(),
        date.getUTCMinutes(),
        date.getUTCSeconds(),
        date.getUTCMilliseconds(), 
    ];
}
function arrayToUtcDate(a) {
    // according to web standards (and Safari), a month index is required.
    // massage if only given a year.
    if (a.length === 1) a = a.concat([
        0
    ]);
    return new Date(Date.UTC.apply(Date, a));
}
// Other Utils
function isValidDate(m) {
    return !isNaN(m.valueOf());
}
function timeAsMs(m) {
    return m.getUTCHours() * 3600000 + m.getUTCMinutes() * 60000 + m.getUTCSeconds() * 1000 + m.getUTCMilliseconds();
}
function createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {
    return {
        instanceId: guid(),
        defId: defId,
        range: range,
        forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,
        forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo
    };
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
// Merges an array of objects into a single object.
// The second argument allows for an array of property names who's object values will be merged together.
function mergeProps(propObjs, complexPropsMap) {
    var dest = {};
    if (complexPropsMap) for(var name_1 in complexPropsMap){
        var complexObjs = [];
        // collect the trailing object values, stopping when a non-object is discovered
        for(var i = propObjs.length - 1; i >= 0; i -= 1){
            var val = propObjs[i][name_1];
            if (typeof val === 'object' && val) complexObjs.unshift(val);
            else if (val !== undefined) {
                dest[name_1] = val; // if there were no objects, this value will be used
                break;
            }
        }
        // if the trailing values were objects, use the merged value
        if (complexObjs.length) dest[name_1] = mergeProps(complexObjs);
    }
    // copy values into the destination, going from last to first
    for(var i = propObjs.length - 1; i >= 0; i -= 1){
        var props = propObjs[i];
        for(var name_2 in props)if (!(name_2 in dest)) dest[name_2] = props[name_2];
    }
    return dest;
}
function filterHash(hash, func) {
    var filtered = {};
    for(var key in hash)if (func(hash[key], key)) filtered[key] = hash[key];
    return filtered;
}
function mapHash(hash, func) {
    var newHash = {};
    for(var key in hash)newHash[key] = func(hash[key], key);
    return newHash;
}
function arrayToHash(a) {
    var hash = {};
    for(var _i = 0, a_1 = a; _i < a_1.length; _i++){
        var item = a_1[_i];
        hash[item] = true;
    }
    return hash;
}
function buildHashFromArray(a, func) {
    var hash = {};
    for(var i = 0; i < a.length; i += 1){
        var tuple = func(a[i], i);
        hash[tuple[0]] = tuple[1];
    }
    return hash;
}
function hashValuesToArray(obj) {
    var a = [];
    for(var key in obj)a.push(obj[key]);
    return a;
}
function isPropsEqual(obj0, obj1) {
    if (obj0 === obj1) return true;
    for(var key in obj0)if (hasOwnProperty.call(obj0, key)) {
        if (!(key in obj1)) return false;
    }
    for(var key in obj1)if (hasOwnProperty.call(obj1, key)) {
        if (obj0[key] !== obj1[key]) return false;
    }
    return true;
}
function getUnequalProps(obj0, obj1) {
    var keys = [];
    for(var key in obj0){
        if (hasOwnProperty.call(obj0, key)) {
            if (!(key in obj1)) keys.push(key);
        }
    }
    for(var key in obj1){
        if (hasOwnProperty.call(obj1, key)) {
            if (obj0[key] !== obj1[key]) keys.push(key);
        }
    }
    return keys;
}
function compareObjs(oldProps, newProps, equalityFuncs) {
    if (equalityFuncs === void 0) equalityFuncs = {};
    if (oldProps === newProps) return true;
    for(var key in newProps){
        if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;
        else return false;
    }
    // check for props that were omitted in the new
    for(var key in oldProps){
        if (!(key in newProps)) return false;
    }
    return true;
}
/*
assumed "true" equality for handler names like "onReceiveSomething"
*/ function isObjValsEqual(val0, val1, comparator) {
    if (val0 === val1 || comparator === true) return true;
    if (comparator) return comparator(val0, val1);
    return false;
}
function collectFromHash(hash, startIndex, endIndex, step) {
    if (startIndex === void 0) startIndex = 0;
    if (step === void 0) step = 1;
    var res = [];
    if (endIndex == null) endIndex = Object.keys(hash).length;
    for(var i = startIndex; i < endIndex; i += step){
        var val = hash[i];
        if (val !== undefined) res.push(val);
    }
    return res;
}
function parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {
    for(var i = 0; i < recurringTypes.length; i += 1){
        var parsed = recurringTypes[i].parse(refined, dateEnv);
        if (parsed) {
            var allDay = refined.allDay;
            if (allDay == null) {
                allDay = defaultAllDay;
                if (allDay == null) {
                    allDay = parsed.allDayGuess;
                    if (allDay == null) allDay = false;
                }
            }
            return {
                allDay: allDay,
                duration: parsed.duration,
                typeData: parsed.typeData,
                typeId: i
            };
        }
    }
    return null;
}
function expandRecurring(eventStore, framingRange, context) {
    var dateEnv = context.dateEnv, pluginHooks = context.pluginHooks, options = context.options;
    var defs = eventStore.defs, instances = eventStore.instances;
    // remove existing recurring instances
    // TODO: bad. always expand events as a second step
    instances = filterHash(instances, function(instance) {
        return !defs[instance.defId].recurringDef;
    });
    for(var defId in defs){
        var def = defs[defId];
        if (def.recurringDef) {
            var duration = def.recurringDef.duration;
            if (!duration) duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;
            var starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);
            for(var _i = 0, starts_1 = starts; _i < starts_1.length; _i++){
                var start = starts_1[_i];
                var instance1 = createEventInstance(defId, {
                    start: start,
                    end: dateEnv.add(start, duration)
                });
                instances[instance1.instanceId] = instance1;
            }
        }
    }
    return {
        defs: defs,
        instances: instances
    };
}
/*
Event MUST have a recurringDef
*/ function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {
    var typeDef = recurringTypes[eventDef.recurringDef.typeId];
    var markers = typeDef.expand(eventDef.recurringDef.typeData, {
        start: dateEnv.subtract(framingRange.start, duration),
        end: framingRange.end
    }, dateEnv);
    // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to
    if (eventDef.allDay) markers = markers.map(startOfDay);
    return markers;
}
var INTERNAL_UNITS = [
    'years',
    'months',
    'days',
    'milliseconds'
];
var PARSE_RE = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/;
// Parsing and Creation
function createDuration(input, unit) {
    var _a;
    if (typeof input === 'string') return parseString(input);
    if (typeof input === 'object' && input) return parseObject(input);
    if (typeof input === 'number') return parseObject((_a = {}, _a[unit || 'milliseconds'] = input, _a));
    return null;
}
function parseString(s) {
    var m = PARSE_RE.exec(s);
    if (m) {
        var sign = m[1] ? -1 : 1;
        return {
            years: 0,
            months: 0,
            days: sign * (m[2] ? parseInt(m[2], 10) : 0),
            milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 3600000 + (m[4] ? parseInt(m[4], 10) : 0) * 60000 + (m[5] ? parseInt(m[5], 10) : 0) * 1000 + (m[6] ? parseInt(m[6], 10) : 0 // ms
            ))
        };
    }
    return null;
}
function parseObject(obj) {
    var duration = {
        years: obj.years || obj.year || 0,
        months: obj.months || obj.month || 0,
        days: obj.days || obj.day || 0,
        milliseconds: (obj.hours || obj.hour || 0) * 3600000 + (obj.minutes || obj.minute || 0) * 60000 + (obj.seconds || obj.second || 0) * 1000 + (obj.milliseconds || obj.millisecond || obj.ms || 0)
    };
    var weeks = obj.weeks || obj.week;
    if (weeks) {
        duration.days += weeks * 7;
        duration.specifiedWeeks = true;
    }
    return duration;
}
// Equality
function durationsEqual(d0, d1) {
    return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;
}
function asCleanDays(dur) {
    if (!dur.years && !dur.months && !dur.milliseconds) return dur.days;
    return 0;
}
// Simple Math
function addDurations(d0, d1) {
    return {
        years: d0.years + d1.years,
        months: d0.months + d1.months,
        days: d0.days + d1.days,
        milliseconds: d0.milliseconds + d1.milliseconds
    };
}
function subtractDurations(d1, d0) {
    return {
        years: d1.years - d0.years,
        months: d1.months - d0.months,
        days: d1.days - d0.days,
        milliseconds: d1.milliseconds - d0.milliseconds
    };
}
function multiplyDuration(d, n) {
    return {
        years: d.years * n,
        months: d.months * n,
        days: d.days * n,
        milliseconds: d.milliseconds * n
    };
}
// Conversions
// "Rough" because they are based on average-case Gregorian months/years
function asRoughYears(dur) {
    return asRoughDays(dur) / 365;
}
function asRoughMonths(dur) {
    return asRoughDays(dur) / 30;
}
function asRoughDays(dur) {
    return asRoughMs(dur) / 864e5;
}
function asRoughMinutes(dur) {
    return asRoughMs(dur) / 60000;
}
function asRoughSeconds(dur) {
    return asRoughMs(dur) / 1000;
}
function asRoughMs(dur) {
    return dur.years * 31536000000 + dur.months * 2592000000 + dur.days * 864e5 + dur.milliseconds;
}
// Advanced Math
function wholeDivideDurations(numerator, denominator) {
    var res = null;
    for(var i = 0; i < INTERNAL_UNITS.length; i += 1){
        var unit = INTERNAL_UNITS[i];
        if (denominator[unit]) {
            var localRes = numerator[unit] / denominator[unit];
            if (!isInt(localRes) || res !== null && res !== localRes) return null;
            res = localRes;
        } else if (numerator[unit]) // needs to divide by something but can't!
        return null;
    }
    return res;
}
function greatestDurationDenominator(dur) {
    var ms = dur.milliseconds;
    if (ms) {
        if (ms % 1000 !== 0) return {
            unit: 'millisecond',
            value: ms
        };
        if (ms % 60000 !== 0) return {
            unit: 'second',
            value: ms / 1000
        };
        if (ms % 3600000 !== 0) return {
            unit: 'minute',
            value: ms / 60000
        };
        if (ms) return {
            unit: 'hour',
            value: ms / 3600000
        };
    }
    if (dur.days) {
        if (dur.specifiedWeeks && dur.days % 7 === 0) return {
            unit: 'week',
            value: dur.days / 7
        };
        return {
            unit: 'day',
            value: dur.days
        };
    }
    if (dur.months) return {
        unit: 'month',
        value: dur.months
    };
    if (dur.years) return {
        unit: 'year',
        value: dur.years
    };
    return {
        unit: 'millisecond',
        value: 0
    };
}
// timeZoneOffset is in minutes
function buildIsoString(marker, timeZoneOffset, stripZeroTime) {
    if (stripZeroTime === void 0) stripZeroTime = false;
    var s = marker.toISOString();
    s = s.replace('.000', '');
    if (stripZeroTime) s = s.replace('T00:00:00Z', '');
    if (s.length > 10) {
        if (timeZoneOffset == null) s = s.replace('Z', '');
        else if (timeZoneOffset !== 0) s = s.replace('Z', formatTimeZoneOffset(timeZoneOffset, true));
    // otherwise, its UTC-0 and we want to keep the Z
    }
    return s;
}
// formats the date, but with no time part
// TODO: somehow merge with buildIsoString and stripZeroTime
// TODO: rename. omit "string"
function formatDayString(marker) {
    return marker.toISOString().replace(/T.*$/, '');
}
// TODO: use Date::toISOString and use everything after the T?
function formatIsoTimeString(marker) {
    return padStart(marker.getUTCHours(), 2) + ':' + padStart(marker.getUTCMinutes(), 2) + ':' + padStart(marker.getUTCSeconds(), 2);
}
function formatTimeZoneOffset(minutes, doIso) {
    if (doIso === void 0) doIso = false;
    var sign = minutes < 0 ? '-' : '+';
    var abs = Math.abs(minutes);
    var hours = Math.floor(abs / 60);
    var mins = Math.round(abs % 60);
    if (doIso) return sign + padStart(hours, 2) + ":" + padStart(mins, 2);
    return "GMT" + sign + hours + (mins ? ":" + padStart(mins, 2) : '');
}
// TODO: new util arrayify?
function removeExact(array, exactVal) {
    var removeCnt = 0;
    var i = 0;
    while(i < array.length)if (array[i] === exactVal) {
        array.splice(i, 1);
        removeCnt += 1;
    } else i += 1;
    return removeCnt;
}
function isArraysEqual(a0, a1, equalityFunc) {
    if (a0 === a1) return true;
    var len = a0.length;
    var i;
    if (len !== a1.length) return false;
    for(i = 0; i < len; i += 1){
        if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) return false;
    }
    return true;
}
function memoize(workerFunc, resEquality, teardownFunc) {
    var currentArgs;
    var currentRes;
    return function() {
        var newArgs = [];
        for(var _i = 0; _i < arguments.length; _i++)newArgs[_i] = arguments[_i];
        if (!currentArgs) currentRes = workerFunc.apply(this, newArgs);
        else if (!isArraysEqual(currentArgs, newArgs)) {
            if (teardownFunc) teardownFunc(currentRes);
            var res = workerFunc.apply(this, newArgs);
            if (!resEquality || !resEquality(res, currentRes)) currentRes = res;
        }
        currentArgs = newArgs;
        return currentRes;
    };
}
function memoizeObjArg(workerFunc, resEquality, teardownFunc) {
    var _this = this;
    var currentArg;
    var currentRes;
    return function(newArg) {
        if (!currentArg) currentRes = workerFunc.call(_this, newArg);
        else if (!isPropsEqual(currentArg, newArg)) {
            if (teardownFunc) teardownFunc(currentRes);
            var res = workerFunc.call(_this, newArg);
            if (!resEquality || !resEquality(res, currentRes)) currentRes = res;
        }
        currentArg = newArg;
        return currentRes;
    };
}
function memoizeArraylike(workerFunc, resEquality, teardownFunc) {
    var _this = this;
    var currentArgSets = [];
    var currentResults = [];
    return function(newArgSets) {
        var currentLen = currentArgSets.length;
        var newLen = newArgSets.length;
        var i = 0;
        for(; i < currentLen; i += 1){
            if (!newArgSets[i]) {
                if (teardownFunc) teardownFunc(currentResults[i]);
            } else if (!isArraysEqual(currentArgSets[i], newArgSets[i])) {
                if (teardownFunc) teardownFunc(currentResults[i]);
                var res = workerFunc.apply(_this, newArgSets[i]);
                if (!resEquality || !resEquality(res, currentResults[i])) currentResults[i] = res;
            }
        }
        for(; i < newLen; i += 1)currentResults[i] = workerFunc.apply(_this, newArgSets[i]);
        currentArgSets = newArgSets;
        currentResults.splice(newLen); // remove excess
        return currentResults;
    };
}
function memoizeHashlike(workerFunc, resEquality, teardownFunc) {
    var _this = this;
    var currentArgHash = {};
    var currentResHash = {};
    return function(newArgHash) {
        var newResHash = {};
        for(var key in newArgHash){
            if (!currentResHash[key]) newResHash[key] = workerFunc.apply(_this, newArgHash[key]);
            else if (!isArraysEqual(currentArgHash[key], newArgHash[key])) {
                if (teardownFunc) teardownFunc(currentResHash[key]);
                var res = workerFunc.apply(_this, newArgHash[key]);
                newResHash[key] = resEquality && resEquality(res, currentResHash[key]) ? currentResHash[key] : res;
            } else newResHash[key] = currentResHash[key];
        }
        currentArgHash = newArgHash;
        currentResHash = newResHash;
        return newResHash;
    };
}
var EXTENDED_SETTINGS_AND_SEVERITIES = {
    week: 3,
    separator: 0,
    omitZeroMinute: 0,
    meridiem: 0,
    omitCommas: 0
};
var STANDARD_DATE_PROP_SEVERITIES = {
    timeZoneName: 7,
    era: 6,
    year: 5,
    month: 4,
    day: 2,
    weekday: 2,
    hour: 1,
    minute: 1,
    second: 1
};
var MERIDIEM_RE = /\s*([ap])\.?m\.?/i; // eats up leading spaces too
var COMMA_RE = /,/g; // we need re for globalness
var MULTI_SPACE_RE = /\s+/g;
var LTR_RE = /\u200e/g; // control character
var UTC_RE = /UTC|GMT/;
var NativeFormatter = /** @class */ function() {
    function NativeFormatter1(formatSettings) {
        var standardDateProps = {};
        var extendedSettings = {};
        var severity = 0;
        for(var name_1 in formatSettings)if (name_1 in EXTENDED_SETTINGS_AND_SEVERITIES) {
            extendedSettings[name_1] = formatSettings[name_1];
            severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name_1], severity);
        } else {
            standardDateProps[name_1] = formatSettings[name_1];
            if (name_1 in STANDARD_DATE_PROP_SEVERITIES) severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name_1], severity);
        }
        this.standardDateProps = standardDateProps;
        this.extendedSettings = extendedSettings;
        this.severity = severity;
        this.buildFormattingFunc = memoize(buildFormattingFunc);
    }
    NativeFormatter1.prototype.format = function(date, context) {
        return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);
    };
    NativeFormatter1.prototype.formatRange = function(start, end, context, betterDefaultSeparator) {
        var _a = this, standardDateProps = _a.standardDateProps, extendedSettings = _a.extendedSettings;
        var diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);
        if (!diffSeverity) return this.format(start, context);
        var biggestUnitForPartial = diffSeverity;
        if (biggestUnitForPartial > 1 && (standardDateProps.year === 'numeric' || standardDateProps.year === '2-digit') && (standardDateProps.month === 'numeric' || standardDateProps.month === '2-digit') && (standardDateProps.day === 'numeric' || standardDateProps.day === '2-digit')) biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time
        var full0 = this.format(start, context);
        var full1 = this.format(end, context);
        if (full0 === full1) return full0;
        var partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);
        var partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);
        var partial0 = partialFormattingFunc(start);
        var partial1 = partialFormattingFunc(end);
        var insertion = findCommonInsertion(full0, partial0, full1, partial1);
        var separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || '';
        if (insertion) return insertion.before + partial0 + separator + partial1 + insertion.after;
        return full0 + separator + full1;
    };
    NativeFormatter1.prototype.getLargestUnit = function() {
        switch(this.severity){
            case 7:
            case 6:
            case 5:
                return 'year';
            case 4:
                return 'month';
            case 3:
                return 'week';
            case 2:
                return 'day';
            default:
                return 'time'; // really?
        }
    };
    return NativeFormatter1;
}();
function buildFormattingFunc(standardDateProps, extendedSettings, context) {
    var standardDatePropCnt = Object.keys(standardDateProps).length;
    if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === 'short') return function(date) {
        return formatTimeZoneOffset(date.timeZoneOffset);
    };
    if (standardDatePropCnt === 0 && extendedSettings.week) return function(date) {
        return formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);
    };
    return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);
}
function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {
    standardDateProps = _tslib.__assign({}, standardDateProps); // copy
    extendedSettings = _tslib.__assign({}, extendedSettings); // copy
    sanitizeSettings(standardDateProps, extendedSettings);
    standardDateProps.timeZone = 'UTC'; // we leverage the only guaranteed timeZone for our UTC markers
    var normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);
    var zeroFormat; // needed?
    if (extendedSettings.omitZeroMinute) {
        var zeroProps = _tslib.__assign({}, standardDateProps);
        delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings
        zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);
    }
    return function(date) {
        var marker = date.marker;
        var format;
        if (zeroFormat && !marker.getUTCMinutes()) format = zeroFormat;
        else format = normalFormat;
        var s = format.format(marker);
        return postProcess(s, date, standardDateProps, extendedSettings, context);
    };
}
function sanitizeSettings(standardDateProps, extendedSettings) {
    // deal with a browser inconsistency where formatting the timezone
    // requires that the hour/minute be present.
    if (standardDateProps.timeZoneName) {
        if (!standardDateProps.hour) standardDateProps.hour = '2-digit';
        if (!standardDateProps.minute) standardDateProps.minute = '2-digit';
    }
    // only support short timezone names
    if (standardDateProps.timeZoneName === 'long') standardDateProps.timeZoneName = 'short';
    // if requesting to display seconds, MUST display minutes
    if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) delete extendedSettings.omitZeroMinute;
}
function postProcess(s, date, standardDateProps, extendedSettings, context) {
    s = s.replace(LTR_RE, ''); // remove left-to-right control chars. do first. good for other regexes
    if (standardDateProps.timeZoneName === 'short') s = injectTzoStr(s, context.timeZone === 'UTC' || date.timeZoneOffset == null ? 'UTC' : formatTimeZoneOffset(date.timeZoneOffset));
    if (extendedSettings.omitCommas) s = s.replace(COMMA_RE, '').trim();
    if (extendedSettings.omitZeroMinute) s = s.replace(':00', ''); // zeroFormat doesn't always achieve this
    // ^ do anything that might create adjacent spaces before this point,
    // because MERIDIEM_RE likes to eat up loading spaces
    if (extendedSettings.meridiem === false) s = s.replace(MERIDIEM_RE, '').trim();
    else if (extendedSettings.meridiem === 'narrow') s = s.replace(MERIDIEM_RE, function(m0, m1) {
        return m1.toLocaleLowerCase();
    });
    else if (extendedSettings.meridiem === 'short') s = s.replace(MERIDIEM_RE, function(m0, m1) {
        return m1.toLocaleLowerCase() + "m";
    });
    else if (extendedSettings.meridiem === 'lowercase') s = s.replace(MERIDIEM_RE, function(m0) {
        return m0.toLocaleLowerCase();
    });
    s = s.replace(MULTI_SPACE_RE, ' ');
    s = s.trim();
    return s;
}
function injectTzoStr(s, tzoStr) {
    var replaced = false;
    s = s.replace(UTC_RE, function() {
        replaced = true;
        return tzoStr;
    });
    // IE11 doesn't include UTC/GMT in the original string, so append to end
    if (!replaced) s += " " + tzoStr;
    return s;
}
function formatWeekNumber(num, weekText, weekTextLong, locale, display) {
    var parts = [];
    if (display === 'long') parts.push(weekTextLong);
    else if (display === 'short' || display === 'narrow') parts.push(weekText);
    if (display === 'long' || display === 'short') parts.push(' ');
    parts.push(locale.simpleNumberFormat.format(num));
    if (locale.options.direction === 'rtl') parts.reverse();
    return parts.join('');
}
// Range Formatting Utils
// 0 = exactly the same
// 1 = different by time
// and bigger
function computeMarkerDiffSeverity(d0, d1, ca) {
    if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) return 5;
    if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) return 4;
    if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) return 2;
    if (timeAsMs(d0) !== timeAsMs(d1)) return 1;
    return 0;
}
function computePartialFormattingOptions(options, biggestUnit) {
    var partialOptions = {};
    for(var name_2 in options)if (!(name_2 in STANDARD_DATE_PROP_SEVERITIES) || STANDARD_DATE_PROP_SEVERITIES[name_2] <= biggestUnit) partialOptions[name_2] = options[name_2];
    return partialOptions;
}
function findCommonInsertion(full0, partial0, full1, partial1) {
    var i0 = 0;
    while(i0 < full0.length){
        var found0 = full0.indexOf(partial0, i0);
        if (found0 === -1) break;
        var before0 = full0.substr(0, found0);
        i0 = found0 + partial0.length;
        var after0 = full0.substr(i0);
        var i1 = 0;
        while(i1 < full1.length){
            var found1 = full1.indexOf(partial1, i1);
            if (found1 === -1) break;
            var before1 = full1.substr(0, found1);
            i1 = found1 + partial1.length;
            var after1 = full1.substr(i1);
            if (before0 === before1 && after0 === after1) return {
                before: before0,
                after: after0
            };
        }
    }
    return null;
}
function expandZonedMarker(dateInfo, calendarSystem) {
    var a = calendarSystem.markerToArray(dateInfo.marker);
    return {
        marker: dateInfo.marker,
        timeZoneOffset: dateInfo.timeZoneOffset,
        array: a,
        year: a[0],
        month: a[1],
        day: a[2],
        hour: a[3],
        minute: a[4],
        second: a[5],
        millisecond: a[6]
    };
}
function createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {
    var startInfo = expandZonedMarker(start, context.calendarSystem);
    var endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;
    return {
        date: startInfo,
        start: startInfo,
        end: endInfo,
        timeZone: context.timeZone,
        localeCodes: context.locale.codes,
        defaultSeparator: betterDefaultSeparator || context.defaultSeparator
    };
}
/*
TODO: fix the terminology of "formatter" vs "formatting func"
*/ /*
At the time of instantiation, this object does not know which cmd-formatting system it will use.
It receives this at the time of formatting, as a setting.
*/ var CmdFormatter = /** @class */ function() {
    function CmdFormatter1(cmdStr) {
        this.cmdStr = cmdStr;
    }
    CmdFormatter1.prototype.format = function(date, context, betterDefaultSeparator) {
        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
    };
    CmdFormatter1.prototype.formatRange = function(start, end, context, betterDefaultSeparator) {
        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));
    };
    return CmdFormatter1;
}();
var FuncFormatter = /** @class */ function() {
    function FuncFormatter1(func) {
        this.func = func;
    }
    FuncFormatter1.prototype.format = function(date, context, betterDefaultSeparator) {
        return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
    };
    FuncFormatter1.prototype.formatRange = function(start, end, context, betterDefaultSeparator) {
        return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));
    };
    return FuncFormatter1;
}();
function createFormatter(input) {
    if (typeof input === 'object' && input) return new NativeFormatter(input);
    if (typeof input === 'string') return new CmdFormatter(input);
    if (typeof input === 'function') return new FuncFormatter(input);
    return null;
}
// base options
// ------------
var BASE_OPTION_REFINERS = {
    navLinkDayClick: identity,
    navLinkWeekClick: identity,
    duration: createDuration,
    bootstrapFontAwesome: identity,
    buttonIcons: identity,
    customButtons: identity,
    defaultAllDayEventDuration: createDuration,
    defaultTimedEventDuration: createDuration,
    nextDayThreshold: createDuration,
    scrollTime: createDuration,
    scrollTimeReset: Boolean,
    slotMinTime: createDuration,
    slotMaxTime: createDuration,
    dayPopoverFormat: createFormatter,
    slotDuration: createDuration,
    snapDuration: createDuration,
    headerToolbar: identity,
    footerToolbar: identity,
    defaultRangeSeparator: String,
    titleRangeSeparator: String,
    forceEventDuration: Boolean,
    dayHeaders: Boolean,
    dayHeaderFormat: createFormatter,
    dayHeaderClassNames: identity,
    dayHeaderContent: identity,
    dayHeaderDidMount: identity,
    dayHeaderWillUnmount: identity,
    dayCellClassNames: identity,
    dayCellContent: identity,
    dayCellDidMount: identity,
    dayCellWillUnmount: identity,
    initialView: String,
    aspectRatio: Number,
    weekends: Boolean,
    weekNumberCalculation: identity,
    weekNumbers: Boolean,
    weekNumberClassNames: identity,
    weekNumberContent: identity,
    weekNumberDidMount: identity,
    weekNumberWillUnmount: identity,
    editable: Boolean,
    viewClassNames: identity,
    viewDidMount: identity,
    viewWillUnmount: identity,
    nowIndicator: Boolean,
    nowIndicatorClassNames: identity,
    nowIndicatorContent: identity,
    nowIndicatorDidMount: identity,
    nowIndicatorWillUnmount: identity,
    showNonCurrentDates: Boolean,
    lazyFetching: Boolean,
    startParam: String,
    endParam: String,
    timeZoneParam: String,
    timeZone: String,
    locales: identity,
    locale: identity,
    themeSystem: String,
    dragRevertDuration: Number,
    dragScroll: Boolean,
    allDayMaintainDuration: Boolean,
    unselectAuto: Boolean,
    dropAccept: identity,
    eventOrder: parseFieldSpecs,
    eventOrderStrict: Boolean,
    handleWindowResize: Boolean,
    windowResizeDelay: Number,
    longPressDelay: Number,
    eventDragMinDistance: Number,
    expandRows: Boolean,
    height: identity,
    contentHeight: identity,
    direction: String,
    weekNumberFormat: createFormatter,
    eventResizableFromStart: Boolean,
    displayEventTime: Boolean,
    displayEventEnd: Boolean,
    weekText: String,
    weekTextLong: String,
    progressiveEventRendering: Boolean,
    businessHours: identity,
    initialDate: identity,
    now: identity,
    eventDataTransform: identity,
    stickyHeaderDates: identity,
    stickyFooterScrollbar: identity,
    viewHeight: identity,
    defaultAllDay: Boolean,
    eventSourceFailure: identity,
    eventSourceSuccess: identity,
    eventDisplay: String,
    eventStartEditable: Boolean,
    eventDurationEditable: Boolean,
    eventOverlap: identity,
    eventConstraint: identity,
    eventAllow: identity,
    eventBackgroundColor: String,
    eventBorderColor: String,
    eventTextColor: String,
    eventColor: String,
    eventClassNames: identity,
    eventContent: identity,
    eventDidMount: identity,
    eventWillUnmount: identity,
    selectConstraint: identity,
    selectOverlap: identity,
    selectAllow: identity,
    droppable: Boolean,
    unselectCancel: String,
    slotLabelFormat: identity,
    slotLaneClassNames: identity,
    slotLaneContent: identity,
    slotLaneDidMount: identity,
    slotLaneWillUnmount: identity,
    slotLabelClassNames: identity,
    slotLabelContent: identity,
    slotLabelDidMount: identity,
    slotLabelWillUnmount: identity,
    dayMaxEvents: identity,
    dayMaxEventRows: identity,
    dayMinWidth: Number,
    slotLabelInterval: createDuration,
    allDayText: String,
    allDayClassNames: identity,
    allDayContent: identity,
    allDayDidMount: identity,
    allDayWillUnmount: identity,
    slotMinWidth: Number,
    navLinks: Boolean,
    eventTimeFormat: createFormatter,
    rerenderDelay: Number,
    moreLinkText: identity,
    moreLinkHint: identity,
    selectMinDistance: Number,
    selectable: Boolean,
    selectLongPressDelay: Number,
    eventLongPressDelay: Number,
    selectMirror: Boolean,
    eventMaxStack: Number,
    eventMinHeight: Number,
    eventMinWidth: Number,
    eventShortHeight: Number,
    slotEventOverlap: Boolean,
    plugins: identity,
    firstDay: Number,
    dayCount: Number,
    dateAlignment: String,
    dateIncrement: createDuration,
    hiddenDays: identity,
    monthMode: Boolean,
    fixedWeekCount: Boolean,
    validRange: identity,
    visibleRange: identity,
    titleFormat: identity,
    eventInteractive: Boolean,
    // only used by list-view, but languages define the value, so we need it in base options
    noEventsText: String,
    viewHint: identity,
    navLinkHint: identity,
    closeHint: String,
    timeHint: String,
    eventHint: String,
    moreLinkClick: identity,
    moreLinkClassNames: identity,
    moreLinkContent: identity,
    moreLinkDidMount: identity,
    moreLinkWillUnmount: identity
};
// do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.
// raw values.
var BASE_OPTION_DEFAULTS = {
    eventDisplay: 'auto',
    defaultRangeSeparator: ' - ',
    titleRangeSeparator: ' \u2013 ',
    defaultTimedEventDuration: '01:00:00',
    defaultAllDayEventDuration: {
        day: 1
    },
    forceEventDuration: false,
    nextDayThreshold: '00:00:00',
    dayHeaders: true,
    initialView: '',
    aspectRatio: 1.35,
    headerToolbar: {
        start: 'title',
        center: '',
        end: 'today prev,next'
    },
    weekends: true,
    weekNumbers: false,
    weekNumberCalculation: 'local',
    editable: false,
    nowIndicator: false,
    scrollTime: '06:00:00',
    scrollTimeReset: true,
    slotMinTime: '00:00:00',
    slotMaxTime: '24:00:00',
    showNonCurrentDates: true,
    lazyFetching: true,
    startParam: 'start',
    endParam: 'end',
    timeZoneParam: 'timeZone',
    timeZone: 'local',
    locales: [],
    locale: '',
    themeSystem: 'standard',
    dragRevertDuration: 500,
    dragScroll: true,
    allDayMaintainDuration: false,
    unselectAuto: true,
    dropAccept: '*',
    eventOrder: 'start,-duration,allDay,title',
    dayPopoverFormat: {
        month: 'long',
        day: 'numeric',
        year: 'numeric'
    },
    handleWindowResize: true,
    windowResizeDelay: 100,
    longPressDelay: 1000,
    eventDragMinDistance: 5,
    expandRows: false,
    navLinks: false,
    selectable: false,
    eventMinHeight: 15,
    eventMinWidth: 30,
    eventShortHeight: 30
};
// calendar listeners
// ------------------
var CALENDAR_LISTENER_REFINERS = {
    datesSet: identity,
    eventsSet: identity,
    eventAdd: identity,
    eventChange: identity,
    eventRemove: identity,
    windowResize: identity,
    eventClick: identity,
    eventMouseEnter: identity,
    eventMouseLeave: identity,
    select: identity,
    unselect: identity,
    loading: identity,
    // internal
    _unmount: identity,
    _beforeprint: identity,
    _afterprint: identity,
    _noEventDrop: identity,
    _noEventResize: identity,
    _resize: identity,
    _scrollRequest: identity
};
// calendar-specific options
// -------------------------
var CALENDAR_OPTION_REFINERS = {
    buttonText: identity,
    buttonHints: identity,
    views: identity,
    plugins: identity,
    initialEvents: identity,
    events: identity,
    eventSources: identity
};
var COMPLEX_OPTION_COMPARATORS = {
    headerToolbar: isBoolComplexEqual,
    footerToolbar: isBoolComplexEqual,
    buttonText: isBoolComplexEqual,
    buttonHints: isBoolComplexEqual,
    buttonIcons: isBoolComplexEqual
};
function isBoolComplexEqual(a, b) {
    if (typeof a === 'object' && typeof b === 'object' && a && b) return isPropsEqual(a, b);
    return a === b;
}
// view-specific options
// ---------------------
var VIEW_OPTION_REFINERS = {
    type: String,
    component: identity,
    buttonText: String,
    buttonTextKey: String,
    dateProfileGeneratorClass: identity,
    usesMinMaxTime: Boolean,
    classNames: identity,
    content: identity,
    didMount: identity,
    willUnmount: identity
};
// util funcs
// ----------------------------------------------------------------------------------------------------
function mergeRawOptions(optionSets) {
    return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);
}
function refineProps(input, refiners) {
    var refined = {};
    var extra = {};
    for(var propName in refiners)if (propName in input) refined[propName] = refiners[propName](input[propName]);
    for(var propName in input)if (!(propName in refiners)) extra[propName] = input[propName];
    return {
        refined: refined,
        extra: extra
    };
}
function identity(raw) {
    return raw;
}
function parseEvents(rawEvents, eventSource, context, allowOpenRange) {
    var eventStore = createEmptyEventStore();
    var eventRefiners = buildEventRefiners(context);
    for(var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++){
        var rawEvent = rawEvents_1[_i];
        var tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners);
        if (tuple) eventTupleToStore(tuple, eventStore);
    }
    return eventStore;
}
function eventTupleToStore(tuple, eventStore) {
    if (eventStore === void 0) eventStore = createEmptyEventStore();
    eventStore.defs[tuple.def.defId] = tuple.def;
    if (tuple.instance) eventStore.instances[tuple.instance.instanceId] = tuple.instance;
    return eventStore;
}
// retrieves events that have the same groupId as the instance specified by `instanceId`
// or they are the same as the instance.
// why might instanceId not be in the store? an event from another calendar?
function getRelevantEvents(eventStore, instanceId) {
    var instance = eventStore.instances[instanceId];
    if (instance) {
        var def_1 = eventStore.defs[instance.defId];
        // get events/instances with same group
        var newStore = filterEventStoreDefs(eventStore, function(lookDef) {
            return isEventDefsGrouped(def_1, lookDef);
        });
        // add the original
        // TODO: wish we could use eventTupleToStore or something like it
        newStore.defs[def_1.defId] = def_1;
        newStore.instances[instance.instanceId] = instance;
        return newStore;
    }
    return createEmptyEventStore();
}
function isEventDefsGrouped(def0, def1) {
    return Boolean(def0.groupId && def0.groupId === def1.groupId);
}
function createEmptyEventStore() {
    return {
        defs: {},
        instances: {}
    };
}
function mergeEventStores(store0, store1) {
    return {
        defs: _tslib.__assign(_tslib.__assign({}, store0.defs), store1.defs),
        instances: _tslib.__assign(_tslib.__assign({}, store0.instances), store1.instances)
    };
}
function filterEventStoreDefs(eventStore, filterFunc) {
    var defs = filterHash(eventStore.defs, filterFunc);
    var instances = filterHash(eventStore.instances, function(instance) {
        return defs[instance.defId] // still exists?
        ;
    });
    return {
        defs: defs,
        instances: instances
    };
}
function excludeSubEventStore(master, sub) {
    var defs = master.defs, instances = master.instances;
    var filteredDefs = {};
    var filteredInstances = {};
    for(var defId in defs)if (!sub.defs[defId]) filteredDefs[defId] = defs[defId];
    for(var instanceId in instances)if (!sub.instances[instanceId] && filteredDefs[instances[instanceId].defId] // def wasn't filtered away
    ) filteredInstances[instanceId] = instances[instanceId];
    return {
        defs: filteredDefs,
        instances: filteredInstances
    };
}
function normalizeConstraint(input, context) {
    if (Array.isArray(input)) return parseEvents(input, null, context, true); // allowOpenRange=true
    if (typeof input === 'object' && input) return parseEvents([
        input
    ], null, context, true); // allowOpenRange=true
    if (input != null) return String(input);
    return null;
}
function parseClassNames(raw) {
    if (Array.isArray(raw)) return raw;
    if (typeof raw === 'string') return raw.split(/\s+/);
    return [];
}
// TODO: better called "EventSettings" or "EventConfig"
// TODO: move this file into structs
// TODO: separate constraint/overlap/allow, because selection uses only that, not other props
var EVENT_UI_REFINERS = {
    display: String,
    editable: Boolean,
    startEditable: Boolean,
    durationEditable: Boolean,
    constraint: identity,
    overlap: identity,
    allow: identity,
    className: parseClassNames,
    classNames: parseClassNames,
    color: String,
    backgroundColor: String,
    borderColor: String,
    textColor: String
};
var EMPTY_EVENT_UI = {
    display: null,
    startEditable: null,
    durationEditable: null,
    constraints: [],
    overlap: null,
    allows: [],
    backgroundColor: '',
    borderColor: '',
    textColor: '',
    classNames: []
};
function createEventUi(refined, context) {
    var constraint = normalizeConstraint(refined.constraint, context);
    return {
        display: refined.display || null,
        startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,
        durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,
        constraints: constraint != null ? [
            constraint
        ] : [],
        overlap: refined.overlap != null ? refined.overlap : null,
        allows: refined.allow != null ? [
            refined.allow
        ] : [],
        backgroundColor: refined.backgroundColor || refined.color || '',
        borderColor: refined.borderColor || refined.color || '',
        textColor: refined.textColor || '',
        classNames: (refined.className || []).concat(refined.classNames || [])
    };
}
// TODO: prevent against problems with <2 args!
function combineEventUis(uis) {
    return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);
}
function combineTwoEventUis(item0, item1) {
    return {
        display: item1.display != null ? item1.display : item0.display,
        startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,
        durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,
        constraints: item0.constraints.concat(item1.constraints),
        overlap: typeof item1.overlap === 'boolean' ? item1.overlap : item0.overlap,
        allows: item0.allows.concat(item1.allows),
        backgroundColor: item1.backgroundColor || item0.backgroundColor,
        borderColor: item1.borderColor || item0.borderColor,
        textColor: item1.textColor || item0.textColor,
        classNames: item0.classNames.concat(item1.classNames)
    };
}
var EVENT_NON_DATE_REFINERS = {
    id: String,
    groupId: String,
    title: String,
    url: String,
    interactive: Boolean
};
var EVENT_DATE_REFINERS = {
    start: identity,
    end: identity,
    date: identity,
    allDay: Boolean
};
var EVENT_REFINERS = _tslib.__assign(_tslib.__assign(_tslib.__assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), {
    extendedProps: identity
});
function parseEvent(raw, eventSource, context, allowOpenRange, refiners) {
    if (refiners === void 0) refiners = buildEventRefiners(context);
    var _a = refineEventDef(raw, context, refiners), refined = _a.refined, extra = _a.extra;
    var defaultAllDay = computeIsDefaultAllDay(eventSource, context);
    var recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);
    if (recurringRes) {
        var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', recurringRes.allDay, Boolean(recurringRes.duration), context);
        def.recurringDef = {
            typeId: recurringRes.typeId,
            typeData: recurringRes.typeData,
            duration: recurringRes.duration
        };
        return {
            def: def,
            instance: null
        };
    }
    var singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);
    if (singleRes) {
        var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', singleRes.allDay, singleRes.hasEnd, context);
        var instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);
        return {
            def: def,
            instance: instance
        };
    }
    return null;
}
function refineEventDef(raw, context, refiners) {
    if (refiners === void 0) refiners = buildEventRefiners(context);
    return refineProps(raw, refiners);
}
function buildEventRefiners(context) {
    return _tslib.__assign(_tslib.__assign(_tslib.__assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);
}
/*
Will NOT populate extendedProps with the leftover properties.
Will NOT populate date-related props.
*/ function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context) {
    var def = {
        title: refined.title || '',
        groupId: refined.groupId || '',
        publicId: refined.id || '',
        url: refined.url || '',
        recurringDef: null,
        defId: guid(),
        sourceId: sourceId,
        allDay: allDay,
        hasEnd: hasEnd,
        interactive: refined.interactive,
        ui: createEventUi(refined, context),
        extendedProps: _tslib.__assign(_tslib.__assign({}, refined.extendedProps || {}), extra)
    };
    for(var _i = 0, _a = context.pluginHooks.eventDefMemberAdders; _i < _a.length; _i++){
        var memberAdder = _a[_i];
        _tslib.__assign(def, memberAdder(refined));
    }
    // help out EventApi from having user modify props
    Object.freeze(def.ui.classNames);
    Object.freeze(def.extendedProps);
    return def;
}
function parseSingle(refined, defaultAllDay, context, allowOpenRange) {
    var allDay = refined.allDay;
    var startMeta;
    var startMarker = null;
    var hasEnd = false;
    var endMeta;
    var endMarker = null;
    var startInput = refined.start != null ? refined.start : refined.date;
    startMeta = context.dateEnv.createMarkerMeta(startInput);
    if (startMeta) startMarker = startMeta.marker;
    else if (!allowOpenRange) return null;
    if (refined.end != null) endMeta = context.dateEnv.createMarkerMeta(refined.end);
    if (allDay == null) {
        if (defaultAllDay != null) allDay = defaultAllDay;
        else // fall back to the date props LAST
        allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);
    }
    if (allDay && startMarker) startMarker = startOfDay(startMarker);
    if (endMeta) {
        endMarker = endMeta.marker;
        if (allDay) endMarker = startOfDay(endMarker);
        if (startMarker && endMarker <= startMarker) endMarker = null;
    }
    if (endMarker) hasEnd = true;
    else if (!allowOpenRange) {
        hasEnd = context.options.forceEventDuration || false;
        endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);
    }
    return {
        allDay: allDay,
        hasEnd: hasEnd,
        range: {
            start: startMarker,
            end: endMarker
        },
        forcedStartTzo: startMeta ? startMeta.forcedTzo : null,
        forcedEndTzo: endMeta ? endMeta.forcedTzo : null
    };
}
function computeIsDefaultAllDay(eventSource, context) {
    var res = null;
    if (eventSource) res = eventSource.defaultAllDay;
    if (res == null) res = context.options.defaultAllDay;
    return res;
}
/* Date stuff that doesn't belong in datelib core
----------------------------------------------------------------------------------------------------------------------*/ // given a timed range, computes an all-day range that has the same exact duration,
// but whose start time is aligned with the start of the day.
function computeAlignedDayRange(timedRange) {
    var dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;
    var start = startOfDay(timedRange.start);
    var end = addDays(start, dayCnt);
    return {
        start: start,
        end: end
    };
}
// given a timed range, computes an all-day range based on how for the end date bleeds into the next day
// TODO: give nextDayThreshold a default arg
function computeVisibleDayRange(timedRange, nextDayThreshold) {
    if (nextDayThreshold === void 0) nextDayThreshold = createDuration(0);
    var startDay = null;
    var endDay = null;
    if (timedRange.end) {
        endDay = startOfDay(timedRange.end);
        var endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`
        // If the end time is actually inclusively part of the next day and is equal to or
        // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
        // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
        if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) endDay = addDays(endDay, 1);
    }
    if (timedRange.start) {
        startDay = startOfDay(timedRange.start); // the beginning of the day the range starts
        // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.
        if (endDay && endDay <= startDay) endDay = addDays(startDay, 1);
    }
    return {
        start: startDay,
        end: endDay
    };
}
// spans from one day into another?
function isMultiDayRange(range) {
    var visibleRange = computeVisibleDayRange(range);
    return diffDays(visibleRange.start, visibleRange.end) > 1;
}
function diffDates(date0, date1, dateEnv, largeUnit) {
    if (largeUnit === 'year') return createDuration(dateEnv.diffWholeYears(date0, date1), 'year');
    if (largeUnit === 'month') return createDuration(dateEnv.diffWholeMonths(date0, date1), 'month');
    return diffDayAndTime(date0, date1); // returns a duration
}
function parseRange(input, dateEnv) {
    var start = null;
    var end = null;
    if (input.start) start = dateEnv.createMarker(input.start);
    if (input.end) end = dateEnv.createMarker(input.end);
    if (!start && !end) return null;
    if (start && end && end < start) return null;
    return {
        start: start,
        end: end
    };
}
// SIDE-EFFECT: will mutate ranges.
// Will return a new array result.
function invertRanges(ranges, constraintRange) {
    var invertedRanges = [];
    var start = constraintRange.start; // the end of the previous range. the start of the new range
    var i;
    var dateRange;
    // ranges need to be in order. required for our date-walking algorithm
    ranges.sort(compareRanges);
    for(i = 0; i < ranges.length; i += 1){
        dateRange = ranges[i];
        // add the span of time before the event (if there is any)
        if (dateRange.start > start) invertedRanges.push({
            start: start,
            end: dateRange.start
        });
        if (dateRange.end > start) start = dateRange.end;
    }
    // add the span of time after the last event (if there is any)
    if (start < constraintRange.end) invertedRanges.push({
        start: start,
        end: constraintRange.end
    });
    return invertedRanges;
}
function compareRanges(range0, range1) {
    return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first
}
function intersectRanges(range0, range1) {
    var start = range0.start, end = range0.end;
    var newRange = null;
    if (range1.start !== null) {
        if (start === null) start = range1.start;
        else start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));
    }
    if (range1.end != null) {
        if (end === null) end = range1.end;
        else end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));
    }
    if (start === null || end === null || start < end) newRange = {
        start: start,
        end: end
    };
    return newRange;
}
function rangesEqual(range0, range1) {
    return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());
}
function rangesIntersect(range0, range1) {
    return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);
}
function rangeContainsRange(outerRange, innerRange) {
    return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);
}
function rangeContainsMarker(range, date) {
    return (range.start === null || date >= range.start) && (range.end === null || date < range.end);
}
// If the given date is not within the given range, move it inside.
// (If it's past the end, make it one millisecond before the end).
function constrainMarkerToRange(date, range) {
    if (range.start != null && date < range.start) return range.start;
    if (range.end != null && date >= range.end) return new Date(range.end.valueOf() - 1);
    return date;
}
/*
Specifying nextDayThreshold signals that all-day ranges should be sliced.
*/ function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {
    var inverseBgByGroupId = {};
    var inverseBgByDefId = {};
    var defByGroupId = {};
    var bgRanges = [];
    var fgRanges = [];
    var eventUis = compileEventUis(eventStore.defs, eventUiBases);
    for(var defId in eventStore.defs){
        var def = eventStore.defs[defId];
        var ui = eventUis[def.defId];
        if (ui.display === 'inverse-background') {
            if (def.groupId) {
                inverseBgByGroupId[def.groupId] = [];
                if (!defByGroupId[def.groupId]) defByGroupId[def.groupId] = def;
            } else inverseBgByDefId[defId] = [];
        }
    }
    for(var instanceId in eventStore.instances){
        var instance = eventStore.instances[instanceId];
        var def = eventStore.defs[instance.defId];
        var ui = eventUis[def.defId];
        var origRange = instance.range;
        var normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;
        var slicedRange = intersectRanges(normalRange, framingRange);
        if (slicedRange) {
            if (ui.display === 'inverse-background') {
                if (def.groupId) inverseBgByGroupId[def.groupId].push(slicedRange);
                else inverseBgByDefId[instance.defId].push(slicedRange);
            } else if (ui.display !== 'none') (ui.display === 'background' ? bgRanges : fgRanges).push({
                def: def,
                ui: ui,
                instance: instance,
                range: slicedRange,
                isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),
                isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()
            });
        }
    }
    for(var groupId in inverseBgByGroupId){
        var ranges = inverseBgByGroupId[groupId];
        var invertedRanges = invertRanges(ranges, framingRange);
        for(var _i = 0, invertedRanges_1 = invertedRanges; _i < invertedRanges_1.length; _i++){
            var invertedRange = invertedRanges_1[_i];
            var def = defByGroupId[groupId];
            var ui = eventUis[def.defId];
            bgRanges.push({
                def: def,
                ui: ui,
                instance: null,
                range: invertedRange,
                isStart: false,
                isEnd: false
            });
        }
    }
    for(var defId in inverseBgByDefId){
        var ranges = inverseBgByDefId[defId];
        var invertedRanges = invertRanges(ranges, framingRange);
        for(var _a = 0, invertedRanges_2 = invertedRanges; _a < invertedRanges_2.length; _a++){
            var invertedRange = invertedRanges_2[_a];
            bgRanges.push({
                def: eventStore.defs[defId],
                ui: eventUis[defId],
                instance: null,
                range: invertedRange,
                isStart: false,
                isEnd: false
            });
        }
    }
    return {
        bg: bgRanges,
        fg: fgRanges
    };
}
function hasBgRendering(def) {
    return def.ui.display === 'background' || def.ui.display === 'inverse-background';
}
function setElSeg(el, seg) {
    el.fcSeg = seg;
}
function getElSeg(el) {
    return el.fcSeg || el.parentNode.fcSeg || null;
}
// event ui computation
function compileEventUis(eventDefs, eventUiBases) {
    return mapHash(eventDefs, function(eventDef) {
        return compileEventUi(eventDef, eventUiBases);
    });
}
function compileEventUi(eventDef, eventUiBases) {
    var uis = [];
    if (eventUiBases['']) uis.push(eventUiBases['']);
    if (eventUiBases[eventDef.defId]) uis.push(eventUiBases[eventDef.defId]);
    uis.push(eventDef.ui);
    return combineEventUis(uis);
}
function sortEventSegs(segs, eventOrderSpecs) {
    var objs = segs.map(buildSegCompareObj);
    objs.sort(function(obj0, obj1) {
        return compareByFieldSpecs(obj0, obj1, eventOrderSpecs);
    });
    return objs.map(function(c) {
        return c._seg;
    });
}
// returns a object with all primitive props that can be compared
function buildSegCompareObj(seg) {
    var eventRange = seg.eventRange;
    var eventDef = eventRange.def;
    var range = eventRange.instance ? eventRange.instance.range : eventRange.range;
    var start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events
    var end = range.end ? range.end.valueOf() : 0; // "
    return _tslib.__assign(_tslib.__assign(_tslib.__assign({}, eventDef.extendedProps), eventDef), {
        id: eventDef.publicId,
        start: start,
        end: end,
        duration: end - start,
        allDay: Number(eventDef.allDay),
        _seg: seg
    });
}
function computeSegDraggable(seg, context) {
    var pluginHooks = context.pluginHooks;
    var transformers = pluginHooks.isDraggableTransformers;
    var _a = seg.eventRange, def = _a.def, ui = _a.ui;
    var val = ui.startEditable;
    for(var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++){
        var transformer = transformers_1[_i];
        val = transformer(val, def, ui, context);
    }
    return val;
}
function computeSegStartResizable(seg, context) {
    return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;
}
function computeSegEndResizable(seg, context) {
    return seg.isEnd && seg.eventRange.ui.durationEditable;
}
function buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, defaultDisplayEventEnd, startOverride, endOverride) {
    var dateEnv = context.dateEnv, options = context.options;
    var displayEventTime = options.displayEventTime, displayEventEnd = options.displayEventEnd;
    var eventDef = seg.eventRange.def;
    var eventInstance = seg.eventRange.instance;
    if (displayEventTime == null) displayEventTime = defaultDisplayEventTime !== false;
    if (displayEventEnd == null) displayEventEnd = defaultDisplayEventEnd !== false;
    var wholeEventStart = eventInstance.range.start;
    var wholeEventEnd = eventInstance.range.end;
    var segStart = startOverride || seg.start || seg.eventRange.range.start;
    var segEnd = endOverride || seg.end || seg.eventRange.range.end;
    var isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();
    var isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();
    if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {
        segStart = isStartDay ? wholeEventStart : segStart;
        segEnd = isEndDay ? wholeEventEnd : segEnd;
        if (displayEventEnd && eventDef.hasEnd) return dateEnv.formatRange(segStart, segEnd, timeFormat, {
            forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,
            forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo
        });
        return dateEnv.format(segStart, timeFormat, {
            forcedTzo: startOverride ? null : eventInstance.forcedStartTzo
        });
    }
    return '';
}
function getSegMeta(seg, todayRange, nowDate) {
    var segRange = seg.eventRange.range;
    return {
        isPast: segRange.end < (nowDate || todayRange.start),
        isFuture: segRange.start >= (nowDate || todayRange.end),
        isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)
    };
}
function getEventClassNames(props) {
    var classNames = [
        'fc-event'
    ];
    if (props.isMirror) classNames.push('fc-event-mirror');
    if (props.isDraggable) classNames.push('fc-event-draggable');
    if (props.isStartResizable || props.isEndResizable) classNames.push('fc-event-resizable');
    if (props.isDragging) classNames.push('fc-event-dragging');
    if (props.isResizing) classNames.push('fc-event-resizing');
    if (props.isSelected) classNames.push('fc-event-selected');
    if (props.isStart) classNames.push('fc-event-start');
    if (props.isEnd) classNames.push('fc-event-end');
    if (props.isPast) classNames.push('fc-event-past');
    if (props.isToday) classNames.push('fc-event-today');
    if (props.isFuture) classNames.push('fc-event-future');
    return classNames;
}
function buildEventRangeKey(eventRange) {
    return eventRange.instance ? eventRange.instance.instanceId : eventRange.def.defId + ":" + eventRange.range.start.toISOString();
// inverse-background events don't have specific instances. TODO: better solution
}
function getSegAnchorAttrs(seg, context) {
    var _a = seg.eventRange, def = _a.def, instance = _a.instance;
    var url = def.url;
    if (url) return {
        href: url
    };
    var emitter = context.emitter, options = context.options;
    var eventInteractive = options.eventInteractive;
    if (eventInteractive == null) {
        eventInteractive = def.interactive;
        if (eventInteractive == null) eventInteractive = Boolean(emitter.hasHandlers('eventClick'));
    }
    // mock what happens in EventClicking
    if (eventInteractive) // only attach keyboard-related handlers because click handler is already done in EventClicking
    return createAriaKeyboardAttrs(function(ev) {
        emitter.trigger('eventClick', {
            el: ev.target,
            event: new EventApi(context, def, instance),
            jsEvent: ev,
            view: context.viewApi
        });
    });
    return {};
}
var STANDARD_PROPS = {
    start: identity,
    end: identity,
    allDay: Boolean
};
function parseDateSpan(raw, dateEnv, defaultDuration) {
    var span = parseOpenDateSpan(raw, dateEnv);
    var range = span.range;
    if (!range.start) return null;
    if (!range.end) {
        if (defaultDuration == null) return null;
        range.end = dateEnv.add(range.start, defaultDuration);
    }
    return span;
}
/*
TODO: somehow combine with parseRange?
Will return null if the start/end props were present but parsed invalidly.
*/ function parseOpenDateSpan(raw, dateEnv) {
    var _a = refineProps(raw, STANDARD_PROPS), standardProps = _a.refined, extra = _a.extra;
    var startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;
    var endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;
    var allDay = standardProps.allDay;
    if (allDay == null) allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);
    return _tslib.__assign({
        range: {
            start: startMeta ? startMeta.marker : null,
            end: endMeta ? endMeta.marker : null
        },
        allDay: allDay
    }, extra);
}
function isDateSpansEqual(span0, span1) {
    return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);
}
// the NON-DATE-RELATED props
function isSpanPropsEqual(span0, span1) {
    for(var propName in span1)if (propName !== 'range' && propName !== 'allDay') {
        if (span0[propName] !== span1[propName]) return false;
    }
    // are there any props that span0 has that span1 DOESN'T have?
    // both have range/allDay, so no need to special-case.
    for(var propName in span0){
        if (!(propName in span1)) return false;
    }
    return true;
}
function buildDateSpanApi(span, dateEnv) {
    return _tslib.__assign(_tslib.__assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), {
        allDay: span.allDay
    });
}
function buildRangeApiWithTimeZone(range, dateEnv, omitTime) {
    return _tslib.__assign(_tslib.__assign({}, buildRangeApi(range, dateEnv, omitTime)), {
        timeZone: dateEnv.timeZone
    });
}
function buildRangeApi(range, dateEnv, omitTime) {
    return {
        start: dateEnv.toDate(range.start),
        end: dateEnv.toDate(range.end),
        startStr: dateEnv.formatIso(range.start, {
            omitTime: omitTime
        }),
        endStr: dateEnv.formatIso(range.end, {
            omitTime: omitTime
        })
    };
}
function fabricateEventRange(dateSpan, eventUiBases, context) {
    var res = refineEventDef({
        editable: false
    }, context);
    var def = parseEventDef(res.refined, res.extra, '', dateSpan.allDay, true, context);
    return {
        def: def,
        ui: compileEventUi(def, eventUiBases),
        instance: createEventInstance(def.defId, dateSpan.range),
        range: dateSpan.range,
        isStart: true,
        isEnd: true
    };
}
function triggerDateSelect(selection, pev, context) {
    context.emitter.trigger('select', _tslib.__assign(_tslib.__assign({}, buildDateSpanApiWithContext(selection, context)), {
        jsEvent: pev ? pev.origEvent : null,
        view: context.viewApi || context.calendarApi.view
    }));
}
function triggerDateUnselect(pev, context) {
    context.emitter.trigger('unselect', {
        jsEvent: pev ? pev.origEvent : null,
        view: context.viewApi || context.calendarApi.view
    });
}
function buildDateSpanApiWithContext(dateSpan, context) {
    var props = {};
    for(var _i = 0, _a = context.pluginHooks.dateSpanTransforms; _i < _a.length; _i++){
        var transform = _a[_i];
        _tslib.__assign(props, transform(dateSpan, context));
    }
    _tslib.__assign(props, buildDateSpanApi(dateSpan, context.dateEnv));
    return props;
}
// Given an event's allDay status and start date, return what its fallback end date should be.
// TODO: rename to computeDefaultEventEnd
function getDefaultEventEnd(allDay, marker, context) {
    var dateEnv = context.dateEnv, options = context.options;
    var end = marker;
    if (allDay) {
        end = startOfDay(end);
        end = dateEnv.add(end, options.defaultAllDayEventDuration);
    } else end = dateEnv.add(end, options.defaultTimedEventDuration);
    return end;
}
// applies the mutation to ALL defs/instances within the event store
function applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {
    var eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);
    var dest = createEmptyEventStore();
    for(var defId in eventStore.defs){
        var def = eventStore.defs[defId];
        dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);
    }
    for(var instanceId in eventStore.instances){
        var instance = eventStore.instances[instanceId];
        var def = dest.defs[instance.defId]; // important to grab the newly modified def
        dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);
    }
    return dest;
}
function applyMutationToEventDef(eventDef, eventConfig, mutation, context) {
    var standardProps = mutation.standardProps || {};
    // if hasEnd has not been specified, guess a good value based on deltas.
    // if duration will change, there's no way the default duration will persist,
    // and thus, we need to mark the event as having a real end
    if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) standardProps.hasEnd = true; // TODO: is this mutation okay?
    var copy = _tslib.__assign(_tslib.__assign(_tslib.__assign({}, eventDef), standardProps), {
        ui: _tslib.__assign(_tslib.__assign({}, eventDef.ui), standardProps.ui)
    });
    if (mutation.extendedProps) copy.extendedProps = _tslib.__assign(_tslib.__assign({}, copy.extendedProps), mutation.extendedProps);
    for(var _i = 0, _a = context.pluginHooks.eventDefMutationAppliers; _i < _a.length; _i++){
        var applier = _a[_i];
        applier(copy, mutation, context);
    }
    if (!copy.hasEnd && context.options.forceEventDuration) copy.hasEnd = true;
    return copy;
}
function applyMutationToEventInstance(eventInstance, eventDef, eventConfig, mutation, context) {
    var dateEnv = context.dateEnv;
    var forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;
    var clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;
    var copy = _tslib.__assign({}, eventInstance);
    if (forceAllDay) copy.range = computeAlignedDayRange(copy.range);
    if (mutation.datesDelta && eventConfig.startEditable) copy.range = {
        start: dateEnv.add(copy.range.start, mutation.datesDelta),
        end: dateEnv.add(copy.range.end, mutation.datesDelta)
    };
    if (mutation.startDelta && eventConfig.durationEditable) copy.range = {
        start: dateEnv.add(copy.range.start, mutation.startDelta),
        end: copy.range.end
    };
    if (mutation.endDelta && eventConfig.durationEditable) copy.range = {
        start: copy.range.start,
        end: dateEnv.add(copy.range.end, mutation.endDelta)
    };
    if (clearEnd) copy.range = {
        start: copy.range.start,
        end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)
    };
    // in case event was all-day but the supplied deltas were not
    // better util for this?
    if (eventDef.allDay) copy.range = {
        start: startOfDay(copy.range.start),
        end: startOfDay(copy.range.end)
    };
    // handle invalid durations
    if (copy.range.end < copy.range.start) copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);
    return copy;
}
// no public types yet. when there are, export from:
// import {} from './api-type-deps'
var ViewApi = /** @class */ function() {
    function ViewApi1(type, getCurrentData, dateEnv) {
        this.type = type;
        this.getCurrentData = getCurrentData;
        this.dateEnv = dateEnv;
    }
    Object.defineProperty(ViewApi1.prototype, "calendar", {
        get: function() {
            return this.getCurrentData().calendarApi;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ViewApi1.prototype, "title", {
        get: function() {
            return this.getCurrentData().viewTitle;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ViewApi1.prototype, "activeStart", {
        get: function() {
            return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ViewApi1.prototype, "activeEnd", {
        get: function() {
            return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ViewApi1.prototype, "currentStart", {
        get: function() {
            return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ViewApi1.prototype, "currentEnd", {
        get: function() {
            return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);
        },
        enumerable: false,
        configurable: true
    });
    ViewApi1.prototype.getOption = function(name) {
        return this.getCurrentData().options[name]; // are the view-specific options
    };
    return ViewApi1;
}();
var EVENT_SOURCE_REFINERS = {
    id: String,
    defaultAllDay: Boolean,
    url: String,
    format: String,
    events: identity,
    eventDataTransform: identity,
    // for any network-related sources
    success: identity,
    failure: identity
};
function parseEventSource(raw, context, refiners) {
    if (refiners === void 0) refiners = buildEventSourceRefiners(context);
    var rawObj;
    if (typeof raw === 'string') rawObj = {
        url: raw
    };
    else if (typeof raw === 'function' || Array.isArray(raw)) rawObj = {
        events: raw
    };
    else if (typeof raw === 'object' && raw) rawObj = raw;
    if (rawObj) {
        var _a = refineProps(rawObj, refiners), refined = _a.refined, extra = _a.extra;
        var metaRes = buildEventSourceMeta(refined, context);
        if (metaRes) return {
            _raw: raw,
            isFetching: false,
            latestFetchId: '',
            fetchRange: null,
            defaultAllDay: refined.defaultAllDay,
            eventDataTransform: refined.eventDataTransform,
            success: refined.success,
            failure: refined.failure,
            publicId: refined.id || '',
            sourceId: guid(),
            sourceDefId: metaRes.sourceDefId,
            meta: metaRes.meta,
            ui: createEventUi(refined, context),
            extendedProps: extra
        };
    }
    return null;
}
function buildEventSourceRefiners(context) {
    return _tslib.__assign(_tslib.__assign(_tslib.__assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);
}
function buildEventSourceMeta(raw, context) {
    var defs = context.pluginHooks.eventSourceDefs;
    for(var i = defs.length - 1; i >= 0; i -= 1){
        var def = defs[i];
        var meta = def.parseMeta(raw);
        if (meta) return {
            sourceDefId: i,
            meta: meta
        };
    }
    return null;
}
function reduceCurrentDate(currentDate, action) {
    switch(action.type){
        case 'CHANGE_DATE':
            return action.dateMarker;
        default:
            return currentDate;
    }
}
function getInitialDate(options, dateEnv) {
    var initialDateInput = options.initialDate;
    // compute the initial ambig-timezone date
    if (initialDateInput != null) return dateEnv.createMarker(initialDateInput);
    return getNow(options.now, dateEnv); // getNow already returns unzoned
}
function getNow(nowInput, dateEnv) {
    if (typeof nowInput === 'function') nowInput = nowInput();
    if (nowInput == null) return dateEnv.createNowMarker();
    return dateEnv.createMarker(nowInput);
}
var CalendarApi = /** @class */ function() {
    function CalendarApi1() {}
    CalendarApi1.prototype.getCurrentData = function() {
        return this.currentDataManager.getCurrentData();
    };
    CalendarApi1.prototype.dispatch = function(action) {
        return this.currentDataManager.dispatch(action);
    };
    Object.defineProperty(CalendarApi1.prototype, "view", {
        get: function() {
            return this.getCurrentData().viewApi;
        } // for public API
        ,
        enumerable: false,
        configurable: true
    });
    CalendarApi1.prototype.batchRendering = function(callback) {
        callback();
    };
    CalendarApi1.prototype.updateSize = function() {
        this.trigger('_resize', true);
    };
    // Options
    // -----------------------------------------------------------------------------------------------------------------
    CalendarApi1.prototype.setOption = function(name, val) {
        this.dispatch({
            type: 'SET_OPTION',
            optionName: name,
            rawOptionValue: val
        });
    };
    CalendarApi1.prototype.getOption = function(name) {
        return this.currentDataManager.currentCalendarOptionsInput[name];
    };
    CalendarApi1.prototype.getAvailableLocaleCodes = function() {
        return Object.keys(this.getCurrentData().availableRawLocales);
    };
    // Trigger
    // -----------------------------------------------------------------------------------------------------------------
    CalendarApi1.prototype.on = function(handlerName, handler) {
        var currentDataManager = this.currentDataManager;
        if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) currentDataManager.emitter.on(handlerName, handler);
        else console.warn("Unknown listener name '" + handlerName + "'");
    };
    CalendarApi1.prototype.off = function(handlerName, handler) {
        this.currentDataManager.emitter.off(handlerName, handler);
    };
    // not meant for public use
    CalendarApi1.prototype.trigger = function(handlerName) {
        var _a;
        var args = [];
        for(var _i = 1; _i < arguments.length; _i++)args[_i - 1] = arguments[_i];
        (_a = this.currentDataManager.emitter).trigger.apply(_a, _tslib.__spreadArray([
            handlerName
        ], args));
    };
    // View
    // -----------------------------------------------------------------------------------------------------------------
    CalendarApi1.prototype.changeView = function(viewType, dateOrRange) {
        var _this = this;
        this.batchRendering(function() {
            _this.unselect();
            if (dateOrRange) {
                if (dateOrRange.start && dateOrRange.end) {
                    _this.dispatch({
                        type: 'CHANGE_VIEW_TYPE',
                        viewType: viewType
                    });
                    _this.dispatch({
                        type: 'SET_OPTION',
                        optionName: 'visibleRange',
                        rawOptionValue: dateOrRange
                    });
                } else {
                    var dateEnv = _this.getCurrentData().dateEnv;
                    _this.dispatch({
                        type: 'CHANGE_VIEW_TYPE',
                        viewType: viewType,
                        dateMarker: dateEnv.createMarker(dateOrRange)
                    });
                }
            } else _this.dispatch({
                type: 'CHANGE_VIEW_TYPE',
                viewType: viewType
            });
        });
    };
    // Forces navigation to a view for the given date.
    // `viewType` can be a specific view name or a generic one like "week" or "day".
    // needs to change
    CalendarApi1.prototype.zoomTo = function(dateMarker, viewType) {
        var state = this.getCurrentData();
        var spec;
        viewType = viewType || 'day'; // day is default zoom
        spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);
        this.unselect();
        if (spec) this.dispatch({
            type: 'CHANGE_VIEW_TYPE',
            viewType: spec.type,
            dateMarker: dateMarker
        });
        else this.dispatch({
            type: 'CHANGE_DATE',
            dateMarker: dateMarker
        });
    };
    // Given a duration singular unit, like "week" or "day", finds a matching view spec.
    // Preference is given to views that have corresponding buttons.
    CalendarApi1.prototype.getUnitViewSpec = function(unit) {
        var _a = this.getCurrentData(), viewSpecs = _a.viewSpecs, toolbarConfig = _a.toolbarConfig;
        var viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);
        var i;
        var spec;
        for(var viewType in viewSpecs)viewTypes.push(viewType);
        for(i = 0; i < viewTypes.length; i += 1){
            spec = viewSpecs[viewTypes[i]];
            if (spec) {
                if (spec.singleUnit === unit) return spec;
            }
        }
        return null;
    };
    // Current Date
    // -----------------------------------------------------------------------------------------------------------------
    CalendarApi1.prototype.prev = function() {
        this.unselect();
        this.dispatch({
            type: 'PREV'
        });
    };
    CalendarApi1.prototype.next = function() {
        this.unselect();
        this.dispatch({
            type: 'NEXT'
        });
    };
    CalendarApi1.prototype.prevYear = function() {
        var state = this.getCurrentData();
        this.unselect();
        this.dispatch({
            type: 'CHANGE_DATE',
            dateMarker: state.dateEnv.addYears(state.currentDate, -1)
        });
    };
    CalendarApi1.prototype.nextYear = function() {
        var state = this.getCurrentData();
        this.unselect();
        this.dispatch({
            type: 'CHANGE_DATE',
            dateMarker: state.dateEnv.addYears(state.currentDate, 1)
        });
    };
    CalendarApi1.prototype.today = function() {
        var state = this.getCurrentData();
        this.unselect();
        this.dispatch({
            type: 'CHANGE_DATE',
            dateMarker: getNow(state.calendarOptions.now, state.dateEnv)
        });
    };
    CalendarApi1.prototype.gotoDate = function(zonedDateInput) {
        var state = this.getCurrentData();
        this.unselect();
        this.dispatch({
            type: 'CHANGE_DATE',
            dateMarker: state.dateEnv.createMarker(zonedDateInput)
        });
    };
    CalendarApi1.prototype.incrementDate = function(deltaInput) {
        var state = this.getCurrentData();
        var delta = createDuration(deltaInput);
        if (delta) {
            this.unselect();
            this.dispatch({
                type: 'CHANGE_DATE',
                dateMarker: state.dateEnv.add(state.currentDate, delta)
            });
        }
    };
    // for external API
    CalendarApi1.prototype.getDate = function() {
        var state = this.getCurrentData();
        return state.dateEnv.toDate(state.currentDate);
    };
    // Date Formatting Utils
    // -----------------------------------------------------------------------------------------------------------------
    CalendarApi1.prototype.formatDate = function(d, formatter) {
        var dateEnv = this.getCurrentData().dateEnv;
        return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));
    };
    // `settings` is for formatter AND isEndExclusive
    CalendarApi1.prototype.formatRange = function(d0, d1, settings) {
        var dateEnv = this.getCurrentData().dateEnv;
        return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);
    };
    CalendarApi1.prototype.formatIso = function(d, omitTime) {
        var dateEnv = this.getCurrentData().dateEnv;
        return dateEnv.formatIso(dateEnv.createMarker(d), {
            omitTime: omitTime
        });
    };
    // Date Selection / Event Selection / DayClick
    // -----------------------------------------------------------------------------------------------------------------
    // this public method receives start/end dates in any format, with any timezone
    // NOTE: args were changed from v3
    CalendarApi1.prototype.select = function(dateOrObj, endDate) {
        var selectionInput;
        if (endDate == null) {
            if (dateOrObj.start != null) selectionInput = dateOrObj;
            else selectionInput = {
                start: dateOrObj,
                end: null
            };
        } else selectionInput = {
            start: dateOrObj,
            end: endDate
        };
        var state = this.getCurrentData();
        var selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({
            days: 1
        }));
        if (selection) {
            this.dispatch({
                type: 'SELECT_DATES',
                selection: selection
            });
            triggerDateSelect(selection, null, state);
        }
    };
    // public method
    CalendarApi1.prototype.unselect = function(pev) {
        var state = this.getCurrentData();
        if (state.dateSelection) {
            this.dispatch({
                type: 'UNSELECT_DATES'
            });
            triggerDateUnselect(pev, state);
        }
    };
    // Public Events API
    // -----------------------------------------------------------------------------------------------------------------
    CalendarApi1.prototype.addEvent = function(eventInput, sourceInput) {
        if (eventInput instanceof EventApi) {
            var def = eventInput._def;
            var instance = eventInput._instance;
            var currentData = this.getCurrentData();
            // not already present? don't want to add an old snapshot
            if (!currentData.eventStore.defs[def.defId]) {
                this.dispatch({
                    type: 'ADD_EVENTS',
                    eventStore: eventTupleToStore({
                        def: def,
                        instance: instance
                    })
                });
                this.triggerEventAdd(eventInput);
            }
            return eventInput;
        }
        var state = this.getCurrentData();
        var eventSource;
        if (sourceInput instanceof EventSourceApi) eventSource = sourceInput.internalEventSource;
        else if (typeof sourceInput === 'boolean') {
            if (sourceInput) eventSource = hashValuesToArray(state.eventSources)[0];
        } else if (sourceInput != null) {
            var sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function
            if (!sourceApi) {
                console.warn("Could not find an event source with ID \"" + sourceInput + "\""); // TODO: test
                return null;
            }
            eventSource = sourceApi.internalEventSource;
        }
        var tuple = parseEvent(eventInput, eventSource, state, false);
        if (tuple) {
            var newEventApi = new EventApi(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);
            this.dispatch({
                type: 'ADD_EVENTS',
                eventStore: eventTupleToStore(tuple)
            });
            this.triggerEventAdd(newEventApi);
            return newEventApi;
        }
        return null;
    };
    CalendarApi1.prototype.triggerEventAdd = function(eventApi) {
        var _this = this;
        var emitter = this.getCurrentData().emitter;
        emitter.trigger('eventAdd', {
            event: eventApi,
            relatedEvents: [],
            revert: function() {
                _this.dispatch({
                    type: 'REMOVE_EVENTS',
                    eventStore: eventApiToStore(eventApi)
                });
            }
        });
    };
    // TODO: optimize
    CalendarApi1.prototype.getEventById = function(id) {
        var state = this.getCurrentData();
        var _a = state.eventStore, defs = _a.defs, instances = _a.instances;
        id = String(id);
        for(var defId in defs){
            var def = defs[defId];
            if (def.publicId === id) {
                if (def.recurringDef) return new EventApi(state, def, null);
                for(var instanceId in instances){
                    var instance = instances[instanceId];
                    if (instance.defId === def.defId) return new EventApi(state, def, instance);
                }
            }
        }
        return null;
    };
    CalendarApi1.prototype.getEvents = function() {
        var currentData = this.getCurrentData();
        return buildEventApis(currentData.eventStore, currentData);
    };
    CalendarApi1.prototype.removeAllEvents = function() {
        this.dispatch({
            type: 'REMOVE_ALL_EVENTS'
        });
    };
    // Public Event Sources API
    // -----------------------------------------------------------------------------------------------------------------
    CalendarApi1.prototype.getEventSources = function() {
        var state = this.getCurrentData();
        var sourceHash = state.eventSources;
        var sourceApis = [];
        for(var internalId in sourceHash)sourceApis.push(new EventSourceApi(state, sourceHash[internalId]));
        return sourceApis;
    };
    CalendarApi1.prototype.getEventSourceById = function(id) {
        var state = this.getCurrentData();
        var sourceHash = state.eventSources;
        id = String(id);
        for(var sourceId in sourceHash){
            if (sourceHash[sourceId].publicId === id) return new EventSourceApi(state, sourceHash[sourceId]);
        }
        return null;
    };
    CalendarApi1.prototype.addEventSource = function(sourceInput) {
        var state = this.getCurrentData();
        if (sourceInput instanceof EventSourceApi) {
            // not already present? don't want to add an old snapshot
            if (!state.eventSources[sourceInput.internalEventSource.sourceId]) this.dispatch({
                type: 'ADD_EVENT_SOURCES',
                sources: [
                    sourceInput.internalEventSource
                ]
            });
            return sourceInput;
        }
        var eventSource = parseEventSource(sourceInput, state);
        if (eventSource) {
            this.dispatch({
                type: 'ADD_EVENT_SOURCES',
                sources: [
                    eventSource
                ]
            });
            return new EventSourceApi(state, eventSource);
        }
        return null;
    };
    CalendarApi1.prototype.removeAllEventSources = function() {
        this.dispatch({
            type: 'REMOVE_ALL_EVENT_SOURCES'
        });
    };
    CalendarApi1.prototype.refetchEvents = function() {
        this.dispatch({
            type: 'FETCH_EVENT_SOURCES',
            isRefetch: true
        });
    };
    // Scroll
    // -----------------------------------------------------------------------------------------------------------------
    CalendarApi1.prototype.scrollToTime = function(timeInput) {
        var time = createDuration(timeInput);
        if (time) this.trigger('_scrollRequest', {
            time: time
        });
    };
    return CalendarApi1;
}();
var EventApi = /** @class */ function() {
    // instance will be null if expressing a recurring event that has no current instances,
    // OR if trying to validate an incoming external event that has no dates assigned
    function EventApi1(context, def, instance) {
        this._context = context;
        this._def = def;
        this._instance = instance || null;
    }
    /*
    TODO: make event struct more responsible for this
    */ EventApi1.prototype.setProp = function(name, val) {
        var _a, _b;
        if (name in EVENT_DATE_REFINERS) console.warn('Could not set date-related prop \'name\'. Use one of the date-related methods instead.');
        else if (name === 'id') {
            val = EVENT_NON_DATE_REFINERS[name](val);
            this.mutate({
                standardProps: {
                    publicId: val
                }
            });
        } else if (name in EVENT_NON_DATE_REFINERS) {
            val = EVENT_NON_DATE_REFINERS[name](val);
            this.mutate({
                standardProps: (_a = {}, _a[name] = val, _a)
            });
        } else if (name in EVENT_UI_REFINERS) {
            var ui = EVENT_UI_REFINERS[name](val);
            if (name === 'color') ui = {
                backgroundColor: val,
                borderColor: val
            };
            else if (name === 'editable') ui = {
                startEditable: val,
                durationEditable: val
            };
            else ui = (_b = {}, _b[name] = val, _b);
            this.mutate({
                standardProps: {
                    ui: ui
                }
            });
        } else console.warn("Could not set prop '" + name + "'. Use setExtendedProp instead.");
    };
    EventApi1.prototype.setExtendedProp = function(name, val) {
        var _a;
        this.mutate({
            extendedProps: (_a = {}, _a[name] = val, _a)
        });
    };
    EventApi1.prototype.setStart = function(startInput, options) {
        if (options === void 0) options = {};
        var dateEnv = this._context.dateEnv;
        var start = dateEnv.createMarker(startInput);
        if (start && this._instance) {
            var instanceRange = this._instance.range;
            var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?
            if (options.maintainDuration) this.mutate({
                datesDelta: startDelta
            });
            else this.mutate({
                startDelta: startDelta
            });
        }
    };
    EventApi1.prototype.setEnd = function(endInput, options) {
        if (options === void 0) options = {};
        var dateEnv = this._context.dateEnv;
        var end;
        if (endInput != null) {
            end = dateEnv.createMarker(endInput);
            if (!end) return; // TODO: warning if parsed bad
        }
        if (this._instance) {
            if (end) {
                var endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);
                this.mutate({
                    endDelta: endDelta
                });
            } else this.mutate({
                standardProps: {
                    hasEnd: false
                }
            });
        }
    };
    EventApi1.prototype.setDates = function(startInput, endInput, options) {
        if (options === void 0) options = {};
        var dateEnv = this._context.dateEnv;
        var standardProps = {
            allDay: options.allDay
        };
        var start = dateEnv.createMarker(startInput);
        var end;
        if (!start) return; // TODO: warning if parsed bad
        if (endInput != null) {
            end = dateEnv.createMarker(endInput);
            if (!end) return;
        }
        if (this._instance) {
            var instanceRange = this._instance.range;
            // when computing the diff for an event being converted to all-day,
            // compute diff off of the all-day values the way event-mutation does.
            if (options.allDay === true) instanceRange = computeAlignedDayRange(instanceRange);
            var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);
            if (end) {
                var endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);
                if (durationsEqual(startDelta, endDelta)) this.mutate({
                    datesDelta: startDelta,
                    standardProps: standardProps
                });
                else this.mutate({
                    startDelta: startDelta,
                    endDelta: endDelta,
                    standardProps: standardProps
                });
            } else {
                standardProps.hasEnd = false;
                this.mutate({
                    datesDelta: startDelta,
                    standardProps: standardProps
                });
            }
        }
    };
    EventApi1.prototype.moveStart = function(deltaInput) {
        var delta = createDuration(deltaInput);
        if (delta) this.mutate({
            startDelta: delta
        });
    };
    EventApi1.prototype.moveEnd = function(deltaInput) {
        var delta = createDuration(deltaInput);
        if (delta) this.mutate({
            endDelta: delta
        });
    };
    EventApi1.prototype.moveDates = function(deltaInput) {
        var delta = createDuration(deltaInput);
        if (delta) this.mutate({
            datesDelta: delta
        });
    };
    EventApi1.prototype.setAllDay = function(allDay, options) {
        if (options === void 0) options = {};
        var standardProps = {
            allDay: allDay
        };
        var maintainDuration = options.maintainDuration;
        if (maintainDuration == null) maintainDuration = this._context.options.allDayMaintainDuration;
        if (this._def.allDay !== allDay) standardProps.hasEnd = maintainDuration;
        this.mutate({
            standardProps: standardProps
        });
    };
    EventApi1.prototype.formatRange = function(formatInput) {
        var dateEnv = this._context.dateEnv;
        var instance = this._instance;
        var formatter = createFormatter(formatInput);
        if (this._def.hasEnd) return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {
            forcedStartTzo: instance.forcedStartTzo,
            forcedEndTzo: instance.forcedEndTzo
        });
        return dateEnv.format(instance.range.start, formatter, {
            forcedTzo: instance.forcedStartTzo
        });
    };
    EventApi1.prototype.mutate = function(mutation) {
        var instance = this._instance;
        if (instance) {
            var def = this._def;
            var context_1 = this._context;
            var eventStore_1 = context_1.getCurrentData().eventStore;
            var relevantEvents = getRelevantEvents(eventStore_1, instance.instanceId);
            var eventConfigBase = {
                '': {
                    display: '',
                    startEditable: true,
                    durationEditable: true,
                    constraints: [],
                    overlap: null,
                    allows: [],
                    backgroundColor: '',
                    borderColor: '',
                    textColor: '',
                    classNames: []
                }
            };
            relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context_1);
            var oldEvent = new EventApi1(context_1, def, instance); // snapshot
            this._def = relevantEvents.defs[def.defId];
            this._instance = relevantEvents.instances[instance.instanceId];
            context_1.dispatch({
                type: 'MERGE_EVENTS',
                eventStore: relevantEvents
            });
            context_1.emitter.trigger('eventChange', {
                oldEvent: oldEvent,
                event: this,
                relatedEvents: buildEventApis(relevantEvents, context_1, instance),
                revert: function() {
                    context_1.dispatch({
                        type: 'RESET_EVENTS',
                        eventStore: eventStore_1
                    });
                }
            });
        }
    };
    EventApi1.prototype.remove = function() {
        var context = this._context;
        var asStore = eventApiToStore(this);
        context.dispatch({
            type: 'REMOVE_EVENTS',
            eventStore: asStore
        });
        context.emitter.trigger('eventRemove', {
            event: this,
            relatedEvents: [],
            revert: function() {
                context.dispatch({
                    type: 'MERGE_EVENTS',
                    eventStore: asStore
                });
            }
        });
    };
    Object.defineProperty(EventApi1.prototype, "source", {
        get: function() {
            var sourceId = this._def.sourceId;
            if (sourceId) return new EventSourceApi(this._context, this._context.getCurrentData().eventSources[sourceId]);
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "start", {
        get: function() {
            return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "end", {
        get: function() {
            return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "startStr", {
        get: function() {
            var instance = this._instance;
            if (instance) return this._context.dateEnv.formatIso(instance.range.start, {
                omitTime: this._def.allDay,
                forcedTzo: instance.forcedStartTzo
            });
            return '';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "endStr", {
        get: function() {
            var instance = this._instance;
            if (instance && this._def.hasEnd) return this._context.dateEnv.formatIso(instance.range.end, {
                omitTime: this._def.allDay,
                forcedTzo: instance.forcedEndTzo
            });
            return '';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "id", {
        // computable props that all access the def
        // TODO: find a TypeScript-compatible way to do this at scale
        get: function() {
            return this._def.publicId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "groupId", {
        get: function() {
            return this._def.groupId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "allDay", {
        get: function() {
            return this._def.allDay;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "title", {
        get: function() {
            return this._def.title;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "url", {
        get: function() {
            return this._def.url;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "display", {
        get: function() {
            return this._def.ui.display || 'auto';
        } // bad. just normalize the type earlier
        ,
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "startEditable", {
        get: function() {
            return this._def.ui.startEditable;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "durationEditable", {
        get: function() {
            return this._def.ui.durationEditable;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "constraint", {
        get: function() {
            return this._def.ui.constraints[0] || null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "overlap", {
        get: function() {
            return this._def.ui.overlap;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "allow", {
        get: function() {
            return this._def.ui.allows[0] || null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "backgroundColor", {
        get: function() {
            return this._def.ui.backgroundColor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "borderColor", {
        get: function() {
            return this._def.ui.borderColor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "textColor", {
        get: function() {
            return this._def.ui.textColor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "classNames", {
        // NOTE: user can't modify these because Object.freeze was called in event-def parsing
        get: function() {
            return this._def.ui.classNames;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventApi1.prototype, "extendedProps", {
        get: function() {
            return this._def.extendedProps;
        },
        enumerable: false,
        configurable: true
    });
    EventApi1.prototype.toPlainObject = function(settings) {
        if (settings === void 0) settings = {};
        var def = this._def;
        var ui = def.ui;
        var _a = this, startStr = _a.startStr, endStr = _a.endStr;
        var res = {};
        if (def.title) res.title = def.title;
        if (startStr) res.start = startStr;
        if (endStr) res.end = endStr;
        if (def.publicId) res.id = def.publicId;
        if (def.groupId) res.groupId = def.groupId;
        if (def.url) res.url = def.url;
        if (ui.display && ui.display !== 'auto') res.display = ui.display;
        // TODO: what about recurring-event properties???
        // TODO: include startEditable/durationEditable/constraint/overlap/allow
        if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) res.color = ui.backgroundColor;
        else {
            if (ui.backgroundColor) res.backgroundColor = ui.backgroundColor;
            if (ui.borderColor) res.borderColor = ui.borderColor;
        }
        if (ui.textColor) res.textColor = ui.textColor;
        if (ui.classNames.length) res.classNames = ui.classNames;
        if (Object.keys(def.extendedProps).length) {
            if (settings.collapseExtendedProps) _tslib.__assign(res, def.extendedProps);
            else res.extendedProps = def.extendedProps;
        }
        return res;
    };
    EventApi1.prototype.toJSON = function() {
        return this.toPlainObject();
    };
    return EventApi1;
}();
function eventApiToStore(eventApi) {
    var _a, _b;
    var def = eventApi._def;
    var instance = eventApi._instance;
    return {
        defs: (_a = {}, _a[def.defId] = def, _a),
        instances: instance ? (_b = {}, _b[instance.instanceId] = instance, _b) : {}
    };
}
function buildEventApis(eventStore, context, excludeInstance) {
    var defs = eventStore.defs, instances = eventStore.instances;
    var eventApis = [];
    var excludeInstanceId = excludeInstance ? excludeInstance.instanceId : '';
    for(var id in instances){
        var instance = instances[id];
        var def = defs[instance.defId];
        if (instance.instanceId !== excludeInstanceId) eventApis.push(new EventApi(context, def, instance));
    }
    return eventApis;
}
var calendarSystemClassMap = {};
function registerCalendarSystem(name, theClass) {
    calendarSystemClassMap[name] = theClass;
}
function createCalendarSystem(name) {
    return new calendarSystemClassMap[name]();
}
var GregorianCalendarSystem = /** @class */ function() {
    function GregorianCalendarSystem1() {}
    GregorianCalendarSystem1.prototype.getMarkerYear = function(d) {
        return d.getUTCFullYear();
    };
    GregorianCalendarSystem1.prototype.getMarkerMonth = function(d) {
        return d.getUTCMonth();
    };
    GregorianCalendarSystem1.prototype.getMarkerDay = function(d) {
        return d.getUTCDate();
    };
    GregorianCalendarSystem1.prototype.arrayToMarker = function(arr) {
        return arrayToUtcDate(arr);
    };
    GregorianCalendarSystem1.prototype.markerToArray = function(marker) {
        return dateToUtcArray(marker);
    };
    return GregorianCalendarSystem1;
}();
registerCalendarSystem('gregory', GregorianCalendarSystem);
var ISO_RE = /^\s*(\d{4})(-?(\d{2})(-?(\d{2})([T ](\d{2}):?(\d{2})(:?(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/;
function parse(str) {
    var m = ISO_RE.exec(str);
    if (m) {
        var marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number("0." + m[12]) * 1000 : 0));
        if (isValidDate(marker)) {
            var timeZoneOffset = null;
            if (m[13]) timeZoneOffset = (m[15] === '-' ? -1 : 1) * (Number(m[16] || 0) * 60 + Number(m[18] || 0));
            return {
                marker: marker,
                isTimeUnspecified: !m[6],
                timeZoneOffset: timeZoneOffset
            };
        }
    }
    return null;
}
var DateEnv = /** @class */ function() {
    function DateEnv1(settings) {
        var timeZone = this.timeZone = settings.timeZone;
        var isNamedTimeZone = timeZone !== 'local' && timeZone !== 'UTC';
        if (settings.namedTimeZoneImpl && isNamedTimeZone) this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);
        this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);
        this.calendarSystem = createCalendarSystem(settings.calendarSystem);
        this.locale = settings.locale;
        this.weekDow = settings.locale.week.dow;
        this.weekDoy = settings.locale.week.doy;
        if (settings.weekNumberCalculation === 'ISO') {
            this.weekDow = 1;
            this.weekDoy = 4;
        }
        if (typeof settings.firstDay === 'number') this.weekDow = settings.firstDay;
        if (typeof settings.weekNumberCalculation === 'function') this.weekNumberFunc = settings.weekNumberCalculation;
        this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;
        this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;
        this.cmdFormatter = settings.cmdFormatter;
        this.defaultSeparator = settings.defaultSeparator;
    }
    // Creating / Parsing
    DateEnv1.prototype.createMarker = function(input) {
        var meta = this.createMarkerMeta(input);
        if (meta === null) return null;
        return meta.marker;
    };
    DateEnv1.prototype.createNowMarker = function() {
        if (this.canComputeOffset) return this.timestampToMarker(new Date().valueOf());
        // if we can't compute the current date val for a timezone,
        // better to give the current local date vals than UTC
        return arrayToUtcDate(dateToLocalArray(new Date()));
    };
    DateEnv1.prototype.createMarkerMeta = function(input) {
        if (typeof input === 'string') return this.parse(input);
        var marker = null;
        if (typeof input === 'number') marker = this.timestampToMarker(input);
        else if (input instanceof Date) {
            input = input.valueOf();
            if (!isNaN(input)) marker = this.timestampToMarker(input);
        } else if (Array.isArray(input)) marker = arrayToUtcDate(input);
        if (marker === null || !isValidDate(marker)) return null;
        return {
            marker: marker,
            isTimeUnspecified: false,
            forcedTzo: null
        };
    };
    DateEnv1.prototype.parse = function(s) {
        var parts = parse(s);
        if (parts === null) return null;
        var marker = parts.marker;
        var forcedTzo = null;
        if (parts.timeZoneOffset !== null) {
            if (this.canComputeOffset) marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60000);
            else forcedTzo = parts.timeZoneOffset;
        }
        return {
            marker: marker,
            isTimeUnspecified: parts.isTimeUnspecified,
            forcedTzo: forcedTzo
        };
    };
    // Accessors
    DateEnv1.prototype.getYear = function(marker) {
        return this.calendarSystem.getMarkerYear(marker);
    };
    DateEnv1.prototype.getMonth = function(marker) {
        return this.calendarSystem.getMarkerMonth(marker);
    };
    // Adding / Subtracting
    DateEnv1.prototype.add = function(marker, dur) {
        var a = this.calendarSystem.markerToArray(marker);
        a[0] += dur.years;
        a[1] += dur.months;
        a[2] += dur.days;
        a[6] += dur.milliseconds;
        return this.calendarSystem.arrayToMarker(a);
    };
    DateEnv1.prototype.subtract = function(marker, dur) {
        var a = this.calendarSystem.markerToArray(marker);
        a[0] -= dur.years;
        a[1] -= dur.months;
        a[2] -= dur.days;
        a[6] -= dur.milliseconds;
        return this.calendarSystem.arrayToMarker(a);
    };
    DateEnv1.prototype.addYears = function(marker, n) {
        var a = this.calendarSystem.markerToArray(marker);
        a[0] += n;
        return this.calendarSystem.arrayToMarker(a);
    };
    DateEnv1.prototype.addMonths = function(marker, n) {
        var a = this.calendarSystem.markerToArray(marker);
        a[1] += n;
        return this.calendarSystem.arrayToMarker(a);
    };
    // Diffing Whole Units
    DateEnv1.prototype.diffWholeYears = function(m0, m1) {
        var calendarSystem = this.calendarSystem;
        if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);
        return null;
    };
    DateEnv1.prototype.diffWholeMonths = function(m0, m1) {
        var calendarSystem = this.calendarSystem;
        if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;
        return null;
    };
    // Range / Duration
    DateEnv1.prototype.greatestWholeUnit = function(m0, m1) {
        var n = this.diffWholeYears(m0, m1);
        if (n !== null) return {
            unit: 'year',
            value: n
        };
        n = this.diffWholeMonths(m0, m1);
        if (n !== null) return {
            unit: 'month',
            value: n
        };
        n = diffWholeWeeks(m0, m1);
        if (n !== null) return {
            unit: 'week',
            value: n
        };
        n = diffWholeDays(m0, m1);
        if (n !== null) return {
            unit: 'day',
            value: n
        };
        n = diffHours(m0, m1);
        if (isInt(n)) return {
            unit: 'hour',
            value: n
        };
        n = diffMinutes(m0, m1);
        if (isInt(n)) return {
            unit: 'minute',
            value: n
        };
        n = diffSeconds(m0, m1);
        if (isInt(n)) return {
            unit: 'second',
            value: n
        };
        return {
            unit: 'millisecond',
            value: m1.valueOf() - m0.valueOf()
        };
    };
    DateEnv1.prototype.countDurationsBetween = function(m0, m1, d) {
        // TODO: can use greatestWholeUnit
        var diff;
        if (d.years) {
            diff = this.diffWholeYears(m0, m1);
            if (diff !== null) return diff / asRoughYears(d);
        }
        if (d.months) {
            diff = this.diffWholeMonths(m0, m1);
            if (diff !== null) return diff / asRoughMonths(d);
        }
        if (d.days) {
            diff = diffWholeDays(m0, m1);
            if (diff !== null) return diff / asRoughDays(d);
        }
        return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);
    };
    // Start-Of
    // these DON'T return zoned-dates. only UTC start-of dates
    DateEnv1.prototype.startOf = function(m, unit) {
        if (unit === 'year') return this.startOfYear(m);
        if (unit === 'month') return this.startOfMonth(m);
        if (unit === 'week') return this.startOfWeek(m);
        if (unit === 'day') return startOfDay(m);
        if (unit === 'hour') return startOfHour(m);
        if (unit === 'minute') return startOfMinute(m);
        if (unit === 'second') return startOfSecond(m);
        return null;
    };
    DateEnv1.prototype.startOfYear = function(m) {
        return this.calendarSystem.arrayToMarker([
            this.calendarSystem.getMarkerYear(m), 
        ]);
    };
    DateEnv1.prototype.startOfMonth = function(m) {
        return this.calendarSystem.arrayToMarker([
            this.calendarSystem.getMarkerYear(m),
            this.calendarSystem.getMarkerMonth(m), 
        ]);
    };
    DateEnv1.prototype.startOfWeek = function(m) {
        return this.calendarSystem.arrayToMarker([
            this.calendarSystem.getMarkerYear(m),
            this.calendarSystem.getMarkerMonth(m),
            m.getUTCDate() - (m.getUTCDay() - this.weekDow + 7) % 7, 
        ]);
    };
    // Week Number
    DateEnv1.prototype.computeWeekNumber = function(marker) {
        if (this.weekNumberFunc) return this.weekNumberFunc(this.toDate(marker));
        return weekOfYear(marker, this.weekDow, this.weekDoy);
    };
    // TODO: choke on timeZoneName: long
    DateEnv1.prototype.format = function(marker, formatter, dateOptions) {
        if (dateOptions === void 0) dateOptions = {};
        return formatter.format({
            marker: marker,
            timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)
        }, this);
    };
    DateEnv1.prototype.formatRange = function(start, end, formatter, dateOptions) {
        if (dateOptions === void 0) dateOptions = {};
        if (dateOptions.isEndExclusive) end = addMs(end, -1);
        return formatter.formatRange({
            marker: start,
            timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)
        }, {
            marker: end,
            timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)
        }, this, dateOptions.defaultSeparator);
    };
    /*
    DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,
    might as well use buildIsoString or some other util directly
    */ DateEnv1.prototype.formatIso = function(marker, extraOptions) {
        if (extraOptions === void 0) extraOptions = {};
        var timeZoneOffset = null;
        if (!extraOptions.omitTimeZoneOffset) {
            if (extraOptions.forcedTzo != null) timeZoneOffset = extraOptions.forcedTzo;
            else timeZoneOffset = this.offsetForMarker(marker);
        }
        return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);
    };
    // TimeZone
    DateEnv1.prototype.timestampToMarker = function(ms) {
        if (this.timeZone === 'local') return arrayToUtcDate(dateToLocalArray(new Date(ms)));
        if (this.timeZone === 'UTC' || !this.namedTimeZoneImpl) return new Date(ms);
        return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));
    };
    DateEnv1.prototype.offsetForMarker = function(m) {
        if (this.timeZone === 'local') return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert "inverse" offset to "normal" offset
        if (this.timeZone === 'UTC') return 0;
        if (this.namedTimeZoneImpl) return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));
        return null;
    };
    // Conversion
    DateEnv1.prototype.toDate = function(m, forcedTzo) {
        if (this.timeZone === 'local') return arrayToLocalDate(dateToUtcArray(m));
        if (this.timeZone === 'UTC') return new Date(m.valueOf()); // make sure it's a copy
        if (!this.namedTimeZoneImpl) return new Date(m.valueOf() - (forcedTzo || 0));
        return new Date(m.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 60000);
    };
    return DateEnv1;
}();
var globalLocales = [];
var MINIMAL_RAW_EN_LOCALE = {
    code: 'en',
    week: {
        dow: 0,
        doy: 4
    },
    direction: 'ltr',
    buttonText: {
        prev: 'prev',
        next: 'next',
        prevYear: 'prev year',
        nextYear: 'next year',
        year: 'year',
        today: 'today',
        month: 'month',
        week: 'week',
        day: 'day',
        list: 'list'
    },
    weekText: 'W',
    weekTextLong: 'Week',
    closeHint: 'Close',
    timeHint: 'Time',
    eventHint: 'Event',
    allDayText: 'all-day',
    moreLinkText: 'more',
    noEventsText: 'No events to display'
};
var RAW_EN_LOCALE = _tslib.__assign(_tslib.__assign({}, MINIMAL_RAW_EN_LOCALE), {
    // Includes things we don't want other locales to inherit,
    // things that derive from other translatable strings.
    buttonHints: {
        prev: 'Previous $0',
        next: 'Next $0',
        today: function(buttonText, unit) {
            return unit === 'day' ? 'Today' : "This " + buttonText;
        }
    },
    viewHint: '$0 view',
    navLinkHint: 'Go to $0',
    moreLinkHint: function(eventCnt) {
        return "Show " + eventCnt + " more event" + (eventCnt === 1 ? '' : 's');
    }
});
function organizeRawLocales(explicitRawLocales) {
    var defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : 'en';
    var allRawLocales = globalLocales.concat(explicitRawLocales);
    var rawLocaleMap = {
        en: RAW_EN_LOCALE
    };
    for(var _i = 0, allRawLocales_1 = allRawLocales; _i < allRawLocales_1.length; _i++){
        var rawLocale = allRawLocales_1[_i];
        rawLocaleMap[rawLocale.code] = rawLocale;
    }
    return {
        map: rawLocaleMap,
        defaultCode: defaultCode
    };
}
function buildLocale(inputSingular, available) {
    if (typeof inputSingular === 'object' && !Array.isArray(inputSingular)) return parseLocale(inputSingular.code, [
        inputSingular.code
    ], inputSingular);
    return queryLocale(inputSingular, available);
}
function queryLocale(codeArg, available) {
    var codes = [].concat(codeArg || []); // will convert to array
    var raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;
    return parseLocale(codeArg, codes, raw);
}
function queryRawLocale(codes, available) {
    for(var i = 0; i < codes.length; i += 1){
        var parts = codes[i].toLocaleLowerCase().split('-');
        for(var j = parts.length; j > 0; j -= 1){
            var simpleId = parts.slice(0, j).join('-');
            if (available[simpleId]) return available[simpleId];
        }
    }
    return null;
}
function parseLocale(codeArg, codes, raw) {
    var merged = mergeProps([
        MINIMAL_RAW_EN_LOCALE,
        raw
    ], [
        'buttonText'
    ]);
    delete merged.code; // don't want this part of the options
    var week = merged.week;
    delete merged.week;
    return {
        codeArg: codeArg,
        codes: codes,
        week: week,
        simpleNumberFormat: new Intl.NumberFormat(codeArg),
        options: merged
    };
}
function formatDate(dateInput, options) {
    if (options === void 0) options = {};
    var dateEnv = buildDateEnv$1(options);
    var formatter = createFormatter(options);
    var dateMeta = dateEnv.createMarkerMeta(dateInput);
    if (!dateMeta) return '';
    return dateEnv.format(dateMeta.marker, formatter, {
        forcedTzo: dateMeta.forcedTzo
    });
}
function formatRange(startInput, endInput, options) {
    var dateEnv = buildDateEnv$1(typeof options === 'object' && options ? options : {}); // pass in if non-null object
    var formatter = createFormatter(options);
    var startMeta = dateEnv.createMarkerMeta(startInput);
    var endMeta = dateEnv.createMarkerMeta(endInput);
    if (!startMeta || !endMeta) return '';
    return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {
        forcedStartTzo: startMeta.forcedTzo,
        forcedEndTzo: endMeta.forcedTzo,
        isEndExclusive: options.isEndExclusive,
        defaultSeparator: BASE_OPTION_DEFAULTS.defaultRangeSeparator
    });
}
// TODO: more DRY and optimized
function buildDateEnv$1(settings) {
    var locale = buildLocale(settings.locale || 'en', organizeRawLocales([]).map); // TODO: don't hardcode 'en' everywhere
    return new DateEnv(_tslib.__assign(_tslib.__assign({
        timeZone: BASE_OPTION_DEFAULTS.timeZone,
        calendarSystem: 'gregory'
    }, settings), {
        locale: locale
    }));
}
var DEF_DEFAULTS = {
    startTime: '09:00',
    endTime: '17:00',
    daysOfWeek: [
        1,
        2,
        3,
        4,
        5
    ],
    display: 'inverse-background',
    classNames: 'fc-non-business',
    groupId: '_businessHours'
};
/*
TODO: pass around as EventDefHash!!!
*/ function parseBusinessHours(input, context) {
    return parseEvents(refineInputs(input), null, context);
}
function refineInputs(input) {
    var rawDefs;
    if (input === true) rawDefs = [
        {}
    ]; // will get DEF_DEFAULTS verbatim
    else if (Array.isArray(input)) // if specifying an array, every sub-definition NEEDS a day-of-week
    rawDefs = input.filter(function(rawDef) {
        return rawDef.daysOfWeek;
    });
    else if (typeof input === 'object' && input) rawDefs = [
        input
    ];
    else rawDefs = [];
    rawDefs = rawDefs.map(function(rawDef) {
        return _tslib.__assign(_tslib.__assign({}, DEF_DEFAULTS), rawDef);
    });
    return rawDefs;
}
function pointInsideRect(point, rect) {
    return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;
}
// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false
function intersectRects(rect1, rect2) {
    var res = {
        left: Math.max(rect1.left, rect2.left),
        right: Math.min(rect1.right, rect2.right),
        top: Math.max(rect1.top, rect2.top),
        bottom: Math.min(rect1.bottom, rect2.bottom)
    };
    if (res.left < res.right && res.top < res.bottom) return res;
    return false;
}
function translateRect(rect, deltaX, deltaY) {
    return {
        left: rect.left + deltaX,
        right: rect.right + deltaX,
        top: rect.top + deltaY,
        bottom: rect.bottom + deltaY
    };
}
// Returns a new point that will have been moved to reside within the given rectangle
function constrainPoint(point, rect) {
    return {
        left: Math.min(Math.max(point.left, rect.left), rect.right),
        top: Math.min(Math.max(point.top, rect.top), rect.bottom)
    };
}
// Returns a point that is the center of the given rectangle
function getRectCenter(rect) {
    return {
        left: (rect.left + rect.right) / 2,
        top: (rect.top + rect.bottom) / 2
    };
}
// Subtracts point2's coordinates from point1's coordinates, returning a delta
function diffPoints(point1, point2) {
    return {
        left: point1.left - point2.left,
        top: point1.top - point2.top
    };
}
var canVGrowWithinCell;
function getCanVGrowWithinCell() {
    if (canVGrowWithinCell == null) canVGrowWithinCell = computeCanVGrowWithinCell();
    return canVGrowWithinCell;
}
function computeCanVGrowWithinCell() {
    // for SSR, because this function is call immediately at top-level
    // TODO: just make this logic execute top-level, immediately, instead of doing lazily
    if (typeof document === 'undefined') return true;
    var el = document.createElement('div');
    el.style.position = 'absolute';
    el.style.top = '0px';
    el.style.left = '0px';
    el.innerHTML = '<table><tr><td><div></div></td></tr></table>';
    el.querySelector('table').style.height = '100px';
    el.querySelector('div').style.height = '100%';
    document.body.appendChild(el);
    var div = el.querySelector('div');
    var possible = div.offsetHeight > 0;
    document.body.removeChild(el);
    return possible;
}
var EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere
var Splitter = /** @class */ function() {
    function Splitter1() {
        this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);
        this.splitDateSelection = memoize(this._splitDateSpan);
        this.splitEventStore = memoize(this._splitEventStore);
        this.splitIndividualUi = memoize(this._splitIndividualUi);
        this.splitEventDrag = memoize(this._splitInteraction);
        this.splitEventResize = memoize(this._splitInteraction);
        this.eventUiBuilders = {}; // TODO: typescript protection
    }
    Splitter1.prototype.splitProps = function(props) {
        var _this = this;
        var keyInfos = this.getKeyInfo(props);
        var defKeys = this.getKeysForEventDefs(props.eventStore);
        var dateSelections = this.splitDateSelection(props.dateSelection);
        var individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*
        var eventStores = this.splitEventStore(props.eventStore, defKeys);
        var eventDrags = this.splitEventDrag(props.eventDrag);
        var eventResizes = this.splitEventResize(props.eventResize);
        var splitProps = {};
        this.eventUiBuilders = mapHash(keyInfos, function(info, key) {
            return _this.eventUiBuilders[key] || memoize(buildEventUiForKey);
        });
        for(var key1 in keyInfos){
            var keyInfo = keyInfos[key1];
            var eventStore = eventStores[key1] || EMPTY_EVENT_STORE;
            var buildEventUi = this.eventUiBuilders[key1];
            splitProps[key1] = {
                businessHours: keyInfo.businessHours || props.businessHours,
                dateSelection: dateSelections[key1] || null,
                eventStore: eventStore,
                eventUiBases: buildEventUi(props.eventUiBases[''], keyInfo.ui, individualUi[key1]),
                eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : '',
                eventDrag: eventDrags[key1] || null,
                eventResize: eventResizes[key1] || null
            };
        }
        return splitProps;
    };
    Splitter1.prototype._splitDateSpan = function(dateSpan) {
        var dateSpans = {};
        if (dateSpan) {
            var keys = this.getKeysForDateSpan(dateSpan);
            for(var _i = 0, keys_1 = keys; _i < keys_1.length; _i++){
                var key = keys_1[_i];
                dateSpans[key] = dateSpan;
            }
        }
        return dateSpans;
    };
    Splitter1.prototype._getKeysForEventDefs = function(eventStore) {
        var _this = this;
        return mapHash(eventStore.defs, function(eventDef) {
            return _this.getKeysForEventDef(eventDef);
        });
    };
    Splitter1.prototype._splitEventStore = function(eventStore, defKeys) {
        var defs = eventStore.defs, instances = eventStore.instances;
        var splitStores = {};
        for(var defId in defs)for(var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++){
            var key = _a[_i];
            if (!splitStores[key]) splitStores[key] = createEmptyEventStore();
            splitStores[key].defs[defId] = defs[defId];
        }
        for(var instanceId in instances){
            var instance = instances[instanceId];
            for(var _b = 0, _c = defKeys[instance.defId]; _b < _c.length; _b++){
                var key = _c[_b];
                if (splitStores[key]) splitStores[key].instances[instanceId] = instance;
            }
        }
        return splitStores;
    };
    Splitter1.prototype._splitIndividualUi = function(eventUiBases, defKeys) {
        var splitHashes = {};
        for(var defId in eventUiBases){
            if (defId) for(var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++){
                var key = _a[_i];
                if (!splitHashes[key]) splitHashes[key] = {};
                splitHashes[key][defId] = eventUiBases[defId];
            }
        }
        return splitHashes;
    };
    Splitter1.prototype._splitInteraction = function(interaction) {
        var splitStates = {};
        if (interaction) {
            var affectedStores_1 = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents));
            // can't rely on defKeys because event data is mutated
            var mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);
            var mutatedStores_1 = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);
            var populate = function(key) {
                if (!splitStates[key]) splitStates[key] = {
                    affectedEvents: affectedStores_1[key] || EMPTY_EVENT_STORE,
                    mutatedEvents: mutatedStores_1[key] || EMPTY_EVENT_STORE,
                    isEvent: interaction.isEvent
                };
            };
            for(var key2 in affectedStores_1)populate(key2);
            for(var key2 in mutatedStores_1)populate(key2);
        }
        return splitStates;
    };
    return Splitter1;
}();
function buildEventUiForKey(allUi, eventUiForKey, individualUi) {
    var baseParts = [];
    if (allUi) baseParts.push(allUi);
    if (eventUiForKey) baseParts.push(eventUiForKey);
    var stuff = {
        '': combineEventUis(baseParts)
    };
    if (individualUi) _tslib.__assign(stuff, individualUi);
    return stuff;
}
function getDateMeta(date, todayRange, nowDate, dateProfile) {
    return {
        dow: date.getUTCDay(),
        isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),
        isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),
        isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),
        isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),
        isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)
    };
}
function getDayClassNames(meta, theme) {
    var classNames = [
        'fc-day',
        "fc-day-" + DAY_IDS[meta.dow], 
    ];
    if (meta.isDisabled) classNames.push('fc-day-disabled');
    else {
        if (meta.isToday) {
            classNames.push('fc-day-today');
            classNames.push(theme.getClass('today'));
        }
        if (meta.isPast) classNames.push('fc-day-past');
        if (meta.isFuture) classNames.push('fc-day-future');
        if (meta.isOther) classNames.push('fc-day-other');
    }
    return classNames;
}
function getSlotClassNames(meta, theme) {
    var classNames = [
        'fc-slot',
        "fc-slot-" + DAY_IDS[meta.dow], 
    ];
    if (meta.isDisabled) classNames.push('fc-slot-disabled');
    else {
        if (meta.isToday) {
            classNames.push('fc-slot-today');
            classNames.push(theme.getClass('today'));
        }
        if (meta.isPast) classNames.push('fc-slot-past');
        if (meta.isFuture) classNames.push('fc-slot-future');
    }
    return classNames;
}
var DAY_FORMAT = createFormatter({
    year: 'numeric',
    month: 'long',
    day: 'numeric'
});
var WEEK_FORMAT = createFormatter({
    week: 'long'
});
function buildNavLinkAttrs(context, dateMarker, viewType, isTabbable) {
    if (viewType === void 0) viewType = 'day';
    if (isTabbable === void 0) isTabbable = true;
    var dateEnv = context.dateEnv, options = context.options, calendarApi = context.calendarApi;
    var dateStr = dateEnv.format(dateMarker, viewType === 'week' ? WEEK_FORMAT : DAY_FORMAT);
    if (options.navLinks) {
        var zonedDate = dateEnv.toDate(dateMarker);
        var handleInteraction = function(ev) {
            var customAction = viewType === 'day' ? options.navLinkDayClick : viewType === 'week' ? options.navLinkWeekClick : null;
            if (typeof customAction === 'function') customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);
            else {
                if (typeof customAction === 'string') viewType = customAction;
                calendarApi.zoomTo(dateMarker, viewType);
            }
        };
        return _tslib.__assign({
            title: formatWithOrdinals(options.navLinkHint, [
                dateStr,
                zonedDate
            ], dateStr),
            'data-navlink': ''
        }, isTabbable ? createAriaClickAttrs(handleInteraction) : {
            onClick: handleInteraction
        });
    }
    return {
        'aria-label': dateStr
    };
}
var _isRtlScrollbarOnLeft = null;
function getIsRtlScrollbarOnLeft() {
    if (_isRtlScrollbarOnLeft === null) _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();
    return _isRtlScrollbarOnLeft;
}
function computeIsRtlScrollbarOnLeft() {
    var outerEl = document.createElement('div');
    applyStyle(outerEl, {
        position: 'absolute',
        top: -1000,
        left: 0,
        border: 0,
        padding: 0,
        overflow: 'scroll',
        direction: 'rtl'
    });
    outerEl.innerHTML = '<div></div>';
    document.body.appendChild(outerEl);
    var innerEl = outerEl.firstChild;
    var res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;
    removeElement(outerEl);
    return res;
}
var _scrollbarWidths;
function getScrollbarWidths() {
    if (!_scrollbarWidths) _scrollbarWidths = computeScrollbarWidths();
    return _scrollbarWidths;
}
function computeScrollbarWidths() {
    var el = document.createElement('div');
    el.style.overflow = 'scroll';
    el.style.position = 'absolute';
    el.style.top = '-9999px';
    el.style.left = '-9999px';
    document.body.appendChild(el);
    var res = computeScrollbarWidthsForEl(el);
    document.body.removeChild(el);
    return res;
}
// WARNING: will include border
function computeScrollbarWidthsForEl(el) {
    return {
        x: el.offsetHeight - el.clientHeight,
        y: el.offsetWidth - el.clientWidth
    };
}
function computeEdges(el, getPadding) {
    if (getPadding === void 0) getPadding = false;
    var computedStyle = window.getComputedStyle(el);
    var borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;
    var borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;
    var borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;
    var borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
    var badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!
    var scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;
    var scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;
    var res = {
        borderLeft: borderLeft,
        borderRight: borderRight,
        borderTop: borderTop,
        borderBottom: borderBottom,
        scrollbarBottom: scrollbarBottom,
        scrollbarLeft: 0,
        scrollbarRight: 0
    };
    if (getIsRtlScrollbarOnLeft() && computedStyle.direction === 'rtl') res.scrollbarLeft = scrollbarLeftRight;
    else res.scrollbarRight = scrollbarLeftRight;
    if (getPadding) {
        res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;
        res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;
        res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;
        res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;
    }
    return res;
}
function computeInnerRect(el, goWithinPadding, doFromWindowViewport) {
    if (goWithinPadding === void 0) goWithinPadding = false;
    var outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);
    var edges = computeEdges(el, goWithinPadding);
    var res = {
        left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,
        right: outerRect.right - edges.borderRight - edges.scrollbarRight,
        top: outerRect.top + edges.borderTop,
        bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom
    };
    if (goWithinPadding) {
        res.left += edges.paddingLeft;
        res.right -= edges.paddingRight;
        res.top += edges.paddingTop;
        res.bottom -= edges.paddingBottom;
    }
    return res;
}
function computeRect(el) {
    var rect = el.getBoundingClientRect();
    return {
        left: rect.left + window.pageXOffset,
        top: rect.top + window.pageYOffset,
        right: rect.right + window.pageXOffset,
        bottom: rect.bottom + window.pageYOffset
    };
}
function computeClippedClientRect(el) {
    var clippingParents = getClippingParents(el);
    var rect = el.getBoundingClientRect();
    for(var _i = 0, clippingParents_1 = clippingParents; _i < clippingParents_1.length; _i++){
        var clippingParent = clippingParents_1[_i];
        var intersection = intersectRects(rect, clippingParent.getBoundingClientRect());
        if (intersection) rect = intersection;
        else return null;
    }
    return rect;
}
function computeHeightAndMargins(el) {
    return el.getBoundingClientRect().height + computeVMargins(el);
}
function computeVMargins(el) {
    var computed = window.getComputedStyle(el);
    return parseInt(computed.marginTop, 10) + parseInt(computed.marginBottom, 10);
}
// does not return window
function getClippingParents(el) {
    var parents = [];
    while(el instanceof HTMLElement){
        var computedStyle = window.getComputedStyle(el);
        if (computedStyle.position === 'fixed') break;
        if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) parents.push(el);
        el = el.parentNode;
    }
    return parents;
}
// given a function that resolves a result asynchronously.
// the function can either call passed-in success and failure callbacks,
// or it can return a promise.
// if you need to pass additional params to func, bind them first.
function unpromisify(func, success, failure) {
    // guard against success/failure callbacks being called more than once
    // and guard against a promise AND callback being used together.
    var isResolved = false;
    var wrappedSuccess = function() {
        if (!isResolved) {
            isResolved = true;
            success.apply(this, arguments); // eslint-disable-line prefer-rest-params
        }
    };
    var wrappedFailure = function() {
        if (!isResolved) {
            isResolved = true;
            if (failure) failure.apply(this, arguments); // eslint-disable-line prefer-rest-params
        }
    };
    var res = func(wrappedSuccess, wrappedFailure);
    if (res && typeof res.then === 'function') res.then(wrappedSuccess, wrappedFailure);
}
var Emitter = /** @class */ function() {
    function Emitter1() {
        this.handlers = {};
        this.thisContext = null;
    }
    Emitter1.prototype.setThisContext = function(thisContext) {
        this.thisContext = thisContext;
    };
    Emitter1.prototype.setOptions = function(options) {
        this.options = options;
    };
    Emitter1.prototype.on = function(type, handler) {
        addToHash(this.handlers, type, handler);
    };
    Emitter1.prototype.off = function(type, handler) {
        removeFromHash(this.handlers, type, handler);
    };
    Emitter1.prototype.trigger = function(type) {
        var args = [];
        for(var _i = 1; _i < arguments.length; _i++)args[_i - 1] = arguments[_i];
        var attachedHandlers = this.handlers[type] || [];
        var optionHandler = this.options && this.options[type];
        var handlers = [].concat(optionHandler || [], attachedHandlers);
        for(var _a = 0, handlers_1 = handlers; _a < handlers_1.length; _a++){
            var handler = handlers_1[_a];
            handler.apply(this.thisContext, args);
        }
    };
    Emitter1.prototype.hasHandlers = function(type) {
        return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);
    };
    return Emitter1;
}();
function addToHash(hash, type, handler) {
    (hash[type] || (hash[type] = [])).push(handler);
}
function removeFromHash(hash, type, handler) {
    if (handler) {
        if (hash[type]) hash[type] = hash[type].filter(function(func) {
            return func !== handler;
        });
    } else delete hash[type]; // remove all handler funcs for this type
}
/*
Records offset information for a set of elements, relative to an origin element.
Can record the left/right OR the top/bottom OR both.
Provides methods for querying the cache by position.
*/ var PositionCache = /** @class */ function() {
    function PositionCache1(originEl, els, isHorizontal, isVertical) {
        this.els = els;
        var originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left
        if (isHorizontal) this.buildElHorizontals(originClientRect.left);
        if (isVertical) this.buildElVerticals(originClientRect.top);
    }
    // Populates the left/right internal coordinate arrays
    PositionCache1.prototype.buildElHorizontals = function(originClientLeft) {
        var lefts = [];
        var rights = [];
        for(var _i = 0, _a = this.els; _i < _a.length; _i++){
            var el = _a[_i];
            var rect = el.getBoundingClientRect();
            lefts.push(rect.left - originClientLeft);
            rights.push(rect.right - originClientLeft);
        }
        this.lefts = lefts;
        this.rights = rights;
    };
    // Populates the top/bottom internal coordinate arrays
    PositionCache1.prototype.buildElVerticals = function(originClientTop) {
        var tops = [];
        var bottoms = [];
        for(var _i = 0, _a = this.els; _i < _a.length; _i++){
            var el = _a[_i];
            var rect = el.getBoundingClientRect();
            tops.push(rect.top - originClientTop);
            bottoms.push(rect.bottom - originClientTop);
        }
        this.tops = tops;
        this.bottoms = bottoms;
    };
    // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
    // If no intersection is made, returns undefined.
    PositionCache1.prototype.leftToIndex = function(leftPosition) {
        var _a = this, lefts = _a.lefts, rights = _a.rights;
        var len = lefts.length;
        var i;
        for(i = 0; i < len; i += 1){
            if (leftPosition >= lefts[i] && leftPosition < rights[i]) return i;
        }
        return undefined; // TODO: better
    };
    // Given a top offset (from document top), returns the index of the el that it vertically intersects.
    // If no intersection is made, returns undefined.
    PositionCache1.prototype.topToIndex = function(topPosition) {
        var _a = this, tops = _a.tops, bottoms = _a.bottoms;
        var len = tops.length;
        var i;
        for(i = 0; i < len; i += 1){
            if (topPosition >= tops[i] && topPosition < bottoms[i]) return i;
        }
        return undefined; // TODO: better
    };
    // Gets the width of the element at the given index
    PositionCache1.prototype.getWidth = function(leftIndex) {
        return this.rights[leftIndex] - this.lefts[leftIndex];
    };
    // Gets the height of the element at the given index
    PositionCache1.prototype.getHeight = function(topIndex) {
        return this.bottoms[topIndex] - this.tops[topIndex];
    };
    return PositionCache1;
}();
/* eslint max-classes-per-file: "off" */ /*
An object for getting/setting scroll-related information for an element.
Internally, this is done very differently for window versus DOM element,
so this object serves as a common interface.
*/ var ScrollController = /** @class */ function() {
    function ScrollController1() {}
    ScrollController1.prototype.getMaxScrollTop = function() {
        return this.getScrollHeight() - this.getClientHeight();
    };
    ScrollController1.prototype.getMaxScrollLeft = function() {
        return this.getScrollWidth() - this.getClientWidth();
    };
    ScrollController1.prototype.canScrollVertically = function() {
        return this.getMaxScrollTop() > 0;
    };
    ScrollController1.prototype.canScrollHorizontally = function() {
        return this.getMaxScrollLeft() > 0;
    };
    ScrollController1.prototype.canScrollUp = function() {
        return this.getScrollTop() > 0;
    };
    ScrollController1.prototype.canScrollDown = function() {
        return this.getScrollTop() < this.getMaxScrollTop();
    };
    ScrollController1.prototype.canScrollLeft = function() {
        return this.getScrollLeft() > 0;
    };
    ScrollController1.prototype.canScrollRight = function() {
        return this.getScrollLeft() < this.getMaxScrollLeft();
    };
    return ScrollController1;
}();
var ElementScrollController = /** @class */ function(_super) {
    _tslib.__extends(ElementScrollController1, _super);
    function ElementScrollController1(el) {
        var _this = _super.call(this) || this;
        _this.el = el;
        return _this;
    }
    ElementScrollController1.prototype.getScrollTop = function() {
        return this.el.scrollTop;
    };
    ElementScrollController1.prototype.getScrollLeft = function() {
        return this.el.scrollLeft;
    };
    ElementScrollController1.prototype.setScrollTop = function(top) {
        this.el.scrollTop = top;
    };
    ElementScrollController1.prototype.setScrollLeft = function(left) {
        this.el.scrollLeft = left;
    };
    ElementScrollController1.prototype.getScrollWidth = function() {
        return this.el.scrollWidth;
    };
    ElementScrollController1.prototype.getScrollHeight = function() {
        return this.el.scrollHeight;
    };
    ElementScrollController1.prototype.getClientHeight = function() {
        return this.el.clientHeight;
    };
    ElementScrollController1.prototype.getClientWidth = function() {
        return this.el.clientWidth;
    };
    return ElementScrollController1;
}(ScrollController);
var WindowScrollController = /** @class */ function(_super) {
    _tslib.__extends(WindowScrollController1, _super);
    function WindowScrollController1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WindowScrollController1.prototype.getScrollTop = function() {
        return window.pageYOffset;
    };
    WindowScrollController1.prototype.getScrollLeft = function() {
        return window.pageXOffset;
    };
    WindowScrollController1.prototype.setScrollTop = function(n) {
        window.scroll(window.pageXOffset, n);
    };
    WindowScrollController1.prototype.setScrollLeft = function(n) {
        window.scroll(n, window.pageYOffset);
    };
    WindowScrollController1.prototype.getScrollWidth = function() {
        return document.documentElement.scrollWidth;
    };
    WindowScrollController1.prototype.getScrollHeight = function() {
        return document.documentElement.scrollHeight;
    };
    WindowScrollController1.prototype.getClientHeight = function() {
        return document.documentElement.clientHeight;
    };
    WindowScrollController1.prototype.getClientWidth = function() {
        return document.documentElement.clientWidth;
    };
    return WindowScrollController1;
}(ScrollController);
var Theme = /** @class */ function() {
    function Theme1(calendarOptions) {
        if (this.iconOverrideOption) this.setIconOverride(calendarOptions[this.iconOverrideOption]);
    }
    Theme1.prototype.setIconOverride = function(iconOverrideHash) {
        var iconClassesCopy;
        var buttonName;
        if (typeof iconOverrideHash === 'object' && iconOverrideHash) {
            iconClassesCopy = _tslib.__assign({}, this.iconClasses);
            for(buttonName in iconOverrideHash)iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
            this.iconClasses = iconClassesCopy;
        } else if (iconOverrideHash === false) this.iconClasses = {};
    };
    Theme1.prototype.applyIconOverridePrefix = function(className) {
        var prefix = this.iconOverridePrefix;
        if (prefix && className.indexOf(prefix) !== 0) className = prefix + className;
        return className;
    };
    Theme1.prototype.getClass = function(key) {
        return this.classes[key] || '';
    };
    Theme1.prototype.getIconClass = function(buttonName, isRtl) {
        var className;
        if (isRtl && this.rtlIconClasses) className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];
        else className = this.iconClasses[buttonName];
        if (className) return this.baseIconClass + " " + className;
        return '';
    };
    Theme1.prototype.getCustomButtonIconClass = function(customButtonProps) {
        var className;
        if (this.iconOverrideCustomButtonOption) {
            className = customButtonProps[this.iconOverrideCustomButtonOption];
            if (className) return this.baseIconClass + " " + this.applyIconOverridePrefix(className);
        }
        return '';
    };
    return Theme1;
}();
Theme.prototype.classes = {};
Theme.prototype.iconClasses = {};
Theme.prototype.baseIconClass = '';
Theme.prototype.iconOverridePrefix = '';
var ScrollResponder = /** @class */ function() {
    function ScrollResponder1(execFunc, emitter, scrollTime, scrollTimeReset) {
        var _this = this;
        this.execFunc = execFunc;
        this.emitter = emitter;
        this.scrollTime = scrollTime;
        this.scrollTimeReset = scrollTimeReset;
        this.handleScrollRequest = function(request) {
            _this.queuedRequest = _tslib.__assign({}, _this.queuedRequest || {}, request);
            _this.drain();
        };
        emitter.on('_scrollRequest', this.handleScrollRequest);
        this.fireInitialScroll();
    }
    ScrollResponder1.prototype.detach = function() {
        this.emitter.off('_scrollRequest', this.handleScrollRequest);
    };
    ScrollResponder1.prototype.update = function(isDatesNew) {
        if (isDatesNew && this.scrollTimeReset) this.fireInitialScroll(); // will drain
        else this.drain();
    };
    ScrollResponder1.prototype.fireInitialScroll = function() {
        this.handleScrollRequest({
            time: this.scrollTime
        });
    };
    ScrollResponder1.prototype.drain = function() {
        if (this.queuedRequest && this.execFunc(this.queuedRequest)) this.queuedRequest = null;
    };
    return ScrollResponder1;
}();
var ViewContextType = _vdomJs.createContext({}); // for Components
function buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {
    return {
        dateEnv: dateEnv,
        options: viewOptions,
        pluginHooks: pluginHooks,
        emitter: emitter,
        dispatch: dispatch,
        getCurrentData: getCurrentData,
        calendarApi: calendarApi,
        viewSpec: viewSpec,
        viewApi: viewApi,
        dateProfileGenerator: dateProfileGenerator,
        theme: theme,
        isRtl: viewOptions.direction === 'rtl',
        addResizeHandler: function(handler) {
            emitter.on('_resize', handler);
        },
        removeResizeHandler: function(handler) {
            emitter.off('_resize', handler);
        },
        createScrollResponder: function(execFunc) {
            return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);
        },
        registerInteractiveComponent: registerInteractiveComponent,
        unregisterInteractiveComponent: unregisterInteractiveComponent
    };
}
/* eslint max-classes-per-file: off */ var PureComponent = /** @class */ function(_super) {
    _tslib.__extends(PureComponent1, _super);
    function PureComponent1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PureComponent1.prototype.shouldComponentUpdate = function(nextProps, nextState) {
        if (this.debug) // eslint-disable-next-line no-console
        console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));
        return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);
    };
    PureComponent1.addPropsEquality = addPropsEquality;
    PureComponent1.addStateEquality = addStateEquality;
    PureComponent1.contextType = ViewContextType;
    return PureComponent1;
}(_vdomJs.Component);
PureComponent.prototype.propEquality = {};
PureComponent.prototype.stateEquality = {};
var BaseComponent = /** @class */ function(_super) {
    _tslib.__extends(BaseComponent1, _super);
    function BaseComponent1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BaseComponent1.contextType = ViewContextType;
    return BaseComponent1;
}(PureComponent);
function addPropsEquality(propEquality) {
    var hash = Object.create(this.prototype.propEquality);
    _tslib.__assign(hash, propEquality);
    this.prototype.propEquality = hash;
}
function addStateEquality(stateEquality) {
    var hash = Object.create(this.prototype.stateEquality);
    _tslib.__assign(hash, stateEquality);
    this.prototype.stateEquality = hash;
}
// use other one
function setRef(ref, current) {
    if (typeof ref === 'function') ref(current);
    else if (ref) // see https://github.com/facebook/react/issues/13029
    ref.current = current;
}
/*
an INTERACTABLE date component

PURPOSES:
- hook up to fg, fill, and mirror renderers
- interface for dragging and hits
*/ var DateComponent = /** @class */ function(_super) {
    _tslib.__extends(DateComponent1, _super);
    function DateComponent1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.uid = guid();
        return _this;
    }
    // Hit System
    // -----------------------------------------------------------------------------------------------------------------
    DateComponent1.prototype.prepareHits = function() {};
    DateComponent1.prototype.queryHit = function(positionLeft, positionTop, elWidth, elHeight) {
        return null; // this should be abstract
    };
    // Pointer Interaction Utils
    // -----------------------------------------------------------------------------------------------------------------
    DateComponent1.prototype.isValidSegDownEl = function(el) {
        return !this.props.eventDrag && !this.props.eventResize && !elementClosest(el, '.fc-event-mirror');
    };
    DateComponent1.prototype.isValidDateDownEl = function(el) {
        return !elementClosest(el, '.fc-event:not(.fc-bg-event)') && !elementClosest(el, '.fc-more-link') && !elementClosest(el, 'a[data-navlink]') && !elementClosest(el, '.fc-popover'); // hack
    };
    return DateComponent1;
}(BaseComponent);
// TODO: easier way to add new hooks? need to update a million things
function createPlugin(input) {
    return {
        id: guid(),
        deps: input.deps || [],
        reducers: input.reducers || [],
        isLoadingFuncs: input.isLoadingFuncs || [],
        contextInit: [].concat(input.contextInit || []),
        eventRefiners: input.eventRefiners || {},
        eventDefMemberAdders: input.eventDefMemberAdders || [],
        eventSourceRefiners: input.eventSourceRefiners || {},
        isDraggableTransformers: input.isDraggableTransformers || [],
        eventDragMutationMassagers: input.eventDragMutationMassagers || [],
        eventDefMutationAppliers: input.eventDefMutationAppliers || [],
        dateSelectionTransformers: input.dateSelectionTransformers || [],
        datePointTransforms: input.datePointTransforms || [],
        dateSpanTransforms: input.dateSpanTransforms || [],
        views: input.views || {},
        viewPropsTransformers: input.viewPropsTransformers || [],
        isPropsValid: input.isPropsValid || null,
        externalDefTransforms: input.externalDefTransforms || [],
        viewContainerAppends: input.viewContainerAppends || [],
        eventDropTransformers: input.eventDropTransformers || [],
        componentInteractions: input.componentInteractions || [],
        calendarInteractions: input.calendarInteractions || [],
        themeClasses: input.themeClasses || {},
        eventSourceDefs: input.eventSourceDefs || [],
        cmdFormatter: input.cmdFormatter,
        recurringTypes: input.recurringTypes || [],
        namedTimeZonedImpl: input.namedTimeZonedImpl,
        initialView: input.initialView || '',
        elementDraggingImpl: input.elementDraggingImpl,
        optionChangeHandlers: input.optionChangeHandlers || {},
        scrollGridImpl: input.scrollGridImpl || null,
        contentTypeHandlers: input.contentTypeHandlers || {},
        listenerRefiners: input.listenerRefiners || {},
        optionRefiners: input.optionRefiners || {},
        propSetHandlers: input.propSetHandlers || {}
    };
}
function buildPluginHooks(pluginDefs, globalDefs) {
    var isAdded = {};
    var hooks = {
        reducers: [],
        isLoadingFuncs: [],
        contextInit: [],
        eventRefiners: {},
        eventDefMemberAdders: [],
        eventSourceRefiners: {},
        isDraggableTransformers: [],
        eventDragMutationMassagers: [],
        eventDefMutationAppliers: [],
        dateSelectionTransformers: [],
        datePointTransforms: [],
        dateSpanTransforms: [],
        views: {},
        viewPropsTransformers: [],
        isPropsValid: null,
        externalDefTransforms: [],
        viewContainerAppends: [],
        eventDropTransformers: [],
        componentInteractions: [],
        calendarInteractions: [],
        themeClasses: {},
        eventSourceDefs: [],
        cmdFormatter: null,
        recurringTypes: [],
        namedTimeZonedImpl: null,
        initialView: '',
        elementDraggingImpl: null,
        optionChangeHandlers: {},
        scrollGridImpl: null,
        contentTypeHandlers: {},
        listenerRefiners: {},
        optionRefiners: {},
        propSetHandlers: {}
    };
    function addDefs(defs) {
        for(var _i = 0, defs_1 = defs; _i < defs_1.length; _i++){
            var def = defs_1[_i];
            if (!isAdded[def.id]) {
                isAdded[def.id] = true;
                addDefs(def.deps);
                hooks = combineHooks(hooks, def);
            }
        }
    }
    if (pluginDefs) addDefs(pluginDefs);
    addDefs(globalDefs);
    return hooks;
}
function buildBuildPluginHooks() {
    var currentOverrideDefs = [];
    var currentGlobalDefs = [];
    var currentHooks;
    return function(overrideDefs, globalDefs) {
        if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) currentHooks = buildPluginHooks(overrideDefs, globalDefs);
        currentOverrideDefs = overrideDefs;
        currentGlobalDefs = globalDefs;
        return currentHooks;
    };
}
function combineHooks(hooks0, hooks1) {
    return {
        reducers: hooks0.reducers.concat(hooks1.reducers),
        isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),
        contextInit: hooks0.contextInit.concat(hooks1.contextInit),
        eventRefiners: _tslib.__assign(_tslib.__assign({}, hooks0.eventRefiners), hooks1.eventRefiners),
        eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),
        eventSourceRefiners: _tslib.__assign(_tslib.__assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),
        isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),
        eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),
        eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),
        dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),
        datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),
        dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),
        views: _tslib.__assign(_tslib.__assign({}, hooks0.views), hooks1.views),
        viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),
        isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,
        externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),
        viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),
        eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),
        calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),
        componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),
        themeClasses: _tslib.__assign(_tslib.__assign({}, hooks0.themeClasses), hooks1.themeClasses),
        eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),
        cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,
        recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),
        namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,
        initialView: hooks0.initialView || hooks1.initialView,
        elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,
        optionChangeHandlers: _tslib.__assign(_tslib.__assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),
        scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,
        contentTypeHandlers: _tslib.__assign(_tslib.__assign({}, hooks0.contentTypeHandlers), hooks1.contentTypeHandlers),
        listenerRefiners: _tslib.__assign(_tslib.__assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),
        optionRefiners: _tslib.__assign(_tslib.__assign({}, hooks0.optionRefiners), hooks1.optionRefiners),
        propSetHandlers: _tslib.__assign(_tslib.__assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)
    };
}
var StandardTheme = /** @class */ function(_super) {
    _tslib.__extends(StandardTheme1, _super);
    function StandardTheme1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StandardTheme1;
}(Theme);
StandardTheme.prototype.classes = {
    root: 'fc-theme-standard',
    tableCellShaded: 'fc-cell-shaded',
    buttonGroup: 'fc-button-group',
    button: 'fc-button fc-button-primary',
    buttonActive: 'fc-button-active'
};
StandardTheme.prototype.baseIconClass = 'fc-icon';
StandardTheme.prototype.iconClasses = {
    close: 'fc-icon-x',
    prev: 'fc-icon-chevron-left',
    next: 'fc-icon-chevron-right',
    prevYear: 'fc-icon-chevrons-left',
    nextYear: 'fc-icon-chevrons-right'
};
StandardTheme.prototype.rtlIconClasses = {
    prev: 'fc-icon-chevron-right',
    next: 'fc-icon-chevron-left',
    prevYear: 'fc-icon-chevrons-right',
    nextYear: 'fc-icon-chevrons-left'
};
StandardTheme.prototype.iconOverrideOption = 'buttonIcons'; // TODO: make TS-friendly
StandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';
StandardTheme.prototype.iconOverridePrefix = 'fc-icon-';
function compileViewDefs(defaultConfigs, overrideConfigs) {
    var hash = {};
    var viewType;
    for(viewType in defaultConfigs)ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
    for(viewType in overrideConfigs)ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
    return hash;
}
function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
    if (hash[viewType]) return hash[viewType];
    var viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);
    if (viewDef) hash[viewType] = viewDef;
    return viewDef;
}
function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
    var defaultConfig = defaultConfigs[viewType];
    var overrideConfig = overrideConfigs[viewType];
    var queryProp = function(name) {
        return defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;
    };
    var theComponent = queryProp('component');
    var superType = queryProp('superType');
    var superDef = null;
    if (superType) {
        if (superType === viewType) throw new Error('Can\'t have a custom view type that references itself');
        superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);
    }
    if (!theComponent && superDef) theComponent = superDef.component;
    if (!theComponent) return null; // don't throw a warning, might be settings for a single-unit view
    return {
        type: viewType,
        component: theComponent,
        defaults: _tslib.__assign(_tslib.__assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),
        overrides: _tslib.__assign(_tslib.__assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})
    };
}
/* eslint max-classes-per-file: off */ // NOTE: in JSX, you should always use this class with <HookProps> arg. otherwise, will default to any???
var RenderHook = /** @class */ function(_super) {
    _tslib.__extends(RenderHook1, _super);
    function RenderHook1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.rootElRef = _vdomJs.createRef();
        _this.handleRootEl = function(el) {
            setRef(_this.rootElRef, el);
            if (_this.props.elRef) setRef(_this.props.elRef, el);
        };
        return _this;
    }
    RenderHook1.prototype.render = function() {
        var _this = this;
        var props = this.props;
        var hookProps = props.hookProps;
        return _vdomJs.createElement(MountHook, {
            hookProps: hookProps,
            didMount: props.didMount,
            willUnmount: props.willUnmount,
            elRef: this.handleRootEl
        }, function(rootElRef) {
            return _vdomJs.createElement(ContentHook, {
                hookProps: hookProps,
                content: props.content,
                defaultContent: props.defaultContent,
                backupElRef: _this.rootElRef
            }, function(innerElRef, innerContent) {
                return props.children(rootElRef, normalizeClassNames(props.classNames, hookProps), innerElRef, innerContent);
            });
        });
    };
    return RenderHook1;
}(BaseComponent);
// TODO: rename to be about function, not default. use in above type
// for forcing rerender of components that use the ContentHook
var CustomContentRenderContext = _vdomJs.createContext(0);
function ContentHook(props) {
    return _vdomJs.createElement(CustomContentRenderContext.Consumer, null, function(renderId) {
        return _vdomJs.createElement(ContentHookInner, _tslib.__assign({
            renderId: renderId
        }, props));
    });
}
var ContentHookInner = /** @class */ function(_super) {
    _tslib.__extends(ContentHookInner1, _super);
    function ContentHookInner1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.innerElRef = _vdomJs.createRef();
        return _this;
    }
    ContentHookInner1.prototype.render = function() {
        return this.props.children(this.innerElRef, this.renderInnerContent());
    };
    ContentHookInner1.prototype.componentDidMount = function() {
        this.updateCustomContent();
    };
    ContentHookInner1.prototype.componentDidUpdate = function() {
        this.updateCustomContent();
    };
    ContentHookInner1.prototype.componentWillUnmount = function() {
        if (this.customContentInfo && this.customContentInfo.destroy) this.customContentInfo.destroy();
    };
    ContentHookInner1.prototype.renderInnerContent = function() {
        var customContentInfo = this.customContentInfo; // only populated if using non-[p]react node(s)
        var innerContent = this.getInnerContent();
        var meta = this.getContentMeta(innerContent);
        // initial run, or content-type changing? (from vue -> react for example)
        if (!customContentInfo || customContentInfo.contentKey !== meta.contentKey) {
            // clearing old value
            if (customContentInfo) {
                if (customContentInfo.destroy) customContentInfo.destroy();
                customContentInfo = this.customContentInfo = null;
            }
            // assigning new value
            if (meta.contentKey) customContentInfo = this.customContentInfo = _tslib.__assign({
                contentKey: meta.contentKey,
                contentVal: innerContent[meta.contentKey]
            }, meta.buildLifecycleFuncs());
        // updating
        } else if (customContentInfo) customContentInfo.contentVal = innerContent[meta.contentKey];
        return customContentInfo ? [] // signal that something was specified
         : innerContent; // assume a [p]react vdom node. use it
    };
    ContentHookInner1.prototype.getInnerContent = function() {
        var props = this.props;
        var innerContent = normalizeContent(props.content, props.hookProps);
        if (innerContent === undefined) innerContent = normalizeContent(props.defaultContent, props.hookProps);
        return innerContent == null ? null : innerContent; // convert undefined to null (better for React)
    };
    ContentHookInner1.prototype.getContentMeta = function(innerContent) {
        var contentTypeHandlers = this.context.pluginHooks.contentTypeHandlers;
        var contentKey = '';
        var buildLifecycleFuncs = null;
        if (innerContent) {
            for(var searchKey in contentTypeHandlers)if (innerContent[searchKey] !== undefined) {
                contentKey = searchKey;
                buildLifecycleFuncs = contentTypeHandlers[searchKey];
                break;
            }
        }
        return {
            contentKey: contentKey,
            buildLifecycleFuncs: buildLifecycleFuncs
        };
    };
    ContentHookInner1.prototype.updateCustomContent = function() {
        if (this.customContentInfo) this.customContentInfo.render(this.innerElRef.current || this.props.backupElRef.current, this.customContentInfo.contentVal);
    };
    return ContentHookInner1;
}(BaseComponent);
var MountHook = /** @class */ function(_super) {
    _tslib.__extends(MountHook1, _super);
    function MountHook1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.handleRootEl = function(rootEl) {
            _this.rootEl = rootEl;
            if (_this.props.elRef) setRef(_this.props.elRef, rootEl);
        };
        return _this;
    }
    MountHook1.prototype.render = function() {
        return this.props.children(this.handleRootEl);
    };
    MountHook1.prototype.componentDidMount = function() {
        var callback = this.props.didMount;
        if (callback) callback(_tslib.__assign(_tslib.__assign({}, this.props.hookProps), {
            el: this.rootEl
        }));
    };
    MountHook1.prototype.componentWillUnmount = function() {
        var callback = this.props.willUnmount;
        if (callback) callback(_tslib.__assign(_tslib.__assign({}, this.props.hookProps), {
            el: this.rootEl
        }));
    };
    return MountHook1;
}(BaseComponent);
function buildClassNameNormalizer() {
    var currentGenerator;
    var currentHookProps;
    var currentClassNames = [];
    return function(generator, hookProps) {
        if (!currentHookProps || !isPropsEqual(currentHookProps, hookProps) || generator !== currentGenerator) {
            currentGenerator = generator;
            currentHookProps = hookProps;
            currentClassNames = normalizeClassNames(generator, hookProps);
        }
        return currentClassNames;
    };
}
function normalizeClassNames(classNames, hookProps) {
    if (typeof classNames === 'function') classNames = classNames(hookProps);
    return parseClassNames(classNames);
}
function normalizeContent(input, hookProps) {
    if (typeof input === 'function') return input(hookProps, _vdomJs.createElement); // give the function the vdom-creation func
    return input;
}
var ViewRoot = /** @class */ function(_super) {
    _tslib.__extends(ViewRoot1, _super);
    function ViewRoot1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.normalizeClassNames = buildClassNameNormalizer();
        return _this;
    }
    ViewRoot1.prototype.render = function() {
        var _a = this, props = _a.props, context = _a.context;
        var options = context.options;
        var hookProps = {
            view: context.viewApi
        };
        var customClassNames = this.normalizeClassNames(options.viewClassNames, hookProps);
        return _vdomJs.createElement(MountHook, {
            hookProps: hookProps,
            didMount: options.viewDidMount,
            willUnmount: options.viewWillUnmount,
            elRef: props.elRef
        }, function(rootElRef) {
            return props.children(rootElRef, [
                "fc-" + props.viewSpec.type + "-view",
                'fc-view'
            ].concat(customClassNames));
        });
    };
    return ViewRoot1;
}(BaseComponent);
function parseViewConfigs(inputs) {
    return mapHash(inputs, parseViewConfig);
}
function parseViewConfig(input) {
    var rawOptions = typeof input === 'function' ? {
        component: input
    } : input;
    var component = rawOptions.component;
    if (rawOptions.content) component = createViewHookComponent(rawOptions);
    return {
        superType: rawOptions.type,
        component: component,
        rawOptions: rawOptions
    };
}
function createViewHookComponent(options) {
    return function(viewProps) {
        return _vdomJs.createElement(ViewContextType.Consumer, null, function(context) {
            return _vdomJs.createElement(ViewRoot, {
                viewSpec: context.viewSpec
            }, function(viewElRef, viewClassNames) {
                var hookProps = _tslib.__assign(_tslib.__assign({}, viewProps), {
                    nextDayThreshold: context.options.nextDayThreshold
                });
                return _vdomJs.createElement(RenderHook, {
                    hookProps: hookProps,
                    classNames: options.classNames,
                    content: options.content,
                    didMount: options.didMount,
                    willUnmount: options.willUnmount,
                    elRef: viewElRef
                }, function(rootElRef, customClassNames, innerElRef, innerContent) {
                    return _vdomJs.createElement("div", {
                        className: viewClassNames.concat(customClassNames).join(' '),
                        ref: rootElRef
                    }, innerContent);
                });
            });
        });
    };
}
function buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
    var defaultConfigs = parseViewConfigs(defaultInputs);
    var overrideConfigs = parseViewConfigs(optionOverrides.views);
    var viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);
    return mapHash(viewDefs, function(viewDef) {
        return buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults);
    });
}
function buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
    var durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;
    var duration = null;
    var durationUnit = '';
    var singleUnit = '';
    var singleUnitOverrides = {};
    if (durationInput) {
        duration = createDurationCached(durationInput);
        if (duration) {
            var denom = greatestDurationDenominator(duration);
            durationUnit = denom.unit;
            if (denom.value === 1) {
                singleUnit = durationUnit;
                singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};
            }
        }
    }
    var queryButtonText = function(optionsSubset) {
        var buttonTextMap = optionsSubset.buttonText || {};
        var buttonTextKey = viewDef.defaults.buttonTextKey;
        if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) return buttonTextMap[buttonTextKey];
        if (buttonTextMap[viewDef.type] != null) return buttonTextMap[viewDef.type];
        if (buttonTextMap[singleUnit] != null) return buttonTextMap[singleUnit];
        return null;
    };
    var queryButtonTitle = function(optionsSubset) {
        var buttonHints = optionsSubset.buttonHints || {};
        var buttonKey = viewDef.defaults.buttonTextKey; // use same key as text
        if (buttonKey != null && buttonHints[buttonKey] != null) return buttonHints[buttonKey];
        if (buttonHints[viewDef.type] != null) return buttonHints[viewDef.type];
        if (buttonHints[singleUnit] != null) return buttonHints[singleUnit];
        return null;
    };
    return {
        type: viewDef.type,
        component: viewDef.component,
        duration: duration,
        durationUnit: durationUnit,
        singleUnit: singleUnit,
        optionDefaults: viewDef.defaults,
        optionOverrides: _tslib.__assign(_tslib.__assign({}, singleUnitOverrides), viewDef.overrides),
        buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || viewDef.overrides.buttonText,
        buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type,
        // not DRY
        buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,
        buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(BASE_OPTION_DEFAULTS)
    };
}
// hack to get memoization working
var durationInputMap = {};
function createDurationCached(durationInput) {
    var json = JSON.stringify(durationInput);
    var res = durationInputMap[json];
    if (res === undefined) {
        res = createDuration(durationInput);
        durationInputMap[json] = res;
    }
    return res;
}
var DateProfileGenerator = /** @class */ function() {
    function DateProfileGenerator1(props) {
        this.props = props;
        this.nowDate = getNow(props.nowInput, props.dateEnv);
        this.initHiddenDays();
    }
    /* Date Range Computation
    ------------------------------------------------------------------------------------------------------------------*/ // Builds a structure with info about what the dates/ranges will be for the "prev" view.
    DateProfileGenerator1.prototype.buildPrev = function(currentDateProfile, currentDate, forceToValid) {
        var dateEnv = this.props.dateEnv;
        var prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);
        return this.build(prevDate, -1, forceToValid);
    };
    // Builds a structure with info about what the dates/ranges will be for the "next" view.
    DateProfileGenerator1.prototype.buildNext = function(currentDateProfile, currentDate, forceToValid) {
        var dateEnv = this.props.dateEnv;
        var nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);
        return this.build(nextDate, 1, forceToValid);
    };
    // Builds a structure holding dates/ranges for rendering around the given date.
    // Optional direction param indicates whether the date is being incremented/decremented
    // from its previous value. decremented = -1, incremented = 1 (default).
    DateProfileGenerator1.prototype.build = function(currentDate, direction, forceToValid) {
        if (forceToValid === void 0) forceToValid = true;
        var props = this.props;
        var validRange;
        var currentInfo;
        var isRangeAllDay;
        var renderRange;
        var activeRange;
        var isValid;
        validRange = this.buildValidRange();
        validRange = this.trimHiddenDays(validRange);
        if (forceToValid) currentDate = constrainMarkerToRange(currentDate, validRange);
        currentInfo = this.buildCurrentRangeInfo(currentDate, direction);
        isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
        renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);
        renderRange = this.trimHiddenDays(renderRange);
        activeRange = renderRange;
        if (!props.showNonCurrentDates) activeRange = intersectRanges(activeRange, currentInfo.range);
        activeRange = this.adjustActiveRange(activeRange);
        activeRange = intersectRanges(activeRange, validRange); // might return null
        // it's invalid if the originally requested date is not contained,
        // or if the range is completely outside of the valid range.
        isValid = rangesIntersect(currentInfo.range, validRange);
        return {
            // constraint for where prev/next operations can go and where events can be dragged/resized to.
            // an object with optional start and end properties.
            validRange: validRange,
            // range the view is formally responsible for.
            // for example, a month view might have 1st-31st, excluding padded dates
            currentRange: currentInfo.range,
            // name of largest unit being displayed, like "month" or "week"
            currentRangeUnit: currentInfo.unit,
            isRangeAllDay: isRangeAllDay,
            // dates that display events and accept drag-n-drop
            // will be `null` if no dates accept events
            activeRange: activeRange,
            // date range with a rendered skeleton
            // includes not-active days that need some sort of DOM
            renderRange: renderRange,
            // Duration object that denotes the first visible time of any given day
            slotMinTime: props.slotMinTime,
            // Duration object that denotes the exclusive visible end time of any given day
            slotMaxTime: props.slotMaxTime,
            isValid: isValid,
            // how far the current date will move for a prev/next operation
            dateIncrement: this.buildDateIncrement(currentInfo.duration)
        };
    };
    // Builds an object with optional start/end properties.
    // Indicates the minimum/maximum dates to display.
    // not responsible for trimming hidden days.
    DateProfileGenerator1.prototype.buildValidRange = function() {
        var input = this.props.validRangeInput;
        var simpleInput = typeof input === 'function' ? input.call(this.props.calendarApi, this.nowDate) : input;
        return this.refineRange(simpleInput) || {
            start: null,
            end: null
        }; // completely open-ended
    };
    // Builds a structure with info about the "current" range, the range that is
    // highlighted as being the current month for example.
    // See build() for a description of `direction`.
    // Guaranteed to have `range` and `unit` properties. `duration` is optional.
    DateProfileGenerator1.prototype.buildCurrentRangeInfo = function(date, direction) {
        var props = this.props;
        var duration = null;
        var unit = null;
        var range = null;
        var dayCount;
        if (props.duration) {
            duration = props.duration;
            unit = props.durationUnit;
            range = this.buildRangeFromDuration(date, direction, duration, unit);
        } else if (dayCount = this.props.dayCount) {
            unit = 'day';
            range = this.buildRangeFromDayCount(date, direction, dayCount);
        } else if (range = this.buildCustomVisibleRange(date)) unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;
        else {
            duration = this.getFallbackDuration();
            unit = greatestDurationDenominator(duration).unit;
            range = this.buildRangeFromDuration(date, direction, duration, unit);
        }
        return {
            duration: duration,
            unit: unit,
            range: range
        };
    };
    DateProfileGenerator1.prototype.getFallbackDuration = function() {
        return createDuration({
            day: 1
        });
    };
    // Returns a new activeRange to have time values (un-ambiguate)
    // slotMinTime or slotMaxTime causes the range to expand.
    DateProfileGenerator1.prototype.adjustActiveRange = function(range) {
        var _a = this.props, dateEnv = _a.dateEnv, usesMinMaxTime = _a.usesMinMaxTime, slotMinTime = _a.slotMinTime, slotMaxTime = _a.slotMaxTime;
        var start = range.start, end = range.end;
        if (usesMinMaxTime) {
            // expand active range if slotMinTime is negative (why not when positive?)
            if (asRoughDays(slotMinTime) < 0) {
                start = startOfDay(start); // necessary?
                start = dateEnv.add(start, slotMinTime);
            }
            // expand active range if slotMaxTime is beyond one day (why not when negative?)
            if (asRoughDays(slotMaxTime) > 1) {
                end = startOfDay(end); // necessary?
                end = addDays(end, -1);
                end = dateEnv.add(end, slotMaxTime);
            }
        }
        return {
            start: start,
            end: end
        };
    };
    // Builds the "current" range when it is specified as an explicit duration.
    // `unit` is the already-computed greatestDurationDenominator unit of duration.
    DateProfileGenerator1.prototype.buildRangeFromDuration = function(date, direction, duration, unit) {
        var _a = this.props, dateEnv = _a.dateEnv, dateAlignment = _a.dateAlignment;
        var start;
        var end;
        var res;
        // compute what the alignment should be
        if (!dateAlignment) {
            var dateIncrement = this.props.dateIncrement;
            if (dateIncrement) {
                // use the smaller of the two units
                if (asRoughMs(dateIncrement) < asRoughMs(duration)) dateAlignment = greatestDurationDenominator(dateIncrement).unit;
                else dateAlignment = unit;
            } else dateAlignment = unit;
        }
        // if the view displays a single day or smaller
        if (asRoughDays(duration) <= 1) {
            if (this.isHiddenDay(start)) {
                start = this.skipHiddenDays(start, direction);
                start = startOfDay(start);
            }
        }
        function computeRes() {
            start = dateEnv.startOf(date, dateAlignment);
            end = dateEnv.add(start, duration);
            res = {
                start: start,
                end: end
            };
        }
        computeRes();
        // if range is completely enveloped by hidden days, go past the hidden days
        if (!this.trimHiddenDays(res)) {
            date = this.skipHiddenDays(date, direction);
            computeRes();
        }
        return res;
    };
    // Builds the "current" range when a dayCount is specified.
    DateProfileGenerator1.prototype.buildRangeFromDayCount = function(date, direction, dayCount) {
        var _a = this.props, dateEnv = _a.dateEnv, dateAlignment = _a.dateAlignment;
        var runningCount = 0;
        var start = date;
        var end;
        if (dateAlignment) start = dateEnv.startOf(start, dateAlignment);
        start = startOfDay(start);
        start = this.skipHiddenDays(start, direction);
        end = start;
        do {
            end = addDays(end, 1);
            if (!this.isHiddenDay(end)) runningCount += 1;
        }while (runningCount < dayCount)
        return {
            start: start,
            end: end
        };
    };
    // Builds a normalized range object for the "visible" range,
    // which is a way to define the currentRange and activeRange at the same time.
    DateProfileGenerator1.prototype.buildCustomVisibleRange = function(date) {
        var props = this.props;
        var input = props.visibleRangeInput;
        var simpleInput = typeof input === 'function' ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;
        var range = this.refineRange(simpleInput);
        if (range && (range.start == null || range.end == null)) return null;
        return range;
    };
    // Computes the range that will represent the element/cells for *rendering*,
    // but which may have voided days/times.
    // not responsible for trimming hidden days.
    DateProfileGenerator1.prototype.buildRenderRange = function(currentRange, currentRangeUnit, isRangeAllDay) {
        return currentRange;
    };
    // Compute the duration value that should be added/substracted to the current date
    // when a prev/next operation happens.
    DateProfileGenerator1.prototype.buildDateIncrement = function(fallback) {
        var dateIncrement = this.props.dateIncrement;
        var customAlignment;
        if (dateIncrement) return dateIncrement;
        if (customAlignment = this.props.dateAlignment) return createDuration(1, customAlignment);
        if (fallback) return fallback;
        return createDuration({
            days: 1
        });
    };
    DateProfileGenerator1.prototype.refineRange = function(rangeInput) {
        if (rangeInput) {
            var range = parseRange(rangeInput, this.props.dateEnv);
            if (range) range = computeVisibleDayRange(range);
            return range;
        }
        return null;
    };
    /* Hidden Days
    ------------------------------------------------------------------------------------------------------------------*/ // Initializes internal variables related to calculating hidden days-of-week
    DateProfileGenerator1.prototype.initHiddenDays = function() {
        var hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden
        var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)
        var dayCnt = 0;
        var i;
        if (this.props.weekends === false) hiddenDays.push(0, 6); // 0=sunday, 6=saturday
        for(i = 0; i < 7; i += 1)if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) dayCnt += 1;
        if (!dayCnt) throw new Error('invalid hiddenDays'); // all days were hidden? bad.
        this.isHiddenDayHash = isHiddenDayHash;
    };
    // Remove days from the beginning and end of the range that are computed as hidden.
    // If the whole range is trimmed off, returns null
    DateProfileGenerator1.prototype.trimHiddenDays = function(range) {
        var start = range.start, end = range.end;
        if (start) start = this.skipHiddenDays(start);
        if (end) end = this.skipHiddenDays(end, -1, true);
        if (start == null || end == null || start < end) return {
            start: start,
            end: end
        };
        return null;
    };
    // Is the current day hidden?
    // `day` is a day-of-week index (0-6), or a Date (used for UTC)
    DateProfileGenerator1.prototype.isHiddenDay = function(day) {
        if (day instanceof Date) day = day.getUTCDay();
        return this.isHiddenDayHash[day];
    };
    // Incrementing the current day until it is no longer a hidden day, returning a copy.
    // DOES NOT CONSIDER validRange!
    // If the initial value of `date` is not a hidden day, don't do anything.
    // Pass `isExclusive` as `true` if you are dealing with an end date.
    // `inc` defaults to `1` (increment one day forward each time)
    DateProfileGenerator1.prototype.skipHiddenDays = function(date, inc, isExclusive) {
        if (inc === void 0) inc = 1;
        if (isExclusive === void 0) isExclusive = false;
        while(this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7])date = addDays(date, inc);
        return date;
    };
    return DateProfileGenerator1;
}();
function reduceViewType(viewType, action) {
    switch(action.type){
        case 'CHANGE_VIEW_TYPE':
            viewType = action.viewType;
    }
    return viewType;
}
function reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {
    var _a;
    switch(action.type){
        case 'SET_OPTION':
            return _tslib.__assign(_tslib.__assign({}, dynamicOptionOverrides), (_a = {}, _a[action.optionName] = action.rawOptionValue, _a));
        default:
            return dynamicOptionOverrides;
    }
}
function reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {
    var dp;
    switch(action.type){
        case 'CHANGE_VIEW_TYPE':
            return dateProfileGenerator.build(action.dateMarker || currentDate);
        case 'CHANGE_DATE':
            return dateProfileGenerator.build(action.dateMarker);
        case 'PREV':
            dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);
            if (dp.isValid) return dp;
            break;
        case 'NEXT':
            dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);
            if (dp.isValid) return dp;
            break;
    }
    return currentDateProfile;
}
function initEventSources(calendarOptions, dateProfile, context) {
    var activeRange = dateProfile ? dateProfile.activeRange : null;
    return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);
}
function reduceEventSources(eventSources, action, dateProfile, context) {
    var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?
    switch(action.type){
        case 'ADD_EVENT_SOURCES':
            return addSources(eventSources, action.sources, activeRange, context);
        case 'REMOVE_EVENT_SOURCE':
            return removeSource(eventSources, action.sourceId);
        case 'PREV':
        case 'NEXT':
        case 'CHANGE_DATE':
        case 'CHANGE_VIEW_TYPE':
            if (dateProfile) return fetchDirtySources(eventSources, activeRange, context);
            return eventSources;
        case 'FETCH_EVENT_SOURCES':
            return fetchSourcesByIds(eventSources, action.sourceIds ? arrayToHash(action.sourceIds) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);
        case 'RECEIVE_EVENTS':
        case 'RECEIVE_EVENT_ERROR':
            return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);
        case 'REMOVE_ALL_EVENT_SOURCES':
            return {};
        default:
            return eventSources;
    }
}
function reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {
    var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?
    return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);
}
function computeEventSourcesLoading(eventSources) {
    for(var sourceId in eventSources){
        if (eventSources[sourceId].isFetching) return true;
    }
    return false;
}
function addSources(eventSourceHash, sources, fetchRange, context) {
    var hash = {};
    for(var _i = 0, sources_1 = sources; _i < sources_1.length; _i++){
        var source = sources_1[_i];
        hash[source.sourceId] = source;
    }
    if (fetchRange) hash = fetchDirtySources(hash, fetchRange, context);
    return _tslib.__assign(_tslib.__assign({}, eventSourceHash), hash);
}
function removeSource(eventSourceHash, sourceId) {
    return filterHash(eventSourceHash, function(eventSource) {
        return eventSource.sourceId !== sourceId;
    });
}
function fetchDirtySources(sourceHash, fetchRange, context) {
    return fetchSourcesByIds(sourceHash, filterHash(sourceHash, function(eventSource) {
        return isSourceDirty(eventSource, fetchRange, context);
    }), fetchRange, false, context);
}
function isSourceDirty(eventSource, fetchRange, context) {
    if (!doesSourceNeedRange(eventSource, context)) return !eventSource.latestFetchId;
    return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;
}
function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {
    var nextSources = {};
    for(var sourceId in prevSources){
        var source = prevSources[sourceId];
        if (sourceIdHash[sourceId]) nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);
        else nextSources[sourceId] = source;
    }
    return nextSources;
}
function fetchSource(eventSource, fetchRange, isRefetch, context) {
    var options = context.options, calendarApi = context.calendarApi;
    var sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];
    var fetchId = guid();
    sourceDef.fetch({
        eventSource: eventSource,
        range: fetchRange,
        isRefetch: isRefetch,
        context: context
    }, function(res) {
        var rawEvents = res.rawEvents;
        if (options.eventSourceSuccess) rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.xhr) || rawEvents;
        if (eventSource.success) rawEvents = eventSource.success.call(calendarApi, rawEvents, res.xhr) || rawEvents;
        context.dispatch({
            type: 'RECEIVE_EVENTS',
            sourceId: eventSource.sourceId,
            fetchId: fetchId,
            fetchRange: fetchRange,
            rawEvents: rawEvents
        });
    }, function(error) {
        console.warn(error.message, error);
        if (options.eventSourceFailure) options.eventSourceFailure.call(calendarApi, error);
        if (eventSource.failure) eventSource.failure(error);
        context.dispatch({
            type: 'RECEIVE_EVENT_ERROR',
            sourceId: eventSource.sourceId,
            fetchId: fetchId,
            fetchRange: fetchRange,
            error: error
        });
    });
    return _tslib.__assign(_tslib.__assign({}, eventSource), {
        isFetching: true,
        latestFetchId: fetchId
    });
}
function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {
    var _a;
    var eventSource = sourceHash[sourceId];
    if (eventSource && fetchId === eventSource.latestFetchId) return _tslib.__assign(_tslib.__assign({}, sourceHash), (_a = {}, _a[sourceId] = _tslib.__assign(_tslib.__assign({}, eventSource), {
        isFetching: false,
        fetchRange: fetchRange
    }), _a));
    return sourceHash;
}
function excludeStaticSources(eventSources, context) {
    return filterHash(eventSources, function(eventSource) {
        return doesSourceNeedRange(eventSource, context);
    });
}
function parseInitialSources(rawOptions, context) {
    var refiners = buildEventSourceRefiners(context);
    var rawSources = [].concat(rawOptions.eventSources || []);
    var sources = []; // parsed
    if (rawOptions.initialEvents) rawSources.unshift(rawOptions.initialEvents);
    if (rawOptions.events) rawSources.unshift(rawOptions.events);
    for(var _i = 0, rawSources_1 = rawSources; _i < rawSources_1.length; _i++){
        var rawSource = rawSources_1[_i];
        var source = parseEventSource(rawSource, context, refiners);
        if (source) sources.push(source);
    }
    return sources;
}
function doesSourceNeedRange(eventSource, context) {
    var defs = context.pluginHooks.eventSourceDefs;
    return !defs[eventSource.sourceDefId].ignoreRange;
}
function reduceEventStore(eventStore, action, eventSources, dateProfile, context) {
    switch(action.type){
        case 'RECEIVE_EVENTS':
            return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);
        case 'ADD_EVENTS':
            return addEvent(eventStore, action.eventStore, dateProfile ? dateProfile.activeRange : null, context);
        case 'RESET_EVENTS':
            return action.eventStore;
        case 'MERGE_EVENTS':
            return mergeEventStores(eventStore, action.eventStore);
        case 'PREV':
        case 'NEXT':
        case 'CHANGE_DATE':
        case 'CHANGE_VIEW_TYPE':
            if (dateProfile) return expandRecurring(eventStore, dateProfile.activeRange, context);
            return eventStore;
        case 'REMOVE_EVENTS':
            return excludeSubEventStore(eventStore, action.eventStore);
        case 'REMOVE_EVENT_SOURCE':
            return excludeEventsBySourceId(eventStore, action.sourceId);
        case 'REMOVE_ALL_EVENT_SOURCES':
            return filterEventStoreDefs(eventStore, function(eventDef) {
                return !eventDef.sourceId // only keep events with no source id
                ;
            });
        case 'REMOVE_ALL_EVENTS':
            return createEmptyEventStore();
        default:
            return eventStore;
    }
}
function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {
    if (eventSource && fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources
    ) {
        var subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);
        if (fetchRange) subset = expandRecurring(subset, fetchRange, context);
        return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);
    }
    return eventStore;
}
function transformRawEvents(rawEvents, eventSource, context) {
    var calEachTransform = context.options.eventDataTransform;
    var sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;
    if (sourceEachTransform) rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);
    if (calEachTransform) rawEvents = transformEachRawEvent(rawEvents, calEachTransform);
    return rawEvents;
}
function transformEachRawEvent(rawEvents, func) {
    var refinedEvents;
    if (!func) refinedEvents = rawEvents;
    else {
        refinedEvents = [];
        for(var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++){
            var rawEvent = rawEvents_1[_i];
            var refinedEvent = func(rawEvent);
            if (refinedEvent) refinedEvents.push(refinedEvent);
            else if (refinedEvent == null) refinedEvents.push(rawEvent);
             // if a different falsy value, do nothing
        }
    }
    return refinedEvents;
}
function addEvent(eventStore, subset, expandRange, context) {
    if (expandRange) subset = expandRecurring(subset, expandRange, context);
    return mergeEventStores(eventStore, subset);
}
function rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {
    var defs = eventStore.defs;
    var instances = mapHash(eventStore.instances, function(instance) {
        var def = defs[instance.defId];
        if (def.allDay || def.recurringDef) return instance; // isn't dependent on timezone
        return _tslib.__assign(_tslib.__assign({}, instance), {
            range: {
                start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),
                end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))
            },
            forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo,
            forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo
        });
    });
    return {
        defs: defs,
        instances: instances
    };
}
function excludeEventsBySourceId(eventStore, sourceId) {
    return filterEventStoreDefs(eventStore, function(eventDef) {
        return eventDef.sourceId !== sourceId;
    });
}
// QUESTION: why not just return instances? do a general object-property-exclusion util
function excludeInstances(eventStore, removals) {
    return {
        defs: eventStore.defs,
        instances: filterHash(eventStore.instances, function(instance) {
            return !removals[instance.instanceId];
        })
    };
}
function reduceDateSelection(currentSelection, action) {
    switch(action.type){
        case 'UNSELECT_DATES':
            return null;
        case 'SELECT_DATES':
            return action.selection;
        default:
            return currentSelection;
    }
}
function reduceSelectedEvent(currentInstanceId, action) {
    switch(action.type){
        case 'UNSELECT_EVENT':
            return '';
        case 'SELECT_EVENT':
            return action.eventInstanceId;
        default:
            return currentInstanceId;
    }
}
function reduceEventDrag(currentDrag, action) {
    var newDrag;
    switch(action.type){
        case 'UNSET_EVENT_DRAG':
            return null;
        case 'SET_EVENT_DRAG':
            newDrag = action.state;
            return {
                affectedEvents: newDrag.affectedEvents,
                mutatedEvents: newDrag.mutatedEvents,
                isEvent: newDrag.isEvent
            };
        default:
            return currentDrag;
    }
}
function reduceEventResize(currentResize, action) {
    var newResize;
    switch(action.type){
        case 'UNSET_EVENT_RESIZE':
            return null;
        case 'SET_EVENT_RESIZE':
            newResize = action.state;
            return {
                affectedEvents: newResize.affectedEvents,
                mutatedEvents: newResize.mutatedEvents,
                isEvent: newResize.isEvent
            };
        default:
            return currentResize;
    }
}
function parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
    var header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
    var footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
    return {
        header: header,
        footer: footer
    };
}
function parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
    var sectionWidgets = {};
    var viewsWithButtons = [];
    var hasTitle = false;
    for(var sectionName in sectionStrHash){
        var sectionStr = sectionStrHash[sectionName];
        var sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);
        sectionWidgets[sectionName] = sectionRes.widgets;
        viewsWithButtons.push.apply(viewsWithButtons, sectionRes.viewsWithButtons);
        hasTitle = hasTitle || sectionRes.hasTitle;
    }
    return {
        sectionWidgets: sectionWidgets,
        viewsWithButtons: viewsWithButtons,
        hasTitle: hasTitle
    };
}
/*
BAD: querying icons and text here. should be done at render time
*/ function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
    var isRtl = calendarOptions.direction === 'rtl';
    var calendarCustomButtons = calendarOptions.customButtons || {};
    var calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};
    var calendarButtonText = calendarOptions.buttonText || {};
    var calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};
    var calendarButtonHints = calendarOptions.buttonHints || {};
    var sectionSubstrs = sectionStr ? sectionStr.split(' ') : [];
    var viewsWithButtons = [];
    var hasTitle = false;
    var widgets = sectionSubstrs.map(function(buttonGroupStr) {
        return buttonGroupStr.split(',').map(function(buttonName) {
            if (buttonName === 'title') {
                hasTitle = true;
                return {
                    buttonName: buttonName
                };
            }
            var customButtonProps;
            var viewSpec;
            var buttonClick;
            var buttonIcon; // only one of these will be set
            var buttonText; // "
            var buttonHint;
            // ^ for the title="" attribute, for accessibility
            if (customButtonProps = calendarCustomButtons[buttonName]) {
                buttonClick = function(ev) {
                    if (customButtonProps.click) customButtonProps.click.call(ev.target, ev, ev.target); // TODO: use Calendar this context?
                };
                (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);
                buttonHint = customButtonProps.hint || customButtonProps.text;
            } else if (viewSpec = viewSpecs[buttonName]) {
                viewsWithButtons.push(buttonName);
                buttonClick = function() {
                    calendarApi.changeView(buttonName);
                };
                (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);
                var textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;
                buttonHint = formatWithOrdinals(viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint, [
                    textFallback,
                    buttonName
                ], textFallback);
            } else if (calendarApi[buttonName]) {
                buttonClick = function() {
                    calendarApi[buttonName]();
                };
                (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]); // everything else is considered default
                if (buttonName === 'prevYear' || buttonName === 'nextYear') {
                    var prevOrNext = buttonName === 'prevYear' ? 'prev' : 'next';
                    buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [
                        calendarButtonText.year || 'year',
                        'year', 
                    ], calendarButtonText[buttonName]);
                } else buttonHint = function(navUnit) {
                    return formatWithOrdinals(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [
                        calendarButtonText[navUnit] || navUnit,
                        navUnit, 
                    ], calendarButtonText[buttonName]);
                };
            }
            return {
                buttonName: buttonName,
                buttonClick: buttonClick,
                buttonIcon: buttonIcon,
                buttonText: buttonText,
                buttonHint: buttonHint
            };
        });
    });
    return {
        widgets: widgets,
        viewsWithButtons: viewsWithButtons,
        hasTitle: hasTitle
    };
}
var eventSourceDef$2 = {
    ignoreRange: true,
    parseMeta: function(refined) {
        if (Array.isArray(refined.events)) return refined.events;
        return null;
    },
    fetch: function(arg, success) {
        success({
            rawEvents: arg.eventSource.meta
        });
    }
};
var arrayEventSourcePlugin = createPlugin({
    eventSourceDefs: [
        eventSourceDef$2
    ]
});
var eventSourceDef$1 = {
    parseMeta: function(refined) {
        if (typeof refined.events === 'function') return refined.events;
        return null;
    },
    fetch: function(arg, success, failure) {
        var dateEnv = arg.context.dateEnv;
        var func = arg.eventSource.meta;
        unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), function(rawEvents) {
            success({
                rawEvents: rawEvents
            }); // needs an object response
        }, failure);
    }
};
var funcEventSourcePlugin = createPlugin({
    eventSourceDefs: [
        eventSourceDef$1
    ]
});
function requestJson(method, url, params, successCallback, failureCallback) {
    method = method.toUpperCase();
    var body = null;
    if (method === 'GET') url = injectQueryStringParams(url, params);
    else body = encodeParams(params);
    var xhr = new XMLHttpRequest();
    xhr.open(method, url, true);
    if (method !== 'GET') xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 400) {
            var parsed = false;
            var res = void 0;
            try {
                res = JSON.parse(xhr.responseText);
                parsed = true;
            } catch (err) {
            // will handle parsed=false
            }
            if (parsed) successCallback(res, xhr);
            else failureCallback('Failure parsing JSON', xhr);
        } else failureCallback('Request failed', xhr);
    };
    xhr.onerror = function() {
        failureCallback('Request failed', xhr);
    };
    xhr.send(body);
}
function injectQueryStringParams(url, params) {
    return url + (url.indexOf('?') === -1 ? '?' : '&') + encodeParams(params);
}
function encodeParams(params) {
    var parts = [];
    for(var key in params)parts.push(encodeURIComponent(key) + "=" + encodeURIComponent(params[key]));
    return parts.join('&');
}
var JSON_FEED_EVENT_SOURCE_REFINERS = {
    method: String,
    extraParams: identity,
    startParam: String,
    endParam: String,
    timeZoneParam: String
};
var eventSourceDef = {
    parseMeta: function(refined) {
        if (refined.url && (refined.format === 'json' || !refined.format)) return {
            url: refined.url,
            format: 'json',
            method: (refined.method || 'GET').toUpperCase(),
            extraParams: refined.extraParams,
            startParam: refined.startParam,
            endParam: refined.endParam,
            timeZoneParam: refined.timeZoneParam
        };
        return null;
    },
    fetch: function(arg, success, failure) {
        var meta = arg.eventSource.meta;
        var requestParams = buildRequestParams(meta, arg.range, arg.context);
        requestJson(meta.method, meta.url, requestParams, function(rawEvents, xhr) {
            success({
                rawEvents: rawEvents,
                xhr: xhr
            });
        }, function(errorMessage, xhr) {
            failure({
                message: errorMessage,
                xhr: xhr
            });
        });
    }
};
var jsonFeedEventSourcePlugin = createPlugin({
    eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,
    eventSourceDefs: [
        eventSourceDef
    ]
});
function buildRequestParams(meta, range, context) {
    var dateEnv = context.dateEnv, options = context.options;
    var startParam;
    var endParam;
    var timeZoneParam;
    var customRequestParams;
    var params = {};
    startParam = meta.startParam;
    if (startParam == null) startParam = options.startParam;
    endParam = meta.endParam;
    if (endParam == null) endParam = options.endParam;
    timeZoneParam = meta.timeZoneParam;
    if (timeZoneParam == null) timeZoneParam = options.timeZoneParam;
    // retrieve any outbound GET/POST data from the options
    if (typeof meta.extraParams === 'function') // supplied as a function that returns a key/value object
    customRequestParams = meta.extraParams();
    else // probably supplied as a straight key/value object
    customRequestParams = meta.extraParams || {};
    _tslib.__assign(params, customRequestParams);
    params[startParam] = dateEnv.formatIso(range.start);
    params[endParam] = dateEnv.formatIso(range.end);
    if (dateEnv.timeZone !== 'local') params[timeZoneParam] = dateEnv.timeZone;
    return params;
}
var SIMPLE_RECURRING_REFINERS = {
    daysOfWeek: identity,
    startTime: createDuration,
    endTime: createDuration,
    duration: createDuration,
    startRecur: identity,
    endRecur: identity
};
var recurring = {
    parse: function(refined, dateEnv) {
        if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {
            var recurringData = {
                daysOfWeek: refined.daysOfWeek || null,
                startTime: refined.startTime || null,
                endTime: refined.endTime || null,
                startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,
                endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null
            };
            var duration = void 0;
            if (refined.duration) duration = refined.duration;
            if (!duration && refined.startTime && refined.endTime) duration = subtractDurations(refined.endTime, refined.startTime);
            return {
                allDayGuess: Boolean(!refined.startTime && !refined.endTime),
                duration: duration,
                typeData: recurringData
            };
        }
        return null;
    },
    expand: function(typeData, framingRange, dateEnv) {
        var clippedFramingRange = intersectRanges(framingRange, {
            start: typeData.startRecur,
            end: typeData.endRecur
        });
        if (clippedFramingRange) return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);
        return [];
    }
};
var simpleRecurringEventsPlugin = createPlugin({
    recurringTypes: [
        recurring
    ],
    eventRefiners: SIMPLE_RECURRING_REFINERS
});
function expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {
    var dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;
    var dayMarker = startOfDay(framingRange.start);
    var endMarker = framingRange.end;
    var instanceStarts = [];
    while(dayMarker < endMarker){
        var instanceStart = void 0;
        // if everyday, or this particular day-of-week
        if (!dowHash || dowHash[dayMarker.getUTCDay()]) {
            if (startTime) instanceStart = dateEnv.add(dayMarker, startTime);
            else instanceStart = dayMarker;
            instanceStarts.push(instanceStart);
        }
        dayMarker = addDays(dayMarker, 1);
    }
    return instanceStarts;
}
var changeHandlerPlugin = createPlugin({
    optionChangeHandlers: {
        events: function(events, context) {
            handleEventSources([
                events
            ], context);
        },
        eventSources: handleEventSources
    }
});
/*
BUG: if `event` was supplied, all previously-given `eventSources` will be wiped out
*/ function handleEventSources(inputs, context) {
    var unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);
    var newInputs = [];
    for(var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++){
        var input = inputs_1[_i];
        var inputFound = false;
        for(var i = 0; i < unfoundSources.length; i += 1)if (unfoundSources[i]._raw === input) {
            unfoundSources.splice(i, 1); // delete
            inputFound = true;
            break;
        }
        if (!inputFound) newInputs.push(input);
    }
    for(var _a = 0, unfoundSources_1 = unfoundSources; _a < unfoundSources_1.length; _a++){
        var unfoundSource = unfoundSources_1[_a];
        context.dispatch({
            type: 'REMOVE_EVENT_SOURCE',
            sourceId: unfoundSource.sourceId
        });
    }
    for(var _b = 0, newInputs_1 = newInputs; _b < newInputs_1.length; _b++){
        var newInput = newInputs_1[_b];
        context.calendarApi.addEventSource(newInput);
    }
}
function handleDateProfile(dateProfile, context) {
    context.emitter.trigger('datesSet', _tslib.__assign(_tslib.__assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), {
        view: context.viewApi
    }));
}
function handleEventStore(eventStore, context) {
    var emitter = context.emitter;
    if (emitter.hasHandlers('eventsSet')) emitter.trigger('eventsSet', buildEventApis(eventStore, context));
}
/*
this array is exposed on the root namespace so that UMD plugins can add to it.
see the rollup-bundles script.
*/ var globalPlugins = [
    arrayEventSourcePlugin,
    funcEventSourcePlugin,
    jsonFeedEventSourcePlugin,
    simpleRecurringEventsPlugin,
    changeHandlerPlugin,
    createPlugin({
        isLoadingFuncs: [
            function(state) {
                return computeEventSourcesLoading(state.eventSources);
            }, 
        ],
        contentTypeHandlers: {
            html: buildHtmlRenderer,
            domNodes: buildDomNodeRenderer
        },
        propSetHandlers: {
            dateProfile: handleDateProfile,
            eventStore: handleEventStore
        }
    }), 
];
function buildHtmlRenderer() {
    var currentEl = null;
    var currentHtml = '';
    function render(el, html) {
        if (el !== currentEl || html !== currentHtml) el.innerHTML = html;
        currentEl = el;
        currentHtml = html;
    }
    function destroy() {
        currentEl.innerHTML = '';
        currentEl = null;
        currentHtml = '';
    }
    return {
        render: render,
        destroy: destroy
    };
}
function buildDomNodeRenderer() {
    var currentEl = null;
    var currentDomNodes = [];
    function render(el, domNodes) {
        var newDomNodes = Array.prototype.slice.call(domNodes);
        if (el !== currentEl || !isArraysEqual(currentDomNodes, newDomNodes)) {
            // append first, remove second (for scroll resetting)
            for(var _i = 0, newDomNodes_1 = newDomNodes; _i < newDomNodes_1.length; _i++){
                var newNode = newDomNodes_1[_i];
                el.appendChild(newNode);
            }
            destroy();
        }
        currentEl = el;
        currentDomNodes = newDomNodes;
    }
    function destroy() {
        currentDomNodes.forEach(removeElement);
        currentDomNodes = [];
        currentEl = null;
    }
    return {
        render: render,
        destroy: destroy
    };
}
var DelayedRunner = /** @class */ function() {
    function DelayedRunner1(drainedOption) {
        this.drainedOption = drainedOption;
        this.isRunning = false;
        this.isDirty = false;
        this.pauseDepths = {};
        this.timeoutId = 0;
    }
    DelayedRunner1.prototype.request = function(delay) {
        this.isDirty = true;
        if (!this.isPaused()) {
            this.clearTimeout();
            if (delay == null) this.tryDrain();
            else this.timeoutId = setTimeout(this.tryDrain.bind(this), delay);
        }
    };
    DelayedRunner1.prototype.pause = function(scope) {
        if (scope === void 0) scope = '';
        var pauseDepths = this.pauseDepths;
        pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;
        this.clearTimeout();
    };
    DelayedRunner1.prototype.resume = function(scope, force) {
        if (scope === void 0) scope = '';
        var pauseDepths = this.pauseDepths;
        if (scope in pauseDepths) {
            if (force) delete pauseDepths[scope];
            else {
                pauseDepths[scope] -= 1;
                var depth = pauseDepths[scope];
                if (depth <= 0) delete pauseDepths[scope];
            }
            this.tryDrain();
        }
    };
    DelayedRunner1.prototype.isPaused = function() {
        return Object.keys(this.pauseDepths).length;
    };
    DelayedRunner1.prototype.tryDrain = function() {
        if (!this.isRunning && !this.isPaused()) {
            this.isRunning = true;
            while(this.isDirty){
                this.isDirty = false;
                this.drained(); // might set isDirty to true again
            }
            this.isRunning = false;
        }
    };
    DelayedRunner1.prototype.clear = function() {
        this.clearTimeout();
        this.isDirty = false;
        this.pauseDepths = {};
    };
    DelayedRunner1.prototype.clearTimeout = function() {
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
            this.timeoutId = 0;
        }
    };
    DelayedRunner1.prototype.drained = function() {
        if (this.drainedOption) this.drainedOption();
    };
    return DelayedRunner1;
}();
var TaskRunner = /** @class */ function() {
    function TaskRunner1(runTaskOption, drainedOption) {
        this.runTaskOption = runTaskOption;
        this.drainedOption = drainedOption;
        this.queue = [];
        this.delayedRunner = new DelayedRunner(this.drain.bind(this));
    }
    TaskRunner1.prototype.request = function(task, delay) {
        this.queue.push(task);
        this.delayedRunner.request(delay);
    };
    TaskRunner1.prototype.pause = function(scope) {
        this.delayedRunner.pause(scope);
    };
    TaskRunner1.prototype.resume = function(scope, force) {
        this.delayedRunner.resume(scope, force);
    };
    TaskRunner1.prototype.drain = function() {
        var queue = this.queue;
        while(queue.length){
            var completedTasks = [];
            var task = void 0;
            while(task = queue.shift()){
                this.runTask(task);
                completedTasks.push(task);
            }
            this.drained(completedTasks);
        } // keep going, in case new tasks were added in the drained handler
    };
    TaskRunner1.prototype.runTask = function(task) {
        if (this.runTaskOption) this.runTaskOption(task);
    };
    TaskRunner1.prototype.drained = function(completedTasks) {
        if (this.drainedOption) this.drainedOption(completedTasks);
    };
    return TaskRunner1;
}();
// Computes what the title at the top of the calendarApi should be for this view
function buildTitle(dateProfile, viewOptions, dateEnv) {
    var range;
    // for views that span a large unit of time, show the proper interval, ignoring stray days before and after
    if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) range = dateProfile.currentRange;
    else range = dateProfile.activeRange;
    return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {
        isEndExclusive: dateProfile.isRangeAllDay,
        defaultSeparator: viewOptions.titleRangeSeparator
    });
}
// Generates the format string that should be used to generate the title for the current date range.
// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.
function buildTitleFormat(dateProfile) {
    var currentRangeUnit = dateProfile.currentRangeUnit;
    if (currentRangeUnit === 'year') return {
        year: 'numeric'
    };
    if (currentRangeUnit === 'month') return {
        year: 'numeric',
        month: 'long'
    }; // like "September 2014"
    var days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);
    if (days !== null && days > 1) // multi-day range. shorter, like "Sep 9 - 10 2014"
    return {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
    };
    // one day. longer, like "September 9 2014"
    return {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    };
}
// in future refactor, do the redux-style function(state=initial) for initial-state
// also, whatever is happening in constructor, have it happen in action queue too
var CalendarDataManager = /** @class */ function() {
    function CalendarDataManager1(props) {
        var _this = this;
        this.computeOptionsData = memoize(this._computeOptionsData);
        this.computeCurrentViewData = memoize(this._computeCurrentViewData);
        this.organizeRawLocales = memoize(organizeRawLocales);
        this.buildLocale = memoize(buildLocale);
        this.buildPluginHooks = buildBuildPluginHooks();
        this.buildDateEnv = memoize(buildDateEnv);
        this.buildTheme = memoize(buildTheme);
        this.parseToolbars = memoize(parseToolbars);
        this.buildViewSpecs = memoize(buildViewSpecs);
        this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);
        this.buildViewApi = memoize(buildViewApi);
        this.buildViewUiProps = memoizeObjArg(buildViewUiProps);
        this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);
        this.buildEventUiBases = memoize(buildEventUiBases);
        this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);
        this.buildTitle = memoize(buildTitle);
        this.emitter = new Emitter();
        this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));
        this.currentCalendarOptionsInput = {};
        this.currentCalendarOptionsRefined = {};
        this.currentViewOptionsInput = {};
        this.currentViewOptionsRefined = {};
        this.currentCalendarOptionsRefiners = {};
        this.getCurrentData = function() {
            return _this.data;
        };
        this.dispatch = function(action) {
            _this.actionRunner.request(action); // protects against recursive calls to _handleAction
        };
        this.props = props;
        this.actionRunner.pause();
        var dynamicOptionOverrides = {};
        var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
        var currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;
        var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
        // wire things up
        // TODO: not DRY
        props.calendarApi.currentDataManager = this;
        this.emitter.setThisContext(props.calendarApi);
        this.emitter.setOptions(currentViewData.options);
        var currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);
        var dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
        if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) currentDate = dateProfile.currentRange.start;
        var calendarContext = {
            dateEnv: optionsData.dateEnv,
            options: optionsData.calendarOptions,
            pluginHooks: optionsData.pluginHooks,
            calendarApi: props.calendarApi,
            dispatch: this.dispatch,
            emitter: this.emitter,
            getCurrentData: this.getCurrentData
        };
        // needs to be after setThisContext
        for(var _i = 0, _a = optionsData.pluginHooks.contextInit; _i < _a.length; _i++){
            var callback = _a[_i];
            callback(calendarContext);
        }
        // NOT DRY
        var eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);
        var initialState = {
            dynamicOptionOverrides: dynamicOptionOverrides,
            currentViewType: currentViewType,
            currentDate: currentDate,
            dateProfile: dateProfile,
            businessHours: this.parseContextBusinessHours(calendarContext),
            eventSources: eventSources,
            eventUiBases: {},
            eventStore: createEmptyEventStore(),
            renderableEventStore: createEmptyEventStore(),
            dateSelection: null,
            eventSelection: '',
            eventDrag: null,
            eventResize: null,
            selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig
        };
        var contextAndState = _tslib.__assign(_tslib.__assign({}, calendarContext), initialState);
        for(var _b = 0, _c = optionsData.pluginHooks.reducers; _b < _c.length; _b++){
            var reducer = _c[_b];
            _tslib.__assign(initialState, reducer(null, null, contextAndState));
        }
        if (computeIsLoading(initialState, calendarContext)) this.emitter.trigger('loading', true); // NOT DRY
        this.state = initialState;
        this.updateData();
        this.actionRunner.resume();
    }
    CalendarDataManager1.prototype.resetOptions = function(optionOverrides, append) {
        var props = this.props;
        props.optionOverrides = append ? _tslib.__assign(_tslib.__assign({}, props.optionOverrides), optionOverrides) : optionOverrides;
        this.actionRunner.request({
            type: 'NOTHING'
        });
    };
    CalendarDataManager1.prototype._handleAction = function(action) {
        var _a = this, props = _a.props, state = _a.state, emitter = _a.emitter;
        var dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);
        var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
        var currentViewType = reduceViewType(state.currentViewType, action);
        var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
        // wire things up
        // TODO: not DRY
        props.calendarApi.currentDataManager = this;
        emitter.setThisContext(props.calendarApi);
        emitter.setOptions(currentViewData.options);
        var calendarContext = {
            dateEnv: optionsData.dateEnv,
            options: optionsData.calendarOptions,
            pluginHooks: optionsData.pluginHooks,
            calendarApi: props.calendarApi,
            dispatch: this.dispatch,
            emitter: emitter,
            getCurrentData: this.getCurrentData
        };
        var currentDate = state.currentDate, dateProfile = state.dateProfile;
        if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
        currentDate = reduceCurrentDate(currentDate, action);
        dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);
        if (action.type === 'PREV' || action.type === 'NEXT' || !rangeContainsMarker(dateProfile.currentRange, currentDate)) currentDate = dateProfile.currentRange.start;
        var eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);
        var eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);
        var isEventsLoading = computeEventSourcesLoading(eventSources); // BAD. also called in this func in computeIsLoading
        var renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : eventStore;
        var _b = this.buildViewUiProps(calendarContext), eventUiSingleBase = _b.eventUiSingleBase, selectionConfig = _b.selectionConfig; // will memoize obj
        var eventUiBySource = this.buildEventUiBySource(eventSources);
        var eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);
        var newState = {
            dynamicOptionOverrides: dynamicOptionOverrides,
            currentViewType: currentViewType,
            currentDate: currentDate,
            dateProfile: dateProfile,
            eventSources: eventSources,
            eventStore: eventStore,
            renderableEventStore: renderableEventStore,
            selectionConfig: selectionConfig,
            eventUiBases: eventUiBases,
            businessHours: this.parseContextBusinessHours(calendarContext),
            dateSelection: reduceDateSelection(state.dateSelection, action),
            eventSelection: reduceSelectedEvent(state.eventSelection, action),
            eventDrag: reduceEventDrag(state.eventDrag, action),
            eventResize: reduceEventResize(state.eventResize, action)
        };
        var contextAndState = _tslib.__assign(_tslib.__assign({}, calendarContext), newState);
        for(var _i = 0, _c = optionsData.pluginHooks.reducers; _i < _c.length; _i++){
            var reducer = _c[_i];
            _tslib.__assign(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value
        }
        var wasLoading = computeIsLoading(state, calendarContext);
        var isLoading = computeIsLoading(newState, calendarContext);
        // TODO: use propSetHandlers in plugin system
        if (!wasLoading && isLoading) emitter.trigger('loading', true);
        else if (wasLoading && !isLoading) emitter.trigger('loading', false);
        this.state = newState;
        if (props.onAction) props.onAction(action);
    };
    CalendarDataManager1.prototype.updateData = function() {
        var _a = this, props = _a.props, state = _a.state;
        var oldData = this.data;
        var optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);
        var currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);
        var data = this.data = _tslib.__assign(_tslib.__assign(_tslib.__assign({
            viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv),
            calendarApi: props.calendarApi,
            dispatch: this.dispatch,
            emitter: this.emitter,
            getCurrentData: this.getCurrentData
        }, optionsData), currentViewData), state);
        var changeHandlers = optionsData.pluginHooks.optionChangeHandlers;
        var oldCalendarOptions = oldData && oldData.calendarOptions;
        var newCalendarOptions = optionsData.calendarOptions;
        if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {
            if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {
                // hack
                state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);
                state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);
            }
            for(var optionName in changeHandlers)if (oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) changeHandlers[optionName](newCalendarOptions[optionName], data);
        }
        if (props.onData) props.onData(data);
    };
    CalendarDataManager1.prototype._computeOptionsData = function(optionOverrides, dynamicOptionOverrides, calendarApi) {
        // TODO: blacklist options that are handled by optionChangeHandlers
        var _a = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides), refinedOptions = _a.refinedOptions, pluginHooks = _a.pluginHooks, localeDefaults = _a.localeDefaults, availableLocaleData = _a.availableLocaleData, extra = _a.extra;
        warnUnknownOptions(extra);
        var dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);
        var viewSpecs = this.buildViewSpecs(pluginHooks.views, optionOverrides, dynamicOptionOverrides, localeDefaults);
        var theme = this.buildTheme(refinedOptions, pluginHooks);
        var toolbarConfig = this.parseToolbars(refinedOptions, optionOverrides, theme, viewSpecs, calendarApi);
        return {
            calendarOptions: refinedOptions,
            pluginHooks: pluginHooks,
            dateEnv: dateEnv,
            viewSpecs: viewSpecs,
            theme: theme,
            toolbarConfig: toolbarConfig,
            localeDefaults: localeDefaults,
            availableRawLocales: availableLocaleData.map
        };
    };
    // always called from behind a memoizer
    CalendarDataManager1.prototype.processRawCalendarOptions = function(optionOverrides, dynamicOptionOverrides) {
        var _a = mergeRawOptions([
            BASE_OPTION_DEFAULTS,
            optionOverrides,
            dynamicOptionOverrides, 
        ]), locales = _a.locales, locale = _a.locale;
        var availableLocaleData = this.organizeRawLocales(locales);
        var availableRawLocales = availableLocaleData.map;
        var localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;
        var pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);
        var refiners = this.currentCalendarOptionsRefiners = _tslib.__assign(_tslib.__assign(_tslib.__assign(_tslib.__assign(_tslib.__assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
        var extra = {};
        var raw = mergeRawOptions([
            BASE_OPTION_DEFAULTS,
            localeDefaults,
            optionOverrides,
            dynamicOptionOverrides, 
        ]);
        var refined = {};
        var currentRaw = this.currentCalendarOptionsInput;
        var currentRefined = this.currentCalendarOptionsRefined;
        var anyChanges = false;
        for(var optionName in raw)if (optionName !== 'plugins') {
            if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName])) refined[optionName] = currentRefined[optionName];
            else if (refiners[optionName]) {
                refined[optionName] = refiners[optionName](raw[optionName]);
                anyChanges = true;
            } else extra[optionName] = currentRaw[optionName];
        }
        if (anyChanges) {
            this.currentCalendarOptionsInput = raw;
            this.currentCalendarOptionsRefined = refined;
        }
        return {
            rawOptions: this.currentCalendarOptionsInput,
            refinedOptions: this.currentCalendarOptionsRefined,
            pluginHooks: pluginHooks,
            availableLocaleData: availableLocaleData,
            localeDefaults: localeDefaults,
            extra: extra
        };
    };
    CalendarDataManager1.prototype._computeCurrentViewData = function(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {
        var viewSpec = optionsData.viewSpecs[viewType];
        if (!viewSpec) throw new Error("viewType \"" + viewType + "\" is not available. Please make sure you've loaded all neccessary plugins");
        var _a = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides), refinedOptions = _a.refinedOptions, extra = _a.extra;
        warnUnknownOptions(extra);
        var dateProfileGenerator = this.buildDateProfileGenerator({
            dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,
            duration: viewSpec.duration,
            durationUnit: viewSpec.durationUnit,
            usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,
            dateEnv: optionsData.dateEnv,
            calendarApi: this.props.calendarApi,
            slotMinTime: refinedOptions.slotMinTime,
            slotMaxTime: refinedOptions.slotMaxTime,
            showNonCurrentDates: refinedOptions.showNonCurrentDates,
            dayCount: refinedOptions.dayCount,
            dateAlignment: refinedOptions.dateAlignment,
            dateIncrement: refinedOptions.dateIncrement,
            hiddenDays: refinedOptions.hiddenDays,
            weekends: refinedOptions.weekends,
            nowInput: refinedOptions.now,
            validRangeInput: refinedOptions.validRange,
            visibleRangeInput: refinedOptions.visibleRange,
            monthMode: refinedOptions.monthMode,
            fixedWeekCount: refinedOptions.fixedWeekCount
        });
        var viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);
        return {
            viewSpec: viewSpec,
            options: refinedOptions,
            dateProfileGenerator: dateProfileGenerator,
            viewApi: viewApi
        };
    };
    CalendarDataManager1.prototype.processRawViewOptions = function(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {
        var raw = mergeRawOptions([
            BASE_OPTION_DEFAULTS,
            viewSpec.optionDefaults,
            localeDefaults,
            optionOverrides,
            viewSpec.optionOverrides,
            dynamicOptionOverrides, 
        ]);
        var refiners = _tslib.__assign(_tslib.__assign(_tslib.__assign(_tslib.__assign(_tslib.__assign(_tslib.__assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
        var refined = {};
        var currentRaw = this.currentViewOptionsInput;
        var currentRefined = this.currentViewOptionsRefined;
        var anyChanges = false;
        var extra = {};
        for(var optionName in raw)if (raw[optionName] === currentRaw[optionName]) refined[optionName] = currentRefined[optionName];
        else {
            if (raw[optionName] === this.currentCalendarOptionsInput[optionName]) {
                if (optionName in this.currentCalendarOptionsRefined) refined[optionName] = this.currentCalendarOptionsRefined[optionName];
            } else if (refiners[optionName]) refined[optionName] = refiners[optionName](raw[optionName]);
            else extra[optionName] = raw[optionName];
            anyChanges = true;
        }
        if (anyChanges) {
            this.currentViewOptionsInput = raw;
            this.currentViewOptionsRefined = refined;
        }
        return {
            rawOptions: this.currentViewOptionsInput,
            refinedOptions: this.currentViewOptionsRefined,
            extra: extra
        };
    };
    return CalendarDataManager1;
}();
function buildDateEnv(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {
    var locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);
    return new DateEnv({
        calendarSystem: 'gregory',
        timeZone: timeZone,
        namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,
        locale: locale,
        weekNumberCalculation: weekNumberCalculation,
        firstDay: firstDay,
        weekText: weekText,
        cmdFormatter: pluginHooks.cmdFormatter,
        defaultSeparator: defaultSeparator
    });
}
function buildTheme(options, pluginHooks) {
    var ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;
    return new ThemeClass(options);
}
function buildDateProfileGenerator(props) {
    var DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;
    return new DateProfileGeneratorClass(props);
}
function buildViewApi(type, getCurrentData, dateEnv) {
    return new ViewApi(type, getCurrentData, dateEnv);
}
function buildEventUiBySource(eventSources) {
    return mapHash(eventSources, function(eventSource) {
        return eventSource.ui;
    });
}
function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {
    var eventUiBases = {
        '': eventUiSingleBase
    };
    for(var defId in eventDefs){
        var def = eventDefs[defId];
        if (def.sourceId && eventUiBySource[def.sourceId]) eventUiBases[defId] = eventUiBySource[def.sourceId];
    }
    return eventUiBases;
}
function buildViewUiProps(calendarContext) {
    var options = calendarContext.options;
    return {
        eventUiSingleBase: createEventUi({
            display: options.eventDisplay,
            editable: options.editable,
            startEditable: options.eventStartEditable,
            durationEditable: options.eventDurationEditable,
            constraint: options.eventConstraint,
            overlap: typeof options.eventOverlap === 'boolean' ? options.eventOverlap : undefined,
            allow: options.eventAllow,
            backgroundColor: options.eventBackgroundColor,
            borderColor: options.eventBorderColor,
            textColor: options.eventTextColor,
            color: options.eventColor
        }, calendarContext),
        selectionConfig: createEventUi({
            constraint: options.selectConstraint,
            overlap: typeof options.selectOverlap === 'boolean' ? options.selectOverlap : undefined,
            allow: options.selectAllow
        }, calendarContext)
    };
}
function computeIsLoading(state, context) {
    for(var _i = 0, _a = context.pluginHooks.isLoadingFuncs; _i < _a.length; _i++){
        var isLoadingFunc = _a[_i];
        if (isLoadingFunc(state)) return true;
    }
    return false;
}
function parseContextBusinessHours(calendarContext) {
    return parseBusinessHours(calendarContext.options.businessHours, calendarContext);
}
function warnUnknownOptions(options, viewName) {
    for(var optionName in options)console.warn("Unknown option '" + optionName + "'" + (viewName ? " for view '" + viewName + "'" : ''));
}
// TODO: move this to react plugin?
var CalendarDataProvider = /** @class */ function(_super) {
    _tslib.__extends(CalendarDataProvider1, _super);
    function CalendarDataProvider1(props) {
        var _this = _super.call(this, props) || this;
        _this.handleData = function(data) {
            if (!_this.dataManager) // eslint-disable-next-line react/no-direct-mutation-state
            _this.state = data; // can't use setState yet
            else _this.setState(data);
        };
        _this.dataManager = new CalendarDataManager({
            optionOverrides: props.optionOverrides,
            calendarApi: props.calendarApi,
            onData: _this.handleData
        });
        return _this;
    }
    CalendarDataProvider1.prototype.render = function() {
        return this.props.children(this.state);
    };
    CalendarDataProvider1.prototype.componentDidUpdate = function(prevProps) {
        var newOptionOverrides = this.props.optionOverrides;
        if (newOptionOverrides !== prevProps.optionOverrides) this.dataManager.resetOptions(newOptionOverrides);
    };
    return CalendarDataProvider1;
}(_vdomJs.Component);
// HELPERS
/*
if nextDayThreshold is specified, slicing is done in an all-day fashion.
you can get nextDayThreshold from context.nextDayThreshold
*/ function sliceEvents(props, allDay) {
    return sliceEventStore(props.eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? props.nextDayThreshold : null).fg;
}
var NamedTimeZoneImpl = /** @class */ function() {
    function NamedTimeZoneImpl1(timeZoneName) {
        this.timeZoneName = timeZoneName;
    }
    return NamedTimeZoneImpl1;
}();
var SegHierarchy = /** @class */ function() {
    function SegHierarchy1() {
        // settings
        this.strictOrder = false;
        this.allowReslicing = false;
        this.maxCoord = -1; // -1 means no max
        this.maxStackCnt = -1; // -1 means no max
        this.levelCoords = []; // ordered
        this.entriesByLevel = []; // parallel with levelCoords
        this.stackCnts = {}; // TODO: use better technique!?
    }
    SegHierarchy1.prototype.addSegs = function(inputs) {
        var hiddenEntries = [];
        for(var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++){
            var input = inputs_1[_i];
            this.insertEntry(input, hiddenEntries);
        }
        return hiddenEntries;
    };
    SegHierarchy1.prototype.insertEntry = function(entry, hiddenEntries) {
        var insertion = this.findInsertion(entry);
        if (this.isInsertionValid(insertion, entry)) {
            this.insertEntryAt(entry, insertion);
            return 1;
        }
        return this.handleInvalidInsertion(insertion, entry, hiddenEntries);
    };
    SegHierarchy1.prototype.isInsertionValid = function(insertion, entry) {
        return (this.maxCoord === -1 || insertion.levelCoord + entry.thickness <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);
    };
    // returns number of new entries inserted
    SegHierarchy1.prototype.handleInvalidInsertion = function(insertion, entry, hiddenEntries) {
        if (this.allowReslicing && insertion.touchingEntry) return this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);
        hiddenEntries.push(entry);
        return 0;
    };
    SegHierarchy1.prototype.splitEntry = function(entry, barrier, hiddenEntries) {
        var partCnt = 0;
        var splitHiddenEntries = [];
        var entrySpan = entry.span;
        var barrierSpan = barrier.span;
        if (entrySpan.start < barrierSpan.start) partCnt += this.insertEntry({
            index: entry.index,
            thickness: entry.thickness,
            span: {
                start: entrySpan.start,
                end: barrierSpan.start
            }
        }, splitHiddenEntries);
        if (entrySpan.end > barrierSpan.end) partCnt += this.insertEntry({
            index: entry.index,
            thickness: entry.thickness,
            span: {
                start: barrierSpan.end,
                end: entrySpan.end
            }
        }, splitHiddenEntries);
        if (partCnt) {
            hiddenEntries.push.apply(hiddenEntries, _tslib.__spreadArray([
                {
                    index: entry.index,
                    thickness: entry.thickness,
                    span: intersectSpans(barrierSpan, entrySpan)
                }
            ], splitHiddenEntries));
            return partCnt;
        }
        hiddenEntries.push(entry);
        return 0;
    };
    SegHierarchy1.prototype.insertEntryAt = function(entry, insertion) {
        var _a = this, entriesByLevel = _a.entriesByLevel, levelCoords = _a.levelCoords;
        if (insertion.lateral === -1) {
            // create a new level
            insertAt(levelCoords, insertion.level, insertion.levelCoord);
            insertAt(entriesByLevel, insertion.level, [
                entry
            ]);
        } else // insert into existing level
        insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);
        this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;
    };
    SegHierarchy1.prototype.findInsertion = function(newEntry) {
        var _a = this, levelCoords = _a.levelCoords, entriesByLevel = _a.entriesByLevel, strictOrder = _a.strictOrder, stackCnts = _a.stackCnts;
        var levelCnt = levelCoords.length;
        var candidateCoord = 0;
        var touchingLevel = -1;
        var touchingLateral = -1;
        var touchingEntry = null;
        var stackCnt = 0;
        for(var trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1){
            var trackingCoord = levelCoords[trackingLevel];
            // if the current level is past the placed entry, we have found a good empty space and can stop.
            // if strictOrder, keep finding more lateral intersections.
            if (!strictOrder && trackingCoord >= candidateCoord + newEntry.thickness) break;
            var trackingEntries = entriesByLevel[trackingLevel];
            var trackingEntry = void 0;
            var searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd); // find first entry after newEntry's end
            var lateralIndex = searchRes[0] + searchRes[1]; // if exact match (which doesn't collide), go to next one
            while((trackingEntry = trackingEntries[lateralIndex]) && trackingEntry.span.start < newEntry.span.end // and not entirely past newEntry
            ){
                var trackingEntryBottom = trackingCoord + trackingEntry.thickness;
                // intersects into the top of the candidate?
                if (trackingEntryBottom > candidateCoord) {
                    candidateCoord = trackingEntryBottom;
                    touchingEntry = trackingEntry;
                    touchingLevel = trackingLevel;
                    touchingLateral = lateralIndex;
                }
                // butts up against top of candidate? (will happen if just intersected as well)
                if (trackingEntryBottom === candidateCoord) // accumulate the highest possible stackCnt of the trackingEntries that butt up
                stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);
                lateralIndex += 1;
            }
        }
        // the destination level will be after touchingEntry's level. find it
        var destLevel = 0;
        if (touchingEntry) {
            destLevel = touchingLevel + 1;
            while(destLevel < levelCnt && levelCoords[destLevel] < candidateCoord)destLevel += 1;
        }
        // if adding to an existing level, find where to insert
        var destLateral = -1;
        if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];
        return {
            touchingLevel: touchingLevel,
            touchingLateral: touchingLateral,
            touchingEntry: touchingEntry,
            stackCnt: stackCnt,
            levelCoord: candidateCoord,
            level: destLevel,
            lateral: destLateral
        };
    };
    // sorted by levelCoord (lowest to highest)
    SegHierarchy1.prototype.toRects = function() {
        var _a = this, entriesByLevel = _a.entriesByLevel, levelCoords = _a.levelCoords;
        var levelCnt = entriesByLevel.length;
        var rects = [];
        for(var level = 0; level < levelCnt; level += 1){
            var entries = entriesByLevel[level];
            var levelCoord = levelCoords[level];
            for(var _i = 0, entries_1 = entries; _i < entries_1.length; _i++){
                var entry = entries_1[_i];
                rects.push(_tslib.__assign(_tslib.__assign({}, entry), {
                    levelCoord: levelCoord
                }));
            }
        }
        return rects;
    };
    return SegHierarchy1;
}();
function getEntrySpanEnd(entry) {
    return entry.span.end;
}
function buildEntryKey(entry) {
    return entry.index + ':' + entry.span.start;
}
// returns groups with entries sorted by input order
function groupIntersectingEntries(entries) {
    var merges = [];
    for(var _i = 0, entries_2 = entries; _i < entries_2.length; _i++){
        var entry = entries_2[_i];
        var filteredMerges = [];
        var hungryMerge = {
            span: entry.span,
            entries: [
                entry
            ]
        };
        for(var _a = 0, merges_1 = merges; _a < merges_1.length; _a++){
            var merge = merges_1[_a];
            if (intersectSpans(merge.span, hungryMerge.span)) hungryMerge = {
                entries: merge.entries.concat(hungryMerge.entries),
                span: joinSpans(merge.span, hungryMerge.span)
            };
            else filteredMerges.push(merge);
        }
        filteredMerges.push(hungryMerge);
        merges = filteredMerges;
    }
    return merges;
}
function joinSpans(span0, span1) {
    return {
        start: Math.min(span0.start, span1.start),
        end: Math.max(span0.end, span1.end)
    };
}
function intersectSpans(span0, span1) {
    var start = Math.max(span0.start, span1.start);
    var end = Math.min(span0.end, span1.end);
    if (start < end) return {
        start: start,
        end: end
    };
    return null;
}
// general util
// ---------------------------------------------------------------------------------------------------------------------
function insertAt(arr, index, item) {
    arr.splice(index, 0, item);
}
function binarySearch(a, searchVal, getItemVal) {
    var startIndex = 0;
    var endIndex = a.length; // exclusive
    if (!endIndex || searchVal < getItemVal(a[startIndex])) return [
        0,
        0
    ];
    if (searchVal > getItemVal(a[endIndex - 1])) return [
        endIndex,
        0
    ];
    while(startIndex < endIndex){
        var middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);
        var middleVal = getItemVal(a[middleIndex]);
        if (searchVal < middleVal) endIndex = middleIndex;
        else if (searchVal > middleVal) startIndex = middleIndex + 1;
        else return [
            middleIndex,
            1
        ];
    }
    return [
        startIndex,
        0
    ];
}
var Interaction = /** @class */ function() {
    function Interaction1(settings) {
        this.component = settings.component;
        this.isHitComboAllowed = settings.isHitComboAllowed || null;
    }
    Interaction1.prototype.destroy = function() {};
    return Interaction1;
}();
function parseInteractionSettings(component, input) {
    return {
        component: component,
        el: input.el,
        useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,
        isHitComboAllowed: input.isHitComboAllowed || null
    };
}
function interactionSettingsToStore(settings) {
    var _a;
    return _a = {}, _a[settings.component.uid] = settings, _a;
}
// global state
var interactionSettingsStore = {};
/*
An abstraction for a dragging interaction originating on an event.
Does higher-level things than PointerDragger, such as possibly:
- a "mirror" that moves with the pointer
- a minimum number of pixels or other criteria for a true drag to begin

subclasses must emit:
- pointerdown
- dragstart
- dragmove
- pointerup
- dragend
*/ var ElementDragging = /** @class */ function() {
    function ElementDragging1(el, selector) {
        this.emitter = new Emitter();
    }
    ElementDragging1.prototype.destroy = function() {};
    ElementDragging1.prototype.setMirrorIsVisible = function(bool) {
    // optional if subclass doesn't want to support a mirror
    };
    ElementDragging1.prototype.setMirrorNeedsRevert = function(bool) {
    // optional if subclass doesn't want to support a mirror
    };
    ElementDragging1.prototype.setAutoScrollEnabled = function(bool) {
    // optional
    };
    return ElementDragging1;
}();
// TODO: get rid of this in favor of options system,
// tho it's really easy to access this globally rather than pass thru options.
var config = {};
/*
Information about what will happen when an external element is dragged-and-dropped
onto a calendar. Contains information for creating an event.
*/ var DRAG_META_REFINERS = {
    startTime: createDuration,
    duration: createDuration,
    create: Boolean,
    sourceId: String
};
function parseDragMeta(raw) {
    var _a = refineProps(raw, DRAG_META_REFINERS), refined = _a.refined, extra = _a.extra;
    return {
        startTime: refined.startTime || null,
        duration: refined.duration || null,
        create: refined.create != null ? refined.create : true,
        sourceId: refined.sourceId,
        leftoverProps: extra
    };
}
var ToolbarSection = /** @class */ function(_super) {
    _tslib.__extends(ToolbarSection1, _super);
    function ToolbarSection1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ToolbarSection1.prototype.render = function() {
        var _this = this;
        var children = this.props.widgetGroups.map(function(widgetGroup) {
            return _this.renderWidgetGroup(widgetGroup);
        });
        return _vdomJs.createElement.apply(void 0, _tslib.__spreadArray([
            'div',
            {
                className: 'fc-toolbar-chunk'
            }
        ], children));
    };
    ToolbarSection1.prototype.renderWidgetGroup = function(widgetGroup) {
        var props = this.props;
        var theme = this.context.theme;
        var children = [];
        var isOnlyButtons = true;
        for(var _i = 0, widgetGroup_1 = widgetGroup; _i < widgetGroup_1.length; _i++){
            var widget = widgetGroup_1[_i];
            var buttonName = widget.buttonName, buttonClick = widget.buttonClick, buttonText = widget.buttonText, buttonIcon = widget.buttonIcon, buttonHint = widget.buttonHint;
            if (buttonName === 'title') {
                isOnlyButtons = false;
                children.push(_vdomJs.createElement("h2", {
                    className: "fc-toolbar-title",
                    id: props.titleId
                }, props.title));
            } else {
                var isPressed = buttonName === props.activeButton;
                var isDisabled = !props.isTodayEnabled && buttonName === 'today' || !props.isPrevEnabled && buttonName === 'prev' || !props.isNextEnabled && buttonName === 'next';
                var buttonClasses = [
                    "fc-" + buttonName + "-button",
                    theme.getClass('button')
                ];
                if (isPressed) buttonClasses.push(theme.getClass('buttonActive'));
                children.push(_vdomJs.createElement("button", {
                    type: "button",
                    title: typeof buttonHint === 'function' ? buttonHint(props.navUnit) : buttonHint,
                    disabled: isDisabled,
                    "aria-pressed": isPressed,
                    className: buttonClasses.join(' '),
                    onClick: buttonClick
                }, buttonText || (buttonIcon ? _vdomJs.createElement("span", {
                    className: buttonIcon
                }) : '')));
            }
        }
        if (children.length > 1) {
            var groupClassName = isOnlyButtons && theme.getClass('buttonGroup') || '';
            return _vdomJs.createElement.apply(void 0, _tslib.__spreadArray([
                'div',
                {
                    className: groupClassName
                }
            ], children));
        }
        return children[0];
    };
    return ToolbarSection1;
}(BaseComponent);
var Toolbar = /** @class */ function(_super) {
    _tslib.__extends(Toolbar1, _super);
    function Toolbar1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Toolbar1.prototype.render = function() {
        var _a = this.props, model = _a.model, extraClassName = _a.extraClassName;
        var forceLtr = false;
        var startContent;
        var endContent;
        var sectionWidgets = model.sectionWidgets;
        var centerContent = sectionWidgets.center;
        if (sectionWidgets.left) {
            forceLtr = true;
            startContent = sectionWidgets.left;
        } else startContent = sectionWidgets.start;
        if (sectionWidgets.right) {
            forceLtr = true;
            endContent = sectionWidgets.right;
        } else endContent = sectionWidgets.end;
        var classNames = [
            extraClassName || '',
            'fc-toolbar',
            forceLtr ? 'fc-toolbar-ltr' : '', 
        ];
        return _vdomJs.createElement("div", {
            className: classNames.join(' ')
        }, this.renderSection('start', startContent || []), this.renderSection('center', centerContent || []), this.renderSection('end', endContent || []));
    };
    Toolbar1.prototype.renderSection = function(key, widgetGroups) {
        var props = this.props;
        return _vdomJs.createElement(ToolbarSection, {
            key: key,
            widgetGroups: widgetGroups,
            title: props.title,
            navUnit: props.navUnit,
            activeButton: props.activeButton,
            isTodayEnabled: props.isTodayEnabled,
            isPrevEnabled: props.isPrevEnabled,
            isNextEnabled: props.isNextEnabled,
            titleId: props.titleId
        });
    };
    return Toolbar1;
}(BaseComponent);
// TODO: do function component?
var ViewContainer = /** @class */ function(_super) {
    _tslib.__extends(ViewContainer1, _super);
    function ViewContainer1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            availableWidth: null
        };
        _this.handleEl = function(el) {
            _this.el = el;
            setRef(_this.props.elRef, el);
            _this.updateAvailableWidth();
        };
        _this.handleResize = function() {
            _this.updateAvailableWidth();
        };
        return _this;
    }
    ViewContainer1.prototype.render = function() {
        var _a = this, props = _a.props, state = _a.state;
        var aspectRatio = props.aspectRatio;
        var classNames = [
            'fc-view-harness',
            aspectRatio || props.liquid || props.height ? 'fc-view-harness-active' // harness controls the height
             : 'fc-view-harness-passive'
        ];
        var height = '';
        var paddingBottom = '';
        if (aspectRatio) {
            if (state.availableWidth !== null) height = state.availableWidth / aspectRatio;
            else // while waiting to know availableWidth, we can't set height to *zero*
            // because will cause lots of unnecessary scrollbars within scrollgrid.
            // BETTER: don't start rendering ANYTHING yet until we know container width
            // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)
            paddingBottom = 1 / aspectRatio * 100 + "%";
        } else height = props.height || '';
        return _vdomJs.createElement("div", {
            "aria-labelledby": props.labeledById,
            ref: this.handleEl,
            className: classNames.join(' '),
            style: {
                height: height,
                paddingBottom: paddingBottom
            }
        }, props.children);
    };
    ViewContainer1.prototype.componentDidMount = function() {
        this.context.addResizeHandler(this.handleResize);
    };
    ViewContainer1.prototype.componentWillUnmount = function() {
        this.context.removeResizeHandler(this.handleResize);
    };
    ViewContainer1.prototype.updateAvailableWidth = function() {
        if (this.el && this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth
        ) this.setState({
            availableWidth: this.el.offsetWidth
        });
    };
    return ViewContainer1;
}(BaseComponent);
/*
Detects when the user clicks on an event within a DateComponent
*/ var EventClicking = /** @class */ function(_super) {
    _tslib.__extends(EventClicking1, _super);
    function EventClicking1(settings) {
        var _this = _super.call(this, settings) || this;
        _this.handleSegClick = function(ev, segEl) {
            var component = _this.component;
            var context = component.context;
            var seg = getElSeg(segEl);
            if (seg && component.isValidSegDownEl(ev.target)) {
                // our way to simulate a link click for elements that can't be <a> tags
                // grab before trigger fired in case trigger trashes DOM thru rerendering
                var hasUrlContainer = elementClosest(ev.target, '.fc-event-forced-url');
                var url = hasUrlContainer ? hasUrlContainer.querySelector('a[href]').href : '';
                context.emitter.trigger('eventClick', {
                    el: segEl,
                    event: new EventApi(component.context, seg.eventRange.def, seg.eventRange.instance),
                    jsEvent: ev,
                    view: context.viewApi
                });
                if (url && !ev.defaultPrevented) window.location.href = url;
            }
        };
        _this.destroy = listenBySelector(settings.el, 'click', '.fc-event', _this.handleSegClick);
        return _this;
    }
    return EventClicking1;
}(Interaction);
/*
Triggers events and adds/removes core classNames when the user's pointer
enters/leaves event-elements of a component.
*/ var EventHovering = /** @class */ function(_super) {
    _tslib.__extends(EventHovering1, _super);
    function EventHovering1(settings) {
        var _this = _super.call(this, settings) || this;
        // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it
        _this.handleEventElRemove = function(el) {
            if (el === _this.currentSegEl) _this.handleSegLeave(null, _this.currentSegEl);
        };
        _this.handleSegEnter = function(ev, segEl) {
            if (getElSeg(segEl)) {
                _this.currentSegEl = segEl;
                _this.triggerEvent('eventMouseEnter', ev, segEl);
            }
        };
        _this.handleSegLeave = function(ev, segEl) {
            if (_this.currentSegEl) {
                _this.currentSegEl = null;
                _this.triggerEvent('eventMouseLeave', ev, segEl);
            }
        };
        _this.removeHoverListeners = listenToHoverBySelector(settings.el, '.fc-event', _this.handleSegEnter, _this.handleSegLeave);
        return _this;
    }
    EventHovering1.prototype.destroy = function() {
        this.removeHoverListeners();
    };
    EventHovering1.prototype.triggerEvent = function(publicEvName, ev, segEl) {
        var component = this.component;
        var context = component.context;
        var seg = getElSeg(segEl);
        if (!ev || component.isValidSegDownEl(ev.target)) context.emitter.trigger(publicEvName, {
            el: segEl,
            event: new EventApi(context, seg.eventRange.def, seg.eventRange.instance),
            jsEvent: ev,
            view: context.viewApi
        });
    };
    return EventHovering1;
}(Interaction);
var CalendarContent = /** @class */ function(_super) {
    _tslib.__extends(CalendarContent1, _super);
    function CalendarContent1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.buildViewContext = memoize(buildViewContext);
        _this.buildViewPropTransformers = memoize(buildViewPropTransformers);
        _this.buildToolbarProps = memoize(buildToolbarProps);
        _this.headerRef = _vdomJs.createRef();
        _this.footerRef = _vdomJs.createRef();
        _this.interactionsStore = {};
        // eslint-disable-next-line
        _this.state = {
            viewLabelId: getUniqueDomId()
        };
        // Component Registration
        // -----------------------------------------------------------------------------------------------------------------
        _this.registerInteractiveComponent = function(component, settingsInput) {
            var settings = parseInteractionSettings(component, settingsInput);
            var DEFAULT_INTERACTIONS = [
                EventClicking,
                EventHovering, 
            ];
            var interactionClasses = DEFAULT_INTERACTIONS.concat(_this.props.pluginHooks.componentInteractions);
            var interactions = interactionClasses.map(function(TheInteractionClass) {
                return new TheInteractionClass(settings);
            });
            _this.interactionsStore[component.uid] = interactions;
            interactionSettingsStore[component.uid] = settings;
        };
        _this.unregisterInteractiveComponent = function(component) {
            var listeners = _this.interactionsStore[component.uid];
            if (listeners) {
                for(var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++){
                    var listener = listeners_1[_i];
                    listener.destroy();
                }
                delete _this.interactionsStore[component.uid];
            }
            delete interactionSettingsStore[component.uid];
        };
        // Resizing
        // -----------------------------------------------------------------------------------------------------------------
        _this.resizeRunner = new DelayedRunner(function() {
            _this.props.emitter.trigger('_resize', true); // should window resizes be considered "forced" ?
            _this.props.emitter.trigger('windowResize', {
                view: _this.props.viewApi
            });
        });
        _this.handleWindowResize = function(ev) {
            var options = _this.props.options;
            if (options.handleWindowResize && ev.target === window // avoid jqui events
            ) _this.resizeRunner.request(options.windowResizeDelay);
        };
        return _this;
    }
    /*
    renders INSIDE of an outer div
    */ CalendarContent1.prototype.render = function() {
        var props = this.props;
        var toolbarConfig = props.toolbarConfig, options = props.options;
        var toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, getNow(props.options.now, props.dateEnv), props.viewTitle);
        var viewVGrow = false;
        var viewHeight = '';
        var viewAspectRatio;
        if (props.isHeightAuto || props.forPrint) viewHeight = '';
        else if (options.height != null) viewVGrow = true;
        else if (options.contentHeight != null) viewHeight = options.contentHeight;
        else viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall
        var viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);
        var viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : '';
        return _vdomJs.createElement(ViewContextType.Provider, {
            value: viewContext
        }, toolbarConfig.header && _vdomJs.createElement(Toolbar, _tslib.__assign({
            ref: this.headerRef,
            extraClassName: "fc-header-toolbar",
            model: toolbarConfig.header,
            titleId: viewLabelId
        }, toolbarProps)), _vdomJs.createElement(ViewContainer, {
            liquid: viewVGrow,
            height: viewHeight,
            aspectRatio: viewAspectRatio,
            labeledById: viewLabelId
        }, this.renderView(props), this.buildAppendContent()), toolbarConfig.footer && _vdomJs.createElement(Toolbar, _tslib.__assign({
            ref: this.footerRef,
            extraClassName: "fc-footer-toolbar",
            model: toolbarConfig.footer,
            titleId: ""
        }, toolbarProps)));
    };
    CalendarContent1.prototype.componentDidMount = function() {
        var props = this.props;
        this.calendarInteractions = props.pluginHooks.calendarInteractions.map(function(CalendarInteractionClass) {
            return new CalendarInteractionClass(props);
        });
        window.addEventListener('resize', this.handleWindowResize);
        var propSetHandlers = props.pluginHooks.propSetHandlers;
        for(var propName in propSetHandlers)propSetHandlers[propName](props[propName], props);
    };
    CalendarContent1.prototype.componentDidUpdate = function(prevProps) {
        var props = this.props;
        var propSetHandlers = props.pluginHooks.propSetHandlers;
        for(var propName in propSetHandlers)if (props[propName] !== prevProps[propName]) propSetHandlers[propName](props[propName], props);
    };
    CalendarContent1.prototype.componentWillUnmount = function() {
        window.removeEventListener('resize', this.handleWindowResize);
        this.resizeRunner.clear();
        for(var _i = 0, _a = this.calendarInteractions; _i < _a.length; _i++){
            var interaction = _a[_i];
            interaction.destroy();
        }
        this.props.emitter.trigger('_unmount');
    };
    CalendarContent1.prototype.buildAppendContent = function() {
        var props = this.props;
        var children = props.pluginHooks.viewContainerAppends.map(function(buildAppendContent) {
            return buildAppendContent(props);
        });
        return _vdomJs.createElement.apply(void 0, _tslib.__spreadArray([
            _vdomJs.Fragment,
            {}
        ], children));
    };
    CalendarContent1.prototype.renderView = function(props) {
        var pluginHooks = props.pluginHooks;
        var viewSpec = props.viewSpec;
        var viewProps = {
            dateProfile: props.dateProfile,
            businessHours: props.businessHours,
            eventStore: props.renderableEventStore,
            eventUiBases: props.eventUiBases,
            dateSelection: props.dateSelection,
            eventSelection: props.eventSelection,
            eventDrag: props.eventDrag,
            eventResize: props.eventResize,
            isHeightAuto: props.isHeightAuto,
            forPrint: props.forPrint
        };
        var transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);
        for(var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++){
            var transformer = transformers_1[_i];
            _tslib.__assign(viewProps, transformer.transform(viewProps, props));
        }
        var ViewComponent = viewSpec.component;
        return _vdomJs.createElement(ViewComponent, _tslib.__assign({}, viewProps));
    };
    return CalendarContent1;
}(PureComponent);
function buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {
    // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid
    var todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason
    var prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);
    var nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);
    return {
        title: title,
        activeButton: viewSpec.type,
        navUnit: viewSpec.singleUnit,
        isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),
        isPrevEnabled: prevInfo.isValid,
        isNextEnabled: nextInfo.isValid
    };
}
// Plugin
// -----------------------------------------------------------------------------------------------------------------
function buildViewPropTransformers(theClasses) {
    return theClasses.map(function(TheClass) {
        return new TheClass();
    });
}
var CalendarRoot = /** @class */ function(_super) {
    _tslib.__extends(CalendarRoot1, _super);
    function CalendarRoot1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            forPrint: false
        };
        _this.handleBeforePrint = function() {
            _this.setState({
                forPrint: true
            });
        };
        _this.handleAfterPrint = function() {
            _this.setState({
                forPrint: false
            });
        };
        return _this;
    }
    CalendarRoot1.prototype.render = function() {
        var props = this.props;
        var options = props.options;
        var forPrint = this.state.forPrint;
        var isHeightAuto = forPrint || options.height === 'auto' || options.contentHeight === 'auto';
        var height = !isHeightAuto && options.height != null ? options.height : '';
        var classNames = [
            'fc',
            forPrint ? 'fc-media-print' : 'fc-media-screen',
            "fc-direction-" + options.direction,
            props.theme.getClass('root'), 
        ];
        if (!getCanVGrowWithinCell()) classNames.push('fc-liquid-hack');
        return props.children(classNames, height, isHeightAuto, forPrint);
    };
    CalendarRoot1.prototype.componentDidMount = function() {
        var emitter = this.props.emitter;
        emitter.on('_beforeprint', this.handleBeforePrint);
        emitter.on('_afterprint', this.handleAfterPrint);
    };
    CalendarRoot1.prototype.componentWillUnmount = function() {
        var emitter = this.props.emitter;
        emitter.off('_beforeprint', this.handleBeforePrint);
        emitter.off('_afterprint', this.handleAfterPrint);
    };
    return CalendarRoot1;
}(BaseComponent);
// Computes a default column header formatting string if `colFormat` is not explicitly defined
function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {
    // if more than one week row, or if there are a lot of columns with not much space,
    // put just the day numbers will be in each cell
    if (!datesRepDistinctDays || dayCnt > 10) return createFormatter({
        weekday: 'short'
    }); // "Sat"
    if (dayCnt > 1) return createFormatter({
        weekday: 'short',
        month: 'numeric',
        day: 'numeric',
        omitCommas: true
    }); // "Sat 11/12"
    return createFormatter({
        weekday: 'long'
    }); // "Saturday"
}
var CLASS_NAME = 'fc-col-header-cell'; // do the cushion too? no
function renderInner$1(hookProps) {
    return hookProps.text;
}
var TableDateCell = /** @class */ function(_super) {
    _tslib.__extends(TableDateCell1, _super);
    function TableDateCell1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TableDateCell1.prototype.render = function() {
        var _a = this.context, dateEnv = _a.dateEnv, options = _a.options, theme = _a.theme, viewApi = _a.viewApi;
        var props = this.props;
        var date = props.date, dateProfile = props.dateProfile;
        var dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);
        var classNames = [
            CLASS_NAME
        ].concat(getDayClassNames(dayMeta, theme));
        var text = dateEnv.format(date, props.dayHeaderFormat);
        // if colCnt is 1, we are already in a day-view and don't need a navlink
        var navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};
        var hookProps = _tslib.__assign(_tslib.__assign(_tslib.__assign({
            date: dateEnv.toDate(date),
            view: viewApi
        }, props.extraHookProps), {
            text: text
        }), dayMeta);
        return _vdomJs.createElement(RenderHook, {
            hookProps: hookProps,
            classNames: options.dayHeaderClassNames,
            content: options.dayHeaderContent,
            defaultContent: renderInner$1,
            didMount: options.dayHeaderDidMount,
            willUnmount: options.dayHeaderWillUnmount
        }, function(rootElRef, customClassNames, innerElRef, innerContent) {
            return _vdomJs.createElement("th", _tslib.__assign({
                ref: rootElRef,
                role: "columnheader",
                className: classNames.concat(customClassNames).join(' '),
                "data-date": !dayMeta.isDisabled ? formatDayString(date) : undefined,
                colSpan: props.colSpan
            }, props.extraDataAttrs), _vdomJs.createElement("div", {
                className: "fc-scrollgrid-sync-inner"
            }, !dayMeta.isDisabled && _vdomJs.createElement("a", _tslib.__assign({
                ref: innerElRef,
                className: [
                    'fc-col-header-cell-cushion',
                    props.isSticky ? 'fc-sticky' : '', 
                ].join(' ')
            }, navLinkAttrs), innerContent)));
        });
    };
    return TableDateCell1;
}(BaseComponent);
var WEEKDAY_FORMAT = createFormatter({
    weekday: 'long'
});
var TableDowCell = /** @class */ function(_super) {
    _tslib.__extends(TableDowCell1, _super);
    function TableDowCell1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TableDowCell1.prototype.render = function() {
        var props = this.props;
        var _a = this.context, dateEnv = _a.dateEnv, theme = _a.theme, viewApi = _a.viewApi, options = _a.options;
        var date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT
        var dateMeta = {
            dow: props.dow,
            isDisabled: false,
            isFuture: false,
            isPast: false,
            isToday: false,
            isOther: false
        };
        var classNames = [
            CLASS_NAME
        ].concat(getDayClassNames(dateMeta, theme), props.extraClassNames || []);
        var text = dateEnv.format(date, props.dayHeaderFormat);
        var hookProps = _tslib.__assign(_tslib.__assign(_tslib.__assign(_tslib.__assign({
            date: date
        }, dateMeta), {
            view: viewApi
        }), props.extraHookProps), {
            text: text
        });
        return _vdomJs.createElement(RenderHook, {
            hookProps: hookProps,
            classNames: options.dayHeaderClassNames,
            content: options.dayHeaderContent,
            defaultContent: renderInner$1,
            didMount: options.dayHeaderDidMount,
            willUnmount: options.dayHeaderWillUnmount
        }, function(rootElRef, customClassNames, innerElRef, innerContent) {
            return _vdomJs.createElement("th", _tslib.__assign({
                ref: rootElRef,
                role: "columnheader",
                className: classNames.concat(customClassNames).join(' '),
                colSpan: props.colSpan
            }, props.extraDataAttrs), _vdomJs.createElement("div", {
                className: "fc-scrollgrid-sync-inner"
            }, _vdomJs.createElement("a", {
                "aria-label": dateEnv.format(date, WEEKDAY_FORMAT),
                className: [
                    'fc-col-header-cell-cushion',
                    props.isSticky ? 'fc-sticky' : '', 
                ].join(' '),
                ref: innerElRef
            }, innerContent)));
        });
    };
    return TableDowCell1;
}(BaseComponent);
var NowTimer = /** @class */ function(_super) {
    _tslib.__extends(NowTimer1, _super);
    function NowTimer1(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.initialNowDate = getNow(context.options.now, context.dateEnv);
        _this.initialNowQueriedMs = new Date().valueOf();
        _this.state = _this.computeTiming().currentState;
        return _this;
    }
    NowTimer1.prototype.render = function() {
        var _a = this, props = _a.props, state = _a.state;
        return props.children(state.nowDate, state.todayRange);
    };
    NowTimer1.prototype.componentDidMount = function() {
        this.setTimeout();
    };
    NowTimer1.prototype.componentDidUpdate = function(prevProps) {
        if (prevProps.unit !== this.props.unit) {
            this.clearTimeout();
            this.setTimeout();
        }
    };
    NowTimer1.prototype.componentWillUnmount = function() {
        this.clearTimeout();
    };
    NowTimer1.prototype.computeTiming = function() {
        var _a = this, props = _a.props, context = _a.context;
        var unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);
        var currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);
        var nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));
        var waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();
        // there is a max setTimeout ms value (https://stackoverflow.com/a/3468650/96342)
        // ensure no longer than a day
        waitMs = Math.min(86400000, waitMs);
        return {
            currentState: {
                nowDate: currentUnitStart,
                todayRange: buildDayRange(currentUnitStart)
            },
            nextState: {
                nowDate: nextUnitStart,
                todayRange: buildDayRange(nextUnitStart)
            },
            waitMs: waitMs
        };
    };
    NowTimer1.prototype.setTimeout = function() {
        var _this = this;
        var _a = this.computeTiming(), nextState = _a.nextState, waitMs = _a.waitMs;
        this.timeoutId = setTimeout(function() {
            _this.setState(nextState, function() {
                _this.setTimeout();
            });
        }, waitMs);
    };
    NowTimer1.prototype.clearTimeout = function() {
        if (this.timeoutId) clearTimeout(this.timeoutId);
    };
    NowTimer1.contextType = ViewContextType;
    return NowTimer1;
}(_vdomJs.Component);
function buildDayRange(date) {
    var start = startOfDay(date);
    var end = addDays(start, 1);
    return {
        start: start,
        end: end
    };
}
var DayHeader = /** @class */ function(_super) {
    _tslib.__extends(DayHeader1, _super);
    function DayHeader1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);
        return _this;
    }
    DayHeader1.prototype.render = function() {
        var context = this.context;
        var _a = this.props, dates = _a.dates, dateProfile = _a.dateProfile, datesRepDistinctDays = _a.datesRepDistinctDays, renderIntro = _a.renderIntro;
        var dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);
        return _vdomJs.createElement(NowTimer, {
            unit: "day"
        }, function(nowDate, todayRange) {
            return _vdomJs.createElement("tr", {
                role: "row"
            }, renderIntro && renderIntro('day'), dates.map(function(date) {
                return datesRepDistinctDays ? _vdomJs.createElement(TableDateCell, {
                    key: date.toISOString(),
                    date: date,
                    dateProfile: dateProfile,
                    todayRange: todayRange,
                    colCnt: dates.length,
                    dayHeaderFormat: dayHeaderFormat
                }) : _vdomJs.createElement(TableDowCell, {
                    key: date.getUTCDay(),
                    dow: date.getUTCDay(),
                    dayHeaderFormat: dayHeaderFormat
                });
            }));
        });
    };
    return DayHeader1;
}(BaseComponent);
function createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {
    return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);
}
var DaySeriesModel = /** @class */ function() {
    function DaySeriesModel1(range, dateProfileGenerator) {
        var date = range.start;
        var end = range.end;
        var indices = [];
        var dates = [];
        var dayIndex = -1;
        while(date < end){
            if (dateProfileGenerator.isHiddenDay(date)) indices.push(dayIndex + 0.5); // mark that it's between indices
            else {
                dayIndex += 1;
                indices.push(dayIndex);
                dates.push(date);
            }
            date = addDays(date, 1);
        }
        this.dates = dates;
        this.indices = indices;
        this.cnt = dates.length;
    }
    DaySeriesModel1.prototype.sliceRange = function(range) {
        var firstIndex = this.getDateDayIndex(range.start); // inclusive first index
        var lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index
        var clippedFirstIndex = Math.max(0, firstIndex);
        var clippedLastIndex = Math.min(this.cnt - 1, lastIndex);
        // deal with in-between indices
        clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell
        clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell
        if (clippedFirstIndex <= clippedLastIndex) return {
            firstIndex: clippedFirstIndex,
            lastIndex: clippedLastIndex,
            isStart: firstIndex === clippedFirstIndex,
            isEnd: lastIndex === clippedLastIndex
        };
        return null;
    };
    // Given a date, returns its chronolocial cell-index from the first cell of the grid.
    // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
    // If before the first offset, returns a negative number.
    // If after the last offset, returns an offset past the last cell offset.
    // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
    DaySeriesModel1.prototype.getDateDayIndex = function(date) {
        var indices = this.indices;
        var dayOffset = Math.floor(diffDays(this.dates[0], date));
        if (dayOffset < 0) return indices[0] - 1;
        if (dayOffset >= indices.length) return indices[indices.length - 1] + 1;
        return indices[dayOffset];
    };
    return DaySeriesModel1;
}();
var DayTableModel = /** @class */ function() {
    function DayTableModel1(daySeries, breakOnWeeks) {
        var dates = daySeries.dates;
        var daysPerRow;
        var firstDay;
        var rowCnt;
        if (breakOnWeeks) {
            // count columns until the day-of-week repeats
            firstDay = dates[0].getUTCDay();
            for(daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1){
                if (dates[daysPerRow].getUTCDay() === firstDay) break;
            }
            rowCnt = Math.ceil(dates.length / daysPerRow);
        } else {
            rowCnt = 1;
            daysPerRow = dates.length;
        }
        this.rowCnt = rowCnt;
        this.colCnt = daysPerRow;
        this.daySeries = daySeries;
        this.cells = this.buildCells();
        this.headerDates = this.buildHeaderDates();
    }
    DayTableModel1.prototype.buildCells = function() {
        var rows = [];
        for(var row = 0; row < this.rowCnt; row += 1){
            var cells = [];
            for(var col = 0; col < this.colCnt; col += 1)cells.push(this.buildCell(row, col));
            rows.push(cells);
        }
        return rows;
    };
    DayTableModel1.prototype.buildCell = function(row, col) {
        var date = this.daySeries.dates[row * this.colCnt + col];
        return {
            key: date.toISOString(),
            date: date
        };
    };
    DayTableModel1.prototype.buildHeaderDates = function() {
        var dates = [];
        for(var col = 0; col < this.colCnt; col += 1)dates.push(this.cells[0][col].date);
        return dates;
    };
    DayTableModel1.prototype.sliceRange = function(range) {
        var colCnt = this.colCnt;
        var seriesSeg = this.daySeries.sliceRange(range);
        var segs = [];
        if (seriesSeg) {
            var firstIndex = seriesSeg.firstIndex, lastIndex = seriesSeg.lastIndex;
            var index = firstIndex;
            while(index <= lastIndex){
                var row = Math.floor(index / colCnt);
                var nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);
                segs.push({
                    row: row,
                    firstCol: index % colCnt,
                    lastCol: (nextIndex - 1) % colCnt,
                    isStart: seriesSeg.isStart && index === firstIndex,
                    isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex
                });
                index = nextIndex;
            }
        }
        return segs;
    };
    return DayTableModel1;
}();
var Slicer = /** @class */ function() {
    function Slicer1() {
        this.sliceBusinessHours = memoize(this._sliceBusinessHours);
        this.sliceDateSelection = memoize(this._sliceDateSpan);
        this.sliceEventStore = memoize(this._sliceEventStore);
        this.sliceEventDrag = memoize(this._sliceInteraction);
        this.sliceEventResize = memoize(this._sliceInteraction);
        this.forceDayIfListItem = false; // hack
    }
    Slicer1.prototype.sliceProps = function(props, dateProfile, nextDayThreshold, context) {
        var extraArgs = [];
        for(var _i = 4; _i < arguments.length; _i++)extraArgs[_i - 4] = arguments[_i];
        var eventUiBases = props.eventUiBases;
        var eventSegs = this.sliceEventStore.apply(this, _tslib.__spreadArray([
            props.eventStore,
            eventUiBases,
            dateProfile,
            nextDayThreshold
        ], extraArgs));
        return {
            dateSelectionSegs: this.sliceDateSelection.apply(this, _tslib.__spreadArray([
                props.dateSelection,
                eventUiBases,
                context
            ], extraArgs)),
            businessHourSegs: this.sliceBusinessHours.apply(this, _tslib.__spreadArray([
                props.businessHours,
                dateProfile,
                nextDayThreshold,
                context
            ], extraArgs)),
            fgEventSegs: eventSegs.fg,
            bgEventSegs: eventSegs.bg,
            eventDrag: this.sliceEventDrag.apply(this, _tslib.__spreadArray([
                props.eventDrag,
                eventUiBases,
                dateProfile,
                nextDayThreshold
            ], extraArgs)),
            eventResize: this.sliceEventResize.apply(this, _tslib.__spreadArray([
                props.eventResize,
                eventUiBases,
                dateProfile,
                nextDayThreshold
            ], extraArgs)),
            eventSelection: props.eventSelection
        }; // TODO: give interactionSegs?
    };
    Slicer1.prototype.sliceNowDate = function(date, context) {
        var extraArgs = [];
        for(var _i = 2; _i < arguments.length; _i++)extraArgs[_i - 2] = arguments[_i];
        return this._sliceDateSpan.apply(this, _tslib.__spreadArray([
            {
                range: {
                    start: date,
                    end: addMs(date, 1)
                },
                allDay: false
            },
            {},
            context
        ], extraArgs));
    };
    Slicer1.prototype._sliceBusinessHours = function(businessHours, dateProfile, nextDayThreshold, context) {
        var extraArgs = [];
        for(var _i = 4; _i < arguments.length; _i++)extraArgs[_i - 4] = arguments[_i];
        if (!businessHours) return [];
        return this._sliceEventStore.apply(this, _tslib.__spreadArray([
            expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context),
            {},
            dateProfile,
            nextDayThreshold
        ], extraArgs)).bg;
    };
    Slicer1.prototype._sliceEventStore = function(eventStore, eventUiBases, dateProfile, nextDayThreshold) {
        var extraArgs = [];
        for(var _i = 4; _i < arguments.length; _i++)extraArgs[_i - 4] = arguments[_i];
        if (eventStore) {
            var rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
            return {
                bg: this.sliceEventRanges(rangeRes.bg, extraArgs),
                fg: this.sliceEventRanges(rangeRes.fg, extraArgs)
            };
        }
        return {
            bg: [],
            fg: []
        };
    };
    Slicer1.prototype._sliceInteraction = function(interaction, eventUiBases, dateProfile, nextDayThreshold) {
        var extraArgs = [];
        for(var _i = 4; _i < arguments.length; _i++)extraArgs[_i - 4] = arguments[_i];
        if (!interaction) return null;
        var rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
        return {
            segs: this.sliceEventRanges(rangeRes.fg, extraArgs),
            affectedInstances: interaction.affectedEvents.instances,
            isEvent: interaction.isEvent
        };
    };
    Slicer1.prototype._sliceDateSpan = function(dateSpan, eventUiBases, context) {
        var extraArgs = [];
        for(var _i = 3; _i < arguments.length; _i++)extraArgs[_i - 3] = arguments[_i];
        if (!dateSpan) return [];
        var eventRange = fabricateEventRange(dateSpan, eventUiBases, context);
        var segs = this.sliceRange.apply(this, _tslib.__spreadArray([
            dateSpan.range
        ], extraArgs));
        for(var _a = 0, segs_1 = segs; _a < segs_1.length; _a++){
            var seg = segs_1[_a];
            seg.eventRange = eventRange;
        }
        return segs;
    };
    /*
    "complete" seg means it has component and eventRange
    */ Slicer1.prototype.sliceEventRanges = function(eventRanges, extraArgs) {
        var segs = [];
        for(var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++){
            var eventRange = eventRanges_1[_i];
            segs.push.apply(segs, this.sliceEventRange(eventRange, extraArgs));
        }
        return segs;
    };
    /*
    "complete" seg means it has component and eventRange
    */ Slicer1.prototype.sliceEventRange = function(eventRange, extraArgs) {
        var dateRange = eventRange.range;
        // hack to make multi-day events that are being force-displayed as list-items to take up only one day
        if (this.forceDayIfListItem && eventRange.ui.display === 'list-item') dateRange = {
            start: dateRange.start,
            end: addDays(dateRange.start, 1)
        };
        var segs = this.sliceRange.apply(this, _tslib.__spreadArray([
            dateRange
        ], extraArgs));
        for(var _i = 0, segs_2 = segs; _i < segs_2.length; _i++){
            var seg = segs_2[_i];
            seg.eventRange = eventRange;
            seg.isStart = eventRange.isStart && seg.isStart;
            seg.isEnd = eventRange.isEnd && seg.isEnd;
        }
        return segs;
    };
    return Slicer1;
}();
/*
for incorporating slotMinTime/slotMaxTime if appropriate
TODO: should be part of DateProfile!
TimelineDateProfile already does this btw
*/ function computeActiveRange(dateProfile, isComponentAllDay) {
    var range = dateProfile.activeRange;
    if (isComponentAllDay) return range;
    return {
        start: addMs(range.start, dateProfile.slotMinTime.milliseconds),
        end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5)
    };
}
// high-level segmenting-aware tester functions
// ------------------------------------------------------------------------------------------------------------------------
function isInteractionValid(interaction, dateProfile, context) {
    var instances = interaction.mutatedEvents.instances;
    for(var instanceId in instances){
        if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) return false;
    }
    return isNewPropsValid({
        eventDrag: interaction
    }, context); // HACK: the eventDrag props is used for ALL interactions
}
function isDateSelectionValid(dateSelection, dateProfile, context) {
    if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) return false;
    return isNewPropsValid({
        dateSelection: dateSelection
    }, context);
}
function isNewPropsValid(newProps, context) {
    var calendarState = context.getCurrentData();
    var props = _tslib.__assign({
        businessHours: calendarState.businessHours,
        dateSelection: '',
        eventStore: calendarState.eventStore,
        eventUiBases: calendarState.eventUiBases,
        eventSelection: '',
        eventDrag: null,
        eventResize: null
    }, newProps);
    return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);
}
function isPropsValid(state, context, dateSpanMeta, filterConfig) {
    if (dateSpanMeta === void 0) dateSpanMeta = {};
    if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) return false;
    if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) return false;
    return true;
}
// Moving Event Validation
// ------------------------------------------------------------------------------------------------------------------------
function isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {
    var currentState = context.getCurrentData();
    var interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions
    var subjectEventStore = interaction.mutatedEvents;
    var subjectDefs = subjectEventStore.defs;
    var subjectInstances = subjectEventStore.instances;
    var subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : {
        '': currentState.selectionConfig
    });
    if (filterConfig) subjectConfigs = mapHash(subjectConfigs, filterConfig);
    // exclude the subject events. TODO: exclude defs too?
    var otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);
    var otherDefs = otherEventStore.defs;
    var otherInstances = otherEventStore.instances;
    var otherConfigs = compileEventUis(otherDefs, state.eventUiBases);
    for(var subjectInstanceId in subjectInstances){
        var subjectInstance = subjectInstances[subjectInstanceId];
        var subjectRange = subjectInstance.range;
        var subjectConfig = subjectConfigs[subjectInstance.defId];
        var subjectDef = subjectDefs[subjectInstance.defId];
        // constraint
        if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) return false;
        // overlap
        var eventOverlap = context.options.eventOverlap;
        var eventOverlapFunc = typeof eventOverlap === 'function' ? eventOverlap : null;
        for(var otherInstanceId in otherInstances){
            var otherInstance = otherInstances[otherInstanceId];
            // intersect! evaluate
            if (rangesIntersect(subjectRange, otherInstance.range)) {
                var otherOverlap = otherConfigs[otherInstance.defId].overlap;
                // consider the other event's overlap. only do this if the subject event is a "real" event
                if (otherOverlap === false && interaction.isEvent) return false;
                if (subjectConfig.overlap === false) return false;
                if (eventOverlapFunc && !eventOverlapFunc(new EventApi(context, otherDefs[otherInstance.defId], otherInstance), new EventApi(context, subjectDef, subjectInstance))) return false;
            }
        }
        // allow (a function)
        var calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state
        for(var _i = 0, _a = subjectConfig.allows; _i < _a.length; _i++){
            var subjectAllow = _a[_i];
            var subjectDateSpan = _tslib.__assign(_tslib.__assign({}, dateSpanMeta), {
                range: subjectInstance.range,
                allDay: subjectDef.allDay
            });
            var origDef = calendarEventStore.defs[subjectDef.defId];
            var origInstance = calendarEventStore.instances[subjectInstanceId];
            var eventApi = void 0;
            if (origDef) eventApi = new EventApi(context, origDef, origInstance);
            else eventApi = new EventApi(context, subjectDef); // no instance, because had no dates
            if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) return false;
        }
    }
    return true;
}
// Date Selection Validation
// ------------------------------------------------------------------------------------------------------------------------
function isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {
    var relevantEventStore = state.eventStore;
    var relevantDefs = relevantEventStore.defs;
    var relevantInstances = relevantEventStore.instances;
    var selection = state.dateSelection;
    var selectionRange = selection.range;
    var selectionConfig = context.getCurrentData().selectionConfig;
    if (filterConfig) selectionConfig = filterConfig(selectionConfig);
    // constraint
    if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) return false;
    // overlap
    var selectOverlap = context.options.selectOverlap;
    var selectOverlapFunc = typeof selectOverlap === 'function' ? selectOverlap : null;
    for(var relevantInstanceId in relevantInstances){
        var relevantInstance = relevantInstances[relevantInstanceId];
        // intersect! evaluate
        if (rangesIntersect(selectionRange, relevantInstance.range)) {
            if (selectionConfig.overlap === false) return false;
            if (selectOverlapFunc && !selectOverlapFunc(new EventApi(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) return false;
        }
    }
    // allow (a function)
    for(var _i = 0, _a = selectionConfig.allows; _i < _a.length; _i++){
        var selectionAllow = _a[_i];
        var fullDateSpan = _tslib.__assign(_tslib.__assign({}, dateSpanMeta), selection);
        if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) return false;
    }
    return true;
}
// Constraint Utils
// ------------------------------------------------------------------------------------------------------------------------
function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
    for(var _i = 0, constraints_1 = constraints; _i < constraints_1.length; _i++){
        var constraint = constraints_1[_i];
        if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) return false;
    }
    return true;
}
function constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
    if (constraint === 'businessHours') return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));
    if (typeof constraint === 'string') return eventStoreToRanges(filterEventStoreDefs(otherEventStore, function(eventDef) {
        return eventDef.groupId === constraint;
    }));
    if (typeof constraint === 'object' && constraint) return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));
    return []; // if it's false
}
// TODO: move to event-store file?
function eventStoreToRanges(eventStore) {
    var instances = eventStore.instances;
    var ranges = [];
    for(var instanceId in instances)ranges.push(instances[instanceId].range);
    return ranges;
}
// TODO: move to geom file?
function anyRangesContainRange(outerRanges, innerRange) {
    for(var _i = 0, outerRanges_1 = outerRanges; _i < outerRanges_1.length; _i++){
        var outerRange = outerRanges_1[_i];
        if (rangeContainsRange(outerRange, innerRange)) return true;
    }
    return false;
}
var VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;
var Scroller = /** @class */ function(_super) {
    _tslib.__extends(Scroller1, _super);
    function Scroller1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.handleEl = function(el) {
            _this.el = el;
            setRef(_this.props.elRef, el);
        };
        return _this;
    }
    Scroller1.prototype.render = function() {
        var props = this.props;
        var liquid = props.liquid, liquidIsAbsolute = props.liquidIsAbsolute;
        var isAbsolute = liquid && liquidIsAbsolute;
        var className = [
            'fc-scroller'
        ];
        if (liquid) {
            if (liquidIsAbsolute) className.push('fc-scroller-liquid-absolute');
            else className.push('fc-scroller-liquid');
        }
        return _vdomJs.createElement("div", {
            ref: this.handleEl,
            className: className.join(' '),
            style: {
                overflowX: props.overflowX,
                overflowY: props.overflowY,
                left: isAbsolute && -(props.overcomeLeft || 0) || '',
                right: isAbsolute && -(props.overcomeRight || 0) || '',
                bottom: isAbsolute && -(props.overcomeBottom || 0) || '',
                marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || '',
                marginRight: !isAbsolute && -(props.overcomeRight || 0) || '',
                marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || '',
                maxHeight: props.maxHeight || ''
            }
        }, props.children);
    };
    Scroller1.prototype.needsXScrolling = function() {
        if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) return false;
        // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.
        // much more reliable to see if children are taller than the scroller, even tho doesn't account for
        // inner-child margins and absolute positioning
        var el = this.el;
        var realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();
        var children = el.children;
        for(var i = 0; i < children.length; i += 1){
            var childEl = children[i];
            if (childEl.getBoundingClientRect().width > realClientWidth) return true;
        }
        return false;
    };
    Scroller1.prototype.needsYScrolling = function() {
        if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) return false;
        // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.
        // much more reliable to see if children are taller than the scroller, even tho doesn't account for
        // inner-child margins and absolute positioning
        var el = this.el;
        var realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();
        var children = el.children;
        for(var i = 0; i < children.length; i += 1){
            var childEl = children[i];
            if (childEl.getBoundingClientRect().height > realClientHeight) return true;
        }
        return false;
    };
    Scroller1.prototype.getXScrollbarWidth = function() {
        if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) return 0;
        return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?
    };
    Scroller1.prototype.getYScrollbarWidth = function() {
        if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) return 0;
        return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?
    };
    return Scroller1;
}(BaseComponent);
/*
TODO: somehow infer OtherArgs from masterCallback?
TODO: infer RefType from masterCallback if provided
*/ var RefMap = /** @class */ function() {
    function RefMap1(masterCallback) {
        var _this = this;
        this.masterCallback = masterCallback;
        this.currentMap = {};
        this.depths = {};
        this.callbackMap = {};
        this.handleValue = function(val, key) {
            var _a = _this, depths = _a.depths, currentMap = _a.currentMap;
            var removed = false;
            var added = false;
            if (val !== null) {
                // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore
                removed = key in currentMap;
                currentMap[key] = val;
                depths[key] = (depths[key] || 0) + 1;
                added = true;
            } else {
                depths[key] -= 1;
                if (!depths[key]) {
                    delete currentMap[key];
                    delete _this.callbackMap[key];
                    removed = true;
                }
            }
            if (_this.masterCallback) {
                if (removed) _this.masterCallback(null, String(key));
                if (added) _this.masterCallback(val, String(key));
            }
        };
    }
    RefMap1.prototype.createRef = function(key) {
        var _this = this;
        var refCallback = this.callbackMap[key];
        if (!refCallback) refCallback = this.callbackMap[key] = function(val) {
            _this.handleValue(val, String(key));
        };
        return refCallback;
    };
    // TODO: check callers that don't care about order. should use getAll instead
    // NOTE: this method has become less valuable now that we are encouraged to map order by some other index
    // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and "collect"
    RefMap1.prototype.collect = function(startIndex, endIndex, step) {
        return collectFromHash(this.currentMap, startIndex, endIndex, step);
    };
    RefMap1.prototype.getAll = function() {
        return hashValuesToArray(this.currentMap);
    };
    return RefMap1;
}();
function computeShrinkWidth(chunkEls) {
    var shrinkCells = findElements(chunkEls, '.fc-scrollgrid-shrink');
    var largestWidth = 0;
    for(var _i = 0, shrinkCells_1 = shrinkCells; _i < shrinkCells_1.length; _i++){
        var shrinkCell = shrinkCells_1[_i];
        largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));
    }
    return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits
}
function getSectionHasLiquidHeight(props, sectionConfig) {
    return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)
}
function getAllowYScrolling(props, sectionConfig) {
    return sectionConfig.maxHeight != null || getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars
}
// TODO: ONLY use `arg`. force out internal function to use same API
function renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {
    var expandRows = arg.expandRows;
    var content = typeof chunkConfig.content === 'function' ? chunkConfig.content(arg) : _vdomJs.createElement('table', {
        role: 'presentation',
        className: [
            chunkConfig.tableClassName,
            sectionConfig.syncRowHeights ? 'fc-scrollgrid-sync-table' : '', 
        ].join(' '),
        style: {
            minWidth: arg.tableMinWidth,
            width: arg.clientWidth,
            height: expandRows ? arg.clientHeight : ''
        }
    }, arg.tableColGroupNode, _vdomJs.createElement(isHeader ? 'thead' : 'tbody', {
        role: 'presentation'
    }, typeof chunkConfig.rowContent === 'function' ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));
    return content;
}
function isColPropsEqual(cols0, cols1) {
    return isArraysEqual(cols0, cols1, isPropsEqual);
}
function renderMicroColGroup(cols, shrinkWidth) {
    var colNodes = [];
    /*
    for ColProps with spans, it would have been great to make a single <col span="">
    HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.
    SOLUTION: making individual <col> elements makes Chrome behave.
    */ for(var _i = 0, cols_1 = cols; _i < cols_1.length; _i++){
        var colProps = cols_1[_i];
        var span = colProps.span || 1;
        for(var i = 0; i < span; i += 1)colNodes.push(_vdomJs.createElement("col", {
            style: {
                width: colProps.width === 'shrink' ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || '',
                minWidth: colProps.minWidth || ''
            }
        }));
    }
    return _vdomJs.createElement.apply(void 0, _tslib.__spreadArray([
        'colgroup',
        {}
    ], colNodes));
}
function sanitizeShrinkWidth(shrinkWidth) {
    /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth
    4 accounts for 2 2-pixel borders. TODO: better solution? */ return shrinkWidth == null ? 4 : shrinkWidth;
}
function hasShrinkWidth(cols) {
    for(var _i = 0, cols_2 = cols; _i < cols_2.length; _i++){
        var col = cols_2[_i];
        if (col.width === 'shrink') return true;
    }
    return false;
}
function getScrollGridClassNames(liquid, context) {
    var classNames = [
        'fc-scrollgrid',
        context.theme.getClass('table'), 
    ];
    if (liquid) classNames.push('fc-scrollgrid-liquid');
    return classNames;
}
function getSectionClassNames(sectionConfig, wholeTableVGrow) {
    var classNames = [
        'fc-scrollgrid-section',
        "fc-scrollgrid-section-" + sectionConfig.type,
        sectionConfig.className
    ];
    if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) classNames.push('fc-scrollgrid-section-liquid');
    if (sectionConfig.isSticky) classNames.push('fc-scrollgrid-section-sticky');
    return classNames;
}
function renderScrollShim(arg) {
    return _vdomJs.createElement("div", {
        className: "fc-scrollgrid-sticky-shim",
        style: {
            width: arg.clientWidth,
            minWidth: arg.tableMinWidth
        }
    });
}
function getStickyHeaderDates(options) {
    var stickyHeaderDates = options.stickyHeaderDates;
    if (stickyHeaderDates == null || stickyHeaderDates === 'auto') stickyHeaderDates = options.height === 'auto' || options.viewHeight === 'auto';
    return stickyHeaderDates;
}
function getStickyFooterScrollbar(options) {
    var stickyFooterScrollbar = options.stickyFooterScrollbar;
    if (stickyFooterScrollbar == null || stickyFooterScrollbar === 'auto') stickyFooterScrollbar = options.height === 'auto' || options.viewHeight === 'auto';
    return stickyFooterScrollbar;
}
var SimpleScrollGrid = /** @class */ function(_super) {
    _tslib.__extends(SimpleScrollGrid1, _super);
    function SimpleScrollGrid1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.processCols = memoize(function(a) {
            return a;
        }, isColPropsEqual); // so we get same `cols` props every time
        // yucky to memoize VNodes, but much more efficient for consumers
        _this.renderMicroColGroup = memoize(renderMicroColGroup);
        _this.scrollerRefs = new RefMap();
        _this.scrollerElRefs = new RefMap(_this._handleScrollerEl.bind(_this));
        _this.state = {
            shrinkWidth: null,
            forceYScrollbars: false,
            scrollerClientWidths: {},
            scrollerClientHeights: {}
        };
        // TODO: can do a really simple print-view. dont need to join rows
        _this.handleSizing = function() {
            _this.setState(_tslib.__assign({
                shrinkWidth: _this.computeShrinkWidth()
            }, _this.computeScrollerDims()));
        };
        return _this;
    }
    SimpleScrollGrid1.prototype.render = function() {
        var _a = this, props = _a.props, state = _a.state, context = _a.context;
        var sectionConfigs = props.sections || [];
        var cols = this.processCols(props.cols);
        var microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);
        var classNames = getScrollGridClassNames(props.liquid, context);
        if (props.collapsibleWidth) classNames.push('fc-scrollgrid-collapsible');
        // TODO: make DRY
        var configCnt = sectionConfigs.length;
        var configI = 0;
        var currentConfig;
        var headSectionNodes = [];
        var bodySectionNodes = [];
        var footSectionNodes = [];
        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header'){
            headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
            configI += 1;
        }
        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body'){
            bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));
            configI += 1;
        }
        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer'){
            footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
            configI += 1;
        }
        // firefox bug: when setting height on table and there is a thead or tfoot,
        // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)
        // use getCanVGrowWithinCell as a way to detect table-stupid firefox.
        // if so, use a simpler dom structure, jam everything into a lone tbody.
        var isBuggy = !getCanVGrowWithinCell();
        var roleAttrs = {
            role: 'rowgroup'
        };
        return _vdomJs.createElement('table', {
            role: 'grid',
            className: classNames.join(' '),
            style: {
                height: props.height
            }
        }, Boolean(!isBuggy && headSectionNodes.length) && _vdomJs.createElement.apply(void 0, _tslib.__spreadArray([
            'thead',
            roleAttrs
        ], headSectionNodes)), Boolean(!isBuggy && bodySectionNodes.length) && _vdomJs.createElement.apply(void 0, _tslib.__spreadArray([
            'tbody',
            roleAttrs
        ], bodySectionNodes)), Boolean(!isBuggy && footSectionNodes.length) && _vdomJs.createElement.apply(void 0, _tslib.__spreadArray([
            'tfoot',
            roleAttrs
        ], footSectionNodes)), isBuggy && _vdomJs.createElement.apply(void 0, _tslib.__spreadArray(_tslib.__spreadArray(_tslib.__spreadArray([
            'tbody',
            roleAttrs
        ], headSectionNodes), bodySectionNodes), footSectionNodes)));
    };
    SimpleScrollGrid1.prototype.renderSection = function(sectionConfig, microColGroupNode, isHeader) {
        if ('outerContent' in sectionConfig) return _vdomJs.createElement(_vdomJs.Fragment, {
            key: sectionConfig.key
        }, sectionConfig.outerContent);
        return _vdomJs.createElement("tr", {
            key: sectionConfig.key,
            role: "presentation",
            className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ')
        }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));
    };
    SimpleScrollGrid1.prototype.renderChunkTd = function(sectionConfig, microColGroupNode, chunkConfig, isHeader) {
        if ('outerContent' in chunkConfig) return chunkConfig.outerContent;
        var props = this.props;
        var _a = this.state, forceYScrollbars = _a.forceYScrollbars, scrollerClientWidths = _a.scrollerClientWidths, scrollerClientHeights = _a.scrollerClientHeights;
        var needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?
        var isLiquid = getSectionHasLiquidHeight(props, sectionConfig);
        // for `!props.liquid` - is WHOLE scrollgrid natural height?
        // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars
        var overflowY = !props.liquid ? 'visible' : forceYScrollbars ? 'scroll' : !needsYScrolling ? 'hidden' : 'auto';
        var sectionKey = sectionConfig.key;
        var content = renderChunkContent(sectionConfig, chunkConfig, {
            tableColGroupNode: microColGroupNode,
            tableMinWidth: '',
            clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined ? scrollerClientWidths[sectionKey] : null,
            clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,
            expandRows: sectionConfig.expandRows,
            syncRowHeights: false,
            rowSyncHeights: [],
            reportRowHeightChange: function() {}
        }, isHeader);
        return _vdomJs.createElement(isHeader ? 'th' : 'td', {
            ref: chunkConfig.elRef,
            role: 'presentation'
        }, _vdomJs.createElement("div", {
            className: "fc-scroller-harness" + (isLiquid ? ' fc-scroller-harness-liquid' : '')
        }, _vdomJs.createElement(Scroller, {
            ref: this.scrollerRefs.createRef(sectionKey),
            elRef: this.scrollerElRefs.createRef(sectionKey),
            overflowY: overflowY,
            overflowX: !props.liquid ? 'visible' : 'hidden' /* natural height? */ ,
            maxHeight: sectionConfig.maxHeight,
            liquid: isLiquid,
            liquidIsAbsolute: true
        }, content)));
    };
    SimpleScrollGrid1.prototype._handleScrollerEl = function(scrollerEl, key) {
        var section = getSectionByKey(this.props.sections, key);
        if (section) setRef(section.chunk.scrollerElRef, scrollerEl);
    };
    SimpleScrollGrid1.prototype.componentDidMount = function() {
        this.handleSizing();
        this.context.addResizeHandler(this.handleSizing);
    };
    SimpleScrollGrid1.prototype.componentDidUpdate = function() {
        // TODO: need better solution when state contains non-sizing things
        this.handleSizing();
    };
    SimpleScrollGrid1.prototype.componentWillUnmount = function() {
        this.context.removeResizeHandler(this.handleSizing);
    };
    SimpleScrollGrid1.prototype.computeShrinkWidth = function() {
        return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;
    };
    SimpleScrollGrid1.prototype.computeScrollerDims = function() {
        var scrollbarWidth = getScrollbarWidths();
        var _a = this, scrollerRefs = _a.scrollerRefs, scrollerElRefs = _a.scrollerElRefs;
        var forceYScrollbars = false;
        var scrollerClientWidths = {};
        var scrollerClientHeights = {};
        for(var sectionKey in scrollerRefs.currentMap){
            var scroller = scrollerRefs.currentMap[sectionKey];
            if (scroller && scroller.needsYScrolling()) {
                forceYScrollbars = true;
                break;
            }
        }
        for(var _i = 0, _b = this.props.sections; _i < _b.length; _i++){
            var section = _b[_i];
            var sectionKey = section.key;
            var scrollerEl = scrollerElRefs.currentMap[sectionKey];
            if (scrollerEl) {
                var harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders
                scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future
                 : 0));
                scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);
            }
        }
        return {
            forceYScrollbars: forceYScrollbars,
            scrollerClientWidths: scrollerClientWidths,
            scrollerClientHeights: scrollerClientHeights
        };
    };
    return SimpleScrollGrid1;
}(BaseComponent);
SimpleScrollGrid.addStateEquality({
    scrollerClientWidths: isPropsEqual,
    scrollerClientHeights: isPropsEqual
});
function getSectionByKey(sections, key) {
    for(var _i = 0, sections_1 = sections; _i < sections_1.length; _i++){
        var section = sections_1[_i];
        if (section.key === key) return section;
    }
    return null;
}
var EventRoot = /** @class */ function(_super) {
    _tslib.__extends(EventRoot1, _super);
    function EventRoot1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.elRef = _vdomJs.createRef();
        return _this;
    }
    EventRoot1.prototype.render = function() {
        var _a = this, props = _a.props, context = _a.context;
        var options = context.options;
        var seg = props.seg;
        var eventRange = seg.eventRange;
        var ui = eventRange.ui;
        var hookProps = {
            event: new EventApi(context, eventRange.def, eventRange.instance),
            view: context.viewApi,
            timeText: props.timeText,
            textColor: ui.textColor,
            backgroundColor: ui.backgroundColor,
            borderColor: ui.borderColor,
            isDraggable: !props.disableDragging && computeSegDraggable(seg, context),
            isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),
            isEndResizable: !props.disableResizing && computeSegEndResizable(seg),
            isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),
            isStart: Boolean(seg.isStart),
            isEnd: Boolean(seg.isEnd),
            isPast: Boolean(props.isPast),
            isFuture: Boolean(props.isFuture),
            isToday: Boolean(props.isToday),
            isSelected: Boolean(props.isSelected),
            isDragging: Boolean(props.isDragging),
            isResizing: Boolean(props.isResizing)
        };
        var standardClassNames = getEventClassNames(hookProps).concat(ui.classNames);
        return _vdomJs.createElement(RenderHook, {
            hookProps: hookProps,
            classNames: options.eventClassNames,
            content: options.eventContent,
            defaultContent: props.defaultContent,
            didMount: options.eventDidMount,
            willUnmount: options.eventWillUnmount,
            elRef: this.elRef
        }, function(rootElRef, customClassNames, innerElRef, innerContent) {
            return props.children(rootElRef, standardClassNames.concat(customClassNames), innerElRef, innerContent, hookProps);
        });
    };
    EventRoot1.prototype.componentDidMount = function() {
        setElSeg(this.elRef.current, this.props.seg);
    };
    /*
    need to re-assign seg to the element if seg changes, even if the element is the same
    */ EventRoot1.prototype.componentDidUpdate = function(prevProps) {
        var seg = this.props.seg;
        if (seg !== prevProps.seg) setElSeg(this.elRef.current, seg);
    };
    return EventRoot1;
}(BaseComponent);
// should not be a purecomponent
var StandardEvent = /** @class */ function(_super) {
    _tslib.__extends(StandardEvent1, _super);
    function StandardEvent1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StandardEvent1.prototype.render = function() {
        var _a = this, props = _a.props, context = _a.context;
        var seg = props.seg;
        var timeFormat = context.options.eventTimeFormat || props.defaultTimeFormat;
        var timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);
        return _vdomJs.createElement(EventRoot, {
            seg: seg,
            timeText: timeText,
            disableDragging: props.disableDragging,
            disableResizing: props.disableResizing,
            defaultContent: props.defaultContent || renderInnerContent$1,
            isDragging: props.isDragging,
            isResizing: props.isResizing,
            isDateSelecting: props.isDateSelecting,
            isSelected: props.isSelected,
            isPast: props.isPast,
            isFuture: props.isFuture,
            isToday: props.isToday
        }, function(rootElRef, classNames, innerElRef, innerContent, hookProps) {
            return _vdomJs.createElement("a", _tslib.__assign({
                className: props.extraClassNames.concat(classNames).join(' '),
                style: {
                    borderColor: hookProps.borderColor,
                    backgroundColor: hookProps.backgroundColor
                },
                ref: rootElRef
            }, getSegAnchorAttrs(seg, context)), _vdomJs.createElement("div", {
                className: "fc-event-main",
                ref: innerElRef,
                style: {
                    color: hookProps.textColor
                }
            }, innerContent), hookProps.isStartResizable && _vdomJs.createElement("div", {
                className: "fc-event-resizer fc-event-resizer-start"
            }), hookProps.isEndResizable && _vdomJs.createElement("div", {
                className: "fc-event-resizer fc-event-resizer-end"
            }));
        });
    };
    return StandardEvent1;
}(BaseComponent);
function renderInnerContent$1(innerProps) {
    return _vdomJs.createElement("div", {
        className: "fc-event-main-frame"
    }, innerProps.timeText && _vdomJs.createElement("div", {
        className: "fc-event-time"
    }, innerProps.timeText), _vdomJs.createElement("div", {
        className: "fc-event-title-container"
    }, _vdomJs.createElement("div", {
        className: "fc-event-title fc-sticky"
    }, innerProps.event.title || _vdomJs.createElement(_vdomJs.Fragment, null, "\u00A0"))));
}
var NowIndicatorRoot = function(props) {
    return _vdomJs.createElement(ViewContextType.Consumer, null, function(context) {
        var options = context.options;
        var hookProps = {
            isAxis: props.isAxis,
            date: context.dateEnv.toDate(props.date),
            view: context.viewApi
        };
        return _vdomJs.createElement(RenderHook, {
            hookProps: hookProps,
            classNames: options.nowIndicatorClassNames,
            content: options.nowIndicatorContent,
            didMount: options.nowIndicatorDidMount,
            willUnmount: options.nowIndicatorWillUnmount
        }, props.children);
    });
};
var DAY_NUM_FORMAT = createFormatter({
    day: 'numeric'
});
var DayCellContent = /** @class */ function(_super) {
    _tslib.__extends(DayCellContent1, _super);
    function DayCellContent1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DayCellContent1.prototype.render = function() {
        var _a = this, props = _a.props, context = _a.context;
        var options = context.options;
        var hookProps = refineDayCellHookProps({
            date: props.date,
            dateProfile: props.dateProfile,
            todayRange: props.todayRange,
            showDayNumber: props.showDayNumber,
            extraProps: props.extraHookProps,
            viewApi: context.viewApi,
            dateEnv: context.dateEnv
        });
        return _vdomJs.createElement(ContentHook, {
            hookProps: hookProps,
            content: options.dayCellContent,
            defaultContent: props.defaultContent
        }, props.children);
    };
    return DayCellContent1;
}(BaseComponent);
function refineDayCellHookProps(raw) {
    var date = raw.date, dateEnv = raw.dateEnv;
    var dayMeta = getDateMeta(date, raw.todayRange, null, raw.dateProfile);
    return _tslib.__assign(_tslib.__assign(_tslib.__assign({
        date: dateEnv.toDate(date),
        view: raw.viewApi
    }, dayMeta), {
        dayNumberText: raw.showDayNumber ? dateEnv.format(date, DAY_NUM_FORMAT) : ''
    }), raw.extraProps);
}
var DayCellRoot = /** @class */ function(_super) {
    _tslib.__extends(DayCellRoot1, _super);
    function DayCellRoot1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.refineHookProps = memoizeObjArg(refineDayCellHookProps);
        _this.normalizeClassNames = buildClassNameNormalizer();
        return _this;
    }
    DayCellRoot1.prototype.render = function() {
        var _a = this, props = _a.props, context = _a.context;
        var options = context.options;
        var hookProps = this.refineHookProps({
            date: props.date,
            dateProfile: props.dateProfile,
            todayRange: props.todayRange,
            showDayNumber: props.showDayNumber,
            extraProps: props.extraHookProps,
            viewApi: context.viewApi,
            dateEnv: context.dateEnv
        });
        var classNames = getDayClassNames(hookProps, context.theme).concat(hookProps.isDisabled ? [] // don't use custom classNames if disabled
         : this.normalizeClassNames(options.dayCellClassNames, hookProps));
        var dataAttrs = hookProps.isDisabled ? {} : {
            'data-date': formatDayString(props.date)
        };
        return _vdomJs.createElement(MountHook, {
            hookProps: hookProps,
            didMount: options.dayCellDidMount,
            willUnmount: options.dayCellWillUnmount,
            elRef: props.elRef
        }, function(rootElRef) {
            return props.children(rootElRef, classNames, dataAttrs, hookProps.isDisabled);
        });
    };
    return DayCellRoot1;
}(BaseComponent);
function renderFill(fillType) {
    return _vdomJs.createElement("div", {
        className: "fc-" + fillType
    });
}
var BgEvent = function(props) {
    return _vdomJs.createElement(EventRoot, {
        defaultContent: renderInnerContent,
        seg: props.seg /* uselesss i think */ ,
        timeText: "",
        disableDragging: true,
        disableResizing: true,
        isDragging: false,
        isResizing: false,
        isDateSelecting: false,
        isSelected: false,
        isPast: props.isPast,
        isFuture: props.isFuture,
        isToday: props.isToday
    }, function(rootElRef, classNames, innerElRef, innerContent, hookProps) {
        return _vdomJs.createElement("div", {
            ref: rootElRef,
            className: [
                'fc-bg-event'
            ].concat(classNames).join(' '),
            style: {
                backgroundColor: hookProps.backgroundColor
            }
        }, innerContent);
    });
};
function renderInnerContent(props) {
    var title = props.event.title;
    return title && _vdomJs.createElement("div", {
        className: "fc-event-title"
    }, props.event.title);
}
var WeekNumberRoot = function(props) {
    return _vdomJs.createElement(ViewContextType.Consumer, null, function(context) {
        var dateEnv = context.dateEnv, options = context.options;
        var date = props.date;
        var format = options.weekNumberFormat || props.defaultFormat;
        var num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?
        var text = dateEnv.format(date, format);
        var hookProps = {
            num: num,
            text: text,
            date: date
        };
        return _vdomJs.createElement(RenderHook, {
            hookProps: hookProps,
            classNames: options.weekNumberClassNames,
            content: options.weekNumberContent,
            defaultContent: renderInner,
            didMount: options.weekNumberDidMount,
            willUnmount: options.weekNumberWillUnmount
        }, props.children);
    });
};
function renderInner(innerProps) {
    return innerProps.text;
}
var PADDING_FROM_VIEWPORT = 10;
var Popover = /** @class */ function(_super) {
    _tslib.__extends(Popover1, _super);
    function Popover1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            titleId: getUniqueDomId()
        };
        _this.handleRootEl = function(el) {
            _this.rootEl = el;
            if (_this.props.elRef) setRef(_this.props.elRef, el);
        };
        // Triggered when the user clicks *anywhere* in the document, for the autoHide feature
        _this.handleDocumentMouseDown = function(ev) {
            // only hide the popover if the click happened outside the popover
            var target = getEventTargetViaRoot(ev);
            if (!_this.rootEl.contains(target)) _this.handleCloseClick();
        };
        _this.handleDocumentKeyDown = function(ev) {
            if (ev.key === 'Escape') _this.handleCloseClick();
        };
        _this.handleCloseClick = function() {
            var onClose = _this.props.onClose;
            if (onClose) onClose();
        };
        return _this;
    }
    Popover1.prototype.render = function() {
        var _a = this.context, theme = _a.theme, options = _a.options;
        var _b = this, props = _b.props, state = _b.state;
        var classNames = [
            'fc-popover',
            theme.getClass('popover'), 
        ].concat(props.extraClassNames || []);
        return _vdomJs.createPortal(_vdomJs.createElement("div", _tslib.__assign({
            id: props.id,
            className: classNames.join(' '),
            "aria-labelledby": state.titleId
        }, props.extraAttrs, {
            ref: this.handleRootEl
        }), _vdomJs.createElement("div", {
            className: 'fc-popover-header ' + theme.getClass('popoverHeader')
        }, _vdomJs.createElement("span", {
            className: "fc-popover-title",
            id: state.titleId
        }, props.title), _vdomJs.createElement("span", {
            className: 'fc-popover-close ' + theme.getIconClass('close'),
            title: options.closeHint,
            onClick: this.handleCloseClick
        })), _vdomJs.createElement("div", {
            className: 'fc-popover-body ' + theme.getClass('popoverContent')
        }, props.children)), props.parentEl);
    };
    Popover1.prototype.componentDidMount = function() {
        document.addEventListener('mousedown', this.handleDocumentMouseDown);
        document.addEventListener('keydown', this.handleDocumentKeyDown);
        this.updateSize();
    };
    Popover1.prototype.componentWillUnmount = function() {
        document.removeEventListener('mousedown', this.handleDocumentMouseDown);
        document.removeEventListener('keydown', this.handleDocumentKeyDown);
    };
    Popover1.prototype.updateSize = function() {
        var isRtl = this.context.isRtl;
        var _a = this.props, alignmentEl = _a.alignmentEl, alignGridTop = _a.alignGridTop;
        var rootEl = this.rootEl;
        var alignmentRect = computeClippedClientRect(alignmentEl);
        if (alignmentRect) {
            var popoverDims = rootEl.getBoundingClientRect();
            // position relative to viewport
            var popoverTop = alignGridTop ? elementClosest(alignmentEl, '.fc-scrollgrid').getBoundingClientRect().top : alignmentRect.top;
            var popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;
            // constrain
            popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);
            popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);
            popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);
            var origin_1 = rootEl.offsetParent.getBoundingClientRect();
            applyStyle(rootEl, {
                top: popoverTop - origin_1.top,
                left: popoverLeft - origin_1.left
            });
        }
    };
    return Popover1;
}(BaseComponent);
var MorePopover = /** @class */ function(_super) {
    _tslib.__extends(MorePopover1, _super);
    function MorePopover1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.handleRootEl = function(rootEl) {
            _this.rootEl = rootEl;
            if (rootEl) _this.context.registerInteractiveComponent(_this, {
                el: rootEl,
                useEventCenter: false
            });
            else _this.context.unregisterInteractiveComponent(_this);
        };
        return _this;
    }
    MorePopover1.prototype.render = function() {
        var _a = this.context, options = _a.options, dateEnv = _a.dateEnv;
        var props = this.props;
        var startDate = props.startDate, todayRange = props.todayRange, dateProfile = props.dateProfile;
        var title = dateEnv.format(startDate, options.dayPopoverFormat);
        return _vdomJs.createElement(DayCellRoot, {
            date: startDate,
            dateProfile: dateProfile,
            todayRange: todayRange,
            elRef: this.handleRootEl
        }, function(rootElRef, dayClassNames, dataAttrs) {
            return _vdomJs.createElement(Popover, {
                elRef: rootElRef,
                id: props.id,
                title: title,
                extraClassNames: [
                    'fc-more-popover'
                ].concat(dayClassNames),
                extraAttrs: dataAttrs /* TODO: make these time-based when not whole-day? */ ,
                parentEl: props.parentEl,
                alignmentEl: props.alignmentEl,
                alignGridTop: props.alignGridTop,
                onClose: props.onClose
            }, _vdomJs.createElement(DayCellContent, {
                date: startDate,
                dateProfile: dateProfile,
                todayRange: todayRange
            }, function(innerElRef, innerContent) {
                return innerContent && _vdomJs.createElement("div", {
                    className: "fc-more-popover-misc",
                    ref: innerElRef
                }, innerContent);
            }), props.children);
        });
    };
    MorePopover1.prototype.queryHit = function(positionLeft, positionTop, elWidth, elHeight) {
        var _a = this, rootEl = _a.rootEl, props = _a.props;
        if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) return {
            dateProfile: props.dateProfile,
            dateSpan: _tslib.__assign({
                allDay: true,
                range: {
                    start: props.startDate,
                    end: props.endDate
                }
            }, props.extraDateSpan),
            dayEl: rootEl,
            rect: {
                left: 0,
                top: 0,
                right: elWidth,
                bottom: elHeight
            },
            layer: 1
        };
        return null;
    };
    return MorePopover1;
}(DateComponent);
var MoreLinkRoot = /** @class */ function(_super) {
    _tslib.__extends(MoreLinkRoot1, _super);
    function MoreLinkRoot1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.linkElRef = _vdomJs.createRef();
        _this.state = {
            isPopoverOpen: false,
            popoverId: getUniqueDomId()
        };
        _this.handleClick = function(ev) {
            var _a1 = _this, props = _a1.props, context = _a1.context;
            var moreLinkClick = context.options.moreLinkClick;
            var date = computeRange(props).start;
            function buildPublicSeg(seg) {
                var _a = seg.eventRange, def = _a.def, instance = _a.instance, range = _a.range;
                return {
                    event: new EventApi(context, def, instance),
                    start: context.dateEnv.toDate(range.start),
                    end: context.dateEnv.toDate(range.end),
                    isStart: seg.isStart,
                    isEnd: seg.isEnd
                };
            }
            if (typeof moreLinkClick === 'function') moreLinkClick = moreLinkClick({
                date: date,
                allDay: Boolean(props.allDayDate),
                allSegs: props.allSegs.map(buildPublicSeg),
                hiddenSegs: props.hiddenSegs.map(buildPublicSeg),
                jsEvent: ev,
                view: context.viewApi
            });
            if (!moreLinkClick || moreLinkClick === 'popover') _this.setState({
                isPopoverOpen: true
            });
            else if (typeof moreLinkClick === 'string') context.calendarApi.zoomTo(date, moreLinkClick);
        };
        _this.handlePopoverClose = function() {
            _this.setState({
                isPopoverOpen: false
            });
        };
        return _this;
    }
    MoreLinkRoot1.prototype.render = function() {
        var _this = this;
        var _a = this, props = _a.props, state = _a.state;
        return _vdomJs.createElement(ViewContextType.Consumer, null, function(context) {
            var viewApi = context.viewApi, options = context.options, calendarApi = context.calendarApi;
            var moreLinkText = options.moreLinkText;
            var moreCnt = props.moreCnt;
            var range = computeRange(props);
            var text = typeof moreLinkText === 'function' // TODO: eventually use formatWithOrdinals
             ? moreLinkText.call(calendarApi, moreCnt) : "+" + moreCnt + " " + moreLinkText;
            var title = formatWithOrdinals(options.moreLinkHint, [
                moreCnt
            ], text);
            var hookProps = {
                num: moreCnt,
                shortText: "+" + moreCnt,
                text: text,
                view: viewApi
            };
            return _vdomJs.createElement(_vdomJs.Fragment, null, Boolean(props.moreCnt) && _vdomJs.createElement(RenderHook, {
                elRef: _this.linkElRef,
                hookProps: hookProps,
                classNames: options.moreLinkClassNames,
                content: options.moreLinkContent,
                defaultContent: props.defaultContent || renderMoreLinkInner,
                didMount: options.moreLinkDidMount,
                willUnmount: options.moreLinkWillUnmount
            }, function(rootElRef, customClassNames, innerElRef, innerContent) {
                return props.children(rootElRef, [
                    'fc-more-link'
                ].concat(customClassNames), innerElRef, innerContent, _this.handleClick, title, state.isPopoverOpen, state.isPopoverOpen ? state.popoverId : '');
            }), state.isPopoverOpen && _vdomJs.createElement(MorePopover, {
                id: state.popoverId,
                startDate: range.start,
                endDate: range.end,
                dateProfile: props.dateProfile,
                todayRange: props.todayRange,
                extraDateSpan: props.extraDateSpan,
                parentEl: _this.parentEl,
                alignmentEl: props.alignmentElRef.current,
                alignGridTop: props.alignGridTop,
                onClose: _this.handlePopoverClose
            }, props.popoverContent()));
        });
    };
    MoreLinkRoot1.prototype.componentDidMount = function() {
        this.updateParentEl();
    };
    MoreLinkRoot1.prototype.componentDidUpdate = function() {
        this.updateParentEl();
    };
    MoreLinkRoot1.prototype.updateParentEl = function() {
        if (this.linkElRef.current) this.parentEl = elementClosest(this.linkElRef.current, '.fc-view-harness');
    };
    return MoreLinkRoot1;
}(BaseComponent);
function renderMoreLinkInner(props) {
    return props.text;
}
function computeRange(props) {
    if (props.allDayDate) return {
        start: props.allDayDate,
        end: addDays(props.allDayDate, 1)
    };
    var hiddenSegs = props.hiddenSegs;
    return {
        start: computeEarliestSegStart(hiddenSegs),
        end: computeLatestSegEnd(hiddenSegs)
    };
}
function computeEarliestSegStart(segs) {
    return segs.reduce(pickEarliestStart).eventRange.range.start;
}
function pickEarliestStart(seg0, seg1) {
    return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;
}
function computeLatestSegEnd(segs) {
    return segs.reduce(pickLatestEnd).eventRange.range.end;
}
function pickLatestEnd(seg0, seg1) {
    return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;
}
// exports
// --------------------------------------------------------------------------------------------------
var version = '5.10.2'; // important to type it, so .d.ts has generic string

},{"./main.css":"kqnki","tslib":"5i9Vz","./vdom.js":"8O36s","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"kqnki":[function() {},{}],"8O36s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-enable */ parcelHelpers.export(exports, "Component", ()=>Component
);
parcelHelpers.export(exports, "Fragment", ()=>Fragment
);
parcelHelpers.export(exports, "createContext", ()=>createContext
);
parcelHelpers.export(exports, "createElement", ()=>createElement
);
parcelHelpers.export(exports, "createPortal", ()=>createPortal
);
parcelHelpers.export(exports, "createRef", ()=>createRef
);
parcelHelpers.export(exports, "flushSync", ()=>flushSync
);
parcelHelpers.export(exports, "render", ()=>render
);
parcelHelpers.export(exports, "unmountComponentAtNode", ()=>unmountComponentAtNode
);
/// <reference types="@fullcalendar/core-preact" />
if (typeof FullCalendarVDom === 'undefined') throw new Error('Please import the top-level fullcalendar lib before attempting to import a plugin.');
var Component = FullCalendarVDom.Component;
var createElement = FullCalendarVDom.createElement;
var render = FullCalendarVDom.render;
var createRef = FullCalendarVDom.createRef;
var Fragment = FullCalendarVDom.Fragment;
var createContext = FullCalendarVDom.createContext;
var createPortal = FullCalendarVDom.createPortal;
var flushSync = FullCalendarVDom.flushSync;
var unmountComponentAtNode = FullCalendarVDom.unmountComponentAtNode;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"lpFmL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DayTimeCols", ()=>DayTimeCols
);
parcelHelpers.export(exports, "DayTimeColsSlicer", ()=>DayTimeColsSlicer
);
parcelHelpers.export(exports, "DayTimeColsView", ()=>DayTimeColsView
);
parcelHelpers.export(exports, "TimeCols", ()=>TimeCols
);
parcelHelpers.export(exports, "TimeColsSlatsCoords", ()=>TimeColsSlatsCoords
);
parcelHelpers.export(exports, "TimeColsView", ()=>TimeColsView
);
parcelHelpers.export(exports, "buildDayRanges", ()=>buildDayRanges
);
parcelHelpers.export(exports, "buildSlatMetas", ()=>buildSlatMetas
);
parcelHelpers.export(exports, "buildTimeColsModel", ()=>buildTimeColsModel
);
/*!
FullCalendar v5.10.2
Docs & License: https://fullcalendar.io/
(c) 2021 Adam Shaw
*/ var _mainCss = require("./main.css");
var _common = require("@fullcalendar/common");
var _tslib = require("tslib");
var _daygrid = require("@fullcalendar/daygrid");
var AllDaySplitter = /** @class */ function(_super) {
    _tslib.__extends(AllDaySplitter1, _super);
    function AllDaySplitter1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AllDaySplitter1.prototype.getKeyInfo = function() {
        return {
            allDay: {},
            timed: {}
        };
    };
    AllDaySplitter1.prototype.getKeysForDateSpan = function(dateSpan) {
        if (dateSpan.allDay) return [
            'allDay'
        ];
        return [
            'timed'
        ];
    };
    AllDaySplitter1.prototype.getKeysForEventDef = function(eventDef) {
        if (!eventDef.allDay) return [
            'timed'
        ];
        if (_common.hasBgRendering(eventDef)) return [
            'timed',
            'allDay'
        ];
        return [
            'allDay'
        ];
    };
    return AllDaySplitter1;
}(_common.Splitter);
var DEFAULT_SLAT_LABEL_FORMAT = _common.createFormatter({
    hour: 'numeric',
    minute: '2-digit',
    omitZeroMinute: true,
    meridiem: 'short'
});
function TimeColsAxisCell(props) {
    var classNames = [
        'fc-timegrid-slot',
        'fc-timegrid-slot-label',
        props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor', 
    ];
    return _common.createElement(_common.ViewContextType.Consumer, null, function(context) {
        if (!props.isLabeled) return _common.createElement("td", {
            className: classNames.join(' '),
            "data-time": props.isoTimeStr
        });
        var dateEnv = context.dateEnv, options = context.options, viewApi = context.viewApi;
        var labelFormat = options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? _common.createFormatter(options.slotLabelFormat[0]) : _common.createFormatter(options.slotLabelFormat);
        var hookProps = {
            level: 0,
            time: props.time,
            date: dateEnv.toDate(props.date),
            view: viewApi,
            text: dateEnv.format(props.date, labelFormat)
        };
        return _common.createElement(_common.RenderHook, {
            hookProps: hookProps,
            classNames: options.slotLabelClassNames,
            content: options.slotLabelContent,
            defaultContent: renderInnerContent,
            didMount: options.slotLabelDidMount,
            willUnmount: options.slotLabelWillUnmount
        }, function(rootElRef, customClassNames, innerElRef, innerContent) {
            return _common.createElement("td", {
                ref: rootElRef,
                className: classNames.concat(customClassNames).join(' '),
                "data-time": props.isoTimeStr
            }, _common.createElement("div", {
                className: "fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame"
            }, _common.createElement("div", {
                className: "fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion",
                ref: innerElRef
            }, innerContent)));
        });
    });
}
function renderInnerContent(props) {
    return props.text;
}
var TimeBodyAxis = /** @class */ function(_super) {
    _tslib.__extends(TimeBodyAxis1, _super);
    function TimeBodyAxis1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeBodyAxis1.prototype.render = function() {
        return this.props.slatMetas.map(function(slatMeta) {
            return _common.createElement("tr", {
                key: slatMeta.key
            }, _common.createElement(TimeColsAxisCell, _tslib.__assign({}, slatMeta)));
        });
    };
    return TimeBodyAxis1;
}(_common.BaseComponent);
var DEFAULT_WEEK_NUM_FORMAT = _common.createFormatter({
    week: 'short'
});
var AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;
var TimeColsView = /** @class */ function(_super) {
    _tslib.__extends(TimeColsView1, _super);
    function TimeColsView1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allDaySplitter = new AllDaySplitter(); // for use by subclasses
        _this.headerElRef = _common.createRef();
        _this.rootElRef = _common.createRef();
        _this.scrollerElRef = _common.createRef();
        _this.state = {
            slatCoords: null
        };
        _this.handleScrollTopRequest = function(scrollTop) {
            var scrollerEl = _this.scrollerElRef.current;
            if (scrollerEl) scrollerEl.scrollTop = scrollTop;
        };
        /* Header Render Methods
        ------------------------------------------------------------------------------------------------------------------*/ _this.renderHeadAxis = function(rowKey, frameHeight) {
            if (frameHeight === void 0) frameHeight = '';
            var options = _this.context.options;
            var dateProfile = _this.props.dateProfile;
            var range = dateProfile.renderRange;
            var dayCnt = _common.diffDays(range.start, range.end);
            var navLinkAttrs = dayCnt === 1 // only do in day views (to avoid doing in week views that dont need it)
             ? _common.buildNavLinkAttrs(_this.context, range.start, 'week') : {};
            if (options.weekNumbers && rowKey === 'day') return _common.createElement(_common.WeekNumberRoot, {
                date: range.start,
                defaultFormat: DEFAULT_WEEK_NUM_FORMAT
            }, function(rootElRef, classNames, innerElRef, innerContent) {
                return _common.createElement("th", {
                    ref: rootElRef,
                    "aria-hidden": true,
                    className: [
                        'fc-timegrid-axis',
                        'fc-scrollgrid-shrink', 
                    ].concat(classNames).join(' ')
                }, _common.createElement("div", {
                    className: "fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid",
                    style: {
                        height: frameHeight
                    }
                }, _common.createElement("a", _tslib.__assign({
                    ref: innerElRef,
                    className: "fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner"
                }, navLinkAttrs), innerContent)));
            });
            return _common.createElement("th", {
                "aria-hidden": true,
                className: "fc-timegrid-axis"
            }, _common.createElement("div", {
                className: "fc-timegrid-axis-frame",
                style: {
                    height: frameHeight
                }
            }));
        };
        /* Table Component Render Methods
        ------------------------------------------------------------------------------------------------------------------*/ // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,
        // but DayGrid still needs to have classNames on inner elements in order to measure.
        _this.renderTableRowAxis = function(rowHeight) {
            var _a = _this.context, options = _a.options, viewApi = _a.viewApi;
            var hookProps = {
                text: options.allDayText,
                view: viewApi
            };
            return(// TODO: make reusable hook. used in list view too
            _common.createElement(_common.RenderHook, {
                hookProps: hookProps,
                classNames: options.allDayClassNames,
                content: options.allDayContent,
                defaultContent: renderAllDayInner,
                didMount: options.allDayDidMount,
                willUnmount: options.allDayWillUnmount
            }, function(rootElRef, classNames, innerElRef, innerContent) {
                return _common.createElement("td", {
                    ref: rootElRef,
                    "aria-hidden": true,
                    className: [
                        'fc-timegrid-axis',
                        'fc-scrollgrid-shrink', 
                    ].concat(classNames).join(' ')
                }, _common.createElement("div", {
                    className: 'fc-timegrid-axis-frame fc-scrollgrid-shrink-frame' + (rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : ''),
                    style: {
                        height: rowHeight
                    }
                }, _common.createElement("span", {
                    className: "fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner",
                    ref: innerElRef
                }, innerContent)));
            }));
        };
        _this.handleSlatCoords = function(slatCoords) {
            _this.setState({
                slatCoords: slatCoords
            });
        };
        return _this;
    }
    // rendering
    // ----------------------------------------------------------------------------------------------------
    TimeColsView1.prototype.renderSimpleLayout = function(headerRowContent, allDayContent, timeContent) {
        var _a = this, context = _a.context, props = _a.props;
        var sections = [];
        var stickyHeaderDates = _common.getStickyHeaderDates(context.options);
        if (headerRowContent) sections.push({
            type: 'header',
            key: 'header',
            isSticky: stickyHeaderDates,
            chunk: {
                elRef: this.headerElRef,
                tableClassName: 'fc-col-header',
                rowContent: headerRowContent
            }
        });
        if (allDayContent) {
            sections.push({
                type: 'body',
                key: 'all-day',
                chunk: {
                    content: allDayContent
                }
            });
            sections.push({
                type: 'body',
                key: 'all-day-divider',
                outerContent: _common.createElement("tr", {
                    role: "presentation",
                    className: "fc-scrollgrid-section"
                }, _common.createElement("td", {
                    className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')
                }))
            });
        }
        sections.push({
            type: 'body',
            key: 'body',
            liquid: true,
            expandRows: Boolean(context.options.expandRows),
            chunk: {
                scrollerElRef: this.scrollerElRef,
                content: timeContent
            }
        });
        return _common.createElement(_common.ViewRoot, {
            viewSpec: context.viewSpec,
            elRef: this.rootElRef
        }, function(rootElRef, classNames) {
            return _common.createElement("div", {
                className: [
                    'fc-timegrid'
                ].concat(classNames).join(' '),
                ref: rootElRef
            }, _common.createElement(_common.SimpleScrollGrid, {
                liquid: !props.isHeightAuto && !props.forPrint,
                collapsibleWidth: props.forPrint,
                cols: [
                    {
                        width: 'shrink'
                    }
                ],
                sections: sections
            }));
        });
    };
    TimeColsView1.prototype.renderHScrollLayout = function(headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {
        var _this = this;
        var ScrollGrid = this.context.pluginHooks.scrollGridImpl;
        if (!ScrollGrid) throw new Error('No ScrollGrid implementation');
        var _a = this, context = _a.context, props = _a.props;
        var stickyHeaderDates = !props.forPrint && _common.getStickyHeaderDates(context.options);
        var stickyFooterScrollbar = !props.forPrint && _common.getStickyFooterScrollbar(context.options);
        var sections = [];
        if (headerRowContent) sections.push({
            type: 'header',
            key: 'header',
            isSticky: stickyHeaderDates,
            syncRowHeights: true,
            chunks: [
                {
                    key: 'axis',
                    rowContent: function(arg) {
                        return _common.createElement("tr", {
                            role: "presentation"
                        }, _this.renderHeadAxis('day', arg.rowSyncHeights[0]));
                    }
                },
                {
                    key: 'cols',
                    elRef: this.headerElRef,
                    tableClassName: 'fc-col-header',
                    rowContent: headerRowContent
                }, 
            ]
        });
        if (allDayContent) {
            sections.push({
                type: 'body',
                key: 'all-day',
                syncRowHeights: true,
                chunks: [
                    {
                        key: 'axis',
                        rowContent: function(contentArg) {
                            return _common.createElement("tr", {
                                role: "presentation"
                            }, _this.renderTableRowAxis(contentArg.rowSyncHeights[0]));
                        }
                    },
                    {
                        key: 'cols',
                        content: allDayContent
                    }, 
                ]
            });
            sections.push({
                key: 'all-day-divider',
                type: 'body',
                outerContent: _common.createElement("tr", {
                    role: "presentation",
                    className: "fc-scrollgrid-section"
                }, _common.createElement("td", {
                    colSpan: 2,
                    className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')
                }))
            });
        }
        var isNowIndicator = context.options.nowIndicator;
        sections.push({
            type: 'body',
            key: 'body',
            liquid: true,
            expandRows: Boolean(context.options.expandRows),
            chunks: [
                {
                    key: 'axis',
                    content: function(arg) {
                        return(// TODO: make this now-indicator arrow more DRY with TimeColsContent
                        _common.createElement("div", {
                            className: "fc-timegrid-axis-chunk"
                        }, _common.createElement("table", {
                            "aria-hidden": true,
                            style: {
                                height: arg.expandRows ? arg.clientHeight : ''
                            }
                        }, arg.tableColGroupNode, _common.createElement("tbody", null, _common.createElement(TimeBodyAxis, {
                            slatMetas: slatMetas
                        }))), _common.createElement("div", {
                            className: "fc-timegrid-now-indicator-container"
                        }, _common.createElement(_common.NowTimer, {
                            unit: isNowIndicator ? 'minute' : 'day' /* hacky */ 
                        }, function(nowDate) {
                            var nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate); // might return void
                            if (typeof nowIndicatorTop === 'number') return _common.createElement(_common.NowIndicatorRoot, {
                                isAxis: true,
                                date: nowDate
                            }, function(rootElRef, classNames, innerElRef, innerContent) {
                                return _common.createElement("div", {
                                    ref: rootElRef,
                                    className: [
                                        'fc-timegrid-now-indicator-arrow'
                                    ].concat(classNames).join(' '),
                                    style: {
                                        top: nowIndicatorTop
                                    }
                                }, innerContent);
                            });
                            return null;
                        }))));
                    }
                },
                {
                    key: 'cols',
                    scrollerElRef: this.scrollerElRef,
                    content: timeContent
                }, 
            ]
        });
        if (stickyFooterScrollbar) sections.push({
            key: 'footer',
            type: 'footer',
            isSticky: true,
            chunks: [
                {
                    key: 'axis',
                    content: _common.renderScrollShim
                },
                {
                    key: 'cols',
                    content: _common.renderScrollShim
                }, 
            ]
        });
        return _common.createElement(_common.ViewRoot, {
            viewSpec: context.viewSpec,
            elRef: this.rootElRef
        }, function(rootElRef, classNames) {
            return _common.createElement("div", {
                className: [
                    'fc-timegrid'
                ].concat(classNames).join(' '),
                ref: rootElRef
            }, _common.createElement(ScrollGrid, {
                liquid: !props.isHeightAuto && !props.forPrint,
                collapsibleWidth: false,
                colGroups: [
                    {
                        width: 'shrink',
                        cols: [
                            {
                                width: 'shrink'
                            }
                        ]
                    },
                    {
                        cols: [
                            {
                                span: colCnt,
                                minWidth: dayMinWidth
                            }
                        ]
                    }, 
                ],
                sections: sections
            }));
        });
    };
    /* Dimensions
    ------------------------------------------------------------------------------------------------------------------*/ TimeColsView1.prototype.getAllDayMaxEventProps = function() {
        var _a = this.context.options, dayMaxEvents = _a.dayMaxEvents, dayMaxEventRows = _a.dayMaxEventRows;
        if (dayMaxEvents === true || dayMaxEventRows === true) {
            dayMaxEvents = undefined;
            dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure "auto" goes to a real number
        }
        return {
            dayMaxEvents: dayMaxEvents,
            dayMaxEventRows: dayMaxEventRows
        };
    };
    return TimeColsView1;
}(_common.DateComponent);
function renderAllDayInner(hookProps) {
    return hookProps.text;
}
var TimeColsSlatsCoords = /** @class */ function() {
    function TimeColsSlatsCoords1(positions, dateProfile, slotDuration) {
        this.positions = positions;
        this.dateProfile = dateProfile;
        this.slotDuration = slotDuration;
    }
    TimeColsSlatsCoords1.prototype.safeComputeTop = function(date) {
        var dateProfile = this.dateProfile;
        if (_common.rangeContainsMarker(dateProfile.currentRange, date)) {
            var startOfDayDate = _common.startOfDay(date);
            var timeMs = date.valueOf() - startOfDayDate.valueOf();
            if (timeMs >= _common.asRoughMs(dateProfile.slotMinTime) && timeMs < _common.asRoughMs(dateProfile.slotMaxTime)) return this.computeTimeTop(_common.createDuration(timeMs));
        }
        return null;
    };
    // Computes the top coordinate, relative to the bounds of the grid, of the given date.
    // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
    TimeColsSlatsCoords1.prototype.computeDateTop = function(when, startOfDayDate) {
        if (!startOfDayDate) startOfDayDate = _common.startOfDay(when);
        return this.computeTimeTop(_common.createDuration(when.valueOf() - startOfDayDate.valueOf()));
    };
    // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
    // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.
    // Eventually allow computation with arbirary slat dates.
    TimeColsSlatsCoords1.prototype.computeTimeTop = function(duration) {
        var _a = this, positions = _a.positions, dateProfile = _a.dateProfile;
        var len = positions.els.length;
        // floating-point value of # of slots covered
        var slatCoverage = (duration.milliseconds - _common.asRoughMs(dateProfile.slotMinTime)) / _common.asRoughMs(this.slotDuration);
        var slatIndex;
        var slatRemainder;
        // compute a floating-point number for how many slats should be progressed through.
        // from 0 to number of slats (inclusive)
        // constrained because slotMinTime/slotMaxTime might be customized.
        slatCoverage = Math.max(0, slatCoverage);
        slatCoverage = Math.min(len, slatCoverage);
        // an integer index of the furthest whole slat
        // from 0 to number slats (*exclusive*, so len-1)
        slatIndex = Math.floor(slatCoverage);
        slatIndex = Math.min(slatIndex, len - 1);
        // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.
        // could be 1.0 if slatCoverage is covering *all* the slots
        slatRemainder = slatCoverage - slatIndex;
        return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;
    };
    return TimeColsSlatsCoords1;
}();
var TimeColsSlatsBody = /** @class */ function(_super) {
    _tslib.__extends(TimeColsSlatsBody1, _super);
    function TimeColsSlatsBody1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeColsSlatsBody1.prototype.render = function() {
        var _a = this, props = _a.props, context = _a.context;
        var options = context.options;
        var slatElRefs = props.slatElRefs;
        return _common.createElement("tbody", null, props.slatMetas.map(function(slatMeta, i) {
            var hookProps = {
                time: slatMeta.time,
                date: context.dateEnv.toDate(slatMeta.date),
                view: context.viewApi
            };
            var classNames = [
                'fc-timegrid-slot',
                'fc-timegrid-slot-lane',
                slatMeta.isLabeled ? '' : 'fc-timegrid-slot-minor', 
            ];
            return _common.createElement("tr", {
                key: slatMeta.key,
                ref: slatElRefs.createRef(slatMeta.key)
            }, props.axis && _common.createElement(TimeColsAxisCell, _tslib.__assign({}, slatMeta)), _common.createElement(_common.RenderHook, {
                hookProps: hookProps,
                classNames: options.slotLaneClassNames,
                content: options.slotLaneContent,
                didMount: options.slotLaneDidMount,
                willUnmount: options.slotLaneWillUnmount
            }, function(rootElRef, customClassNames, innerElRef, innerContent) {
                return _common.createElement("td", {
                    ref: rootElRef,
                    className: classNames.concat(customClassNames).join(' '),
                    "data-time": slatMeta.isoTimeStr
                }, innerContent);
            }));
        }));
    };
    return TimeColsSlatsBody1;
}(_common.BaseComponent);
/*
for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.
*/ var TimeColsSlats = /** @class */ function(_super) {
    _tslib.__extends(TimeColsSlats1, _super);
    function TimeColsSlats1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.rootElRef = _common.createRef();
        _this.slatElRefs = new _common.RefMap();
        return _this;
    }
    TimeColsSlats1.prototype.render = function() {
        var _a = this, props = _a.props, context = _a.context;
        return _common.createElement("div", {
            ref: this.rootElRef,
            className: "fc-timegrid-slots"
        }, _common.createElement("table", {
            "aria-hidden": true,
            className: context.theme.getClass('table'),
            style: {
                minWidth: props.tableMinWidth,
                width: props.clientWidth,
                height: props.minHeight
            }
        }, props.tableColGroupNode /* relies on there only being a single <col> for the axis */ , _common.createElement(TimeColsSlatsBody, {
            slatElRefs: this.slatElRefs,
            axis: props.axis,
            slatMetas: props.slatMetas
        })));
    };
    TimeColsSlats1.prototype.componentDidMount = function() {
        this.updateSizing();
    };
    TimeColsSlats1.prototype.componentDidUpdate = function() {
        this.updateSizing();
    };
    TimeColsSlats1.prototype.componentWillUnmount = function() {
        if (this.props.onCoords) this.props.onCoords(null);
    };
    TimeColsSlats1.prototype.updateSizing = function() {
        var _a = this, context = _a.context, props = _a.props;
        if (props.onCoords && props.clientWidth !== null // means sizing has stabilized
        ) {
            var rootEl = this.rootElRef.current;
            if (rootEl.offsetHeight) props.onCoords(new TimeColsSlatsCoords(new _common.PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));
        }
    };
    return TimeColsSlats1;
}(_common.BaseComponent);
function collectSlatEls(elMap, slatMetas) {
    return slatMetas.map(function(slatMeta) {
        return elMap[slatMeta.key];
    });
}
function splitSegsByCol(segs, colCnt) {
    var segsByCol = [];
    var i;
    for(i = 0; i < colCnt; i += 1)segsByCol.push([]);
    if (segs) for(i = 0; i < segs.length; i += 1)segsByCol[segs[i].col].push(segs[i]);
    return segsByCol;
}
function splitInteractionByCol(ui, colCnt) {
    var byRow = [];
    if (!ui) for(var i = 0; i < colCnt; i += 1)byRow[i] = null;
    else {
        for(var i = 0; i < colCnt; i += 1)byRow[i] = {
            affectedInstances: ui.affectedInstances,
            isEvent: ui.isEvent,
            segs: []
        };
        for(var _i = 0, _a = ui.segs; _i < _a.length; _i++){
            var seg = _a[_i];
            byRow[seg.col].segs.push(seg);
        }
    }
    return byRow;
}
var TimeColMoreLink = /** @class */ function(_super) {
    _tslib.__extends(TimeColMoreLink1, _super);
    function TimeColMoreLink1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.rootElRef = _common.createRef();
        return _this;
    }
    TimeColMoreLink1.prototype.render = function() {
        var _this = this;
        var props = this.props;
        return _common.createElement(_common.MoreLinkRoot, {
            allDayDate: null,
            moreCnt: props.hiddenSegs.length,
            allSegs: props.hiddenSegs,
            hiddenSegs: props.hiddenSegs,
            alignmentElRef: this.rootElRef,
            defaultContent: renderMoreLinkInner,
            extraDateSpan: props.extraDateSpan,
            dateProfile: props.dateProfile,
            todayRange: props.todayRange,
            popoverContent: function() {
                return renderPlainFgSegs(props.hiddenSegs, props);
            }
        }, function(rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {
            return _common.createElement("a", {
                ref: function(el) {
                    _common.setRef(rootElRef, el);
                    _common.setRef(_this.rootElRef, el);
                },
                className: [
                    'fc-timegrid-more-link'
                ].concat(classNames).join(' '),
                style: {
                    top: props.top,
                    bottom: props.bottom
                },
                onClick: handleClick,
                title: title,
                "aria-expanded": isExpanded,
                "aria-controls": popoverId
            }, _common.createElement("div", {
                ref: innerElRef,
                className: "fc-timegrid-more-link-inner fc-sticky"
            }, innerContent));
        });
    };
    return TimeColMoreLink1;
}(_common.BaseComponent);
function renderMoreLinkInner(props) {
    return props.shortText;
}
// segInputs assumed sorted
function buildPositioning(segInputs, strictOrder, maxStackCnt) {
    var hierarchy = new _common.SegHierarchy();
    if (strictOrder != null) hierarchy.strictOrder = strictOrder;
    if (maxStackCnt != null) hierarchy.maxStackCnt = maxStackCnt;
    var hiddenEntries = hierarchy.addSegs(segInputs);
    var hiddenGroups = _common.groupIntersectingEntries(hiddenEntries);
    var web = buildWeb(hierarchy);
    web = stretchWeb(web, 1); // all levelCoords/thickness will have 0.0-1.0
    var segRects = webToRects(web);
    return {
        segRects: segRects,
        hiddenGroups: hiddenGroups
    };
}
function buildWeb(hierarchy) {
    var entriesByLevel = hierarchy.entriesByLevel;
    var buildNode = cacheable(function(level, lateral) {
        return level + ':' + lateral;
    }, function(level, lateral) {
        var siblingRange = findNextLevelSegs(hierarchy, level, lateral);
        var nextLevelRes = buildNodes(siblingRange, buildNode);
        var entry = entriesByLevel[level][lateral];
        return [
            _tslib.__assign(_tslib.__assign({}, entry), {
                nextLevelNodes: nextLevelRes[0]
            }),
            entry.thickness + nextLevelRes[1]
        ];
    });
    return buildNodes(entriesByLevel.length ? {
        level: 0,
        lateralStart: 0,
        lateralEnd: entriesByLevel[0].length
    } : null, buildNode)[0];
}
function buildNodes(siblingRange, buildNode) {
    if (!siblingRange) return [
        [],
        0
    ];
    var level = siblingRange.level, lateralStart = siblingRange.lateralStart, lateralEnd = siblingRange.lateralEnd;
    var lateral = lateralStart;
    var pairs = [];
    while(lateral < lateralEnd){
        pairs.push(buildNode(level, lateral));
        lateral += 1;
    }
    pairs.sort(cmpDescPressures);
    return [
        pairs.map(extractNode),
        pairs[0][1]
    ];
}
function cmpDescPressures(a, b) {
    return b[1] - a[1];
}
function extractNode(a) {
    return a[0];
}
function findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {
    var levelCoords = hierarchy.levelCoords, entriesByLevel = hierarchy.entriesByLevel;
    var subjectEntry = entriesByLevel[subjectLevel][subjectLateral];
    var afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;
    var levelCnt = levelCoords.length;
    var level = subjectLevel;
    // skip past levels that are too high up
    for(; level < levelCnt && levelCoords[level] < afterSubject; level += 1); // do nothing
    for(; level < levelCnt; level += 1){
        var entries = entriesByLevel[level];
        var entry = void 0;
        var searchIndex = _common.binarySearch(entries, subjectEntry.span.start, _common.getEntrySpanEnd);
        var lateralStart = searchIndex[0] + searchIndex[1]; // if exact match (which doesn't collide), go to next one
        var lateralEnd = lateralStart;
        while((entry = entries[lateralEnd]) && entry.span.start < subjectEntry.span.end)lateralEnd += 1;
        if (lateralStart < lateralEnd) return {
            level: level,
            lateralStart: lateralStart,
            lateralEnd: lateralEnd
        };
    }
    return null;
}
function stretchWeb(topLevelNodes, totalThickness) {
    var stretchNode = cacheable(function(node, startCoord, prevThickness) {
        return _common.buildEntryKey(node);
    }, function(node, startCoord, prevThickness) {
        var nextLevelNodes = node.nextLevelNodes, thickness = node.thickness;
        var allThickness = thickness + prevThickness;
        var thicknessFraction = thickness / allThickness;
        var endCoord;
        var newChildren = [];
        if (!nextLevelNodes.length) endCoord = totalThickness;
        else for(var _i = 0, nextLevelNodes_1 = nextLevelNodes; _i < nextLevelNodes_1.length; _i++){
            var childNode = nextLevelNodes_1[_i];
            if (endCoord === undefined) {
                var res = stretchNode(childNode, startCoord, allThickness);
                endCoord = res[0];
                newChildren.push(res[1]);
            } else {
                var res = stretchNode(childNode, endCoord, 0);
                newChildren.push(res[1]);
            }
        }
        var newThickness = (endCoord - startCoord) * thicknessFraction;
        return [
            endCoord - newThickness,
            _tslib.__assign(_tslib.__assign({}, node), {
                thickness: newThickness,
                nextLevelNodes: newChildren
            })
        ];
    });
    return topLevelNodes.map(function(node) {
        return stretchNode(node, 0, 0)[1];
    });
}
// not sorted in any particular order
function webToRects(topLevelNodes) {
    var rects = [];
    var processNode = cacheable(function(node, levelCoord, stackDepth) {
        return _common.buildEntryKey(node);
    }, function(node, levelCoord, stackDepth) {
        var rect = _tslib.__assign(_tslib.__assign({}, node), {
            levelCoord: levelCoord,
            stackDepth: stackDepth,
            stackForward: 0
        });
        rects.push(rect);
        return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;
    });
    function processNodes(nodes, levelCoord, stackDepth) {
        var stackForward = 0;
        for(var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++){
            var node = nodes_1[_i];
            stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);
        }
        return stackForward;
    }
    processNodes(topLevelNodes, 0, 0);
    return rects; // TODO: sort rects by levelCoord to be consistent with toRects?
}
// TODO: move to general util
function cacheable(keyFunc, workFunc) {
    var cache = {};
    return function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        var key = keyFunc.apply(void 0, args);
        return key in cache ? cache[key] : cache[key] = workFunc.apply(void 0, args);
    };
}
function computeSegVCoords(segs, colDate, slatCoords, eventMinHeight) {
    if (slatCoords === void 0) slatCoords = null;
    if (eventMinHeight === void 0) eventMinHeight = 0;
    var vcoords = [];
    if (slatCoords) for(var i = 0; i < segs.length; i += 1){
        var seg = segs[i];
        var spanStart = slatCoords.computeDateTop(seg.start, colDate);
        var spanEnd = Math.max(spanStart + (eventMinHeight || 0), slatCoords.computeDateTop(seg.end, colDate));
        vcoords.push({
            start: Math.round(spanStart),
            end: Math.round(spanEnd)
        });
    }
    return vcoords;
}
function computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack) {
    var segInputs = [];
    var dumbSegs = []; // segs without coords
    for(var i = 0; i < segs.length; i += 1){
        var vcoords = segVCoords[i];
        if (vcoords) segInputs.push({
            index: i,
            thickness: 1,
            span: vcoords
        });
        else dumbSegs.push(segs[i]);
    }
    var _a = buildPositioning(segInputs, eventOrderStrict, eventMaxStack), segRects = _a.segRects, hiddenGroups = _a.hiddenGroups;
    var segPlacements = [];
    for(var _i = 0, segRects_1 = segRects; _i < segRects_1.length; _i++){
        var segRect = segRects_1[_i];
        segPlacements.push({
            seg: segs[segRect.index],
            rect: segRect
        });
    }
    for(var _b = 0, dumbSegs_1 = dumbSegs; _b < dumbSegs_1.length; _b++){
        var dumbSeg = dumbSegs_1[_b];
        segPlacements.push({
            seg: dumbSeg,
            rect: null
        });
    }
    return {
        segPlacements: segPlacements,
        hiddenGroups: hiddenGroups
    };
}
var DEFAULT_TIME_FORMAT = _common.createFormatter({
    hour: 'numeric',
    minute: '2-digit',
    meridiem: false
});
var TimeColEvent = /** @class */ function(_super) {
    _tslib.__extends(TimeColEvent1, _super);
    function TimeColEvent1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeColEvent1.prototype.render = function() {
        var classNames = [
            'fc-timegrid-event',
            'fc-v-event', 
        ];
        if (this.props.isShort) classNames.push('fc-timegrid-event-short');
        return _common.createElement(_common.StandardEvent, _tslib.__assign({}, this.props, {
            defaultTimeFormat: DEFAULT_TIME_FORMAT,
            extraClassNames: classNames
        }));
    };
    return TimeColEvent1;
}(_common.BaseComponent);
var TimeColMisc = /** @class */ function(_super) {
    _tslib.__extends(TimeColMisc1, _super);
    function TimeColMisc1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeColMisc1.prototype.render = function() {
        var props = this.props;
        return _common.createElement(_common.DayCellContent, {
            date: props.date,
            dateProfile: props.dateProfile,
            todayRange: props.todayRange,
            extraHookProps: props.extraHookProps
        }, function(innerElRef, innerContent) {
            return innerContent && _common.createElement("div", {
                className: "fc-timegrid-col-misc",
                ref: innerElRef
            }, innerContent);
        });
    };
    return TimeColMisc1;
}(_common.BaseComponent);
var TimeCol = /** @class */ function(_super) {
    _tslib.__extends(TimeCol1, _super);
    function TimeCol1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.sortEventSegs = _common.memoize(_common.sortEventSegs);
        return _this;
    }
    // TODO: memoize event-placement?
    TimeCol1.prototype.render = function() {
        var _this = this;
        var _a = this, props = _a.props, context = _a.context;
        var isSelectMirror = context.options.selectMirror;
        var mirrorSegs = props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || [];
        var interactionAffectedInstances = props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};
        var sortedFgSegs = this.sortEventSegs(props.fgEventSegs, context.options.eventOrder);
        return _common.createElement(_common.DayCellRoot, {
            elRef: props.elRef,
            date: props.date,
            dateProfile: props.dateProfile,
            todayRange: props.todayRange,
            extraHookProps: props.extraHookProps
        }, function(rootElRef, classNames, dataAttrs) {
            return _common.createElement("td", _tslib.__assign({
                ref: rootElRef,
                role: "gridcell",
                className: [
                    'fc-timegrid-col'
                ].concat(classNames, props.extraClassNames || []).join(' ')
            }, dataAttrs, props.extraDataAttrs), _common.createElement("div", {
                className: "fc-timegrid-col-frame"
            }, _common.createElement("div", {
                className: "fc-timegrid-col-bg"
            }, _this.renderFillSegs(props.businessHourSegs, 'non-business'), _this.renderFillSegs(props.bgEventSegs, 'bg-event'), _this.renderFillSegs(props.dateSelectionSegs, 'highlight')), _common.createElement("div", {
                className: "fc-timegrid-col-events"
            }, _this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)), _common.createElement("div", {
                className: "fc-timegrid-col-events"
            }, _this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror))), _common.createElement("div", {
                className: "fc-timegrid-now-indicator-container"
            }, _this.renderNowIndicator(props.nowIndicatorSegs)), _common.createElement(TimeColMisc, {
                date: props.date,
                dateProfile: props.dateProfile,
                todayRange: props.todayRange,
                extraHookProps: props.extraHookProps
            })));
        });
    };
    TimeCol1.prototype.renderFgSegs = function(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting) {
        var props = this.props;
        if (props.forPrint) return renderPlainFgSegs(sortedFgSegs, props);
        return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting);
    };
    TimeCol1.prototype.renderPositionedFgSegs = function(segs, segIsInvisible, isDragging, isResizing, isDateSelecting) {
        var _this = this;
        var _a = this.context.options, eventMaxStack = _a.eventMaxStack, eventShortHeight = _a.eventShortHeight, eventOrderStrict = _a.eventOrderStrict, eventMinHeight = _a.eventMinHeight;
        var _b = this.props, date = _b.date, slatCoords = _b.slatCoords, eventSelection = _b.eventSelection, todayRange = _b.todayRange, nowDate = _b.nowDate;
        var isMirror = isDragging || isResizing || isDateSelecting;
        var segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);
        var _c = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack), segPlacements = _c.segPlacements, hiddenGroups = _c.hiddenGroups;
        return _common.createElement(_common.Fragment, null, this.renderHiddenGroups(hiddenGroups, segs), segPlacements.map(function(segPlacement) {
            var seg = segPlacement.seg, rect = segPlacement.rect;
            var instanceId = seg.eventRange.instance.instanceId;
            var isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);
            var vStyle = computeSegVStyle(rect && rect.span);
            var hStyle = !isMirror && rect ? _this.computeSegHStyle(rect) : {
                left: 0,
                right: 0
            };
            var isInset = Boolean(rect) && rect.stackForward > 0;
            var isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight; // look at other places for this problem
            return _common.createElement("div", {
                className: 'fc-timegrid-event-harness' + (isInset ? ' fc-timegrid-event-harness-inset' : ''),
                key: instanceId,
                style: _tslib.__assign(_tslib.__assign({
                    visibility: isVisible ? '' : 'hidden'
                }, vStyle), hStyle)
            }, _common.createElement(TimeColEvent, _tslib.__assign({
                seg: seg,
                isDragging: isDragging,
                isResizing: isResizing,
                isDateSelecting: isDateSelecting,
                isSelected: instanceId === eventSelection,
                isShort: isShort
            }, _common.getSegMeta(seg, todayRange, nowDate))));
        }));
    };
    // will already have eventMinHeight applied because segInputs already had it
    TimeCol1.prototype.renderHiddenGroups = function(hiddenGroups, segs) {
        var _a = this.props, extraDateSpan = _a.extraDateSpan, dateProfile = _a.dateProfile, todayRange = _a.todayRange, nowDate = _a.nowDate, eventSelection = _a.eventSelection, eventDrag = _a.eventDrag, eventResize = _a.eventResize;
        return _common.createElement(_common.Fragment, null, hiddenGroups.map(function(hiddenGroup) {
            var positionCss = computeSegVStyle(hiddenGroup.span);
            var hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);
            return _common.createElement(TimeColMoreLink, {
                key: _common.buildIsoString(_common.computeEarliestSegStart(hiddenSegs)),
                hiddenSegs: hiddenSegs,
                top: positionCss.top,
                bottom: positionCss.bottom,
                extraDateSpan: extraDateSpan,
                dateProfile: dateProfile,
                todayRange: todayRange,
                nowDate: nowDate,
                eventSelection: eventSelection,
                eventDrag: eventDrag,
                eventResize: eventResize
            });
        }));
    };
    TimeCol1.prototype.renderFillSegs = function(segs, fillType) {
        var _a = this, props = _a.props, context = _a.context;
        var segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight); // don't assume all populated
        var children = segVCoords.map(function(vcoords, i) {
            var seg = segs[i];
            return _common.createElement("div", {
                key: _common.buildEventRangeKey(seg.eventRange),
                className: "fc-timegrid-bg-harness",
                style: computeSegVStyle(vcoords)
            }, fillType === 'bg-event' ? _common.createElement(_common.BgEvent, _tslib.__assign({
                seg: seg
            }, _common.getSegMeta(seg, props.todayRange, props.nowDate))) : _common.renderFill(fillType));
        });
        return _common.createElement(_common.Fragment, null, children);
    };
    TimeCol1.prototype.renderNowIndicator = function(segs) {
        var _a = this.props, slatCoords = _a.slatCoords, date = _a.date;
        if (!slatCoords) return null;
        return segs.map(function(seg, i) {
            return _common.createElement(_common.NowIndicatorRoot, {
                isAxis: false,
                date: date,
                // key doesn't matter. will only ever be one
                key: i
            }, function(rootElRef, classNames, innerElRef, innerContent) {
                return _common.createElement("div", {
                    ref: rootElRef,
                    className: [
                        'fc-timegrid-now-indicator-line'
                    ].concat(classNames).join(' '),
                    style: {
                        top: slatCoords.computeDateTop(seg.start, date)
                    }
                }, innerContent);
            });
        });
    };
    TimeCol1.prototype.computeSegHStyle = function(segHCoords) {
        var _a = this.context, isRtl = _a.isRtl, options = _a.options;
        var shouldOverlap = options.slotEventOverlap;
        var nearCoord = segHCoords.levelCoord; // the left side if LTR. the right side if RTL. floating-point
        var farCoord = segHCoords.levelCoord + segHCoords.thickness; // the right side if LTR. the left side if RTL. floating-point
        var left; // amount of space from left edge, a fraction of the total width
        var right; // amount of space from right edge, a fraction of the total width
        if (shouldOverlap) // double the width, but don't go beyond the maximum forward coordinate (1.0)
        farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);
        if (isRtl) {
            left = 1 - farCoord;
            right = nearCoord;
        } else {
            left = nearCoord;
            right = 1 - farCoord;
        }
        var props = {
            zIndex: segHCoords.stackDepth + 1,
            left: left * 100 + '%',
            right: right * 100 + '%'
        };
        if (shouldOverlap && !segHCoords.stackForward) // add padding to the edge so that forward stacked events don't cover the resizer's icon
        props[isRtl ? 'marginLeft' : 'marginRight'] = 20; // 10 is a guesstimate of the icon's width
        return props;
    };
    return TimeCol1;
}(_common.BaseComponent);
function renderPlainFgSegs(sortedFgSegs, _a) {
    var todayRange = _a.todayRange, nowDate = _a.nowDate, eventSelection = _a.eventSelection, eventDrag = _a.eventDrag, eventResize = _a.eventResize;
    var hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};
    return _common.createElement(_common.Fragment, null, sortedFgSegs.map(function(seg) {
        var instanceId = seg.eventRange.instance.instanceId;
        return _common.createElement("div", {
            key: instanceId,
            style: {
                visibility: hiddenInstances[instanceId] ? 'hidden' : ''
            }
        }, _common.createElement(TimeColEvent, _tslib.__assign({
            seg: seg,
            isDragging: false,
            isResizing: false,
            isDateSelecting: false,
            isSelected: instanceId === eventSelection,
            isShort: false
        }, _common.getSegMeta(seg, todayRange, nowDate))));
    }));
}
function computeSegVStyle(segVCoords) {
    if (!segVCoords) return {
        top: '',
        bottom: ''
    };
    return {
        top: segVCoords.start,
        bottom: -segVCoords.end
    };
}
function compileSegsFromEntries(segEntries, allSegs) {
    return segEntries.map(function(segEntry) {
        return allSegs[segEntry.index];
    });
}
var TimeColsContent = /** @class */ function(_super) {
    _tslib.__extends(TimeColsContent1, _super);
    function TimeColsContent1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.splitFgEventSegs = _common.memoize(splitSegsByCol);
        _this.splitBgEventSegs = _common.memoize(splitSegsByCol);
        _this.splitBusinessHourSegs = _common.memoize(splitSegsByCol);
        _this.splitNowIndicatorSegs = _common.memoize(splitSegsByCol);
        _this.splitDateSelectionSegs = _common.memoize(splitSegsByCol);
        _this.splitEventDrag = _common.memoize(splitInteractionByCol);
        _this.splitEventResize = _common.memoize(splitInteractionByCol);
        _this.rootElRef = _common.createRef();
        _this.cellElRefs = new _common.RefMap();
        return _this;
    }
    TimeColsContent1.prototype.render = function() {
        var _this = this;
        var _a = this, props = _a.props, context = _a.context;
        var nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate); // might return void
        var colCnt = props.cells.length;
        var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);
        var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);
        var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);
        var nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);
        var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);
        var eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);
        var eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);
        return _common.createElement("div", {
            className: "fc-timegrid-cols",
            ref: this.rootElRef
        }, _common.createElement("table", {
            role: "presentation",
            style: {
                minWidth: props.tableMinWidth,
                width: props.clientWidth
            }
        }, props.tableColGroupNode, _common.createElement("tbody", {
            role: "presentation"
        }, _common.createElement("tr", {
            role: "row"
        }, props.axis && _common.createElement("td", {
            "aria-hidden": true,
            className: "fc-timegrid-col fc-timegrid-axis"
        }, _common.createElement("div", {
            className: "fc-timegrid-col-frame"
        }, _common.createElement("div", {
            className: "fc-timegrid-now-indicator-container"
        }, typeof nowIndicatorTop === 'number' && _common.createElement(_common.NowIndicatorRoot, {
            isAxis: true,
            date: props.nowDate
        }, function(rootElRef, classNames, innerElRef, innerContent) {
            return _common.createElement("div", {
                ref: rootElRef,
                className: [
                    'fc-timegrid-now-indicator-arrow'
                ].concat(classNames).join(' '),
                style: {
                    top: nowIndicatorTop
                }
            }, innerContent);
        })))), props.cells.map(function(cell, i) {
            return _common.createElement(TimeCol, {
                key: cell.key,
                elRef: _this.cellElRefs.createRef(cell.key),
                dateProfile: props.dateProfile,
                date: cell.date,
                nowDate: props.nowDate,
                todayRange: props.todayRange,
                extraHookProps: cell.extraHookProps,
                extraDataAttrs: cell.extraDataAttrs,
                extraClassNames: cell.extraClassNames,
                extraDateSpan: cell.extraDateSpan,
                fgEventSegs: fgEventSegsByRow[i],
                bgEventSegs: bgEventSegsByRow[i],
                businessHourSegs: businessHourSegsByRow[i],
                nowIndicatorSegs: nowIndicatorSegsByRow[i],
                dateSelectionSegs: dateSelectionSegsByRow[i],
                eventDrag: eventDragByRow[i],
                eventResize: eventResizeByRow[i],
                slatCoords: props.slatCoords,
                eventSelection: props.eventSelection,
                forPrint: props.forPrint
            });
        })))));
    };
    TimeColsContent1.prototype.componentDidMount = function() {
        this.updateCoords();
    };
    TimeColsContent1.prototype.componentDidUpdate = function() {
        this.updateCoords();
    };
    TimeColsContent1.prototype.updateCoords = function() {
        var props = this.props;
        if (props.onColCoords && props.clientWidth !== null // means sizing has stabilized
        ) props.onColCoords(new _common.PositionCache(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true, false));
    };
    return TimeColsContent1;
}(_common.BaseComponent);
function collectCellEls(elMap, cells) {
    return cells.map(function(cell) {
        return elMap[cell.key];
    });
}
/* A component that renders one or more columns of vertical time slots
----------------------------------------------------------------------------------------------------------------------*/ var TimeCols = /** @class */ function(_super) {
    _tslib.__extends(TimeCols1, _super);
    function TimeCols1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.processSlotOptions = _common.memoize(processSlotOptions);
        _this.state = {
            slatCoords: null
        };
        _this.handleRootEl = function(el) {
            if (el) _this.context.registerInteractiveComponent(_this, {
                el: el,
                isHitComboAllowed: _this.props.isHitComboAllowed
            });
            else _this.context.unregisterInteractiveComponent(_this);
        };
        _this.handleScrollRequest = function(request) {
            var onScrollTopRequest = _this.props.onScrollTopRequest;
            var slatCoords = _this.state.slatCoords;
            if (onScrollTopRequest && slatCoords) {
                if (request.time) {
                    var top_1 = slatCoords.computeTimeTop(request.time);
                    top_1 = Math.ceil(top_1); // zoom can give weird floating-point values. rather scroll a little bit further
                    if (top_1) top_1 += 1; // to overcome top border that slots beyond the first have. looks better
                    onScrollTopRequest(top_1);
                }
                return true;
            }
            return false;
        };
        _this.handleColCoords = function(colCoords) {
            _this.colCoords = colCoords;
        };
        _this.handleSlatCoords = function(slatCoords) {
            _this.setState({
                slatCoords: slatCoords
            });
            if (_this.props.onSlatCoords) _this.props.onSlatCoords(slatCoords);
        };
        return _this;
    }
    TimeCols1.prototype.render = function() {
        var _a = this, props = _a.props, state = _a.state;
        return _common.createElement("div", {
            className: "fc-timegrid-body",
            ref: this.handleRootEl,
            style: {
                // these props are important to give this wrapper correct dimensions for interactions
                // TODO: if we set it here, can we avoid giving to inner tables?
                width: props.clientWidth,
                minWidth: props.tableMinWidth
            }
        }, _common.createElement(TimeColsSlats, {
            axis: props.axis,
            dateProfile: props.dateProfile,
            slatMetas: props.slatMetas,
            clientWidth: props.clientWidth,
            minHeight: props.expandRows ? props.clientHeight : '',
            tableMinWidth: props.tableMinWidth,
            tableColGroupNode: props.axis ? props.tableColGroupNode : null,
            onCoords: this.handleSlatCoords
        }), _common.createElement(TimeColsContent, {
            cells: props.cells,
            axis: props.axis,
            dateProfile: props.dateProfile,
            businessHourSegs: props.businessHourSegs,
            bgEventSegs: props.bgEventSegs,
            fgEventSegs: props.fgEventSegs,
            dateSelectionSegs: props.dateSelectionSegs,
            eventSelection: props.eventSelection,
            eventDrag: props.eventDrag,
            eventResize: props.eventResize,
            todayRange: props.todayRange,
            nowDate: props.nowDate,
            nowIndicatorSegs: props.nowIndicatorSegs,
            clientWidth: props.clientWidth,
            tableMinWidth: props.tableMinWidth,
            tableColGroupNode: props.tableColGroupNode,
            slatCoords: state.slatCoords,
            onColCoords: this.handleColCoords,
            forPrint: props.forPrint
        }));
    };
    TimeCols1.prototype.componentDidMount = function() {
        this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);
    };
    TimeCols1.prototype.componentDidUpdate = function(prevProps) {
        this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);
    };
    TimeCols1.prototype.componentWillUnmount = function() {
        this.scrollResponder.detach();
    };
    TimeCols1.prototype.queryHit = function(positionLeft, positionTop) {
        var _a = this.context, dateEnv = _a.dateEnv, options = _a.options;
        var colCoords = this.colCoords;
        var dateProfile = this.props.dateProfile;
        var slatCoords = this.state.slatCoords;
        var _b = this.processSlotOptions(this.props.slotDuration, options.snapDuration), snapDuration = _b.snapDuration, snapsPerSlot = _b.snapsPerSlot;
        var colIndex = colCoords.leftToIndex(positionLeft);
        var slatIndex = slatCoords.positions.topToIndex(positionTop);
        if (colIndex != null && slatIndex != null) {
            var cell = this.props.cells[colIndex];
            var slatTop = slatCoords.positions.tops[slatIndex];
            var slatHeight = slatCoords.positions.getHeight(slatIndex);
            var partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1
            var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat
            var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
            var dayDate = this.props.cells[colIndex].date;
            var time = _common.addDurations(dateProfile.slotMinTime, _common.multiplyDuration(snapDuration, snapIndex));
            var start = dateEnv.add(dayDate, time);
            var end = dateEnv.add(start, snapDuration);
            return {
                dateProfile: dateProfile,
                dateSpan: _tslib.__assign({
                    range: {
                        start: start,
                        end: end
                    },
                    allDay: false
                }, cell.extraDateSpan),
                dayEl: colCoords.els[colIndex],
                rect: {
                    left: colCoords.lefts[colIndex],
                    right: colCoords.rights[colIndex],
                    top: slatTop,
                    bottom: slatTop + slatHeight
                },
                layer: 0
            };
        }
        return null;
    };
    return TimeCols1;
}(_common.DateComponent);
function processSlotOptions(slotDuration, snapDurationOverride) {
    var snapDuration = snapDurationOverride || slotDuration;
    var snapsPerSlot = _common.wholeDivideDurations(slotDuration, snapDuration);
    if (snapsPerSlot === null) {
        snapDuration = slotDuration;
        snapsPerSlot = 1;
    // TODO: say warning?
    }
    return {
        snapDuration: snapDuration,
        snapsPerSlot: snapsPerSlot
    };
}
var DayTimeColsSlicer = /** @class */ function(_super) {
    _tslib.__extends(DayTimeColsSlicer1, _super);
    function DayTimeColsSlicer1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DayTimeColsSlicer1.prototype.sliceRange = function(range, dayRanges) {
        var segs = [];
        for(var col = 0; col < dayRanges.length; col += 1){
            var segRange = _common.intersectRanges(range, dayRanges[col]);
            if (segRange) segs.push({
                start: segRange.start,
                end: segRange.end,
                isStart: segRange.start.valueOf() === range.start.valueOf(),
                isEnd: segRange.end.valueOf() === range.end.valueOf(),
                col: col
            });
        }
        return segs;
    };
    return DayTimeColsSlicer1;
}(_common.Slicer);
var DayTimeCols = /** @class */ function(_super) {
    _tslib.__extends(DayTimeCols1, _super);
    function DayTimeCols1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.buildDayRanges = _common.memoize(buildDayRanges);
        _this.slicer = new DayTimeColsSlicer();
        _this.timeColsRef = _common.createRef();
        return _this;
    }
    DayTimeCols1.prototype.render = function() {
        var _this = this;
        var _a = this, props = _a.props, context = _a.context;
        var dateProfile = props.dateProfile, dayTableModel = props.dayTableModel;
        var isNowIndicator = context.options.nowIndicator;
        var dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);
        // give it the first row of cells
        // TODO: would move this further down hierarchy, but sliceNowDate needs it
        return _common.createElement(_common.NowTimer, {
            unit: isNowIndicator ? 'minute' : 'day'
        }, function(nowDate, todayRange) {
            return _common.createElement(TimeCols, _tslib.__assign({
                ref: _this.timeColsRef
            }, _this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), {
                forPrint: props.forPrint,
                axis: props.axis,
                dateProfile: dateProfile,
                slatMetas: props.slatMetas,
                slotDuration: props.slotDuration,
                cells: dayTableModel.cells[0],
                tableColGroupNode: props.tableColGroupNode,
                tableMinWidth: props.tableMinWidth,
                clientWidth: props.clientWidth,
                clientHeight: props.clientHeight,
                expandRows: props.expandRows,
                nowDate: nowDate,
                nowIndicatorSegs: isNowIndicator && _this.slicer.sliceNowDate(nowDate, context, dayRanges),
                todayRange: todayRange,
                onScrollTopRequest: props.onScrollTopRequest,
                onSlatCoords: props.onSlatCoords
            }));
        });
    };
    return DayTimeCols1;
}(_common.DateComponent);
function buildDayRanges(dayTableModel, dateProfile, dateEnv) {
    var ranges = [];
    for(var _i = 0, _a = dayTableModel.headerDates; _i < _a.length; _i++){
        var date = _a[_i];
        ranges.push({
            start: dateEnv.add(date, dateProfile.slotMinTime),
            end: dateEnv.add(date, dateProfile.slotMaxTime)
        });
    }
    return ranges;
}
// potential nice values for the slot-duration and interval-duration
// from largest to smallest
var STOCK_SUB_DURATIONS = [
    {
        hours: 1
    },
    {
        minutes: 30
    },
    {
        minutes: 15
    },
    {
        seconds: 30
    },
    {
        seconds: 15
    }, 
];
function buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {
    var dayStart = new Date(0);
    var slatTime = slotMinTime;
    var slatIterator = _common.createDuration(0);
    var labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);
    var metas = [];
    while(_common.asRoughMs(slatTime) < _common.asRoughMs(slotMaxTime)){
        var date = dateEnv.add(dayStart, slatTime);
        var isLabeled = _common.wholeDivideDurations(slatIterator, labelInterval) !== null;
        metas.push({
            date: date,
            time: slatTime,
            key: date.toISOString(),
            isoTimeStr: _common.formatIsoTimeString(date),
            isLabeled: isLabeled
        });
        slatTime = _common.addDurations(slatTime, slotDuration);
        slatIterator = _common.addDurations(slatIterator, slotDuration);
    }
    return metas;
}
// Computes an automatic value for slotLabelInterval
function computeLabelInterval(slotDuration) {
    var i;
    var labelInterval;
    var slotsPerLabel;
    // find the smallest stock label interval that results in more than one slots-per-label
    for(i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1){
        labelInterval = _common.createDuration(STOCK_SUB_DURATIONS[i]);
        slotsPerLabel = _common.wholeDivideDurations(labelInterval, slotDuration);
        if (slotsPerLabel !== null && slotsPerLabel > 1) return labelInterval;
    }
    return slotDuration; // fall back
}
var DayTimeColsView = /** @class */ function(_super) {
    _tslib.__extends(DayTimeColsView1, _super);
    function DayTimeColsView1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.buildTimeColsModel = _common.memoize(buildTimeColsModel);
        _this.buildSlatMetas = _common.memoize(buildSlatMetas);
        return _this;
    }
    DayTimeColsView1.prototype.render = function() {
        var _this = this;
        var _a = this.context, options = _a.options, dateEnv = _a.dateEnv, dateProfileGenerator = _a.dateProfileGenerator;
        var props = this.props;
        var dateProfile = props.dateProfile;
        var dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);
        var splitProps = this.allDaySplitter.splitProps(props);
        var slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);
        var dayMinWidth = options.dayMinWidth;
        var hasAttachedAxis = !dayMinWidth;
        var hasDetachedAxis = dayMinWidth;
        var headerContent = options.dayHeaders && _common.createElement(_common.DayHeader, {
            dates: dayTableModel.headerDates,
            dateProfile: dateProfile,
            datesRepDistinctDays: true,
            renderIntro: hasAttachedAxis ? this.renderHeadAxis : null
        });
        var allDayContent = options.allDaySlot !== false && function(contentArg) {
            return _common.createElement(_daygrid.DayTable, _tslib.__assign({}, splitProps.allDay, {
                dateProfile: dateProfile,
                dayTableModel: dayTableModel,
                nextDayThreshold: options.nextDayThreshold,
                tableMinWidth: contentArg.tableMinWidth,
                colGroupNode: contentArg.tableColGroupNode,
                renderRowIntro: hasAttachedAxis ? _this.renderTableRowAxis : null,
                showWeekNumbers: false,
                expandRows: false,
                headerAlignElRef: _this.headerElRef,
                clientWidth: contentArg.clientWidth,
                clientHeight: contentArg.clientHeight,
                forPrint: props.forPrint
            }, _this.getAllDayMaxEventProps()));
        };
        var timeGridContent = function(contentArg) {
            return _common.createElement(DayTimeCols, _tslib.__assign({}, splitProps.timed, {
                dayTableModel: dayTableModel,
                dateProfile: dateProfile,
                axis: hasAttachedAxis,
                slotDuration: options.slotDuration,
                slatMetas: slatMetas,
                forPrint: props.forPrint,
                tableColGroupNode: contentArg.tableColGroupNode,
                tableMinWidth: contentArg.tableMinWidth,
                clientWidth: contentArg.clientWidth,
                clientHeight: contentArg.clientHeight,
                onSlatCoords: _this.handleSlatCoords,
                expandRows: contentArg.expandRows,
                onScrollTopRequest: _this.handleScrollTopRequest
            }));
        };
        return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);
    };
    return DayTimeColsView1;
}(TimeColsView);
function buildTimeColsModel(dateProfile, dateProfileGenerator) {
    var daySeries = new _common.DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
    return new _common.DayTableModel(daySeries, false);
}
var OPTION_REFINERS = {
    allDaySlot: Boolean
};
var main = _common.createPlugin({
    initialView: 'timeGridWeek',
    optionRefiners: OPTION_REFINERS,
    views: {
        timeGrid: {
            component: DayTimeColsView,
            usesMinMaxTime: true,
            allDaySlot: true,
            slotDuration: '00:30:00',
            slotEventOverlap: true
        },
        timeGridDay: {
            type: 'timeGrid',
            duration: {
                days: 1
            }
        },
        timeGridWeek: {
            type: 'timeGrid',
            duration: {
                weeks: 1
            }
        }
    }
});
exports.default = main;

},{"./main.css":"kcl4J","@fullcalendar/common":"cnjgQ","tslib":"5i9Vz","@fullcalendar/daygrid":"1Spto","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"kcl4J":[function() {},{}],"1Spto":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DayGridView", ()=>DayTableView
);
parcelHelpers.export(exports, "DayTable", ()=>DayTable
);
parcelHelpers.export(exports, "DayTableSlicer", ()=>DayTableSlicer
);
parcelHelpers.export(exports, "Table", ()=>Table
);
parcelHelpers.export(exports, "TableView", ()=>TableView
);
parcelHelpers.export(exports, "buildDayTableModel", ()=>buildDayTableModel
);
/*!
FullCalendar v5.10.2
Docs & License: https://fullcalendar.io/
(c) 2021 Adam Shaw
*/ var _mainCss = require("./main.css");
var _common = require("@fullcalendar/common");
var _tslib = require("tslib");
/* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.
----------------------------------------------------------------------------------------------------------------------*/ // It is a manager for a Table subcomponent, which does most of the heavy lifting.
// It is responsible for managing width/height.
var TableView = /** @class */ function(_super) {
    _tslib.__extends(TableView1, _super);
    function TableView1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.headerElRef = _common.createRef();
        return _this;
    }
    TableView1.prototype.renderSimpleLayout = function(headerRowContent, bodyContent) {
        var _a = this, props = _a.props, context = _a.context;
        var sections = [];
        var stickyHeaderDates = _common.getStickyHeaderDates(context.options);
        if (headerRowContent) sections.push({
            type: 'header',
            key: 'header',
            isSticky: stickyHeaderDates,
            chunk: {
                elRef: this.headerElRef,
                tableClassName: 'fc-col-header',
                rowContent: headerRowContent
            }
        });
        sections.push({
            type: 'body',
            key: 'body',
            liquid: true,
            chunk: {
                content: bodyContent
            }
        });
        return _common.createElement(_common.ViewRoot, {
            viewSpec: context.viewSpec
        }, function(rootElRef, classNames) {
            return _common.createElement("div", {
                ref: rootElRef,
                className: [
                    'fc-daygrid'
                ].concat(classNames).join(' ')
            }, _common.createElement(_common.SimpleScrollGrid, {
                liquid: !props.isHeightAuto && !props.forPrint,
                collapsibleWidth: props.forPrint,
                cols: [],
                sections: sections
            }));
        });
    };
    TableView1.prototype.renderHScrollLayout = function(headerRowContent, bodyContent, colCnt, dayMinWidth) {
        var ScrollGrid = this.context.pluginHooks.scrollGridImpl;
        if (!ScrollGrid) throw new Error('No ScrollGrid implementation');
        var _a = this, props = _a.props, context = _a.context;
        var stickyHeaderDates = !props.forPrint && _common.getStickyHeaderDates(context.options);
        var stickyFooterScrollbar = !props.forPrint && _common.getStickyFooterScrollbar(context.options);
        var sections = [];
        if (headerRowContent) sections.push({
            type: 'header',
            key: 'header',
            isSticky: stickyHeaderDates,
            chunks: [
                {
                    key: 'main',
                    elRef: this.headerElRef,
                    tableClassName: 'fc-col-header',
                    rowContent: headerRowContent
                }
            ]
        });
        sections.push({
            type: 'body',
            key: 'body',
            liquid: true,
            chunks: [
                {
                    key: 'main',
                    content: bodyContent
                }
            ]
        });
        if (stickyFooterScrollbar) sections.push({
            type: 'footer',
            key: 'footer',
            isSticky: true,
            chunks: [
                {
                    key: 'main',
                    content: _common.renderScrollShim
                }
            ]
        });
        return _common.createElement(_common.ViewRoot, {
            viewSpec: context.viewSpec
        }, function(rootElRef, classNames) {
            return _common.createElement("div", {
                ref: rootElRef,
                className: [
                    'fc-daygrid'
                ].concat(classNames).join(' ')
            }, _common.createElement(ScrollGrid, {
                liquid: !props.isHeightAuto && !props.forPrint,
                collapsibleWidth: props.forPrint,
                colGroups: [
                    {
                        cols: [
                            {
                                span: colCnt,
                                minWidth: dayMinWidth
                            }
                        ]
                    }
                ],
                sections: sections
            }));
        });
    };
    return TableView1;
}(_common.DateComponent);
function splitSegsByRow(segs, rowCnt) {
    var byRow = [];
    for(var i = 0; i < rowCnt; i += 1)byRow[i] = [];
    for(var _i = 0, segs_1 = segs; _i < segs_1.length; _i++){
        var seg = segs_1[_i];
        byRow[seg.row].push(seg);
    }
    return byRow;
}
function splitSegsByFirstCol(segs, colCnt) {
    var byCol = [];
    for(var i = 0; i < colCnt; i += 1)byCol[i] = [];
    for(var _i = 0, segs_2 = segs; _i < segs_2.length; _i++){
        var seg = segs_2[_i];
        byCol[seg.firstCol].push(seg);
    }
    return byCol;
}
function splitInteractionByRow(ui, rowCnt) {
    var byRow = [];
    if (!ui) for(var i = 0; i < rowCnt; i += 1)byRow[i] = null;
    else {
        for(var i = 0; i < rowCnt; i += 1)byRow[i] = {
            affectedInstances: ui.affectedInstances,
            isEvent: ui.isEvent,
            segs: []
        };
        for(var _i = 0, _a = ui.segs; _i < _a.length; _i++){
            var seg = _a[_i];
            byRow[seg.row].segs.push(seg);
        }
    }
    return byRow;
}
var TableCellTop = /** @class */ function(_super) {
    _tslib.__extends(TableCellTop1, _super);
    function TableCellTop1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TableCellTop1.prototype.render = function() {
        var props = this.props;
        var navLinkAttrs = _common.buildNavLinkAttrs(this.context, props.date);
        return _common.createElement(_common.DayCellContent, {
            date: props.date,
            dateProfile: props.dateProfile,
            todayRange: props.todayRange,
            showDayNumber: props.showDayNumber,
            extraHookProps: props.extraHookProps,
            defaultContent: renderTopInner
        }, function(innerElRef, innerContent) {
            return (innerContent || props.forceDayTop) && _common.createElement("div", {
                className: "fc-daygrid-day-top",
                ref: innerElRef
            }, _common.createElement("a", _tslib.__assign({
                id: props.dayNumberId,
                className: "fc-daygrid-day-number"
            }, navLinkAttrs), innerContent || _common.createElement(_common.Fragment, null, "\u00A0")));
        });
    };
    return TableCellTop1;
}(_common.BaseComponent);
function renderTopInner(props) {
    return props.dayNumberText;
}
var DEFAULT_TABLE_EVENT_TIME_FORMAT = _common.createFormatter({
    hour: 'numeric',
    minute: '2-digit',
    omitZeroMinute: true,
    meridiem: 'narrow'
});
function hasListItemDisplay(seg) {
    var display = seg.eventRange.ui.display;
    return display === 'list-item' || display === 'auto' && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && seg.isStart && seg.isEnd // "
    ;
}
var TableBlockEvent = /** @class */ function(_super) {
    _tslib.__extends(TableBlockEvent1, _super);
    function TableBlockEvent1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TableBlockEvent1.prototype.render = function() {
        var props = this.props;
        return _common.createElement(_common.StandardEvent, _tslib.__assign({}, props, {
            extraClassNames: [
                'fc-daygrid-event',
                'fc-daygrid-block-event',
                'fc-h-event'
            ],
            defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT,
            defaultDisplayEventEnd: props.defaultDisplayEventEnd,
            disableResizing: !props.seg.eventRange.def.allDay
        }));
    };
    return TableBlockEvent1;
}(_common.BaseComponent);
var TableListItemEvent = /** @class */ function(_super) {
    _tslib.__extends(TableListItemEvent1, _super);
    function TableListItemEvent1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TableListItemEvent1.prototype.render = function() {
        var _a = this, props = _a.props, context = _a.context;
        var timeFormat = context.options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;
        var timeText = _common.buildSegTimeText(props.seg, timeFormat, context, true, props.defaultDisplayEventEnd);
        return _common.createElement(_common.EventRoot, {
            seg: props.seg,
            timeText: timeText,
            defaultContent: renderInnerContent,
            isDragging: props.isDragging,
            isResizing: false,
            isDateSelecting: false,
            isSelected: props.isSelected,
            isPast: props.isPast,
            isFuture: props.isFuture,
            isToday: props.isToday
        }, function(rootElRef, classNames, innerElRef, innerContent) {
            return _common.createElement("a", _tslib.__assign({
                className: [
                    'fc-daygrid-event',
                    'fc-daygrid-dot-event'
                ].concat(classNames).join(' '),
                ref: rootElRef
            }, _common.getSegAnchorAttrs(props.seg, context)), innerContent);
        });
    };
    return TableListItemEvent1;
}(_common.BaseComponent);
function renderInnerContent(innerProps) {
    return _common.createElement(_common.Fragment, null, _common.createElement("div", {
        className: "fc-daygrid-event-dot",
        style: {
            borderColor: innerProps.borderColor || innerProps.backgroundColor
        }
    }), innerProps.timeText && _common.createElement("div", {
        className: "fc-event-time"
    }, innerProps.timeText), _common.createElement("div", {
        className: "fc-event-title"
    }, innerProps.event.title || _common.createElement(_common.Fragment, null, "\u00A0")));
}
var TableCellMoreLink = /** @class */ function(_super) {
    _tslib.__extends(TableCellMoreLink1, _super);
    function TableCellMoreLink1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.compileSegs = _common.memoize(compileSegs);
        return _this;
    }
    TableCellMoreLink1.prototype.render = function() {
        var props = this.props;
        var _a = this.compileSegs(props.singlePlacements), allSegs = _a.allSegs, invisibleSegs = _a.invisibleSegs;
        return _common.createElement(_common.MoreLinkRoot, {
            dateProfile: props.dateProfile,
            todayRange: props.todayRange,
            allDayDate: props.allDayDate,
            moreCnt: props.moreCnt,
            allSegs: allSegs,
            hiddenSegs: invisibleSegs,
            alignmentElRef: props.alignmentElRef,
            alignGridTop: props.alignGridTop,
            extraDateSpan: props.extraDateSpan,
            popoverContent: function() {
                var isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};
                return _common.createElement(_common.Fragment, null, allSegs.map(function(seg) {
                    var instanceId = seg.eventRange.instance.instanceId;
                    return _common.createElement("div", {
                        className: "fc-daygrid-event-harness",
                        key: instanceId,
                        style: {
                            visibility: isForcedInvisible[instanceId] ? 'hidden' : ''
                        }
                    }, hasListItemDisplay(seg) ? _common.createElement(TableListItemEvent, _tslib.__assign({
                        seg: seg,
                        isDragging: false,
                        isSelected: instanceId === props.eventSelection,
                        defaultDisplayEventEnd: false
                    }, _common.getSegMeta(seg, props.todayRange))) : _common.createElement(TableBlockEvent, _tslib.__assign({
                        seg: seg,
                        isDragging: false,
                        isResizing: false,
                        isDateSelecting: false,
                        isSelected: instanceId === props.eventSelection,
                        defaultDisplayEventEnd: false
                    }, _common.getSegMeta(seg, props.todayRange))));
                }));
            }
        }, function(rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {
            return _common.createElement("a", _tslib.__assign({
                ref: rootElRef,
                className: [
                    'fc-daygrid-more-link'
                ].concat(classNames).join(' '),
                title: title,
                "aria-expanded": isExpanded,
                "aria-controls": popoverId
            }, _common.createAriaClickAttrs(handleClick)), innerContent);
        });
    };
    return TableCellMoreLink1;
}(_common.BaseComponent);
function compileSegs(singlePlacements) {
    var allSegs = [];
    var invisibleSegs = [];
    for(var _i = 0, singlePlacements_1 = singlePlacements; _i < singlePlacements_1.length; _i++){
        var placement = singlePlacements_1[_i];
        allSegs.push(placement.seg);
        if (!placement.isVisible) invisibleSegs.push(placement.seg);
    }
    return {
        allSegs: allSegs,
        invisibleSegs: invisibleSegs
    };
}
var DEFAULT_WEEK_NUM_FORMAT = _common.createFormatter({
    week: 'narrow'
});
var TableCell = /** @class */ function(_super) {
    _tslib.__extends(TableCell1, _super);
    function TableCell1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.rootElRef = _common.createRef();
        _this.state = {
            dayNumberId: _common.getUniqueDomId()
        };
        _this.handleRootEl = function(el) {
            _common.setRef(_this.rootElRef, el);
            _common.setRef(_this.props.elRef, el);
        };
        return _this;
    }
    TableCell1.prototype.render = function() {
        var _a = this, context = _a.context, props = _a.props, state = _a.state, rootElRef = _a.rootElRef;
        var date = props.date, dateProfile = props.dateProfile;
        var navLinkAttrs = _common.buildNavLinkAttrs(context, date, 'week');
        return _common.createElement(_common.DayCellRoot, {
            date: date,
            dateProfile: dateProfile,
            todayRange: props.todayRange,
            showDayNumber: props.showDayNumber,
            extraHookProps: props.extraHookProps,
            elRef: this.handleRootEl
        }, function(dayElRef, dayClassNames, rootDataAttrs, isDisabled) {
            return _common.createElement("td", _tslib.__assign({
                ref: dayElRef,
                role: "gridcell",
                className: [
                    'fc-daygrid-day'
                ].concat(dayClassNames, props.extraClassNames || []).join(' ')
            }, rootDataAttrs, props.extraDataAttrs, props.showDayNumber ? {
                'aria-labelledby': state.dayNumberId
            } : {}), _common.createElement("div", {
                className: "fc-daygrid-day-frame fc-scrollgrid-sync-inner",
                ref: props.innerElRef /* different from hook system! RENAME */ 
            }, props.showWeekNumber && _common.createElement(_common.WeekNumberRoot, {
                date: date,
                defaultFormat: DEFAULT_WEEK_NUM_FORMAT
            }, function(weekElRef, weekClassNames, innerElRef, innerContent) {
                return _common.createElement("a", _tslib.__assign({
                    ref: weekElRef,
                    className: [
                        'fc-daygrid-week-number'
                    ].concat(weekClassNames).join(' ')
                }, navLinkAttrs), innerContent);
            }), !isDisabled && _common.createElement(TableCellTop, {
                date: date,
                dateProfile: dateProfile,
                showDayNumber: props.showDayNumber,
                dayNumberId: state.dayNumberId,
                forceDayTop: props.forceDayTop,
                todayRange: props.todayRange,
                extraHookProps: props.extraHookProps
            }), _common.createElement("div", {
                className: "fc-daygrid-day-events",
                ref: props.fgContentElRef
            }, props.fgContent, _common.createElement("div", {
                className: "fc-daygrid-day-bottom",
                style: {
                    marginTop: props.moreMarginTop
                }
            }, _common.createElement(TableCellMoreLink, {
                allDayDate: date,
                singlePlacements: props.singlePlacements,
                moreCnt: props.moreCnt,
                alignmentElRef: rootElRef,
                alignGridTop: !props.showDayNumber,
                extraDateSpan: props.extraDateSpan,
                dateProfile: props.dateProfile,
                eventSelection: props.eventSelection,
                eventDrag: props.eventDrag,
                eventResize: props.eventResize,
                todayRange: props.todayRange
            }))), _common.createElement("div", {
                className: "fc-daygrid-day-bg"
            }, props.bgContent)));
        });
    };
    return TableCell1;
}(_common.DateComponent);
function computeFgSegPlacement(segs, dayMaxEvents, dayMaxEventRows, strictOrder, eventInstanceHeights, maxContentHeight, cells) {
    var hierarchy = new DayGridSegHierarchy();
    hierarchy.allowReslicing = true;
    hierarchy.strictOrder = strictOrder;
    if (dayMaxEvents === true || dayMaxEventRows === true) {
        hierarchy.maxCoord = maxContentHeight;
        hierarchy.hiddenConsumes = true;
    } else if (typeof dayMaxEvents === 'number') hierarchy.maxStackCnt = dayMaxEvents;
    else if (typeof dayMaxEventRows === 'number') {
        hierarchy.maxStackCnt = dayMaxEventRows;
        hierarchy.hiddenConsumes = true;
    }
    // create segInputs only for segs with known heights
    var segInputs = [];
    var unknownHeightSegs = [];
    for(var i = 0; i < segs.length; i += 1){
        var seg = segs[i];
        var instanceId = seg.eventRange.instance.instanceId;
        var eventHeight = eventInstanceHeights[instanceId];
        if (eventHeight != null) segInputs.push({
            index: i,
            thickness: eventHeight,
            span: {
                start: seg.firstCol,
                end: seg.lastCol + 1
            }
        });
        else unknownHeightSegs.push(seg);
    }
    var hiddenEntries = hierarchy.addSegs(segInputs);
    var segRects = hierarchy.toRects();
    var _a = placeRects(segRects, segs, cells), singleColPlacements = _a.singleColPlacements, multiColPlacements = _a.multiColPlacements, leftoverMargins = _a.leftoverMargins;
    var moreCnts = [];
    var moreMarginTops = [];
    // add segs with unknown heights
    for(var _i = 0, unknownHeightSegs_1 = unknownHeightSegs; _i < unknownHeightSegs_1.length; _i++){
        var seg = unknownHeightSegs_1[_i];
        multiColPlacements[seg.firstCol].push({
            seg: seg,
            isVisible: false,
            isAbsolute: true,
            absoluteTop: 0,
            marginTop: 0
        });
        for(var col = seg.firstCol; col <= seg.lastCol; col += 1)singleColPlacements[col].push({
            seg: resliceSeg(seg, col, col + 1, cells),
            isVisible: false,
            isAbsolute: false,
            absoluteTop: 0,
            marginTop: 0
        });
    }
    // add the hidden entries
    for(var col = 0; col < cells.length; col += 1)moreCnts.push(0);
    for(var _b = 0, hiddenEntries_1 = hiddenEntries; _b < hiddenEntries_1.length; _b++){
        var hiddenEntry = hiddenEntries_1[_b];
        var seg = segs[hiddenEntry.index];
        var hiddenSpan = hiddenEntry.span;
        multiColPlacements[hiddenSpan.start].push({
            seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),
            isVisible: false,
            isAbsolute: true,
            absoluteTop: 0,
            marginTop: 0
        });
        for(var col = hiddenSpan.start; col < hiddenSpan.end; col += 1){
            moreCnts[col] += 1;
            singleColPlacements[col].push({
                seg: resliceSeg(seg, col, col + 1, cells),
                isVisible: false,
                isAbsolute: false,
                absoluteTop: 0,
                marginTop: 0
            });
        }
    }
    // deal with leftover margins
    for(var col = 0; col < cells.length; col += 1)moreMarginTops.push(leftoverMargins[col]);
    return {
        singleColPlacements: singleColPlacements,
        multiColPlacements: multiColPlacements,
        moreCnts: moreCnts,
        moreMarginTops: moreMarginTops
    };
}
// rects ordered by top coord, then left
function placeRects(allRects, segs, cells) {
    var rectsByEachCol = groupRectsByEachCol(allRects, cells.length);
    var singleColPlacements = [];
    var multiColPlacements = [];
    var leftoverMargins = [];
    for(var col = 0; col < cells.length; col += 1){
        var rects = rectsByEachCol[col];
        // compute all static segs in singlePlacements
        var singlePlacements = [];
        var currentHeight = 0;
        var currentMarginTop = 0;
        for(var _i = 0, rects_1 = rects; _i < rects_1.length; _i++){
            var rect = rects_1[_i];
            var seg = segs[rect.index];
            singlePlacements.push({
                seg: resliceSeg(seg, col, col + 1, cells),
                isVisible: true,
                isAbsolute: false,
                absoluteTop: rect.levelCoord,
                marginTop: rect.levelCoord - currentHeight
            });
            currentHeight = rect.levelCoord + rect.thickness;
        }
        // compute mixed static/absolute segs in multiPlacements
        var multiPlacements = [];
        currentHeight = 0;
        currentMarginTop = 0;
        for(var _a = 0, rects_2 = rects; _a < rects_2.length; _a++){
            var rect = rects_2[_a];
            var seg = segs[rect.index];
            var isAbsolute = rect.span.end - rect.span.start > 1; // multi-column?
            var isFirstCol = rect.span.start === col;
            currentMarginTop += rect.levelCoord - currentHeight; // amount of space since bottom of previous seg
            currentHeight = rect.levelCoord + rect.thickness; // height will now be bottom of current seg
            if (isAbsolute) {
                currentMarginTop += rect.thickness;
                if (isFirstCol) multiPlacements.push({
                    seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
                    isVisible: true,
                    isAbsolute: true,
                    absoluteTop: rect.levelCoord,
                    marginTop: 0
                });
            } else if (isFirstCol) {
                multiPlacements.push({
                    seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
                    isVisible: true,
                    isAbsolute: false,
                    absoluteTop: rect.levelCoord,
                    marginTop: currentMarginTop
                });
                currentMarginTop = 0;
            }
        }
        singleColPlacements.push(singlePlacements);
        multiColPlacements.push(multiPlacements);
        leftoverMargins.push(currentMarginTop);
    }
    return {
        singleColPlacements: singleColPlacements,
        multiColPlacements: multiColPlacements,
        leftoverMargins: leftoverMargins
    };
}
function groupRectsByEachCol(rects, colCnt) {
    var rectsByEachCol = [];
    for(var col = 0; col < colCnt; col += 1)rectsByEachCol.push([]);
    for(var _i = 0, rects_3 = rects; _i < rects_3.length; _i++){
        var rect = rects_3[_i];
        for(var col = rect.span.start; col < rect.span.end; col += 1)rectsByEachCol[col].push(rect);
    }
    return rectsByEachCol;
}
function resliceSeg(seg, spanStart, spanEnd, cells) {
    if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) return seg;
    var eventRange = seg.eventRange;
    var origRange = eventRange.range;
    var slicedRange = _common.intersectRanges(origRange, {
        start: cells[spanStart].date,
        end: _common.addDays(cells[spanEnd - 1].date, 1)
    });
    return _tslib.__assign(_tslib.__assign({}, seg), {
        firstCol: spanStart,
        lastCol: spanEnd - 1,
        eventRange: {
            def: eventRange.def,
            ui: _tslib.__assign(_tslib.__assign({}, eventRange.ui), {
                durationEditable: false
            }),
            instance: eventRange.instance,
            range: slicedRange
        },
        isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),
        isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()
    });
}
var DayGridSegHierarchy = /** @class */ function(_super) {
    _tslib.__extends(DayGridSegHierarchy1, _super);
    function DayGridSegHierarchy1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // config
        _this.hiddenConsumes = false;
        // allows us to keep hidden entries in the hierarchy so they take up space
        _this.forceHidden = {};
        return _this;
    }
    DayGridSegHierarchy1.prototype.addSegs = function(segInputs) {
        var _this = this;
        var hiddenSegs = _super.prototype.addSegs.call(this, segInputs);
        var entriesByLevel = this.entriesByLevel;
        var excludeHidden = function(entry) {
            return !_this.forceHidden[_common.buildEntryKey(entry)];
        };
        // remove the forced-hidden segs
        for(var level = 0; level < entriesByLevel.length; level += 1)entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);
        return hiddenSegs;
    };
    DayGridSegHierarchy1.prototype.handleInvalidInsertion = function(insertion, entry, hiddenEntries) {
        var _a = this, entriesByLevel = _a.entriesByLevel, forceHidden = _a.forceHidden;
        var touchingEntry = insertion.touchingEntry, touchingLevel = insertion.touchingLevel, touchingLateral = insertion.touchingLateral;
        if (this.hiddenConsumes && touchingEntry) {
            var touchingEntryId = _common.buildEntryKey(touchingEntry);
            // if not already hidden
            if (!forceHidden[touchingEntryId]) {
                if (this.allowReslicing) {
                    var placeholderEntry = _tslib.__assign(_tslib.__assign({}, touchingEntry), {
                        span: _common.intersectSpans(touchingEntry.span, entry.span)
                    });
                    var placeholderEntryId = _common.buildEntryKey(placeholderEntry);
                    forceHidden[placeholderEntryId] = true;
                    entriesByLevel[touchingLevel][touchingLateral] = placeholderEntry; // replace touchingEntry with our placeholder
                    this.splitEntry(touchingEntry, entry, hiddenEntries); // split up the touchingEntry, reinsert it
                } else {
                    forceHidden[touchingEntryId] = true;
                    hiddenEntries.push(touchingEntry);
                }
            }
        }
        return _super.prototype.handleInvalidInsertion.call(this, insertion, entry, hiddenEntries);
    };
    return DayGridSegHierarchy1;
}(_common.SegHierarchy);
var TableRow = /** @class */ function(_super) {
    _tslib.__extends(TableRow1, _super);
    function TableRow1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.cellElRefs = new _common.RefMap(); // the <td>
        _this.frameElRefs = new _common.RefMap(); // the fc-daygrid-day-frame
        _this.fgElRefs = new _common.RefMap(); // the fc-daygrid-day-events
        _this.segHarnessRefs = new _common.RefMap(); // indexed by "instanceId:firstCol"
        _this.rootElRef = _common.createRef();
        _this.state = {
            framePositions: null,
            maxContentHeight: null,
            eventInstanceHeights: {}
        };
        return _this;
    }
    TableRow1.prototype.render = function() {
        var _this = this;
        var _a = this, props = _a.props, state = _a.state, context = _a.context;
        var options = context.options;
        var colCnt = props.cells.length;
        var businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);
        var bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);
        var highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);
        var mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);
        var _b = computeFgSegPlacement(_common.sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.eventInstanceHeights, state.maxContentHeight, props.cells), singleColPlacements = _b.singleColPlacements, multiColPlacements = _b.multiColPlacements, moreCnts = _b.moreCnts, moreMarginTops = _b.moreMarginTops;
        var isForcedInvisible = props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};
        return _common.createElement("tr", {
            ref: this.rootElRef,
            role: "row"
        }, props.renderIntro && props.renderIntro(), props.cells.map(function(cell, col) {
            var normalFgNodes = _this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);
            var mirrorFgNodes = _this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);
            return _common.createElement(TableCell, {
                key: cell.key,
                elRef: _this.cellElRefs.createRef(cell.key),
                innerElRef: _this.frameElRefs.createRef(cell.key),
                dateProfile: props.dateProfile,
                date: cell.date,
                showDayNumber: props.showDayNumbers,
                showWeekNumber: props.showWeekNumbers && col === 0,
                forceDayTop: props.showWeekNumbers /* even displaying weeknum for row, not necessarily day */ ,
                todayRange: props.todayRange,
                eventSelection: props.eventSelection,
                eventDrag: props.eventDrag,
                eventResize: props.eventResize,
                extraHookProps: cell.extraHookProps,
                extraDataAttrs: cell.extraDataAttrs,
                extraClassNames: cell.extraClassNames,
                extraDateSpan: cell.extraDateSpan,
                moreCnt: moreCnts[col],
                moreMarginTop: moreMarginTops[col],
                singlePlacements: singleColPlacements[col],
                fgContentElRef: _this.fgElRefs.createRef(cell.key),
                fgContent: _common.createElement(_common.Fragment, null, _common.createElement(_common.Fragment, null, normalFgNodes), _common.createElement(_common.Fragment, null, mirrorFgNodes)),
                bgContent: _common.createElement(_common.Fragment, null, _this.renderFillSegs(highlightSegsByCol[col], 'highlight'), _this.renderFillSegs(businessHoursByCol[col], 'non-business'), _this.renderFillSegs(bgEventSegsByCol[col], 'bg-event'))
            });
        }));
    };
    TableRow1.prototype.componentDidMount = function() {
        this.updateSizing(true);
    };
    TableRow1.prototype.componentDidUpdate = function(prevProps, prevState) {
        var currentProps = this.props;
        this.updateSizing(!_common.isPropsEqual(prevProps, currentProps));
    };
    TableRow1.prototype.getHighlightSegs = function() {
        var props = this.props;
        if (props.eventDrag && props.eventDrag.segs.length) return props.eventDrag.segs;
        if (props.eventResize && props.eventResize.segs.length) return props.eventResize.segs;
        return props.dateSelectionSegs;
    };
    TableRow1.prototype.getMirrorSegs = function() {
        var props = this.props;
        if (props.eventResize && props.eventResize.segs.length) return props.eventResize.segs;
        return [];
    };
    TableRow1.prototype.renderFgSegs = function(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {
        var context = this.context;
        var eventSelection = this.props.eventSelection;
        var framePositions = this.state.framePositions;
        var defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1
        var isMirror = isDragging || isResizing || isDateSelecting;
        var nodes = [];
        if (framePositions) for(var _i = 0, segPlacements_1 = segPlacements; _i < segPlacements_1.length; _i++){
            var placement = segPlacements_1[_i];
            var seg = placement.seg;
            var instanceId = seg.eventRange.instance.instanceId;
            var key = instanceId + ':' + col;
            var isVisible = placement.isVisible && !isForcedInvisible[instanceId];
            var isAbsolute = placement.isAbsolute;
            var left = '';
            var right = '';
            if (isAbsolute) {
                if (context.isRtl) {
                    right = 0;
                    left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];
                } else {
                    left = 0;
                    right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];
                }
            }
            /*
                known bug: events that are force to be list-item but span multiple days still take up space in later columns
                todo: in print view, for multi-day events, don't display title within non-start/end segs
                */ nodes.push(_common.createElement("div", {
                className: 'fc-daygrid-event-harness' + (isAbsolute ? ' fc-daygrid-event-harness-abs' : ''),
                key: key,
                ref: isMirror ? null : this.segHarnessRefs.createRef(key),
                style: {
                    visibility: isVisible ? '' : 'hidden',
                    marginTop: isAbsolute ? '' : placement.marginTop,
                    top: isAbsolute ? placement.absoluteTop : '',
                    left: left,
                    right: right
                }
            }, hasListItemDisplay(seg) ? _common.createElement(TableListItemEvent, _tslib.__assign({
                seg: seg,
                isDragging: isDragging,
                isSelected: instanceId === eventSelection,
                defaultDisplayEventEnd: defaultDisplayEventEnd
            }, _common.getSegMeta(seg, todayRange))) : _common.createElement(TableBlockEvent, _tslib.__assign({
                seg: seg,
                isDragging: isDragging,
                isResizing: isResizing,
                isDateSelecting: isDateSelecting,
                isSelected: instanceId === eventSelection,
                defaultDisplayEventEnd: defaultDisplayEventEnd
            }, _common.getSegMeta(seg, todayRange)))));
        }
        return nodes;
    };
    TableRow1.prototype.renderFillSegs = function(segs, fillType) {
        var isRtl = this.context.isRtl;
        var todayRange = this.props.todayRange;
        var framePositions = this.state.framePositions;
        var nodes = [];
        if (framePositions) for(var _i = 0, segs_1 = segs; _i < segs_1.length; _i++){
            var seg = segs_1[_i];
            var leftRightCss = isRtl ? {
                right: 0,
                left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]
            } : {
                left: 0,
                right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]
            };
            nodes.push(_common.createElement("div", {
                key: _common.buildEventRangeKey(seg.eventRange),
                className: "fc-daygrid-bg-harness",
                style: leftRightCss
            }, fillType === 'bg-event' ? _common.createElement(_common.BgEvent, _tslib.__assign({
                seg: seg
            }, _common.getSegMeta(seg, todayRange))) : _common.renderFill(fillType)));
        }
        return _common.createElement.apply(void 0, _tslib.__spreadArray([
            _common.Fragment,
            {}
        ], nodes));
    };
    TableRow1.prototype.updateSizing = function(isExternalSizingChange) {
        var _a = this, props = _a.props, frameElRefs = _a.frameElRefs;
        if (!props.forPrint && props.clientWidth !== null // positioning ready?
        ) {
            if (isExternalSizingChange) {
                var frameEls = props.cells.map(function(cell) {
                    return frameElRefs.currentMap[cell.key];
                });
                if (frameEls.length) {
                    var originEl = this.rootElRef.current;
                    this.setState({
                        framePositions: new _common.PositionCache(originEl, frameEls, true, false)
                    });
                }
            }
            var oldInstanceHeights = this.state.eventInstanceHeights;
            var newInstanceHeights = this.queryEventInstanceHeights();
            var limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;
            this.setState({
                // HACK to prevent oscillations of events being shown/hidden from max-event-rows
                // Essentially, once you compute an element's height, never null-out.
                // TODO: always display all events, as visibility:hidden?
                eventInstanceHeights: _tslib.__assign(_tslib.__assign({}, oldInstanceHeights), newInstanceHeights),
                maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null
            });
        }
    };
    TableRow1.prototype.queryEventInstanceHeights = function() {
        var segElMap = this.segHarnessRefs.currentMap;
        var eventInstanceHeights = {};
        // get the max height amongst instance segs
        for(var key in segElMap){
            var height = Math.round(segElMap[key].getBoundingClientRect().height);
            var instanceId = key.split(':')[0]; // deconstruct how renderFgSegs makes the key
            eventInstanceHeights[instanceId] = Math.max(eventInstanceHeights[instanceId] || 0, height);
        }
        return eventInstanceHeights;
    };
    TableRow1.prototype.computeMaxContentHeight = function() {
        var firstKey = this.props.cells[0].key;
        var cellEl = this.cellElRefs.currentMap[firstKey];
        var fcContainerEl = this.fgElRefs.currentMap[firstKey];
        return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;
    };
    TableRow1.prototype.getCellEls = function() {
        var elMap = this.cellElRefs.currentMap;
        return this.props.cells.map(function(cell) {
            return elMap[cell.key];
        });
    };
    return TableRow1;
}(_common.DateComponent);
TableRow.addStateEquality({
    eventInstanceHeights: _common.isPropsEqual
});
function buildMirrorPlacements(mirrorSegs, colPlacements) {
    if (!mirrorSegs.length) return [];
    var topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?
    return mirrorSegs.map(function(seg) {
        return {
            seg: seg,
            isVisible: true,
            isAbsolute: true,
            absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],
            marginTop: 0
        };
    });
}
function buildAbsoluteTopHash(colPlacements) {
    var topsByInstanceId = {};
    for(var _i = 0, colPlacements_1 = colPlacements; _i < colPlacements_1.length; _i++){
        var placements = colPlacements_1[_i];
        for(var _a = 0, placements_1 = placements; _a < placements_1.length; _a++){
            var placement = placements_1[_a];
            topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;
        }
    }
    return topsByInstanceId;
}
var Table = /** @class */ function(_super) {
    _tslib.__extends(Table1, _super);
    function Table1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.splitBusinessHourSegs = _common.memoize(splitSegsByRow);
        _this.splitBgEventSegs = _common.memoize(splitSegsByRow);
        _this.splitFgEventSegs = _common.memoize(splitSegsByRow);
        _this.splitDateSelectionSegs = _common.memoize(splitSegsByRow);
        _this.splitEventDrag = _common.memoize(splitInteractionByRow);
        _this.splitEventResize = _common.memoize(splitInteractionByRow);
        _this.rowRefs = new _common.RefMap();
        _this.handleRootEl = function(rootEl) {
            _this.rootEl = rootEl;
            if (rootEl) _this.context.registerInteractiveComponent(_this, {
                el: rootEl,
                isHitComboAllowed: _this.props.isHitComboAllowed
            });
            else _this.context.unregisterInteractiveComponent(_this);
        };
        return _this;
    }
    Table1.prototype.render = function() {
        var _this = this;
        var props = this.props;
        var dateProfile = props.dateProfile, dayMaxEventRows = props.dayMaxEventRows, dayMaxEvents = props.dayMaxEvents, expandRows = props.expandRows;
        var rowCnt = props.cells.length;
        var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);
        var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);
        var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);
        var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);
        var eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);
        var eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);
        var limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;
        // if rows can't expand to fill fixed height, can't do balanced-height event limit
        // TODO: best place to normalize these options?
        if (limitViaBalanced && !expandRows) {
            limitViaBalanced = false;
            dayMaxEventRows = null;
            dayMaxEvents = null;
        }
        var classNames = [
            'fc-daygrid-body',
            limitViaBalanced ? 'fc-daygrid-body-balanced' : 'fc-daygrid-body-unbalanced',
            expandRows ? '' : 'fc-daygrid-body-natural'
        ];
        return _common.createElement("div", {
            className: classNames.join(' '),
            ref: this.handleRootEl,
            style: {
                // these props are important to give this wrapper correct dimensions for interactions
                // TODO: if we set it here, can we avoid giving to inner tables?
                width: props.clientWidth,
                minWidth: props.tableMinWidth
            }
        }, _common.createElement(_common.NowTimer, {
            unit: "day"
        }, function(nowDate, todayRange) {
            return _common.createElement(_common.Fragment, null, _common.createElement("table", {
                role: "presentation",
                className: "fc-scrollgrid-sync-table",
                style: {
                    width: props.clientWidth,
                    minWidth: props.tableMinWidth,
                    height: expandRows ? props.clientHeight : ''
                }
            }, props.colGroupNode, _common.createElement("tbody", {
                role: "presentation"
            }, props.cells.map(function(cells, row) {
                return _common.createElement(TableRow, {
                    ref: _this.rowRefs.createRef(row),
                    key: cells.length ? cells[0].date.toISOString() : row // in case there are no cells (like when resource view is loading)
                    ,
                    showDayNumbers: rowCnt > 1,
                    showWeekNumbers: props.showWeekNumbers,
                    todayRange: todayRange,
                    dateProfile: dateProfile,
                    cells: cells,
                    renderIntro: props.renderRowIntro,
                    businessHourSegs: businessHourSegsByRow[row],
                    eventSelection: props.eventSelection,
                    bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay),
                    fgEventSegs: fgEventSegsByRow[row],
                    dateSelectionSegs: dateSelectionSegsByRow[row],
                    eventDrag: eventDragByRow[row],
                    eventResize: eventResizeByRow[row],
                    dayMaxEvents: dayMaxEvents,
                    dayMaxEventRows: dayMaxEventRows,
                    clientWidth: props.clientWidth,
                    clientHeight: props.clientHeight,
                    forPrint: props.forPrint
                });
            }))));
        }));
    };
    // Hit System
    // ----------------------------------------------------------------------------------------------------
    Table1.prototype.prepareHits = function() {
        this.rowPositions = new _common.PositionCache(this.rootEl, this.rowRefs.collect().map(function(rowObj) {
            return rowObj.getCellEls()[0];
        }), false, true);
        this.colPositions = new _common.PositionCache(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), true, false);
    };
    Table1.prototype.queryHit = function(positionLeft, positionTop) {
        var _a = this, colPositions = _a.colPositions, rowPositions = _a.rowPositions;
        var col = colPositions.leftToIndex(positionLeft);
        var row = rowPositions.topToIndex(positionTop);
        if (row != null && col != null) {
            var cell = this.props.cells[row][col];
            return {
                dateProfile: this.props.dateProfile,
                dateSpan: _tslib.__assign({
                    range: this.getCellRange(row, col),
                    allDay: true
                }, cell.extraDateSpan),
                dayEl: this.getCellEl(row, col),
                rect: {
                    left: colPositions.lefts[col],
                    right: colPositions.rights[col],
                    top: rowPositions.tops[row],
                    bottom: rowPositions.bottoms[row]
                },
                layer: 0
            };
        }
        return null;
    };
    Table1.prototype.getCellEl = function(row, col) {
        return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal
    };
    Table1.prototype.getCellRange = function(row, col) {
        var start = this.props.cells[row][col].date;
        var end = _common.addDays(start, 1);
        return {
            start: start,
            end: end
        };
    };
    return Table1;
}(_common.DateComponent);
function isSegAllDay(seg) {
    return seg.eventRange.def.allDay;
}
var DayTableSlicer = /** @class */ function(_super) {
    _tslib.__extends(DayTableSlicer1, _super);
    function DayTableSlicer1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.forceDayIfListItem = true;
        return _this;
    }
    DayTableSlicer1.prototype.sliceRange = function(dateRange, dayTableModel) {
        return dayTableModel.sliceRange(dateRange);
    };
    return DayTableSlicer1;
}(_common.Slicer);
var DayTable = /** @class */ function(_super) {
    _tslib.__extends(DayTable1, _super);
    function DayTable1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.slicer = new DayTableSlicer();
        _this.tableRef = _common.createRef();
        return _this;
    }
    DayTable1.prototype.render = function() {
        var _a = this, props = _a.props, context = _a.context;
        return _common.createElement(Table, _tslib.__assign({
            ref: this.tableRef
        }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), {
            dateProfile: props.dateProfile,
            cells: props.dayTableModel.cells,
            colGroupNode: props.colGroupNode,
            tableMinWidth: props.tableMinWidth,
            renderRowIntro: props.renderRowIntro,
            dayMaxEvents: props.dayMaxEvents,
            dayMaxEventRows: props.dayMaxEventRows,
            showWeekNumbers: props.showWeekNumbers,
            expandRows: props.expandRows,
            headerAlignElRef: props.headerAlignElRef,
            clientWidth: props.clientWidth,
            clientHeight: props.clientHeight,
            forPrint: props.forPrint
        }));
    };
    return DayTable1;
}(_common.DateComponent);
var DayTableView = /** @class */ function(_super) {
    _tslib.__extends(DayTableView1, _super);
    function DayTableView1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.buildDayTableModel = _common.memoize(buildDayTableModel);
        _this.headerRef = _common.createRef();
        _this.tableRef = _common.createRef();
        return _this;
    }
    DayTableView1.prototype.render = function() {
        var _this = this;
        var _a = this.context, options = _a.options, dateProfileGenerator = _a.dateProfileGenerator;
        var props = this.props;
        var dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);
        var headerContent = options.dayHeaders && _common.createElement(_common.DayHeader, {
            ref: this.headerRef,
            dateProfile: props.dateProfile,
            dates: dayTableModel.headerDates,
            datesRepDistinctDays: dayTableModel.rowCnt === 1
        });
        var bodyContent = function(contentArg) {
            return _common.createElement(DayTable, {
                ref: _this.tableRef,
                dateProfile: props.dateProfile,
                dayTableModel: dayTableModel,
                businessHours: props.businessHours,
                dateSelection: props.dateSelection,
                eventStore: props.eventStore,
                eventUiBases: props.eventUiBases,
                eventSelection: props.eventSelection,
                eventDrag: props.eventDrag,
                eventResize: props.eventResize,
                nextDayThreshold: options.nextDayThreshold,
                colGroupNode: contentArg.tableColGroupNode,
                tableMinWidth: contentArg.tableMinWidth,
                dayMaxEvents: options.dayMaxEvents,
                dayMaxEventRows: options.dayMaxEventRows,
                showWeekNumbers: options.weekNumbers,
                expandRows: !props.isHeightAuto,
                headerAlignElRef: _this.headerElRef,
                clientWidth: contentArg.clientWidth,
                clientHeight: contentArg.clientHeight,
                forPrint: props.forPrint
            });
        };
        return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);
    };
    return DayTableView1;
}(TableView);
function buildDayTableModel(dateProfile, dateProfileGenerator) {
    var daySeries = new _common.DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
    return new _common.DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));
}
var TableDateProfileGenerator = /** @class */ function(_super) {
    _tslib.__extends(TableDateProfileGenerator1, _super);
    function TableDateProfileGenerator1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Computes the date range that will be rendered.
    TableDateProfileGenerator1.prototype.buildRenderRange = function(currentRange, currentRangeUnit, isRangeAllDay) {
        var dateEnv = this.props.dateEnv;
        var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);
        var start = renderRange.start;
        var end = renderRange.end;
        var endOfWeek;
        // year and month views should be aligned with weeks. this is already done for week
        if (/^(year|month)$/.test(currentRangeUnit)) {
            start = dateEnv.startOfWeek(start);
            // make end-of-week if not already
            endOfWeek = dateEnv.startOfWeek(end);
            if (endOfWeek.valueOf() !== end.valueOf()) end = _common.addWeeks(endOfWeek, 1);
        }
        // ensure 6 weeks
        if (this.props.monthMode && this.props.fixedWeekCount) {
            var rowCnt = Math.ceil(_common.diffWeeks(start, end));
            end = _common.addWeeks(end, 6 - rowCnt);
        }
        return {
            start: start,
            end: end
        };
    };
    return TableDateProfileGenerator1;
}(_common.DateProfileGenerator);
var main = _common.createPlugin({
    initialView: 'dayGridMonth',
    views: {
        dayGrid: {
            component: DayTableView,
            dateProfileGeneratorClass: TableDateProfileGenerator
        },
        dayGridDay: {
            type: 'dayGrid',
            duration: {
                days: 1
            }
        },
        dayGridWeek: {
            type: 'dayGrid',
            duration: {
                weeks: 1
            }
        },
        dayGridMonth: {
            type: 'dayGrid',
            duration: {
                months: 1
            },
            monthMode: true,
            fixedWeekCount: true
        }
    }
});
exports.default = main;

},{"./main.css":"3aESi","@fullcalendar/common":"cnjgQ","tslib":"5i9Vz","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"3aESi":[function() {},{}],"7J4yz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaults", ()=>_helpersSegmentJs.d
);
parcelHelpers.export(exports, "Animation", ()=>Animation
);
parcelHelpers.export(exports, "Animations", ()=>Animations
);
parcelHelpers.export(exports, "ArcElement", ()=>ArcElement
);
parcelHelpers.export(exports, "BarController", ()=>BarController
);
parcelHelpers.export(exports, "BarElement", ()=>BarElement
);
parcelHelpers.export(exports, "BasePlatform", ()=>BasePlatform
);
parcelHelpers.export(exports, "BasicPlatform", ()=>BasicPlatform
);
parcelHelpers.export(exports, "BubbleController", ()=>BubbleController
);
parcelHelpers.export(exports, "CategoryScale", ()=>CategoryScale
);
parcelHelpers.export(exports, "Chart", ()=>Chart
);
parcelHelpers.export(exports, "DatasetController", ()=>DatasetController
);
parcelHelpers.export(exports, "Decimation", ()=>plugin_decimation
);
parcelHelpers.export(exports, "DomPlatform", ()=>DomPlatform
);
parcelHelpers.export(exports, "DoughnutController", ()=>DoughnutController
);
parcelHelpers.export(exports, "Element", ()=>Element
);
parcelHelpers.export(exports, "Filler", ()=>plugin_filler
);
parcelHelpers.export(exports, "Interaction", ()=>Interaction
);
parcelHelpers.export(exports, "Legend", ()=>plugin_legend
);
parcelHelpers.export(exports, "LineController", ()=>LineController
);
parcelHelpers.export(exports, "LineElement", ()=>LineElement
);
parcelHelpers.export(exports, "LinearScale", ()=>LinearScale
);
parcelHelpers.export(exports, "LogarithmicScale", ()=>LogarithmicScale
);
parcelHelpers.export(exports, "PieController", ()=>PieController
);
parcelHelpers.export(exports, "PointElement", ()=>PointElement
);
parcelHelpers.export(exports, "PolarAreaController", ()=>PolarAreaController
);
parcelHelpers.export(exports, "RadarController", ()=>RadarController
);
parcelHelpers.export(exports, "RadialLinearScale", ()=>RadialLinearScale
);
parcelHelpers.export(exports, "Scale", ()=>Scale
);
parcelHelpers.export(exports, "ScatterController", ()=>ScatterController
);
parcelHelpers.export(exports, "SubTitle", ()=>plugin_subtitle
);
parcelHelpers.export(exports, "Ticks", ()=>Ticks
);
parcelHelpers.export(exports, "TimeScale", ()=>TimeScale
);
parcelHelpers.export(exports, "TimeSeriesScale", ()=>TimeSeriesScale
);
parcelHelpers.export(exports, "Title", ()=>plugin_title
);
parcelHelpers.export(exports, "Tooltip", ()=>plugin_tooltip
);
parcelHelpers.export(exports, "_adapters", ()=>adapters
);
parcelHelpers.export(exports, "_detectPlatform", ()=>_detectPlatform
);
parcelHelpers.export(exports, "animator", ()=>animator
);
parcelHelpers.export(exports, "controllers", ()=>controllers
);
parcelHelpers.export(exports, "elements", ()=>elements
);
parcelHelpers.export(exports, "layouts", ()=>layouts
);
parcelHelpers.export(exports, "plugins", ()=>plugins
);
parcelHelpers.export(exports, "registerables", ()=>registerables
);
parcelHelpers.export(exports, "registry", ()=>registry
);
parcelHelpers.export(exports, "scales", ()=>scales
);
/*!
 * Chart.js v3.7.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */ var _helpersSegmentJs = require("./chunks/helpers.segment.js");
class Animator {
    _notify(chart, anims, date, type) {
        const callbacks = anims.listeners[type];
        const numSteps = anims.duration;
        callbacks.forEach((fn)=>fn({
                chart,
                initial: anims.initial,
                numSteps,
                currentStep: Math.min(date - anims.start, numSteps)
            })
        );
    }
    _refresh() {
        if (this._request) return;
        this._running = true;
        this._request = _helpersSegmentJs.r.call(window, ()=>{
            this._update();
            this._request = null;
            if (this._running) this._refresh();
        });
    }
    _update(date = Date.now()) {
        let remaining = 0;
        this._charts.forEach((anims, chart)=>{
            if (!anims.running || !anims.items.length) return;
            const items = anims.items;
            let i = items.length - 1;
            let draw1 = false;
            let item;
            for(; i >= 0; --i){
                item = items[i];
                if (item._active) {
                    if (item._total > anims.duration) anims.duration = item._total;
                    item.tick(date);
                    draw1 = true;
                } else {
                    items[i] = items[items.length - 1];
                    items.pop();
                }
            }
            if (draw1) {
                chart.draw();
                this._notify(chart, anims, date, 'progress');
            }
            if (!items.length) {
                anims.running = false;
                this._notify(chart, anims, date, 'complete');
                anims.initial = false;
            }
            remaining += items.length;
        });
        this._lastDate = date;
        if (remaining === 0) this._running = false;
    }
    _getAnims(chart) {
        const charts = this._charts;
        let anims = charts.get(chart);
        if (!anims) {
            anims = {
                running: false,
                initial: true,
                items: [],
                listeners: {
                    complete: [],
                    progress: []
                }
            };
            charts.set(chart, anims);
        }
        return anims;
    }
    listen(chart, event, cb) {
        this._getAnims(chart).listeners[event].push(cb);
    }
    add(chart, items) {
        if (!items || !items.length) return;
        this._getAnims(chart).items.push(...items);
    }
    has(chart) {
        return this._getAnims(chart).items.length > 0;
    }
    start(chart) {
        const anims = this._charts.get(chart);
        if (!anims) return;
        anims.running = true;
        anims.start = Date.now();
        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration)
        , 0);
        this._refresh();
    }
    running(chart) {
        if (!this._running) return false;
        const anims = this._charts.get(chart);
        if (!anims || !anims.running || !anims.items.length) return false;
        return true;
    }
    stop(chart) {
        const anims = this._charts.get(chart);
        if (!anims || !anims.items.length) return;
        const items = anims.items;
        let i = items.length - 1;
        for(; i >= 0; --i)items[i].cancel();
        anims.items = [];
        this._notify(chart, anims, Date.now(), 'complete');
    }
    remove(chart) {
        return this._charts.delete(chart);
    }
    constructor(){
        this._request = null;
        this._charts = new Map();
        this._running = false;
        this._lastDate = undefined;
    }
}
var animator = new Animator();
const transparent = 'transparent';
const interpolators = {
    boolean (from, to, factor) {
        return factor > 0.5 ? to : from;
    },
    color (from, to, factor) {
        const c0 = _helpersSegmentJs.c(from || transparent);
        const c1 = c0.valid && _helpersSegmentJs.c(to || transparent);
        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
    },
    number (from, to, factor) {
        return from + (to - from) * factor;
    }
};
class Animation {
    active() {
        return this._active;
    }
    update(cfg, to, date) {
        if (this._active) {
            this._notify(false);
            const currentValue = this._target[this._prop];
            const elapsed = date - this._start;
            const remain = this._duration - elapsed;
            this._start = date;
            this._duration = Math.floor(Math.max(remain, cfg.duration));
            this._total += elapsed;
            this._loop = !!cfg.loop;
            this._to = _helpersSegmentJs.a([
                cfg.to,
                to,
                currentValue,
                cfg.from
            ]);
            this._from = _helpersSegmentJs.a([
                cfg.from,
                currentValue,
                to
            ]);
        }
    }
    cancel() {
        if (this._active) {
            this.tick(Date.now());
            this._active = false;
            this._notify(false);
        }
    }
    tick(date) {
        const elapsed = date - this._start;
        const duration = this._duration;
        const prop = this._prop;
        const from = this._from;
        const loop = this._loop;
        const to = this._to;
        let factor;
        this._active = from !== to && (loop || elapsed < duration);
        if (!this._active) {
            this._target[prop] = to;
            this._notify(true);
            return;
        }
        if (elapsed < 0) {
            this._target[prop] = from;
            return;
        }
        factor = elapsed / duration % 2;
        factor = loop && factor > 1 ? 2 - factor : factor;
        factor = this._easing(Math.min(1, Math.max(0, factor)));
        this._target[prop] = this._fn(from, to, factor);
    }
    wait() {
        const promises = this._promises || (this._promises = []);
        return new Promise((res, rej)=>{
            promises.push({
                res,
                rej
            });
        });
    }
    _notify(resolved) {
        const method = resolved ? 'res' : 'rej';
        const promises = this._promises || [];
        for(let i = 0; i < promises.length; i++)promises[i][method]();
    }
    constructor(cfg, target, prop, to){
        const currentValue = target[prop];
        to = _helpersSegmentJs.a([
            cfg.to,
            to,
            currentValue,
            cfg.from
        ]);
        const from = _helpersSegmentJs.a([
            cfg.from,
            currentValue,
            to
        ]);
        this._active = true;
        this._fn = cfg.fn || interpolators[cfg.type || typeof from];
        this._easing = _helpersSegmentJs.e[cfg.easing] || _helpersSegmentJs.e.linear;
        this._start = Math.floor(Date.now() + (cfg.delay || 0));
        this._duration = this._total = Math.floor(cfg.duration);
        this._loop = !!cfg.loop;
        this._target = target;
        this._prop = prop;
        this._from = from;
        this._to = to;
        this._promises = undefined;
    }
}
const numbers = [
    'x',
    'y',
    'borderWidth',
    'radius',
    'tension'
];
const colors = [
    'color',
    'borderColor',
    'backgroundColor'
];
_helpersSegmentJs.d.set('animation', {
    delay: undefined,
    duration: 1000,
    easing: 'easeOutQuart',
    fn: undefined,
    from: undefined,
    loop: undefined,
    to: undefined,
    type: undefined
});
const animationOptions = Object.keys(_helpersSegmentJs.d.animation);
_helpersSegmentJs.d.describe('animation', {
    _fallback: false,
    _indexable: false,
    _scriptable: (name)=>name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'
});
_helpersSegmentJs.d.set('animations', {
    colors: {
        type: 'color',
        properties: colors
    },
    numbers: {
        type: 'number',
        properties: numbers
    }
});
_helpersSegmentJs.d.describe('animations', {
    _fallback: 'animation'
});
_helpersSegmentJs.d.set('transitions', {
    active: {
        animation: {
            duration: 400
        }
    },
    resize: {
        animation: {
            duration: 0
        }
    },
    show: {
        animations: {
            colors: {
                from: 'transparent'
            },
            visible: {
                type: 'boolean',
                duration: 0
            }
        }
    },
    hide: {
        animations: {
            colors: {
                to: 'transparent'
            },
            visible: {
                type: 'boolean',
                easing: 'linear',
                fn: (v)=>v | 0
            }
        }
    }
});
class Animations {
    configure(config) {
        if (!_helpersSegmentJs.i(config)) return;
        const animatedProps = this._properties;
        Object.getOwnPropertyNames(config).forEach((key)=>{
            const cfg = config[key];
            if (!_helpersSegmentJs.i(cfg)) return;
            const resolved = {};
            for (const option of animationOptions)resolved[option] = cfg[option];
            (_helpersSegmentJs.b(cfg.properties) && cfg.properties || [
                key
            ]).forEach((prop)=>{
                if (prop === key || !animatedProps.has(prop)) animatedProps.set(prop, resolved);
            });
        });
    }
    _animateOptions(target, values) {
        const newOptions = values.options;
        const options = resolveTargetOptions(target, newOptions);
        if (!options) return [];
        const animations = this._createAnimations(options, newOptions);
        if (newOptions.$shared) awaitAll(target.options.$animations, newOptions).then(()=>{
            target.options = newOptions;
        }, ()=>{});
        return animations;
    }
    _createAnimations(target, values) {
        const animatedProps = this._properties;
        const animations = [];
        const running = target.$animations || (target.$animations = {});
        const props = Object.keys(values);
        const date = Date.now();
        let i;
        for(i = props.length - 1; i >= 0; --i){
            const prop = props[i];
            if (prop.charAt(0) === '$') continue;
            if (prop === 'options') {
                animations.push(...this._animateOptions(target, values));
                continue;
            }
            const value = values[prop];
            let animation = running[prop];
            const cfg = animatedProps.get(prop);
            if (animation) {
                if (cfg && animation.active()) {
                    animation.update(cfg, value, date);
                    continue;
                } else animation.cancel();
            }
            if (!cfg || !cfg.duration) {
                target[prop] = value;
                continue;
            }
            running[prop] = animation = new Animation(cfg, target, prop, value);
            animations.push(animation);
        }
        return animations;
    }
    update(target, values) {
        if (this._properties.size === 0) {
            Object.assign(target, values);
            return;
        }
        const animations = this._createAnimations(target, values);
        if (animations.length) {
            animator.add(this._chart, animations);
            return true;
        }
    }
    constructor(chart, config){
        this._chart = chart;
        this._properties = new Map();
        this.configure(config);
    }
}
function awaitAll(animations, properties) {
    const running = [];
    const keys = Object.keys(properties);
    for(let i = 0; i < keys.length; i++){
        const anim = animations[keys[i]];
        if (anim && anim.active()) running.push(anim.wait());
    }
    return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
    if (!newOptions) return;
    let options = target.options;
    if (!options) {
        target.options = newOptions;
        return;
    }
    if (options.$shared) target.options = options = Object.assign({}, options, {
        $shared: false,
        $animations: {}
    });
    return options;
}
function scaleClip(scale, allowedOverflow) {
    const opts = scale && scale.options || {};
    const reverse = opts.reverse;
    const min = opts.min === undefined ? allowedOverflow : 0;
    const max = opts.max === undefined ? allowedOverflow : 0;
    return {
        start: reverse ? max : min,
        end: reverse ? min : max
    };
}
function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) return false;
    const x = scaleClip(xScale, allowedOverflow);
    const y = scaleClip(yScale, allowedOverflow);
    return {
        top: y.end,
        right: x.end,
        bottom: y.start,
        left: x.start
    };
}
function toClip(value) {
    let t, r, b, l;
    if (_helpersSegmentJs.i(value)) {
        t = value.top;
        r = value.right;
        b = value.bottom;
        l = value.left;
    } else t = r = b = l = value;
    return {
        top: t,
        right: r,
        bottom: b,
        left: l,
        disabled: value === false
    };
}
function getSortedDatasetIndices(chart, filterVisible) {
    const keys = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i, ilen;
    for(i = 0, ilen = metasets.length; i < ilen; ++i)keys.push(metasets[i].index);
    return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
    const keys = stack.keys;
    const singleMode = options.mode === 'single';
    let i, ilen, datasetIndex, otherValue;
    if (value === null) return;
    for(i = 0, ilen = keys.length; i < ilen; ++i){
        datasetIndex = +keys[i];
        if (datasetIndex === dsIndex) {
            if (options.all) continue;
            break;
        }
        otherValue = stack.values[datasetIndex];
        if (_helpersSegmentJs.g(otherValue) && (singleMode || value === 0 || _helpersSegmentJs.s(value) === _helpersSegmentJs.s(otherValue))) value += otherValue;
    }
    return value;
}
function convertObjectDataToArray(data) {
    const keys = Object.keys(data);
    const adata = new Array(keys.length);
    let i, ilen, key;
    for(i = 0, ilen = keys.length; i < ilen; ++i){
        key = keys[i];
        adata[i] = {
            x: key,
            y: data[key]
        };
    }
    return adata;
}
function isStacked(scale, meta) {
    const stacked = scale && scale.options.stacked;
    return stacked || stacked === undefined && meta.stack !== undefined;
}
function getStackKey(indexScale, valueScale, meta) {
    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
    const { min , max , minDefined , maxDefined  } = scale.getUserBounds();
    return {
        min: minDefined ? min : Number.NEGATIVE_INFINITY,
        max: maxDefined ? max : Number.POSITIVE_INFINITY
    };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){
        const value = stack[meta.index];
        if (positive && value > 0 || !positive && value < 0) return meta.index;
    }
    return null;
}
function updateStacks(controller, parsed) {
    const { chart , _cachedMeta: meta  } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale , vScale , index: datasetIndex  } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta);
    const ilen = parsed.length;
    let stack;
    for(let i = 0; i < ilen; ++i){
        const item = parsed[i];
        const { [iAxis]: index , [vAxis]: value  } = item;
        const itemStacks = item._stacks || (item._stacks = {});
        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
        stack[datasetIndex] = value;
        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    }
}
function getFirstScaleId(chart, axis) {
    const scales1 = chart.scales;
    return Object.keys(scales1).filter((key)=>scales1[key].axis === axis
    ).shift();
}
function createDatasetContext(parent, index) {
    return _helpersSegmentJs.h(parent, {
        active: false,
        dataset: undefined,
        datasetIndex: index,
        index,
        mode: 'default',
        type: 'dataset'
    });
}
function createDataContext(parent, index, element) {
    return _helpersSegmentJs.h(parent, {
        active: false,
        dataIndex: index,
        parsed: undefined,
        raw: undefined,
        element,
        index,
        mode: 'default',
        type: 'data'
    });
}
function clearStacks(meta, items) {
    const datasetIndex = meta.controller.index;
    const axis = meta.vScale && meta.vScale.axis;
    if (!axis) return;
    items = items || meta._parsed;
    for (const parsed of items){
        const stacks = parsed._stacks;
        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) return;
        delete stacks[axis][datasetIndex];
    }
}
const isDirectUpdateMode = (mode)=>mode === 'reset' || mode === 'none'
;
const cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached)
;
const createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {
        keys: getSortedDatasetIndices(chart, true),
        values: null
    }
;
class DatasetController {
    initialize() {
        const meta = this._cachedMeta;
        this.configure();
        this.linkScales();
        meta._stacked = isStacked(meta.vScale, meta);
        this.addElements();
    }
    updateIndex(datasetIndex) {
        if (this.index !== datasetIndex) clearStacks(this._cachedMeta);
        this.index = datasetIndex;
    }
    linkScales() {
        const chart = this.chart;
        const meta = this._cachedMeta;
        const dataset = this.getDataset();
        const chooseId = (axis, x, y, r)=>axis === 'x' ? x : axis === 'r' ? r : y
        ;
        const xid = meta.xAxisID = _helpersSegmentJs.v(dataset.xAxisID, getFirstScaleId(chart, 'x'));
        const yid = meta.yAxisID = _helpersSegmentJs.v(dataset.yAxisID, getFirstScaleId(chart, 'y'));
        const rid = meta.rAxisID = _helpersSegmentJs.v(dataset.rAxisID, getFirstScaleId(chart, 'r'));
        const indexAxis = meta.indexAxis;
        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
        meta.xScale = this.getScaleForId(xid);
        meta.yScale = this.getScaleForId(yid);
        meta.rScale = this.getScaleForId(rid);
        meta.iScale = this.getScaleForId(iid);
        meta.vScale = this.getScaleForId(vid);
    }
    getDataset() {
        return this.chart.data.datasets[this.index];
    }
    getMeta() {
        return this.chart.getDatasetMeta(this.index);
    }
    getScaleForId(scaleID) {
        return this.chart.scales[scaleID];
    }
    _getOtherScale(scale) {
        const meta = this._cachedMeta;
        return scale === meta.iScale ? meta.vScale : meta.iScale;
    }
    reset() {
        this._update('reset');
    }
    _destroy() {
        const meta = this._cachedMeta;
        if (this._data) _helpersSegmentJs.u(this._data, this);
        if (meta._stacked) clearStacks(meta);
    }
    _dataCheck() {
        const dataset = this.getDataset();
        const data = dataset.data || (dataset.data = []);
        const _data = this._data;
        if (_helpersSegmentJs.i(data)) this._data = convertObjectDataToArray(data);
        else if (_data !== data) {
            if (_data) {
                _helpersSegmentJs.u(_data, this);
                const meta = this._cachedMeta;
                clearStacks(meta);
                meta._parsed = [];
            }
            if (data && Object.isExtensible(data)) _helpersSegmentJs.l(data, this);
            this._syncList = [];
            this._data = data;
        }
    }
    addElements() {
        const meta = this._cachedMeta;
        this._dataCheck();
        if (this.datasetElementType) meta.dataset = new this.datasetElementType();
    }
    buildOrUpdateElements(resetNewElements) {
        const meta = this._cachedMeta;
        const dataset = this.getDataset();
        let stackChanged = false;
        this._dataCheck();
        const oldStacked = meta._stacked;
        meta._stacked = isStacked(meta.vScale, meta);
        if (meta.stack !== dataset.stack) {
            stackChanged = true;
            clearStacks(meta);
            meta.stack = dataset.stack;
        }
        this._resyncElements(resetNewElements);
        if (stackChanged || oldStacked !== meta._stacked) updateStacks(this, meta._parsed);
    }
    configure() {
        const config = this.chart.config;
        const scopeKeys = config.datasetScopeKeys(this._type);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
        this.options = config.createResolver(scopes, this.getContext());
        this._parsing = this.options.parsing;
        this._cachedDataOpts = {};
    }
    parse(start, count) {
        const { _cachedMeta: meta , _data: data  } = this;
        const { iScale , _stacked  } = meta;
        const iAxis = iScale.axis;
        let sorted = start === 0 && count === data.length ? true : meta._sorted;
        let prev = start > 0 && meta._parsed[start - 1];
        let i, cur, parsed;
        if (this._parsing === false) {
            meta._parsed = data;
            meta._sorted = true;
            parsed = data;
        } else {
            if (_helpersSegmentJs.b(data[start])) parsed = this.parseArrayData(meta, data, start, count);
            else if (_helpersSegmentJs.i(data[start])) parsed = this.parseObjectData(meta, data, start, count);
            else parsed = this.parsePrimitiveData(meta, data, start, count);
            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis]
            ;
            for(i = 0; i < count; ++i){
                meta._parsed[i + start] = cur = parsed[i];
                if (sorted) {
                    if (isNotInOrderComparedToPrev()) sorted = false;
                    prev = cur;
                }
            }
            meta._sorted = sorted;
        }
        if (_stacked) updateStacks(this, parsed);
    }
    parsePrimitiveData(meta, data, start, count) {
        const { iScale , vScale  } = meta;
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const labels = iScale.getLabels();
        const singleScale = iScale === vScale;
        const parsed = new Array(count);
        let i, ilen, index;
        for(i = 0, ilen = count; i < ilen; ++i){
            index = i + start;
            parsed[i] = {
                [iAxis]: singleScale || iScale.parse(labels[index], index),
                [vAxis]: vScale.parse(data[index], index)
            };
        }
        return parsed;
    }
    parseArrayData(meta, data, start, count) {
        const { xScale , yScale  } = meta;
        const parsed = new Array(count);
        let i, ilen, index, item;
        for(i = 0, ilen = count; i < ilen; ++i){
            index = i + start;
            item = data[index];
            parsed[i] = {
                x: xScale.parse(item[0], index),
                y: yScale.parse(item[1], index)
            };
        }
        return parsed;
    }
    parseObjectData(meta, data, start, count) {
        const { xScale , yScale  } = meta;
        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;
        const parsed = new Array(count);
        let i, ilen, index, item;
        for(i = 0, ilen = count; i < ilen; ++i){
            index = i + start;
            item = data[index];
            parsed[i] = {
                x: xScale.parse(_helpersSegmentJs.f(item, xAxisKey), index),
                y: yScale.parse(_helpersSegmentJs.f(item, yAxisKey), index)
            };
        }
        return parsed;
    }
    getParsed(index) {
        return this._cachedMeta._parsed[index];
    }
    getDataElement(index) {
        return this._cachedMeta.data[index];
    }
    applyStack(scale, parsed, mode) {
        const chart = this.chart;
        const meta = this._cachedMeta;
        const value = parsed[scale.axis];
        const stack = {
            keys: getSortedDatasetIndices(chart, true),
            values: parsed._stacks[scale.axis]
        };
        return applyStack(stack, value, meta.index, {
            mode
        });
    }
    updateRangeFromParsed(range, scale, parsed, stack) {
        const parsedValue = parsed[scale.axis];
        let value = parsedValue === null ? NaN : parsedValue;
        const values = stack && parsed._stacks[scale.axis];
        if (stack && values) {
            stack.values = values;
            value = applyStack(stack, parsedValue, this._cachedMeta.index);
        }
        range.min = Math.min(range.min, value);
        range.max = Math.max(range.max, value);
    }
    getMinMax(scale, canStack) {
        const meta = this._cachedMeta;
        const _parsed = meta._parsed;
        const sorted = meta._sorted && scale === meta.iScale;
        const ilen = _parsed.length;
        const otherScale = this._getOtherScale(scale);
        const stack = createStack(canStack, meta, this.chart);
        const range = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
        };
        const { min: otherMin , max: otherMax  } = getUserBounds(otherScale);
        let i, parsed;
        function _skip() {
            parsed = _parsed[i];
            const otherValue = parsed[otherScale.axis];
            return !_helpersSegmentJs.g(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
        }
        for(i = 0; i < ilen; ++i){
            if (_skip()) continue;
            this.updateRangeFromParsed(range, scale, parsed, stack);
            if (sorted) break;
        }
        if (sorted) for(i = ilen - 1; i >= 0; --i){
            if (_skip()) continue;
            this.updateRangeFromParsed(range, scale, parsed, stack);
            break;
        }
        return range;
    }
    getAllParsedValues(scale) {
        const parsed = this._cachedMeta._parsed;
        const values = [];
        let i, ilen, value;
        for(i = 0, ilen = parsed.length; i < ilen; ++i){
            value = parsed[i][scale.axis];
            if (_helpersSegmentJs.g(value)) values.push(value);
        }
        return values;
    }
    getMaxOverflow() {
        return false;
    }
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const vScale = meta.vScale;
        const parsed = this.getParsed(index);
        return {
            label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',
            value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''
        };
    }
    _update(mode) {
        const meta = this._cachedMeta;
        this.update(mode || 'default');
        meta._clip = toClip(_helpersSegmentJs.v(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
    }
    update(mode) {}
    draw() {
        const ctx = this._ctx;
        const chart = this.chart;
        const meta = this._cachedMeta;
        const elements1 = meta.data || [];
        const area = chart.chartArea;
        const active = [];
        const start = this._drawStart || 0;
        const count = this._drawCount || elements1.length - start;
        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
        let i;
        if (meta.dataset) meta.dataset.draw(ctx, area, start, count);
        for(i = start; i < start + count; ++i){
            const element = elements1[i];
            if (element.hidden) continue;
            if (element.active && drawActiveElementsOnTop) active.push(element);
            else element.draw(ctx, area);
        }
        for(i = 0; i < active.length; ++i)active[i].draw(ctx, area);
    }
    getStyle(index, active) {
        const mode = active ? 'active' : 'default';
        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
    }
    getContext(index, active, mode) {
        const dataset = this.getDataset();
        let context;
        if (index >= 0 && index < this._cachedMeta.data.length) {
            const element = this._cachedMeta.data[index];
            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
            context.parsed = this.getParsed(index);
            context.raw = dataset.data[index];
            context.index = context.dataIndex = index;
        } else {
            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
            context.dataset = dataset;
            context.index = context.datasetIndex = this.index;
        }
        context.active = !!active;
        context.mode = mode;
        return context;
    }
    resolveDatasetElementOptions(mode) {
        return this._resolveElementOptions(this.datasetElementType.id, mode);
    }
    resolveDataElementOptions(index, mode) {
        return this._resolveElementOptions(this.dataElementType.id, mode, index);
    }
    _resolveElementOptions(elementType, mode = 'default', index) {
        const active = mode === 'active';
        const cache = this._cachedDataOpts;
        const cacheKey = elementType + '-' + mode;
        const cached = cache[cacheKey];
        const sharing = this.enableOptionSharing && _helpersSegmentJs.j(index);
        if (cached) return cloneIfNotShared(cached, sharing);
        const config = this.chart.config;
        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
        const prefixes = active ? [
            `${elementType}Hover`,
            'hover',
            elementType,
            ''
        ] : [
            elementType,
            ''
        ];
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        const names = Object.keys(_helpersSegmentJs.d.elements[elementType]);
        const context = ()=>this.getContext(index, active)
        ;
        const values = config.resolveNamedOptions(scopes, names, context, prefixes);
        if (values.$shared) {
            values.$shared = sharing;
            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
        }
        return values;
    }
    _resolveAnimations(index, transition, active) {
        const chart = this.chart;
        const cache = this._cachedDataOpts;
        const cacheKey = `animation-${transition}`;
        const cached = cache[cacheKey];
        if (cached) return cached;
        let options;
        if (chart.options.animation !== false) {
            const config = this.chart.config;
            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
            options = config.createResolver(scopes, this.getContext(index, active, transition));
        }
        const animations = new Animations(chart, options && options.animations);
        if (options && options._cacheable) cache[cacheKey] = Object.freeze(animations);
        return animations;
    }
    getSharedOptions(options) {
        if (!options.$shared) return;
        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
    }
    includeOptions(mode, sharedOptions) {
        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
    }
    updateElement(element, index, properties, mode) {
        if (isDirectUpdateMode(mode)) Object.assign(element, properties);
        else this._resolveAnimations(index, mode).update(element, properties);
    }
    updateSharedOptions(sharedOptions, mode, newOptions) {
        if (sharedOptions && !isDirectUpdateMode(mode)) this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);
    }
    _setStyle(element, index, mode, active) {
        element.active = active;
        const options = this.getStyle(index, active);
        this._resolveAnimations(index, mode, active).update(element, {
            options: !active && this.getSharedOptions(options) || options
        });
    }
    removeHoverStyle(element, datasetIndex, index) {
        this._setStyle(element, index, 'active', false);
    }
    setHoverStyle(element, datasetIndex, index) {
        this._setStyle(element, index, 'active', true);
    }
    _removeDatasetHoverStyle() {
        const element = this._cachedMeta.dataset;
        if (element) this._setStyle(element, undefined, 'active', false);
    }
    _setDatasetHoverStyle() {
        const element = this._cachedMeta.dataset;
        if (element) this._setStyle(element, undefined, 'active', true);
    }
    _resyncElements(resetNewElements) {
        const data = this._data;
        const elements2 = this._cachedMeta.data;
        for (const [method, arg1, arg2] of this._syncList)this[method](arg1, arg2);
        this._syncList = [];
        const numMeta = elements2.length;
        const numData = data.length;
        const count = Math.min(numData, numMeta);
        if (count) this.parse(0, count);
        if (numData > numMeta) this._insertElements(numMeta, numData - numMeta, resetNewElements);
        else if (numData < numMeta) this._removeElements(numData, numMeta - numData);
    }
    _insertElements(start, count, resetNewElements = true) {
        const meta = this._cachedMeta;
        const data = meta.data;
        const end = start + count;
        let i;
        const move = (arr)=>{
            arr.length += count;
            for(i = arr.length - 1; i >= end; i--)arr[i] = arr[i - count];
        };
        move(data);
        for(i = start; i < end; ++i)data[i] = new this.dataElementType();
        if (this._parsing) move(meta._parsed);
        this.parse(start, count);
        if (resetNewElements) this.updateElements(data, start, count, 'reset');
    }
    updateElements(element, start, count, mode) {}
    _removeElements(start, count) {
        const meta = this._cachedMeta;
        if (this._parsing) {
            const removed = meta._parsed.splice(start, count);
            if (meta._stacked) clearStacks(meta, removed);
        }
        meta.data.splice(start, count);
    }
    _sync(args) {
        if (this._parsing) this._syncList.push(args);
        else {
            const [method, arg1, arg2] = args;
            this[method](arg1, arg2);
        }
        this.chart._dataChanges.push([
            this.index,
            ...args
        ]);
    }
    _onDataPush() {
        const count = arguments.length;
        this._sync([
            '_insertElements',
            this.getDataset().data.length - count,
            count
        ]);
    }
    _onDataPop() {
        this._sync([
            '_removeElements',
            this._cachedMeta.data.length - 1,
            1
        ]);
    }
    _onDataShift() {
        this._sync([
            '_removeElements',
            0,
            1
        ]);
    }
    _onDataSplice(start, count) {
        if (count) this._sync([
            '_removeElements',
            start,
            count
        ]);
        const newCount = arguments.length - 2;
        if (newCount) this._sync([
            '_insertElements',
            start,
            newCount
        ]);
    }
    _onDataUnshift() {
        this._sync([
            '_insertElements',
            0,
            arguments.length
        ]);
    }
    constructor(chart, datasetIndex){
        this.chart = chart;
        this._ctx = chart.ctx;
        this.index = datasetIndex;
        this._cachedDataOpts = {};
        this._cachedMeta = this.getMeta();
        this._type = this._cachedMeta.type;
        this.options = undefined;
        this._parsing = false;
        this._data = undefined;
        this._objectData = undefined;
        this._sharedOptions = undefined;
        this._drawStart = undefined;
        this._drawCount = undefined;
        this.enableOptionSharing = false;
        this.$context = undefined;
        this._syncList = [];
        this.initialize();
    }
}
DatasetController.defaults = {};
DatasetController.prototype.datasetElementType = null;
DatasetController.prototype.dataElementType = null;
function getAllScaleValues(scale, type) {
    if (!scale._cache.$bar) {
        const visibleMetas = scale.getMatchingVisibleMetas(type);
        let values = [];
        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++)values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
        scale._cache.$bar = _helpersSegmentJs._(values.sort((a, b)=>a - b
        ));
    }
    return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
    const scale = meta.iScale;
    const values = getAllScaleValues(scale, meta.type);
    let min = scale._length;
    let i, ilen, curr, prev;
    const updateMinAndPrev = ()=>{
        if (curr === 32767 || curr === -32768) return;
        if (_helpersSegmentJs.j(prev)) min = Math.min(min, Math.abs(curr - prev) || min);
        prev = curr;
    };
    for(i = 0, ilen = values.length; i < ilen; ++i){
        curr = scale.getPixelForValue(values[i]);
        updateMinAndPrev();
    }
    prev = undefined;
    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){
        curr = scale.getPixelForTick(i);
        updateMinAndPrev();
    }
    return min;
}
function computeFitCategoryTraits(index, ruler, options, stackCount) {
    const thickness = options.barThickness;
    let size, ratio;
    if (_helpersSegmentJs.k(thickness)) {
        size = ruler.min * options.categoryPercentage;
        ratio = options.barPercentage;
    } else {
        size = thickness * stackCount;
        ratio = 1;
    }
    return {
        chunk: size / stackCount,
        ratio,
        start: ruler.pixels[index] - size / 2
    };
}
function computeFlexCategoryTraits(index, ruler, options, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index];
    let prev = index > 0 ? pixels[index - 1] : null;
    let next = index < pixels.length - 1 ? pixels[index + 1] : null;
    const percent = options.categoryPercentage;
    if (prev === null) prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    if (next === null) next = curr + curr - prev;
    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
    const size = Math.abs(next - prev) / 2 * percent;
    return {
        chunk: size / stackCount,
        ratio: options.barPercentage,
        start
    };
}
function parseFloatBar(entry, item, vScale, i) {
    const startValue = vScale.parse(entry[0], i);
    const endValue = vScale.parse(entry[1], i);
    const min = Math.min(startValue, endValue);
    const max = Math.max(startValue, endValue);
    let barStart = min;
    let barEnd = max;
    if (Math.abs(min) > Math.abs(max)) {
        barStart = max;
        barEnd = min;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
        barStart,
        barEnd,
        start: startValue,
        end: endValue,
        min,
        max
    };
}
function parseValue(entry, item, vScale, i) {
    if (_helpersSegmentJs.b(entry)) parseFloatBar(entry, item, vScale, i);
    else item[vScale.axis] = vScale.parse(entry, i);
    return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i, ilen, item, entry;
    for(i = start, ilen = start + count; i < ilen; ++i){
        entry = data[i];
        item = {};
        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
        parsed.push(parseValue(entry, item, vScale, i));
    }
    return parsed;
}
function isFloatBar(custom) {
    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;
}
function barSign(size, vScale, actualBase) {
    if (size !== 0) return _helpersSegmentJs.s(size);
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
    let reverse, start, end, top, bottom;
    if (properties.horizontal) {
        reverse = properties.base > properties.x;
        start = 'left';
        end = 'right';
    } else {
        reverse = properties.base < properties.y;
        start = 'bottom';
        end = 'top';
    }
    if (reverse) {
        top = 'end';
        bottom = 'start';
    } else {
        top = 'start';
        bottom = 'end';
    }
    return {
        start,
        end,
        reverse,
        top,
        bottom
    };
}
function setBorderSkipped(properties, options, stack, index) {
    let edge = options.borderSkipped;
    const res = {};
    if (!edge) {
        properties.borderSkipped = res;
        return;
    }
    const { start , end , reverse , top , bottom  } = borderProps(properties);
    if (edge === 'middle' && stack) {
        properties.enableBorderRadius = true;
        if ((stack._top || 0) === index) edge = top;
        else if ((stack._bottom || 0) === index) edge = bottom;
        else {
            res[parseEdge(bottom, start, end, reverse)] = true;
            edge = top;
        }
    }
    res[parseEdge(edge, start, end, reverse)] = true;
    properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
    if (reverse) {
        edge = swap(edge, a, b);
        edge = startEnd(edge, b, a);
    } else edge = startEnd(edge, a, b);
    return edge;
}
function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
    return v === 'start' ? start : v === 'end' ? end : v;
}
function setInflateAmount(properties, { inflateAmount  }, ratio) {
    properties.inflateAmount = inflateAmount === 'auto' ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
class BarController extends DatasetController {
    parsePrimitiveData(meta, data, start, count) {
        return parseArrayOrPrimitive(meta, data, start, count);
    }
    parseArrayData(meta, data, start, count) {
        return parseArrayOrPrimitive(meta, data, start, count);
    }
    parseObjectData(meta, data, start, count) {
        const { iScale , vScale  } = meta;
        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;
        const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;
        const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;
        const parsed = [];
        let i, ilen, item, obj;
        for(i = start, ilen = start + count; i < ilen; ++i){
            obj = data[i];
            item = {};
            item[iScale.axis] = iScale.parse(_helpersSegmentJs.f(obj, iAxisKey), i);
            parsed.push(parseValue(_helpersSegmentJs.f(obj, vAxisKey), item, vScale, i));
        }
        return parsed;
    }
    updateRangeFromParsed(range, scale, parsed, stack) {
        super.updateRangeFromParsed(range, scale, parsed, stack);
        const custom = parsed._custom;
        if (custom && scale === this._cachedMeta.vScale) {
            range.min = Math.min(range.min, custom.min);
            range.max = Math.max(range.max, custom.max);
        }
    }
    getMaxOverflow() {
        return 0;
    }
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const { iScale , vScale  } = meta;
        const parsed = this.getParsed(index);
        const custom = parsed._custom;
        const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);
        return {
            label: '' + iScale.getLabelForValue(parsed[iScale.axis]),
            value
        };
    }
    initialize() {
        this.enableOptionSharing = true;
        super.initialize();
        const meta = this._cachedMeta;
        meta.stack = this.getDataset().stack;
    }
    update(mode) {
        const meta = this._cachedMeta;
        this.updateElements(meta.data, 0, meta.data.length, mode);
    }
    updateElements(bars, start, count, mode) {
        const reset = mode === 'reset';
        const { index , _cachedMeta: { vScale  }  } = this;
        const base = vScale.getBasePixel();
        const horizontal = vScale.isHorizontal();
        const ruler = this._getRuler();
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions);
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
        for(let i = start; i < start + count; i++){
            const parsed = this.getParsed(i);
            const vpixels = reset || _helpersSegmentJs.k(parsed[vScale.axis]) ? {
                base,
                head: base
            } : this._calculateBarValuePixels(i);
            const ipixels = this._calculateBarIndexPixels(i, ruler);
            const stack = (parsed._stacks || {})[vScale.axis];
            const properties = {
                horizontal,
                base: vpixels.base,
                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,
                x: horizontal ? vpixels.head : ipixels.center,
                y: horizontal ? ipixels.center : vpixels.head,
                height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                width: horizontal ? Math.abs(vpixels.size) : ipixels.size
            };
            if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);
            const options = properties.options || bars[i].options;
            setBorderSkipped(properties, options, stack, index);
            setInflateAmount(properties, options, ruler.ratio);
            this.updateElement(bars[i], i, properties, mode);
        }
    }
    _getStacks(last, dataIndex) {
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const metasets = iScale.getMatchingVisibleMetas(this._type);
        const stacked = iScale.options.stacked;
        const ilen = metasets.length;
        const stacks = [];
        let i, item;
        for(i = 0; i < ilen; ++i){
            item = metasets[i];
            if (!item.controller.options.grouped) continue;
            if (typeof dataIndex !== 'undefined') {
                const val = item.controller.getParsed(dataIndex)[item.controller._cachedMeta.vScale.axis];
                if (_helpersSegmentJs.k(val) || isNaN(val)) continue;
            }
            if (stacked === false || stacks.indexOf(item.stack) === -1 || stacked === undefined && item.stack === undefined) stacks.push(item.stack);
            if (item.index === last) break;
        }
        if (!stacks.length) stacks.push(undefined);
        return stacks;
    }
    _getStackCount(index) {
        return this._getStacks(undefined, index).length;
    }
    _getStackIndex(datasetIndex, name, dataIndex) {
        const stacks = this._getStacks(datasetIndex, dataIndex);
        const index = name !== undefined ? stacks.indexOf(name) : -1;
        return index === -1 ? stacks.length - 1 : index;
    }
    _getRuler() {
        const opts = this.options;
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const pixels = [];
        let i, ilen;
        for(i = 0, ilen = meta.data.length; i < ilen; ++i)pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
        const barThickness = opts.barThickness;
        const min = barThickness || computeMinSampleSize(meta);
        return {
            min,
            pixels,
            start: iScale._startPixel,
            end: iScale._endPixel,
            stackCount: this._getStackCount(),
            scale: iScale,
            grouped: opts.grouped,
            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
        };
    }
    _calculateBarValuePixels(index) {
        const { _cachedMeta: { vScale , _stacked  } , options: { base: baseValue , minBarLength  }  } = this;
        const actualBase = baseValue || 0;
        const parsed = this.getParsed(index);
        const custom = parsed._custom;
        const floating = isFloatBar(custom);
        let value = parsed[vScale.axis];
        let start = 0;
        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
        let head, size;
        if (length !== value) {
            start = length - value;
            length = value;
        }
        if (floating) {
            value = custom.barStart;
            length = custom.barEnd - custom.barStart;
            if (value !== 0 && _helpersSegmentJs.s(value) !== _helpersSegmentJs.s(custom.barEnd)) start = 0;
            start += value;
        }
        const startValue = !_helpersSegmentJs.k(baseValue) && !floating ? baseValue : start;
        let base = vScale.getPixelForValue(startValue);
        if (this.chart.getDataVisibility(index)) head = vScale.getPixelForValue(start + length);
        else head = base;
        size = head - base;
        if (Math.abs(size) < minBarLength) {
            size = barSign(size, vScale, actualBase) * minBarLength;
            if (value === actualBase) base -= size / 2;
            head = base + size;
        }
        if (base === vScale.getPixelForValue(actualBase)) {
            const halfGrid = _helpersSegmentJs.s(size) * vScale.getLineWidthForValue(actualBase) / 2;
            base += halfGrid;
            size -= halfGrid;
        }
        return {
            size,
            base,
            head,
            center: head + size / 2
        };
    }
    _calculateBarIndexPixels(index, ruler) {
        const scale = ruler.scale;
        const options = this.options;
        const skipNull = options.skipNull;
        const maxBarThickness = _helpersSegmentJs.v(options.maxBarThickness, Infinity);
        let center, size;
        if (ruler.grouped) {
            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
            const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);
            center = range.start + range.chunk * stackIndex + range.chunk / 2;
            size = Math.min(maxBarThickness, range.chunk * range.ratio);
        } else {
            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
        }
        return {
            base: center - size / 2,
            head: center + size / 2,
            center,
            size
        };
    }
    draw() {
        const meta = this._cachedMeta;
        const vScale = meta.vScale;
        const rects = meta.data;
        const ilen = rects.length;
        let i = 0;
        for(; i < ilen; ++i)if (this.getParsed(i)[vScale.axis] !== null) rects[i].draw(this._ctx);
    }
}
BarController.id = 'bar';
BarController.defaults = {
    datasetElementType: false,
    dataElementType: 'bar',
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: true,
    animations: {
        numbers: {
            type: 'number',
            properties: [
                'x',
                'y',
                'base',
                'width',
                'height'
            ]
        }
    }
};
BarController.overrides = {
    scales: {
        _index_: {
            type: 'category',
            offset: true,
            grid: {
                offset: true
            }
        },
        _value_: {
            type: 'linear',
            beginAtZero: true
        }
    }
};
class BubbleController extends DatasetController {
    initialize() {
        this.enableOptionSharing = true;
        super.initialize();
    }
    parsePrimitiveData(meta, data, start, count) {
        const parsed = super.parsePrimitiveData(meta, data, start, count);
        for(let i = 0; i < parsed.length; i++)parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
        return parsed;
    }
    parseArrayData(meta, data, start, count) {
        const parsed = super.parseArrayData(meta, data, start, count);
        for(let i = 0; i < parsed.length; i++){
            const item = data[start + i];
            parsed[i]._custom = _helpersSegmentJs.v(item[2], this.resolveDataElementOptions(i + start).radius);
        }
        return parsed;
    }
    parseObjectData(meta, data, start, count) {
        const parsed = super.parseObjectData(meta, data, start, count);
        for(let i = 0; i < parsed.length; i++){
            const item = data[start + i];
            parsed[i]._custom = _helpersSegmentJs.v(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
        }
        return parsed;
    }
    getMaxOverflow() {
        const data = this._cachedMeta.data;
        let max = 0;
        for(let i = data.length - 1; i >= 0; --i)max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
        return max > 0 && max;
    }
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const { xScale , yScale  } = meta;
        const parsed = this.getParsed(index);
        const x = xScale.getLabelForValue(parsed.x);
        const y = yScale.getLabelForValue(parsed.y);
        const r = parsed._custom;
        return {
            label: meta.label,
            value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'
        };
    }
    update(mode) {
        const points = this._cachedMeta.data;
        this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start, count, mode) {
        const reset = mode === 'reset';
        const { iScale , vScale  } = this._cachedMeta;
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        for(let i = start; i < start + count; i++){
            const point = points[i];
            const parsed = !reset && this.getParsed(i);
            const properties = {};
            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
            properties.skip = isNaN(iPixel) || isNaN(vPixel);
            if (includeOptions) {
                properties.options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);
                if (reset) properties.options.radius = 0;
            }
            this.updateElement(point, i, properties, mode);
        }
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
    }
    resolveDataElementOptions(index, mode) {
        const parsed = this.getParsed(index);
        let values = super.resolveDataElementOptions(index, mode);
        if (values.$shared) values = Object.assign({}, values, {
            $shared: false
        });
        const radius = values.radius;
        if (mode !== 'active') values.radius = 0;
        values.radius += _helpersSegmentJs.v(parsed && parsed._custom, radius);
        return values;
    }
}
BubbleController.id = 'bubble';
BubbleController.defaults = {
    datasetElementType: false,
    dataElementType: 'point',
    animations: {
        numbers: {
            type: 'number',
            properties: [
                'x',
                'y',
                'borderWidth',
                'radius'
            ]
        }
    }
};
BubbleController.overrides = {
    scales: {
        x: {
            type: 'linear'
        },
        y: {
            type: 'linear'
        }
    },
    plugins: {
        tooltip: {
            callbacks: {
                title () {
                    return '';
                }
            }
        }
    }
};
function getRatioAndOffset(rotation, circumference, cutout) {
    let ratioX = 1;
    let ratioY = 1;
    let offsetX = 0;
    let offsetY = 0;
    if (circumference < _helpersSegmentJs.T) {
        const startAngle = rotation;
        const endAngle = startAngle + circumference;
        const startX = Math.cos(startAngle);
        const startY = Math.sin(startAngle);
        const endX = Math.cos(endAngle);
        const endY = Math.sin(endAngle);
        const calcMax = (angle, a, b)=>_helpersSegmentJs.p(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout)
        ;
        const calcMin = (angle, a, b)=>_helpersSegmentJs.p(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout)
        ;
        const maxX = calcMax(0, startX, endX);
        const maxY = calcMax(_helpersSegmentJs.H, startY, endY);
        const minX = calcMin(_helpersSegmentJs.P, startX, endX);
        const minY = calcMin(_helpersSegmentJs.P + _helpersSegmentJs.H, startY, endY);
        ratioX = (maxX - minX) / 2;
        ratioY = (maxY - minY) / 2;
        offsetX = -(maxX + minX) / 2;
        offsetY = -(maxY + minY) / 2;
    }
    return {
        ratioX,
        ratioY,
        offsetX,
        offsetY
    };
}
class DoughnutController extends DatasetController {
    linkScales() {}
    parse(start, count) {
        const data = this.getDataset().data;
        const meta = this._cachedMeta;
        if (this._parsing === false) meta._parsed = data;
        else {
            let getter = (i)=>+data[i]
            ;
            if (_helpersSegmentJs.i(data[start])) {
                const { key ='value'  } = this._parsing;
                getter = (i)=>+_helpersSegmentJs.f(data[i], key)
                ;
            }
            let i1, ilen;
            for(i1 = start, ilen = start + count; i1 < ilen; ++i1)meta._parsed[i1] = getter(i1);
        }
    }
    _getRotation() {
        return _helpersSegmentJs.t(this.options.rotation - 90);
    }
    _getCircumference() {
        return _helpersSegmentJs.t(this.options.circumference);
    }
    _getRotationExtents() {
        let min = _helpersSegmentJs.T;
        let max = -_helpersSegmentJs.T;
        for(let i = 0; i < this.chart.data.datasets.length; ++i)if (this.chart.isDatasetVisible(i)) {
            const controller = this.chart.getDatasetMeta(i).controller;
            const rotation = controller._getRotation();
            const circumference = controller._getCircumference();
            min = Math.min(min, rotation);
            max = Math.max(max, rotation + circumference);
        }
        return {
            rotation: min,
            circumference: max - min
        };
    }
    update(mode) {
        const chart = this.chart;
        const { chartArea  } = chart;
        const meta = this._cachedMeta;
        const arcs = meta.data;
        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
        const cutout = Math.min(_helpersSegmentJs.m(this.options.cutout, maxSize), 1);
        const chartWeight = this._getRingWeight(this.index);
        const { circumference , rotation  } = this._getRotationExtents();
        const { ratioX , ratioY , offsetX , offsetY  } = getRatioAndOffset(rotation, circumference, cutout);
        const maxWidth = (chartArea.width - spacing) / ratioX;
        const maxHeight = (chartArea.height - spacing) / ratioY;
        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
        const outerRadius = _helpersSegmentJs.n(this.options.radius, maxRadius);
        const innerRadius = Math.max(outerRadius * cutout, 0);
        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
        this.offsetX = offsetX * outerRadius;
        this.offsetY = offsetY * outerRadius;
        meta.total = this.calculateTotal();
        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
        this.updateElements(arcs, 0, arcs.length, mode);
    }
    _circumference(i, reset) {
        const opts = this.options;
        const meta = this._cachedMeta;
        const circumference = this._getCircumference();
        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) return 0;
        return this.calculateCircumference(meta._parsed[i] * circumference / _helpersSegmentJs.T);
    }
    updateElements(arcs, start, count, mode) {
        const reset = mode === 'reset';
        const chart = this.chart;
        const chartArea = chart.chartArea;
        const opts = chart.options;
        const animationOpts = opts.animation;
        const centerX = (chartArea.left + chartArea.right) / 2;
        const centerY = (chartArea.top + chartArea.bottom) / 2;
        const animateScale = reset && animationOpts.animateScale;
        const innerRadius = animateScale ? 0 : this.innerRadius;
        const outerRadius = animateScale ? 0 : this.outerRadius;
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions);
        let startAngle = this._getRotation();
        let i;
        for(i = 0; i < start; ++i)startAngle += this._circumference(i, reset);
        for(i = start; i < start + count; ++i){
            const circumference = this._circumference(i, reset);
            const arc = arcs[i];
            const properties = {
                x: centerX + this.offsetX,
                y: centerY + this.offsetY,
                startAngle,
                endAngle: startAngle + circumference,
                circumference,
                outerRadius,
                innerRadius
            };
            if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);
            startAngle += circumference;
            this.updateElement(arc, i, properties, mode);
        }
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
    }
    calculateTotal() {
        const meta = this._cachedMeta;
        const metaData = meta.data;
        let total = 0;
        let i;
        for(i = 0; i < metaData.length; i++){
            const value = meta._parsed[i];
            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) total += Math.abs(value);
        }
        return total;
    }
    calculateCircumference(value) {
        const total = this._cachedMeta.total;
        if (total > 0 && !isNaN(value)) return _helpersSegmentJs.T * (Math.abs(value) / total);
        return 0;
    }
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const chart = this.chart;
        const labels = chart.data.labels || [];
        const value = _helpersSegmentJs.o(meta._parsed[index], chart.options.locale);
        return {
            label: labels[index] || '',
            value
        };
    }
    getMaxBorderWidth(arcs) {
        let max = 0;
        const chart = this.chart;
        let i, ilen, meta, controller, options;
        if (!arcs) {
            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i)if (chart.isDatasetVisible(i)) {
                meta = chart.getDatasetMeta(i);
                arcs = meta.data;
                controller = meta.controller;
                break;
            }
        }
        if (!arcs) return 0;
        for(i = 0, ilen = arcs.length; i < ilen; ++i){
            options = controller.resolveDataElementOptions(i);
            if (options.borderAlign !== 'inner') max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
        }
        return max;
    }
    getMaxOffset(arcs) {
        let max = 0;
        for(let i = 0, ilen = arcs.length; i < ilen; ++i){
            const options = this.resolveDataElementOptions(i);
            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
        }
        return max;
    }
    _getRingWeightOffset(datasetIndex) {
        let ringWeightOffset = 0;
        for(let i = 0; i < datasetIndex; ++i)if (this.chart.isDatasetVisible(i)) ringWeightOffset += this._getRingWeight(i);
        return ringWeightOffset;
    }
    _getRingWeight(datasetIndex) {
        return Math.max(_helpersSegmentJs.v(this.chart.data.datasets[datasetIndex].weight, 1), 0);
    }
    _getVisibleDatasetWeightTotal() {
        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
    constructor(chart, datasetIndex){
        super(chart, datasetIndex);
        this.enableOptionSharing = true;
        this.innerRadius = undefined;
        this.outerRadius = undefined;
        this.offsetX = undefined;
        this.offsetY = undefined;
    }
}
DoughnutController.id = 'doughnut';
DoughnutController.defaults = {
    datasetElementType: false,
    dataElementType: 'arc',
    animation: {
        animateRotate: true,
        animateScale: false
    },
    animations: {
        numbers: {
            type: 'number',
            properties: [
                'circumference',
                'endAngle',
                'innerRadius',
                'outerRadius',
                'startAngle',
                'x',
                'y',
                'offset',
                'borderWidth',
                'spacing'
            ]
        }
    },
    cutout: '50%',
    rotation: 0,
    circumference: 360,
    radius: '100%',
    spacing: 0,
    indexAxis: 'r'
};
DoughnutController.descriptors = {
    _scriptable: (name)=>name !== 'spacing'
    ,
    _indexable: (name)=>name !== 'spacing'
};
DoughnutController.overrides = {
    aspectRatio: 1,
    plugins: {
        legend: {
            labels: {
                generateLabels (chart) {
                    const data = chart.data;
                    if (data.labels.length && data.datasets.length) {
                        const { labels: { pointStyle  }  } = chart.legend.options;
                        return data.labels.map((label, i)=>{
                            const meta = chart.getDatasetMeta(0);
                            const style = meta.controller.getStyle(i);
                            return {
                                text: label,
                                fillStyle: style.backgroundColor,
                                strokeStyle: style.borderColor,
                                lineWidth: style.borderWidth,
                                pointStyle: pointStyle,
                                hidden: !chart.getDataVisibility(i),
                                index: i
                            };
                        });
                    }
                    return [];
                }
            },
            onClick (e, legendItem, legend) {
                legend.chart.toggleDataVisibility(legendItem.index);
                legend.chart.update();
            }
        },
        tooltip: {
            callbacks: {
                title () {
                    return '';
                },
                label (tooltipItem) {
                    let dataLabel = tooltipItem.label;
                    const value = ': ' + tooltipItem.formattedValue;
                    if (_helpersSegmentJs.b(dataLabel)) {
                        dataLabel = dataLabel.slice();
                        dataLabel[0] += value;
                    } else dataLabel += value;
                    return dataLabel;
                }
            }
        }
    }
};
class LineController extends DatasetController {
    initialize() {
        this.enableOptionSharing = true;
        super.initialize();
    }
    update(mode) {
        const meta = this._cachedMeta;
        const { dataset: line , data: points = [] , _dataset  } = meta;
        const animationsDisabled = this.chart._animationsDisabled;
        let { start , count  } = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
        this._drawStart = start;
        this._drawCount = count;
        if (scaleRangesChanged(meta)) {
            start = 0;
            count = points.length;
        }
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) options.borderWidth = 0;
        options.segment = this.options.segment;
        this.updateElement(line, undefined, {
            animated: !animationsDisabled,
            options
        }, mode);
        this.updateElements(points, start, count, mode);
    }
    updateElements(points, start, count, mode) {
        const reset = mode === 'reset';
        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const { spanGaps , segment  } = this.options;
        const maxGapLength = _helpersSegmentJs.q(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
        let prevParsed = start > 0 && this.getParsed(start - 1);
        for(let i = start; i < start + count; ++i){
            const point = points[i];
            const parsed = this.getParsed(i);
            const properties = directUpdate ? point : {};
            const nullData = _helpersSegmentJs.k(parsed[vAxis]);
            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
            properties.stop = i > 0 && parsed[iAxis] - prevParsed[iAxis] > maxGapLength;
            if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
            }
            if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
            if (!directUpdate) this.updateElement(point, i, properties, mode);
            prevParsed = parsed;
        }
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
    }
    getMaxOverflow() {
        const meta = this._cachedMeta;
        const dataset = meta.dataset;
        const border = dataset.options && dataset.options.borderWidth || 0;
        const data = meta.data || [];
        if (!data.length) return border;
        const firstPoint = data[0].size(this.resolveDataElementOptions(0));
        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
        return Math.max(border, firstPoint, lastPoint) / 2;
    }
    draw() {
        const meta = this._cachedMeta;
        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
        super.draw();
    }
}
LineController.id = 'line';
LineController.defaults = {
    datasetElementType: 'line',
    dataElementType: 'point',
    showLine: true,
    spanGaps: false
};
LineController.overrides = {
    scales: {
        _index_: {
            type: 'category'
        },
        _value_: {
            type: 'linear'
        }
    }
};
function getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
    const pointCount = points.length;
    let start = 0;
    let count = pointCount;
    if (meta._sorted) {
        const { iScale , _parsed  } = meta;
        const axis = iScale.axis;
        const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();
        if (minDefined) start = _helpersSegmentJs.w(Math.min(_helpersSegmentJs.x(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _helpersSegmentJs.x(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
        if (maxDefined) count = _helpersSegmentJs.w(Math.max(_helpersSegmentJs.x(_parsed, iScale.axis, max).hi + 1, animationsDisabled ? 0 : _helpersSegmentJs.x(points, axis, iScale.getPixelForValue(max)).hi + 1), start, pointCount) - start;
        else count = pointCount - start;
    }
    return {
        start,
        count
    };
}
function scaleRangesChanged(meta) {
    const { xScale , yScale , _scaleRanges  } = meta;
    const newRanges = {
        xmin: xScale.min,
        xmax: xScale.max,
        ymin: yScale.min,
        ymax: yScale.max
    };
    if (!_scaleRanges) {
        meta._scaleRanges = newRanges;
        return true;
    }
    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
}
class PolarAreaController extends DatasetController {
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const chart = this.chart;
        const labels = chart.data.labels || [];
        const value = _helpersSegmentJs.o(meta._parsed[index].r, chart.options.locale);
        return {
            label: labels[index] || '',
            value
        };
    }
    update(mode) {
        const arcs = this._cachedMeta.data;
        this._updateRadius();
        this.updateElements(arcs, 0, arcs.length, mode);
    }
    _updateRadius() {
        const chart = this.chart;
        const chartArea = chart.chartArea;
        const opts = chart.options;
        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
        const outerRadius = Math.max(minSize / 2, 0);
        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
        this.outerRadius = outerRadius - radiusLength * this.index;
        this.innerRadius = this.outerRadius - radiusLength;
    }
    updateElements(arcs, start, count, mode) {
        const reset = mode === 'reset';
        const chart = this.chart;
        const dataset = this.getDataset();
        const opts = chart.options;
        const animationOpts = opts.animation;
        const scale = this._cachedMeta.rScale;
        const centerX = scale.xCenter;
        const centerY = scale.yCenter;
        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * _helpersSegmentJs.P;
        let angle = datasetStartAngle;
        let i;
        const defaultAngle = 360 / this.countVisibleElements();
        for(i = 0; i < start; ++i)angle += this._computeAngle(i, mode, defaultAngle);
        for(i = start; i < start + count; i++){
            const arc = arcs[i];
            let startAngle = angle;
            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;
            angle = endAngle;
            if (reset) {
                if (animationOpts.animateScale) outerRadius = 0;
                if (animationOpts.animateRotate) startAngle = endAngle = datasetStartAngle;
            }
            const properties = {
                x: centerX,
                y: centerY,
                innerRadius: 0,
                outerRadius,
                startAngle,
                endAngle,
                options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)
            };
            this.updateElement(arc, i, properties, mode);
        }
    }
    countVisibleElements() {
        const dataset = this.getDataset();
        const meta = this._cachedMeta;
        let count = 0;
        meta.data.forEach((element, index)=>{
            if (!isNaN(dataset.data[index]) && this.chart.getDataVisibility(index)) count++;
        });
        return count;
    }
    _computeAngle(index, mode, defaultAngle) {
        return this.chart.getDataVisibility(index) ? _helpersSegmentJs.t(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;
    }
    constructor(chart, datasetIndex){
        super(chart, datasetIndex);
        this.innerRadius = undefined;
        this.outerRadius = undefined;
    }
}
PolarAreaController.id = 'polarArea';
PolarAreaController.defaults = {
    dataElementType: 'arc',
    animation: {
        animateRotate: true,
        animateScale: true
    },
    animations: {
        numbers: {
            type: 'number',
            properties: [
                'x',
                'y',
                'startAngle',
                'endAngle',
                'innerRadius',
                'outerRadius'
            ]
        }
    },
    indexAxis: 'r',
    startAngle: 0
};
PolarAreaController.overrides = {
    aspectRatio: 1,
    plugins: {
        legend: {
            labels: {
                generateLabels (chart) {
                    const data = chart.data;
                    if (data.labels.length && data.datasets.length) {
                        const { labels: { pointStyle  }  } = chart.legend.options;
                        return data.labels.map((label, i)=>{
                            const meta = chart.getDatasetMeta(0);
                            const style = meta.controller.getStyle(i);
                            return {
                                text: label,
                                fillStyle: style.backgroundColor,
                                strokeStyle: style.borderColor,
                                lineWidth: style.borderWidth,
                                pointStyle: pointStyle,
                                hidden: !chart.getDataVisibility(i),
                                index: i
                            };
                        });
                    }
                    return [];
                }
            },
            onClick (e, legendItem, legend) {
                legend.chart.toggleDataVisibility(legendItem.index);
                legend.chart.update();
            }
        },
        tooltip: {
            callbacks: {
                title () {
                    return '';
                },
                label (context) {
                    return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;
                }
            }
        }
    },
    scales: {
        r: {
            type: 'radialLinear',
            angleLines: {
                display: false
            },
            beginAtZero: true,
            grid: {
                circular: true
            },
            pointLabels: {
                display: false
            },
            startAngle: 0
        }
    }
};
class PieController extends DoughnutController {
}
PieController.id = 'pie';
PieController.defaults = {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: '100%'
};
class RadarController extends DatasetController {
    getLabelAndValue(index) {
        const vScale = this._cachedMeta.vScale;
        const parsed = this.getParsed(index);
        return {
            label: vScale.getLabels()[index],
            value: '' + vScale.getLabelForValue(parsed[vScale.axis])
        };
    }
    update(mode) {
        const meta = this._cachedMeta;
        const line = meta.dataset;
        const points = meta.data || [];
        const labels = meta.iScale.getLabels();
        line.points = points;
        if (mode !== 'resize') {
            const options = this.resolveDatasetElementOptions(mode);
            if (!this.options.showLine) options.borderWidth = 0;
            const properties = {
                _loop: true,
                _fullLoop: labels.length === points.length,
                options
            };
            this.updateElement(line, undefined, properties, mode);
        }
        this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start, count, mode) {
        const dataset = this.getDataset();
        const scale = this._cachedMeta.rScale;
        const reset = mode === 'reset';
        for(let i = start; i < start + count; i++){
            const point = points[i];
            const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);
            const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);
            const x = reset ? scale.xCenter : pointPosition.x;
            const y = reset ? scale.yCenter : pointPosition.y;
            const properties = {
                x,
                y,
                angle: pointPosition.angle,
                skip: isNaN(x) || isNaN(y),
                options
            };
            this.updateElement(point, i, properties, mode);
        }
    }
}
RadarController.id = 'radar';
RadarController.defaults = {
    datasetElementType: 'line',
    dataElementType: 'point',
    indexAxis: 'r',
    showLine: true,
    elements: {
        line: {
            fill: 'start'
        }
    }
};
RadarController.overrides = {
    aspectRatio: 1,
    scales: {
        r: {
            type: 'radialLinear'
        }
    }
};
class ScatterController extends LineController {
}
ScatterController.id = 'scatter';
ScatterController.defaults = {
    showLine: false,
    fill: false
};
ScatterController.overrides = {
    interaction: {
        mode: 'point'
    },
    plugins: {
        tooltip: {
            callbacks: {
                title () {
                    return '';
                },
                label (item) {
                    return '(' + item.label + ', ' + item.formattedValue + ')';
                }
            }
        }
    },
    scales: {
        x: {
            type: 'linear'
        },
        y: {
            type: 'linear'
        }
    }
};
var controllers = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    BarController: BarController,
    BubbleController: BubbleController,
    DoughnutController: DoughnutController,
    LineController: LineController,
    PolarAreaController: PolarAreaController,
    PieController: PieController,
    RadarController: RadarController,
    ScatterController: ScatterController
});
function abstract() {
    throw new Error('This method is not implemented: Check that a complete date adapter is provided.');
}
class DateAdapter {
    formats() {
        return abstract();
    }
    parse(value, format) {
        return abstract();
    }
    format(timestamp, format) {
        return abstract();
    }
    add(timestamp, amount, unit) {
        return abstract();
    }
    diff(a, b, unit) {
        return abstract();
    }
    startOf(timestamp, unit, weekday) {
        return abstract();
    }
    endOf(timestamp, unit) {
        return abstract();
    }
    constructor(options){
        this.options = options || {};
    }
}
DateAdapter.override = function(members) {
    Object.assign(DateAdapter.prototype, members);
};
var adapters = {
    _date: DateAdapter
};
function getRelativePosition(e, chart) {
    if ('native' in e) return {
        x: e.x,
        y: e.y
    };
    return _helpersSegmentJs.y(e, chart);
}
function evaluateAllVisibleItems(chart, handler) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    let index, data, element;
    for(let i = 0, ilen = metasets.length; i < ilen; ++i){
        ({ index , data  } = metasets[i]);
        for(let j = 0, jlen = data.length; j < jlen; ++j){
            element = data[j];
            if (!element.skip) handler(element, index, j);
        }
    }
}
function binarySearch(metaset, axis, value, intersect) {
    const { controller , data , _sorted  } = metaset;
    const iScale = controller._cachedMeta.iScale;
    if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {
        const lookupMethod = iScale._reversePixels ? _helpersSegmentJs.A : _helpersSegmentJs.x;
        if (!intersect) return lookupMethod(data, axis, value);
        else if (controller._sharedOptions) {
            const el = data[0];
            const range = typeof el.getRange === 'function' && el.getRange(axis);
            if (range) {
                const start = lookupMethod(data, axis, value - range);
                const end = lookupMethod(data, axis, value + range);
                return {
                    lo: start.lo,
                    hi: end.hi
                };
            }
        }
    }
    return {
        lo: 0,
        hi: data.length - 1
    };
}
function optimizedEvaluateItems(chart, axis, position, handler, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value = position[axis];
    for(let i = 0, ilen = metasets.length; i < ilen; ++i){
        const { index , data  } = metasets[i];
        const { lo , hi  } = binarySearch(metasets[i], axis, value, intersect);
        for(let j = lo; j <= hi; ++j){
            const element = data[j];
            if (!element.skip) handler(element, index, j);
        }
    }
}
function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf('x') !== -1;
    const useY = axis.indexOf('y') !== -1;
    return function(pt1, pt2) {
        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
}
function getIntersectItems(chart, position, axis, useFinalPosition) {
    const items = [];
    if (!_helpersSegmentJs.z(position, chart.chartArea, chart._minPadding)) return items;
    const evaluationFunc = function(element, datasetIndex, index) {
        if (element.inRange(position.x, position.y, useFinalPosition)) items.push({
            element,
            datasetIndex,
            index
        });
    };
    optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);
    return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index) {
        const { startAngle , endAngle  } = element.getProps([
            'startAngle',
            'endAngle'
        ], useFinalPosition);
        const { angle  } = _helpersSegmentJs.B(element, {
            x: position.x,
            y: position.y
        });
        if (_helpersSegmentJs.p(angle, startAngle, endAngle)) items.push({
            element,
            datasetIndex,
            index
        });
    }
    optimizedEvaluateItems(chart, axis, position, evaluationFunc);
    return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index) {
        const inRange1 = element.inRange(position.x, position.y, useFinalPosition);
        if (intersect && !inRange1) return;
        const center = element.getCenterPoint(useFinalPosition);
        const pointInArea = _helpersSegmentJs.z(center, chart.chartArea, chart._minPadding);
        if (!pointInArea && !inRange1) return;
        const distance = distanceMetric(position, center);
        if (distance < minDistance) {
            items = [
                {
                    element,
                    datasetIndex,
                    index
                }
            ];
            minDistance = distance;
        } else if (distance === minDistance) items.push({
            element,
            datasetIndex,
            index
        });
    }
    optimizedEvaluateItems(chart, axis, position, evaluationFunc);
    return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition) {
    if (!_helpersSegmentJs.z(position, chart.chartArea, chart._minPadding)) return [];
    return axis === 'r' && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition);
}
function getAxisItems(chart, e, options, useFinalPosition) {
    const position = getRelativePosition(e, chart);
    const items = [];
    const axis = options.axis;
    const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';
    let intersectsItem = false;
    evaluateAllVisibleItems(chart, (element, datasetIndex, index)=>{
        if (element[rangeMethod](position[axis], useFinalPosition)) items.push({
            element,
            datasetIndex,
            index
        });
        if (element.inRange(position.x, position.y, useFinalPosition)) intersectsItem = true;
    });
    if (options.intersect && !intersectsItem) return [];
    return items;
}
var Interaction = {
    modes: {
        index (chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options.axis || 'x';
            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);
            const elements3 = [];
            if (!items.length) return [];
            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{
                const index = items[0].index;
                const element = meta.data[index];
                if (element && !element.skip) elements3.push({
                    element,
                    datasetIndex: meta.index,
                    index
                });
            });
            return elements3;
        },
        dataset (chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options.axis || 'xy';
            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);
            if (items.length > 0) {
                const datasetIndex = items[0].datasetIndex;
                const data = chart.getDatasetMeta(datasetIndex).data;
                items = [];
                for(let i = 0; i < data.length; ++i)items.push({
                    element: data[i],
                    datasetIndex,
                    index: i
                });
            }
            return items;
        },
        point (chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options.axis || 'xy';
            return getIntersectItems(chart, position, axis, useFinalPosition);
        },
        nearest (chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options.axis || 'xy';
            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition);
        },
        x (chart, e, options, useFinalPosition) {
            return getAxisItems(chart, e, {
                axis: 'x',
                intersect: options.intersect
            }, useFinalPosition);
        },
        y (chart, e, options, useFinalPosition) {
            return getAxisItems(chart, e, {
                axis: 'y',
                intersect: options.intersect
            }, useFinalPosition);
        }
    }
};
const STATIC_POSITIONS = [
    'left',
    'top',
    'right',
    'bottom'
];
function filterByPosition(array, position) {
    return array.filter((v)=>v.pos === position
    );
}
function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis
    );
}
function sortByWeight(array, reverse) {
    return array.sort((a, b)=>{
        const v0 = reverse ? b : a;
        const v1 = reverse ? a : b;
        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
}
function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i, ilen, box, pos, stack, stackWeight;
    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){
        box = boxes[i];
        ({ position: pos , options: { stack , stackWeight =1  }  } = box);
        layoutBoxes.push({
            index: i,
            box,
            pos,
            horizontal: box.isHorizontal(),
            weight: box.weight,
            stack: stack && pos + stack,
            stackWeight
        });
    }
    return layoutBoxes;
}
function buildStacks(layouts1) {
    const stacks = {};
    for (const wrap of layouts1){
        const { stack , pos , stackWeight  } = wrap;
        if (!stack || !STATIC_POSITIONS.includes(pos)) continue;
        const _stack = stacks[stack] || (stacks[stack] = {
            count: 0,
            placed: 0,
            weight: 0,
            size: 0
        });
        _stack.count++;
        _stack.weight += stackWeight;
    }
    return stacks;
}
function setLayoutDims(layouts2, params) {
    const stacks = buildStacks(layouts2);
    const { vBoxMaxWidth , hBoxMaxHeight  } = params;
    let i, ilen, layout;
    for(i = 0, ilen = layouts2.length; i < ilen; ++i){
        layout = layouts2[i];
        const { fullSize  } = layout.box;
        const stack = stacks[layout.stack];
        const factor = stack && layout.stackWeight / stack.weight;
        if (layout.horizontal) {
            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
            layout.height = hBoxMaxHeight;
        } else {
            layout.width = vBoxMaxWidth;
            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
        }
    }
    return stacks;
}
function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize
    ), true);
    const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);
    const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));
    const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);
    const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');
    return {
        fullSize,
        leftAndTop: left.concat(top),
        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
        chartArea: filterByPosition(layoutBoxes, 'chartArea'),
        vertical: left.concat(right).concat(centerVertical),
        horizontal: top.concat(bottom).concat(centerHorizontal)
    };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
    const { pos , box  } = layout;
    const maxPadding = chartArea.maxPadding;
    if (!_helpersSegmentJs.i(pos)) {
        if (layout.size) chartArea[pos] -= layout.size;
        const stack = stacks[layout.stack] || {
            size: 0,
            count: 1
        };
        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
        layout.size = stack.size / stack.count;
        chartArea[pos] += layout.size;
    }
    if (box.getPadding) updateMaxPadding(maxPadding, box.getPadding());
    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));
    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal ? {
        same: widthChanged,
        other: heightChanged
    } : {
        same: heightChanged,
        other: widthChanged
    };
}
function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
        chartArea[pos] += change;
        return change;
    }
    chartArea.y += updatePos('top');
    chartArea.x += updatePos('left');
    updatePos('right');
    updatePos('bottom');
}
function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions) {
        const margin = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
        };
        positions.forEach((pos)=>{
            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
        });
        return margin;
    }
    return horizontal ? marginForPositions([
        'left',
        'right'
    ]) : marginForPositions([
        'top',
        'bottom'
    ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i, ilen, layout, box, refit, changed;
    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){
        layout = boxes[i];
        box = layout.box;
        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
        const { same , other  } = updateDims(chartArea, params, layout, stacks);
        refit |= same && refitBoxes.length;
        changed = changed || other;
        if (!box.fullSize) refitBoxes.push(layout);
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
    box.top = top;
    box.left = left;
    box.right = left + width;
    box.bottom = top + height;
    box.width = width;
    box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x , y  } = chartArea;
    for (const layout of boxes){
        const box = layout.box;
        const stack = stacks[layout.stack] || {
            count: 1,
            placed: 0,
            weight: 1
        };
        const weight = layout.stackWeight / stack.weight || 1;
        if (layout.horizontal) {
            const width = chartArea.w * weight;
            const height = stack.size || box.height;
            if (_helpersSegmentJs.j(stack.start)) y = stack.start;
            if (box.fullSize) setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
            else setBoxDims(box, chartArea.left + stack.placed, y, width, height);
            stack.start = y;
            stack.placed += width;
            y = box.bottom;
        } else {
            const height = chartArea.h * weight;
            const width = stack.size || box.width;
            if (_helpersSegmentJs.j(stack.start)) x = stack.start;
            if (box.fullSize) setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
            else setBoxDims(box, x, chartArea.top + stack.placed, width, height);
            stack.start = x;
            stack.placed += height;
            x = box.right;
        }
    }
    chartArea.x = x;
    chartArea.y = y;
}
_helpersSegmentJs.d.set('layout', {
    autoPadding: true,
    padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    }
});
var layouts = {
    addBox (chart, item) {
        if (!chart.boxes) chart.boxes = [];
        item.fullSize = item.fullSize || false;
        item.position = item.position || 'top';
        item.weight = item.weight || 0;
        item._layers = item._layers || function() {
            return [
                {
                    z: 0,
                    draw (chartArea) {
                        item.draw(chartArea);
                    }
                }
            ];
        };
        chart.boxes.push(item);
    },
    removeBox (chart, layoutItem) {
        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
        if (index !== -1) chart.boxes.splice(index, 1);
    },
    configure (chart, item, options) {
        item.fullSize = options.fullSize;
        item.position = options.position;
        item.weight = options.weight;
    },
    update (chart, width, height, minPadding) {
        if (!chart) return;
        const padding = _helpersSegmentJs.C(chart.options.layout.padding);
        const availableWidth = Math.max(width - padding.width, 0);
        const availableHeight = Math.max(height - padding.height, 0);
        const boxes = buildLayoutBoxes(chart.boxes);
        const verticalBoxes = boxes.vertical;
        const horizontalBoxes = boxes.horizontal;
        _helpersSegmentJs.D(chart.boxes, (box)=>{
            if (typeof box.beforeLayout === 'function') box.beforeLayout();
        });
        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1
        , 0) || 1;
        const params = Object.freeze({
            outerWidth: width,
            outerHeight: height,
            padding,
            availableWidth,
            availableHeight,
            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
            hBoxMaxHeight: availableHeight / 2
        });
        const maxPadding = Object.assign({}, padding);
        updateMaxPadding(maxPadding, _helpersSegmentJs.C(minPadding));
        const chartArea = Object.assign({
            maxPadding,
            w: availableWidth,
            h: availableHeight,
            x: padding.left,
            y: padding.top
        }, padding);
        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
        fitBoxes(boxes.fullSize, chartArea, params, stacks);
        fitBoxes(verticalBoxes, chartArea, params, stacks);
        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) fitBoxes(verticalBoxes, chartArea, params, stacks);
        handleMaxPadding(chartArea);
        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
        chartArea.x += chartArea.w;
        chartArea.y += chartArea.h;
        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
        chart.chartArea = {
            left: chartArea.left,
            top: chartArea.top,
            right: chartArea.left + chartArea.w,
            bottom: chartArea.top + chartArea.h,
            height: chartArea.h,
            width: chartArea.w
        };
        _helpersSegmentJs.D(boxes.chartArea, (layout)=>{
            const box = layout.box;
            Object.assign(box, chart.chartArea);
            box.update(chartArea.w, chartArea.h, {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
            });
        });
    }
};
class BasePlatform {
    acquireContext(canvas, aspectRatio) {}
    releaseContext(context) {
        return false;
    }
    addEventListener(chart, type, listener) {}
    removeEventListener(chart, type, listener) {}
    getDevicePixelRatio() {
        return 1;
    }
    getMaximumSize(element, width, height, aspectRatio) {
        width = Math.max(0, width || element.width);
        height = height || element.height;
        return {
            width,
            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
        };
    }
    isAttached(canvas) {
        return true;
    }
    updateConfig(config) {}
}
class BasicPlatform extends BasePlatform {
    acquireContext(item) {
        return item && item.getContext && item.getContext('2d') || null;
    }
    updateConfig(config) {
        config.options.animation = false;
    }
}
const EXPANDO_KEY = '$chartjs';
const EVENT_TYPES = {
    touchstart: 'mousedown',
    touchmove: 'mousemove',
    touchend: 'mouseup',
    pointerenter: 'mouseenter',
    pointerdown: 'mousedown',
    pointermove: 'mousemove',
    pointerup: 'mouseup',
    pointerleave: 'mouseout',
    pointerout: 'mouseout'
};
const isNullOrEmpty = (value)=>value === null || value === ''
;
function initCanvas(canvas, aspectRatio) {
    const style = canvas.style;
    const renderHeight = canvas.getAttribute('height');
    const renderWidth = canvas.getAttribute('width');
    canvas[EXPANDO_KEY] = {
        initial: {
            height: renderHeight,
            width: renderWidth,
            style: {
                display: style.display,
                height: style.height,
                width: style.width
            }
        }
    };
    style.display = style.display || 'block';
    style.boxSizing = style.boxSizing || 'border-box';
    if (isNullOrEmpty(renderWidth)) {
        const displayWidth = _helpersSegmentJs.G(canvas, 'width');
        if (displayWidth !== undefined) canvas.width = displayWidth;
    }
    if (isNullOrEmpty(renderHeight)) {
        if (canvas.style.height === '') canvas.height = canvas.width / (aspectRatio || 2);
        else {
            const displayHeight = _helpersSegmentJs.G(canvas, 'height');
            if (displayHeight !== undefined) canvas.height = displayHeight;
        }
    }
    return canvas;
}
const eventListenerOptions = _helpersSegmentJs.J ? {
    passive: true
} : false;
function addListener(node, type, listener) {
    node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
    const type = EVENT_TYPES[event.type] || event.type;
    const { x , y  } = _helpersSegmentJs.y(event, chart);
    return {
        type,
        chart,
        native: event,
        x: x !== undefined ? x : null,
        y: y !== undefined ? y : null
    };
}
function nodeListContains(nodeList, canvas) {
    for (const node of nodeList){
        if (node === canvas || node.contains(canvas)) return true;
    }
}
function createAttachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries)=>{
        let trigger = false;
        for (const entry of entries){
            trigger = trigger || nodeListContains(entry.addedNodes, canvas);
            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
        }
        if (trigger) listener();
    });
    observer.observe(document, {
        childList: true,
        subtree: true
    });
    return observer;
}
function createDetachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries)=>{
        let trigger = false;
        for (const entry of entries){
            trigger = trigger || nodeListContains(entry.removedNodes, canvas);
            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
        }
        if (trigger) listener();
    });
    observer.observe(document, {
        childList: true,
        subtree: true
    });
    return observer;
}
const drpListeningCharts = new Map();
let oldDevicePixelRatio = 0;
function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) return;
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize, chart)=>{
        if (chart.currentDevicePixelRatio !== dpr) resize();
    });
}
function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) window.addEventListener('resize', onWindowResize);
    drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) window.removeEventListener('resize', onWindowResize);
}
function createResizeObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const container = canvas && _helpersSegmentJs.F(canvas);
    if (!container) return;
    const resize = _helpersSegmentJs.I((width, height)=>{
        const w = container.clientWidth;
        listener(width, height);
        if (w < container.clientWidth) listener();
    }, window);
    const observer = new ResizeObserver((entries)=>{
        const entry = entries[0];
        const width = entry.contentRect.width;
        const height = entry.contentRect.height;
        if (width === 0 && height === 0) return;
        resize(width, height);
    });
    observer.observe(container);
    listenDevicePixelRatioChanges(chart, resize);
    return observer;
}
function releaseObserver(chart, type, observer) {
    if (observer) observer.disconnect();
    if (type === 'resize') unlistenDevicePixelRatioChanges(chart);
}
function createProxyAndListen(chart, type, listener) {
    const canvas = chart.canvas;
    const proxy = _helpersSegmentJs.I((event)=>{
        if (chart.ctx !== null) listener(fromNativeEvent(event, chart));
    }, chart, (args)=>{
        const event = args[0];
        return [
            event,
            event.offsetX,
            event.offsetY
        ];
    });
    addListener(canvas, type, proxy);
    return proxy;
}
class DomPlatform extends BasePlatform {
    acquireContext(canvas, aspectRatio) {
        const context = canvas && canvas.getContext && canvas.getContext('2d');
        if (context && context.canvas === canvas) {
            initCanvas(canvas, aspectRatio);
            return context;
        }
        return null;
    }
    releaseContext(context) {
        const canvas = context.canvas;
        if (!canvas[EXPANDO_KEY]) return false;
        const initial = canvas[EXPANDO_KEY].initial;
        [
            'height',
            'width'
        ].forEach((prop)=>{
            const value = initial[prop];
            if (_helpersSegmentJs.k(value)) canvas.removeAttribute(prop);
            else canvas.setAttribute(prop, value);
        });
        const style = initial.style || {};
        Object.keys(style).forEach((key)=>{
            canvas.style[key] = style[key];
        });
        canvas.width = canvas.width;
        delete canvas[EXPANDO_KEY];
        return true;
    }
    addEventListener(chart, type, listener) {
        this.removeEventListener(chart, type);
        const proxies = chart.$proxies || (chart.$proxies = {});
        const handlers = {
            attach: createAttachObserver,
            detach: createDetachObserver,
            resize: createResizeObserver
        };
        const handler = handlers[type] || createProxyAndListen;
        proxies[type] = handler(chart, type, listener);
    }
    removeEventListener(chart, type) {
        const proxies = chart.$proxies || (chart.$proxies = {});
        const proxy = proxies[type];
        if (!proxy) return;
        const handlers = {
            attach: releaseObserver,
            detach: releaseObserver,
            resize: releaseObserver
        };
        const handler = handlers[type] || removeListener;
        handler(chart, type, proxy);
        proxies[type] = undefined;
    }
    getDevicePixelRatio() {
        return window.devicePixelRatio;
    }
    getMaximumSize(canvas, width, height, aspectRatio) {
        return _helpersSegmentJs.E(canvas, width, height, aspectRatio);
    }
    isAttached(canvas) {
        const container = _helpersSegmentJs.F(canvas);
        return !!(container && container.isConnected);
    }
}
function _detectPlatform(canvas) {
    if (!_helpersSegmentJs.K() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) return BasicPlatform;
    return DomPlatform;
}
class Element {
    tooltipPosition(useFinalPosition) {
        const { x , y  } = this.getProps([
            'x',
            'y'
        ], useFinalPosition);
        return {
            x,
            y
        };
    }
    hasValue() {
        return _helpersSegmentJs.q(this.x) && _helpersSegmentJs.q(this.y);
    }
    getProps(props, final) {
        const anims = this.$animations;
        if (!final || !anims) return this;
        const ret = {};
        props.forEach((prop)=>{
            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
        });
        return ret;
    }
    constructor(){
        this.x = undefined;
        this.y = undefined;
        this.active = false;
        this.options = undefined;
        this.$animations = undefined;
    }
}
Element.defaults = {};
Element.defaultRoutes = undefined;
const formatters = {
    values (value) {
        return _helpersSegmentJs.b(value) ? value : '' + value;
    },
    numeric (tickValue, index, ticks) {
        if (tickValue === 0) return '0';
        const locale = this.chart.options.locale;
        let notation;
        let delta = tickValue;
        if (ticks.length > 1) {
            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
            if (maxTick < 1e-4 || maxTick > 1e+15) notation = 'scientific';
            delta = calculateDelta(tickValue, ticks);
        }
        const logDelta = _helpersSegmentJs.L(Math.abs(delta));
        const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
        const options = {
            notation,
            minimumFractionDigits: numDecimal,
            maximumFractionDigits: numDecimal
        };
        Object.assign(options, this.options.ticks.format);
        return _helpersSegmentJs.o(tickValue, locale, options);
    },
    logarithmic (tickValue, index, ticks) {
        if (tickValue === 0) return '0';
        const remain = tickValue / Math.pow(10, Math.floor(_helpersSegmentJs.L(tickValue)));
        if (remain === 1 || remain === 2 || remain === 5) return formatters.numeric.call(this, tickValue, index, ticks);
        return '';
    }
};
function calculateDelta(tickValue, ticks) {
    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) delta = tickValue - Math.floor(tickValue);
    return delta;
}
var Ticks = {
    formatters
};
_helpersSegmentJs.d.set('scale', {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: 'ticks',
    grace: 0,
    grid: {
        display: true,
        lineWidth: 1,
        drawBorder: true,
        drawOnChartArea: true,
        drawTicks: true,
        tickLength: 8,
        tickWidth: (_ctx, options)=>options.lineWidth
        ,
        tickColor: (_ctx, options)=>options.color
        ,
        offset: false,
        borderDash: [],
        borderDashOffset: 0.0,
        borderWidth: 1
    },
    title: {
        display: false,
        text: '',
        padding: {
            top: 4,
            bottom: 4
        }
    },
    ticks: {
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        textStrokeWidth: 0,
        textStrokeColor: '',
        padding: 3,
        display: true,
        autoSkip: true,
        autoSkipPadding: 3,
        labelOffset: 0,
        callback: Ticks.formatters.values,
        minor: {},
        major: {},
        align: 'center',
        crossAlign: 'near',
        showLabelBackdrop: false,
        backdropColor: 'rgba(255, 255, 255, 0.75)',
        backdropPadding: 2
    }
});
_helpersSegmentJs.d.route('scale.ticks', 'color', '', 'color');
_helpersSegmentJs.d.route('scale.grid', 'color', '', 'borderColor');
_helpersSegmentJs.d.route('scale.grid', 'borderColor', '', 'borderColor');
_helpersSegmentJs.d.route('scale.title', 'color', '', 'color');
_helpersSegmentJs.d.describe('scale', {
    _fallback: false,
    _scriptable: (name)=>!name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser'
    ,
    _indexable: (name)=>name !== 'borderDash' && name !== 'tickBorderDash'
});
_helpersSegmentJs.d.describe('scales', {
    _fallback: 'scale'
});
_helpersSegmentJs.d.describe('scale.ticks', {
    _scriptable: (name)=>name !== 'backdropPadding' && name !== 'callback'
    ,
    _indexable: (name)=>name !== 'backdropPadding'
});
function autoSkip(scale, ticks) {
    const tickOpts = scale.options.ticks;
    const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first = majorIndices[0];
    const last = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
        return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
        let i, ilen;
        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
        skip(ticks, newTicks, spacing, _helpersSegmentJs.k(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++)skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
        skip(ticks, newTicks, spacing, last, _helpersSegmentJs.k(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
        return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
}
function determineMaxTicks(scale) {
    const offset = scale.options.offset;
    const tickLength = scale._tickSize();
    const maxScale = scale._length / tickLength + (offset ? 0 : 1);
    const maxChart = scale._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) return Math.max(spacing, 1);
    const factors = _helpersSegmentJs.M(evenMajorSpacing);
    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){
        const factor = factors[i];
        if (factor > spacing) return factor;
    }
    return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
    const result = [];
    let i, ilen;
    for(i = 0, ilen = ticks.length; i < ilen; i++)if (ticks[i].major) result.push(i);
    return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next = majorIndices[0];
    let i;
    spacing = Math.ceil(spacing);
    for(i = 0; i < ticks.length; i++)if (i === next) {
        newTicks.push(ticks[i]);
        count++;
        next = majorIndices[count * spacing];
    }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start = _helpersSegmentJs.v(majorStart, 0);
    const end = Math.min(_helpersSegmentJs.v(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length, i, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
        length = majorEnd - majorStart;
        spacing = length / Math.floor(length / spacing);
    }
    next = start;
    while(next < 0){
        count++;
        next = Math.round(start + count * spacing);
    }
    for(i = Math.max(start, 0); i < end; i++)if (i === next) {
        newTicks.push(ticks[i]);
        count++;
        next = Math.round(start + count * spacing);
    }
}
function getEvenSpacing(arr) {
    const len = arr.length;
    let i, diff;
    if (len < 2) return false;
    for(diff = arr[0], i = 1; i < len; ++i){
        if (arr[i] - arr[i - 1] !== diff) return false;
    }
    return diff;
}
const reverseAlign = (align)=>align === 'left' ? 'right' : align === 'right' ? 'left' : align
;
const offsetFromEdge = (scale, edge, offset)=>edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset
;
function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i = 0;
    for(; i < len; i += increment)result.push(arr[Math.floor(i)]);
    return result;
}
function getPixelForGridLine(scale, index, offsetGridLines) {
    const length = scale.ticks.length;
    const validIndex1 = Math.min(index, length - 1);
    const start = scale._startPixel;
    const end = scale._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale.getPixelForTick(validIndex1);
    let offset;
    if (offsetGridLines) {
        if (length === 1) offset = Math.max(lineValue - start, end - lineValue);
        else if (index === 0) offset = (scale.getPixelForTick(1) - lineValue) / 2;
        else offset = (lineValue - scale.getPixelForTick(validIndex1 - 1)) / 2;
        lineValue += validIndex1 < index ? offset : -offset;
        if (lineValue < start - epsilon || lineValue > end + epsilon) return;
    }
    return lineValue;
}
function garbageCollect(caches, length) {
    _helpersSegmentJs.D(caches, (cache)=>{
        const gc = cache.gc;
        const gcLen = gc.length / 2;
        let i;
        if (gcLen > length) {
            for(i = 0; i < gcLen; ++i)delete cache.data[gc[i]];
            gc.splice(0, gcLen);
        }
    });
}
function getTickMarkLength(options) {
    return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
    if (!options.display) return 0;
    const font = _helpersSegmentJs.Z(options.font, fallback);
    const padding = _helpersSegmentJs.C(options.padding);
    const lines = _helpersSegmentJs.b(options.text) ? options.text.length : 1;
    return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
    return _helpersSegmentJs.h(parent, {
        scale,
        type: 'scale'
    });
}
function createTickContext(parent, index, tick) {
    return _helpersSegmentJs.h(parent, {
        tick,
        index,
        type: 'tick'
    });
}
function titleAlign(align, position, reverse) {
    let ret = _helpersSegmentJs.$(align);
    if (reverse && position !== 'right' || !reverse && position === 'right') ret = reverseAlign(ret);
    return ret;
}
function titleArgs(scale, offset, position, align) {
    const { top , left , bottom , right , chart  } = scale;
    const { chartArea , scales: scales2  } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom - top;
    const width = right - left;
    if (scale.isHorizontal()) {
        titleX = _helpersSegmentJs.a0(align, left, right);
        if (_helpersSegmentJs.i(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
        } else if (position === 'center') titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
        else titleY = offsetFromEdge(scale, position, offset);
        maxWidth = right - left;
    } else {
        if (_helpersSegmentJs.i(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
        } else if (position === 'center') titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
        else titleX = offsetFromEdge(scale, position, offset);
        titleY = _helpersSegmentJs.a0(align, bottom, top);
        rotation = position === 'left' ? -_helpersSegmentJs.H : _helpersSegmentJs.H;
    }
    return {
        titleX,
        titleY,
        maxWidth,
        rotation
    };
}
class Scale extends Element {
    init(options) {
        this.options = options.setContext(this.getContext());
        this.axis = options.axis;
        this._userMin = this.parse(options.min);
        this._userMax = this.parse(options.max);
        this._suggestedMin = this.parse(options.suggestedMin);
        this._suggestedMax = this.parse(options.suggestedMax);
    }
    parse(raw, index) {
        return raw;
    }
    getUserBounds() {
        let { _userMin , _userMax , _suggestedMin , _suggestedMax  } = this;
        _userMin = _helpersSegmentJs.N(_userMin, Number.POSITIVE_INFINITY);
        _userMax = _helpersSegmentJs.N(_userMax, Number.NEGATIVE_INFINITY);
        _suggestedMin = _helpersSegmentJs.N(_suggestedMin, Number.POSITIVE_INFINITY);
        _suggestedMax = _helpersSegmentJs.N(_suggestedMax, Number.NEGATIVE_INFINITY);
        return {
            min: _helpersSegmentJs.N(_userMin, _suggestedMin),
            max: _helpersSegmentJs.N(_userMax, _suggestedMax),
            minDefined: _helpersSegmentJs.g(_userMin),
            maxDefined: _helpersSegmentJs.g(_userMax)
        };
    }
    getMinMax(canStack) {
        let { min , max , minDefined , maxDefined  } = this.getUserBounds();
        let range;
        if (minDefined && maxDefined) return {
            min,
            max
        };
        const metas = this.getMatchingVisibleMetas();
        for(let i = 0, ilen = metas.length; i < ilen; ++i){
            range = metas[i].controller.getMinMax(this, canStack);
            if (!minDefined) min = Math.min(min, range.min);
            if (!maxDefined) max = Math.max(max, range.max);
        }
        min = maxDefined && min > max ? max : min;
        max = minDefined && min > max ? min : max;
        return {
            min: _helpersSegmentJs.N(min, _helpersSegmentJs.N(max, min)),
            max: _helpersSegmentJs.N(max, _helpersSegmentJs.N(min, max))
        };
    }
    getPadding() {
        return {
            left: this.paddingLeft || 0,
            top: this.paddingTop || 0,
            right: this.paddingRight || 0,
            bottom: this.paddingBottom || 0
        };
    }
    getTicks() {
        return this.ticks;
    }
    getLabels() {
        const data = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
    }
    beforeLayout() {
        this._cache = {};
        this._dataLimitsCached = false;
    }
    beforeUpdate() {
        _helpersSegmentJs.O(this.options.beforeUpdate, [
            this
        ]);
    }
    update(maxWidth, maxHeight, margins) {
        const { beginAtZero , grace , ticks: tickOpts  } = this.options;
        const sampleSize = tickOpts.sampleSize;
        this.beforeUpdate();
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins = Object.assign({
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        }, margins);
        this.ticks = null;
        this._labelSizes = null;
        this._gridLineItems = null;
        this._labelItems = null;
        this.beforeSetDimensions();
        this.setDimensions();
        this.afterSetDimensions();
        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
        if (!this._dataLimitsCached) {
            this.beforeDataLimits();
            this.determineDataLimits();
            this.afterDataLimits();
            this._range = _helpersSegmentJs.Q(this, grace, beginAtZero);
            this._dataLimitsCached = true;
        }
        this.beforeBuildTicks();
        this.ticks = this.buildTicks() || [];
        this.afterBuildTicks();
        const samplingEnabled = sampleSize < this.ticks.length;
        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
        this.configure();
        this.beforeCalculateLabelRotation();
        this.calculateLabelRotation();
        this.afterCalculateLabelRotation();
        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {
            this.ticks = autoSkip(this, this.ticks);
            this._labelSizes = null;
        }
        if (samplingEnabled) this._convertTicksToLabels(this.ticks);
        this.beforeFit();
        this.fit();
        this.afterFit();
        this.afterUpdate();
    }
    configure() {
        let reversePixels = this.options.reverse;
        let startPixel, endPixel;
        if (this.isHorizontal()) {
            startPixel = this.left;
            endPixel = this.right;
        } else {
            startPixel = this.top;
            endPixel = this.bottom;
            reversePixels = !reversePixels;
        }
        this._startPixel = startPixel;
        this._endPixel = endPixel;
        this._reversePixels = reversePixels;
        this._length = endPixel - startPixel;
        this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
        _helpersSegmentJs.O(this.options.afterUpdate, [
            this
        ]);
    }
    beforeSetDimensions() {
        _helpersSegmentJs.O(this.options.beforeSetDimensions, [
            this
        ]);
    }
    setDimensions() {
        if (this.isHorizontal()) {
            this.width = this.maxWidth;
            this.left = 0;
            this.right = this.width;
        } else {
            this.height = this.maxHeight;
            this.top = 0;
            this.bottom = this.height;
        }
        this.paddingLeft = 0;
        this.paddingTop = 0;
        this.paddingRight = 0;
        this.paddingBottom = 0;
    }
    afterSetDimensions() {
        _helpersSegmentJs.O(this.options.afterSetDimensions, [
            this
        ]);
    }
    _callHooks(name) {
        this.chart.notifyPlugins(name, this.getContext());
        _helpersSegmentJs.O(this.options[name], [
            this
        ]);
    }
    beforeDataLimits() {
        this._callHooks('beforeDataLimits');
    }
    determineDataLimits() {}
    afterDataLimits() {
        this._callHooks('afterDataLimits');
    }
    beforeBuildTicks() {
        this._callHooks('beforeBuildTicks');
    }
    buildTicks() {
        return [];
    }
    afterBuildTicks() {
        this._callHooks('afterBuildTicks');
    }
    beforeTickToLabelConversion() {
        _helpersSegmentJs.O(this.options.beforeTickToLabelConversion, [
            this
        ]);
    }
    generateTickLabels(ticks) {
        const tickOpts = this.options.ticks;
        let i, ilen, tick;
        for(i = 0, ilen = ticks.length; i < ilen; i++){
            tick = ticks[i];
            tick.label = _helpersSegmentJs.O(tickOpts.callback, [
                tick.value,
                i,
                ticks
            ], this);
        }
    }
    afterTickToLabelConversion() {
        _helpersSegmentJs.O(this.options.afterTickToLabelConversion, [
            this
        ]);
    }
    beforeCalculateLabelRotation() {
        _helpersSegmentJs.O(this.options.beforeCalculateLabelRotation, [
            this
        ]);
    }
    calculateLabelRotation() {
        const options = this.options;
        const tickOpts = options.ticks;
        const numTicks = this.ticks.length;
        const minRotation = tickOpts.minRotation || 0;
        const maxRotation = tickOpts.maxRotation;
        let labelRotation = minRotation;
        let tickWidth, maxHeight, maxLabelDiagonal;
        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
            this.labelRotation = minRotation;
            return;
        }
        const labelSizes = this._getLabelSizes();
        const maxLabelWidth = labelSizes.widest.width;
        const maxLabelHeight = labelSizes.highest.height;
        const maxWidth = _helpersSegmentJs.w(this.chart.width - maxLabelWidth, 0, this.maxWidth);
        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
        if (maxLabelWidth + 6 > tickWidth) {
            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
            labelRotation = _helpersSegmentJs.R(Math.min(Math.asin(_helpersSegmentJs.w((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_helpersSegmentJs.w(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_helpersSegmentJs.w(maxLabelHeight / maxLabelDiagonal, -1, 1))));
            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
        }
        this.labelRotation = labelRotation;
    }
    afterCalculateLabelRotation() {
        _helpersSegmentJs.O(this.options.afterCalculateLabelRotation, [
            this
        ]);
    }
    beforeFit() {
        _helpersSegmentJs.O(this.options.beforeFit, [
            this
        ]);
    }
    fit() {
        const minSize = {
            width: 0,
            height: 0
        };
        const { chart , options: { ticks: tickOpts , title: titleOpts , grid: gridOpts  }  } = this;
        const display = this._isVisible();
        const isHorizontal = this.isHorizontal();
        if (display) {
            const titleHeight = getTitleHeight(titleOpts, chart.options.font);
            if (isHorizontal) {
                minSize.width = this.maxWidth;
                minSize.height = getTickMarkLength(gridOpts) + titleHeight;
            } else {
                minSize.height = this.maxHeight;
                minSize.width = getTickMarkLength(gridOpts) + titleHeight;
            }
            if (tickOpts.display && this.ticks.length) {
                const { first , last , widest , highest  } = this._getLabelSizes();
                const tickPadding = tickOpts.padding * 2;
                const angleRadians = _helpersSegmentJs.t(this.labelRotation);
                const cos = Math.cos(angleRadians);
                const sin = Math.sin(angleRadians);
                if (isHorizontal) {
                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
                } else {
                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
                }
                this._calculatePadding(first, last, sin, cos);
            }
        }
        this._handleMargins();
        if (isHorizontal) {
            this.width = this._length = chart.width - this._margins.left - this._margins.right;
            this.height = minSize.height;
        } else {
            this.width = minSize.width;
            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
        }
    }
    _calculatePadding(first, last, sin, cos) {
        const { ticks: { align , padding  } , position  } = this.options;
        const isRotated = this.labelRotation !== 0;
        const labelsBelowTicks = position !== 'top' && this.axis === 'x';
        if (this.isHorizontal()) {
            const offsetLeft = this.getPixelForTick(0) - this.left;
            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
            let paddingLeft = 0;
            let paddingRight = 0;
            if (isRotated) {
                if (labelsBelowTicks) {
                    paddingLeft = cos * first.width;
                    paddingRight = sin * last.height;
                } else {
                    paddingLeft = sin * first.height;
                    paddingRight = cos * last.width;
                }
            } else if (align === 'start') paddingRight = last.width;
            else if (align === 'end') paddingLeft = first.width;
            else {
                paddingLeft = first.width / 2;
                paddingRight = last.width / 2;
            }
            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
        } else {
            let paddingTop = last.height / 2;
            let paddingBottom = first.height / 2;
            if (align === 'start') {
                paddingTop = 0;
                paddingBottom = first.height;
            } else if (align === 'end') {
                paddingTop = last.height;
                paddingBottom = 0;
            }
            this.paddingTop = paddingTop + padding;
            this.paddingBottom = paddingBottom + padding;
        }
    }
    _handleMargins() {
        if (this._margins) {
            this._margins.left = Math.max(this.paddingLeft, this._margins.left);
            this._margins.top = Math.max(this.paddingTop, this._margins.top);
            this._margins.right = Math.max(this.paddingRight, this._margins.right);
            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
        }
    }
    afterFit() {
        _helpersSegmentJs.O(this.options.afterFit, [
            this
        ]);
    }
    isHorizontal() {
        const { axis , position  } = this.options;
        return position === 'top' || position === 'bottom' || axis === 'x';
    }
    isFullSize() {
        return this.options.fullSize;
    }
    _convertTicksToLabels(ticks) {
        this.beforeTickToLabelConversion();
        this.generateTickLabels(ticks);
        let i, ilen;
        for(i = 0, ilen = ticks.length; i < ilen; i++)if (_helpersSegmentJs.k(ticks[i].label)) {
            ticks.splice(i, 1);
            ilen--;
            i--;
        }
        this.afterTickToLabelConversion();
    }
    _getLabelSizes() {
        let labelSizes = this._labelSizes;
        if (!labelSizes) {
            const sampleSize = this.options.ticks.sampleSize;
            let ticks = this.ticks;
            if (sampleSize < ticks.length) ticks = sample(ticks, sampleSize);
            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
        }
        return labelSizes;
    }
    _computeLabelSizes(ticks, length) {
        const { ctx , _longestTextCache: caches  } = this;
        const widths = [];
        const heights = [];
        let widestLabelSize = 0;
        let highestLabelSize = 0;
        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
        for(i = 0; i < length; ++i){
            label = ticks[i].label;
            tickFont = this._resolveTickFontOptions(i);
            ctx.font = fontString = tickFont.string;
            cache = caches[fontString] = caches[fontString] || {
                data: {},
                gc: []
            };
            lineHeight = tickFont.lineHeight;
            width = height = 0;
            if (!_helpersSegmentJs.k(label) && !_helpersSegmentJs.b(label)) {
                width = _helpersSegmentJs.S(ctx, cache.data, cache.gc, width, label);
                height = lineHeight;
            } else if (_helpersSegmentJs.b(label)) for(j = 0, jlen = label.length; j < jlen; ++j){
                nestedLabel = label[j];
                if (!_helpersSegmentJs.k(nestedLabel) && !_helpersSegmentJs.b(nestedLabel)) {
                    width = _helpersSegmentJs.S(ctx, cache.data, cache.gc, width, nestedLabel);
                    height += lineHeight;
                }
            }
            widths.push(width);
            heights.push(height);
            widestLabelSize = Math.max(width, widestLabelSize);
            highestLabelSize = Math.max(height, highestLabelSize);
        }
        garbageCollect(caches, length);
        const widest = widths.indexOf(widestLabelSize);
        const highest = heights.indexOf(highestLabelSize);
        const valueAt = (idx)=>({
                width: widths[idx] || 0,
                height: heights[idx] || 0
            })
        ;
        return {
            first: valueAt(0),
            last: valueAt(length - 1),
            widest: valueAt(widest),
            highest: valueAt(highest),
            widths,
            heights
        };
    }
    getLabelForValue(value) {
        return value;
    }
    getPixelForValue(value, index) {
        return NaN;
    }
    getValueForPixel(pixel) {}
    getPixelForTick(index) {
        const ticks = this.ticks;
        if (index < 0 || index > ticks.length - 1) return null;
        return this.getPixelForValue(ticks[index].value);
    }
    getPixelForDecimal(decimal) {
        if (this._reversePixels) decimal = 1 - decimal;
        const pixel = this._startPixel + decimal * this._length;
        return _helpersSegmentJs.U(this._alignToPixels ? _helpersSegmentJs.V(this.chart, pixel, 0) : pixel);
    }
    getDecimalForPixel(pixel) {
        const decimal = (pixel - this._startPixel) / this._length;
        return this._reversePixels ? 1 - decimal : decimal;
    }
    getBasePixel() {
        return this.getPixelForValue(this.getBaseValue());
    }
    getBaseValue() {
        const { min , max  } = this;
        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
    }
    getContext(index) {
        const ticks = this.ticks || [];
        if (index >= 0 && index < ticks.length) {
            const tick = ticks[index];
            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
        }
        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
    }
    _tickSize() {
        const optionTicks = this.options.ticks;
        const rot = _helpersSegmentJs.t(this.labelRotation);
        const cos = Math.abs(Math.cos(rot));
        const sin = Math.abs(Math.sin(rot));
        const labelSizes = this._getLabelSizes();
        const padding = optionTicks.autoSkipPadding || 0;
        const w = labelSizes ? labelSizes.widest.width + padding : 0;
        const h = labelSizes ? labelSizes.highest.height + padding : 0;
        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
    }
    _isVisible() {
        const display = this.options.display;
        if (display !== 'auto') return !!display;
        return this.getMatchingVisibleMetas().length > 0;
    }
    _computeGridLineItems(chartArea) {
        const axis = this.axis;
        const chart = this.chart;
        const options = this.options;
        const { grid , position  } = options;
        const offset = grid.offset;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const ticksLength = ticks.length + (offset ? 1 : 0);
        const tl = getTickMarkLength(grid);
        const items = [];
        const borderOpts = grid.setContext(this.getContext());
        const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
        const axisHalfWidth = axisWidth / 2;
        const alignBorderValue = function(pixel) {
            return _helpersSegmentJs.V(chart, pixel, axisWidth);
        };
        let borderValue, i, lineValue, alignedLineValue;
        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
        if (position === 'top') {
            borderValue = alignBorderValue(this.bottom);
            ty1 = this.bottom - tl;
            ty2 = borderValue - axisHalfWidth;
            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
            y2 = chartArea.bottom;
        } else if (position === 'bottom') {
            borderValue = alignBorderValue(this.top);
            y1 = chartArea.top;
            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
            ty1 = borderValue + axisHalfWidth;
            ty2 = this.top + tl;
        } else if (position === 'left') {
            borderValue = alignBorderValue(this.right);
            tx1 = this.right - tl;
            tx2 = borderValue - axisHalfWidth;
            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
            x2 = chartArea.right;
        } else if (position === 'right') {
            borderValue = alignBorderValue(this.left);
            x1 = chartArea.left;
            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
            tx1 = borderValue + axisHalfWidth;
            tx2 = this.left + tl;
        } else if (axis === 'x') {
            if (position === 'center') borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
            else if (_helpersSegmentJs.i(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
            }
            y1 = chartArea.top;
            y2 = chartArea.bottom;
            ty1 = borderValue + axisHalfWidth;
            ty2 = ty1 + tl;
        } else if (axis === 'y') {
            if (position === 'center') borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
            else if (_helpersSegmentJs.i(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
            }
            tx1 = borderValue - axisHalfWidth;
            tx2 = tx1 - tl;
            x1 = chartArea.left;
            x2 = chartArea.right;
        }
        const limit = _helpersSegmentJs.v(options.ticks.maxTicksLimit, ticksLength);
        const step = Math.max(1, Math.ceil(ticksLength / limit));
        for(i = 0; i < ticksLength; i += step){
            const optsAtIndex = grid.setContext(this.getContext(i));
            const lineWidth = optsAtIndex.lineWidth;
            const lineColor = optsAtIndex.color;
            const borderDash = grid.borderDash || [];
            const borderDashOffset = optsAtIndex.borderDashOffset;
            const tickWidth = optsAtIndex.tickWidth;
            const tickColor = optsAtIndex.tickColor;
            const tickBorderDash = optsAtIndex.tickBorderDash || [];
            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
            lineValue = getPixelForGridLine(this, i, offset);
            if (lineValue === undefined) continue;
            alignedLineValue = _helpersSegmentJs.V(chart, lineValue, lineWidth);
            if (isHorizontal) tx1 = tx2 = x1 = x2 = alignedLineValue;
            else ty1 = ty2 = y1 = y2 = alignedLineValue;
            items.push({
                tx1,
                ty1,
                tx2,
                ty2,
                x1,
                y1,
                x2,
                y2,
                width: lineWidth,
                color: lineColor,
                borderDash,
                borderDashOffset,
                tickWidth,
                tickColor,
                tickBorderDash,
                tickBorderDashOffset
            });
        }
        this._ticksLength = ticksLength;
        this._borderValue = borderValue;
        return items;
    }
    _computeLabelItems(chartArea) {
        const axis = this.axis;
        const options = this.options;
        const { position , ticks: optionTicks  } = options;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const { align , crossAlign , padding , mirror  } = optionTicks;
        const tl = getTickMarkLength(options.grid);
        const tickAndPadding = tl + padding;
        const hTickAndPadding = mirror ? -padding : tickAndPadding;
        const rotation = -_helpersSegmentJs.t(this.labelRotation);
        const items = [];
        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
        let textBaseline = 'middle';
        if (position === 'top') {
            y = this.bottom - hTickAndPadding;
            textAlign = this._getXAxisLabelAlignment();
        } else if (position === 'bottom') {
            y = this.top + hTickAndPadding;
            textAlign = this._getXAxisLabelAlignment();
        } else if (position === 'left') {
            const ret = this._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
        } else if (position === 'right') {
            const ret = this._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
        } else if (axis === 'x') {
            if (position === 'center') y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
            else if (_helpersSegmentJs.i(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
            }
            textAlign = this._getXAxisLabelAlignment();
        } else if (axis === 'y') {
            if (position === 'center') x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
            else if (_helpersSegmentJs.i(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                x = this.chart.scales[positionAxisID].getPixelForValue(value);
            }
            textAlign = this._getYAxisLabelAlignment(tl).textAlign;
        }
        if (axis === 'y') {
            if (align === 'start') textBaseline = 'top';
            else if (align === 'end') textBaseline = 'bottom';
        }
        const labelSizes = this._getLabelSizes();
        for(i = 0, ilen = ticks.length; i < ilen; ++i){
            tick = ticks[i];
            label = tick.label;
            const optsAtIndex = optionTicks.setContext(this.getContext(i));
            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
            font = this._resolveTickFontOptions(i);
            lineHeight = font.lineHeight;
            lineCount = _helpersSegmentJs.b(label) ? label.length : 1;
            const halfCount = lineCount / 2;
            const color = optsAtIndex.color;
            const strokeColor = optsAtIndex.textStrokeColor;
            const strokeWidth = optsAtIndex.textStrokeWidth;
            if (isHorizontal) {
                x = pixel;
                if (position === 'top') {
                    if (crossAlign === 'near' || rotation !== 0) textOffset = -lineCount * lineHeight + lineHeight / 2;
                    else if (crossAlign === 'center') textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                    else textOffset = -labelSizes.highest.height + lineHeight / 2;
                } else {
                    if (crossAlign === 'near' || rotation !== 0) textOffset = lineHeight / 2;
                    else if (crossAlign === 'center') textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                    else textOffset = labelSizes.highest.height - lineCount * lineHeight;
                }
                if (mirror) textOffset *= -1;
            } else {
                y = pixel;
                textOffset = (1 - lineCount) * lineHeight / 2;
            }
            let backdrop;
            if (optsAtIndex.showLabelBackdrop) {
                const labelPadding = _helpersSegmentJs.C(optsAtIndex.backdropPadding);
                const height = labelSizes.heights[i];
                const width = labelSizes.widths[i];
                let top = y + textOffset - labelPadding.top;
                let left = x - labelPadding.left;
                switch(textBaseline){
                    case 'middle':
                        top -= height / 2;
                        break;
                    case 'bottom':
                        top -= height;
                        break;
                }
                switch(textAlign){
                    case 'center':
                        left -= width / 2;
                        break;
                    case 'right':
                        left -= width;
                        break;
                }
                backdrop = {
                    left,
                    top,
                    width: width + labelPadding.width,
                    height: height + labelPadding.height,
                    color: optsAtIndex.backdropColor
                };
            }
            items.push({
                rotation,
                label,
                font,
                color,
                strokeColor,
                strokeWidth,
                textOffset,
                textAlign,
                textBaseline,
                translation: [
                    x,
                    y
                ],
                backdrop
            });
        }
        return items;
    }
    _getXAxisLabelAlignment() {
        const { position , ticks  } = this.options;
        const rotation = -_helpersSegmentJs.t(this.labelRotation);
        if (rotation) return position === 'top' ? 'left' : 'right';
        let align = 'center';
        if (ticks.align === 'start') align = 'left';
        else if (ticks.align === 'end') align = 'right';
        return align;
    }
    _getYAxisLabelAlignment(tl) {
        const { position , ticks: { crossAlign , mirror , padding  }  } = this.options;
        const labelSizes = this._getLabelSizes();
        const tickAndPadding = tl + padding;
        const widest = labelSizes.widest.width;
        let textAlign;
        let x;
        if (position === 'left') {
            if (mirror) {
                x = this.right + padding;
                if (crossAlign === 'near') textAlign = 'left';
                else if (crossAlign === 'center') {
                    textAlign = 'center';
                    x += widest / 2;
                } else {
                    textAlign = 'right';
                    x += widest;
                }
            } else {
                x = this.right - tickAndPadding;
                if (crossAlign === 'near') textAlign = 'right';
                else if (crossAlign === 'center') {
                    textAlign = 'center';
                    x -= widest / 2;
                } else {
                    textAlign = 'left';
                    x = this.left;
                }
            }
        } else if (position === 'right') {
            if (mirror) {
                x = this.left + padding;
                if (crossAlign === 'near') textAlign = 'right';
                else if (crossAlign === 'center') {
                    textAlign = 'center';
                    x -= widest / 2;
                } else {
                    textAlign = 'left';
                    x -= widest;
                }
            } else {
                x = this.left + tickAndPadding;
                if (crossAlign === 'near') textAlign = 'left';
                else if (crossAlign === 'center') {
                    textAlign = 'center';
                    x += widest / 2;
                } else {
                    textAlign = 'right';
                    x = this.right;
                }
            }
        } else textAlign = 'right';
        return {
            textAlign,
            x
        };
    }
    _computeLabelArea() {
        if (this.options.ticks.mirror) return;
        const chart = this.chart;
        const position = this.options.position;
        if (position === 'left' || position === 'right') return {
            top: 0,
            left: this.left,
            bottom: chart.height,
            right: this.right
        };
        if (position === 'top' || position === 'bottom') return {
            top: this.top,
            left: 0,
            bottom: this.bottom,
            right: chart.width
        };
    }
    drawBackground() {
        const { ctx , options: { backgroundColor  } , left , top , width , height  } = this;
        if (backgroundColor) {
            ctx.save();
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(left, top, width, height);
            ctx.restore();
        }
    }
    getLineWidthForValue(value) {
        const grid = this.options.grid;
        if (!this._isVisible() || !grid.display) return 0;
        const ticks = this.ticks;
        const index = ticks.findIndex((t)=>t.value === value
        );
        if (index >= 0) {
            const opts = grid.setContext(this.getContext(index));
            return opts.lineWidth;
        }
        return 0;
    }
    drawGrid(chartArea) {
        const grid = this.options.grid;
        const ctx = this.ctx;
        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
        let i, ilen;
        const drawLine = (p1, p2, style)=>{
            if (!style.width || !style.color) return;
            ctx.save();
            ctx.lineWidth = style.width;
            ctx.strokeStyle = style.color;
            ctx.setLineDash(style.borderDash || []);
            ctx.lineDashOffset = style.borderDashOffset;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            ctx.restore();
        };
        if (grid.display) for(i = 0, ilen = items.length; i < ilen; ++i){
            const item = items[i];
            if (grid.drawOnChartArea) drawLine({
                x: item.x1,
                y: item.y1
            }, {
                x: item.x2,
                y: item.y2
            }, item);
            if (grid.drawTicks) drawLine({
                x: item.tx1,
                y: item.ty1
            }, {
                x: item.tx2,
                y: item.ty2
            }, {
                color: item.tickColor,
                width: item.tickWidth,
                borderDash: item.tickBorderDash,
                borderDashOffset: item.tickBorderDashOffset
            });
        }
    }
    drawBorder() {
        const { chart , ctx , options: { grid  }  } = this;
        const borderOpts = grid.setContext(this.getContext());
        const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
        if (!axisWidth) return;
        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
        const borderValue = this._borderValue;
        let x1, x2, y1, y2;
        if (this.isHorizontal()) {
            x1 = _helpersSegmentJs.V(chart, this.left, axisWidth) - axisWidth / 2;
            x2 = _helpersSegmentJs.V(chart, this.right, lastLineWidth) + lastLineWidth / 2;
            y1 = y2 = borderValue;
        } else {
            y1 = _helpersSegmentJs.V(chart, this.top, axisWidth) - axisWidth / 2;
            y2 = _helpersSegmentJs.V(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
            x1 = x2 = borderValue;
        }
        ctx.save();
        ctx.lineWidth = borderOpts.borderWidth;
        ctx.strokeStyle = borderOpts.borderColor;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.restore();
    }
    drawLabels(chartArea) {
        const optionTicks = this.options.ticks;
        if (!optionTicks.display) return;
        const ctx = this.ctx;
        const area = this._computeLabelArea();
        if (area) _helpersSegmentJs.W(ctx, area);
        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
        let i, ilen;
        for(i = 0, ilen = items.length; i < ilen; ++i){
            const item = items[i];
            const tickFont = item.font;
            const label = item.label;
            if (item.backdrop) {
                ctx.fillStyle = item.backdrop.color;
                ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
            }
            let y = item.textOffset;
            _helpersSegmentJs.X(ctx, label, 0, y, tickFont, item);
        }
        if (area) _helpersSegmentJs.Y(ctx);
    }
    drawTitle() {
        const { ctx , options: { position , title , reverse  }  } = this;
        if (!title.display) return;
        const font = _helpersSegmentJs.Z(title.font);
        const padding = _helpersSegmentJs.C(title.padding);
        const align = title.align;
        let offset = font.lineHeight / 2;
        if (position === 'bottom' || position === 'center' || _helpersSegmentJs.i(position)) {
            offset += padding.bottom;
            if (_helpersSegmentJs.b(title.text)) offset += font.lineHeight * (title.text.length - 1);
        } else offset += padding.top;
        const { titleX , titleY , maxWidth , rotation  } = titleArgs(this, offset, position, align);
        _helpersSegmentJs.X(ctx, title.text, 0, 0, font, {
            color: title.color,
            maxWidth,
            rotation,
            textAlign: titleAlign(align, position, reverse),
            textBaseline: 'middle',
            translation: [
                titleX,
                titleY
            ]
        });
    }
    draw(chartArea) {
        if (!this._isVisible()) return;
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawBorder();
        this.drawTitle();
        this.drawLabels(chartArea);
    }
    _layers() {
        const opts = this.options;
        const tz = opts.ticks && opts.ticks.z || 0;
        const gz = _helpersSegmentJs.v(opts.grid && opts.grid.z, -1);
        if (!this._isVisible() || this.draw !== Scale.prototype.draw) return [
            {
                z: tz,
                draw: (chartArea)=>{
                    this.draw(chartArea);
                }
            }
        ];
        return [
            {
                z: gz,
                draw: (chartArea)=>{
                    this.drawBackground();
                    this.drawGrid(chartArea);
                    this.drawTitle();
                }
            },
            {
                z: gz + 1,
                draw: ()=>{
                    this.drawBorder();
                }
            },
            {
                z: tz,
                draw: (chartArea)=>{
                    this.drawLabels(chartArea);
                }
            }
        ];
    }
    getMatchingVisibleMetas(type) {
        const metas = this.chart.getSortedVisibleDatasetMetas();
        const axisID = this.axis + 'AxisID';
        const result = [];
        let i, ilen;
        for(i = 0, ilen = metas.length; i < ilen; ++i){
            const meta = metas[i];
            if (meta[axisID] === this.id && (!type || meta.type === type)) result.push(meta);
        }
        return result;
    }
    _resolveTickFontOptions(index) {
        const opts = this.options.ticks.setContext(this.getContext(index));
        return _helpersSegmentJs.Z(opts.font);
    }
    _maxDigits() {
        const fontSize = this._resolveTickFontOptions(0).lineHeight;
        return (this.isHorizontal() ? this.width : this.height) / fontSize;
    }
    constructor(cfg){
        super();
        this.id = cfg.id;
        this.type = cfg.type;
        this.options = undefined;
        this.ctx = cfg.ctx;
        this.chart = cfg.chart;
        this.top = undefined;
        this.bottom = undefined;
        this.left = undefined;
        this.right = undefined;
        this.width = undefined;
        this.height = undefined;
        this._margins = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        };
        this.maxWidth = undefined;
        this.maxHeight = undefined;
        this.paddingTop = undefined;
        this.paddingBottom = undefined;
        this.paddingLeft = undefined;
        this.paddingRight = undefined;
        this.axis = undefined;
        this.labelRotation = undefined;
        this.min = undefined;
        this.max = undefined;
        this._range = undefined;
        this.ticks = [];
        this._gridLineItems = null;
        this._labelItems = null;
        this._labelSizes = null;
        this._length = 0;
        this._maxLength = 0;
        this._longestTextCache = {};
        this._startPixel = undefined;
        this._endPixel = undefined;
        this._reversePixels = false;
        this._userMax = undefined;
        this._userMin = undefined;
        this._suggestedMax = undefined;
        this._suggestedMin = undefined;
        this._ticksLength = 0;
        this._borderValue = 0;
        this._cache = {};
        this._dataLimitsCached = false;
        this.$context = undefined;
    }
}
class TypedRegistry {
    isForType(type) {
        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
    }
    register(item) {
        const proto = Object.getPrototypeOf(item);
        let parentScope;
        if (isIChartComponent(proto)) parentScope = this.register(proto);
        const items = this.items;
        const id = item.id;
        const scope = this.scope + '.' + id;
        if (!id) throw new Error('class does not have id: ' + item);
        if (id in items) return scope;
        items[id] = item;
        registerDefaults(item, scope, parentScope);
        if (this.override) _helpersSegmentJs.d.override(item.id, item.overrides);
        return scope;
    }
    get(id) {
        return this.items[id];
    }
    unregister(item) {
        const items = this.items;
        const id = item.id;
        const scope = this.scope;
        if (id in items) delete items[id];
        if (scope && id in _helpersSegmentJs.d[scope]) {
            delete _helpersSegmentJs.d[scope][id];
            if (this.override) delete _helpersSegmentJs.a1[id];
        }
    }
    constructor(type, scope, override){
        this.type = type;
        this.scope = scope;
        this.override = override;
        this.items = Object.create(null);
    }
}
function registerDefaults(item, scope, parentScope) {
    const itemDefaults = _helpersSegmentJs.a2(Object.create(null), [
        parentScope ? _helpersSegmentJs.d.get(parentScope) : {},
        _helpersSegmentJs.d.get(scope),
        item.defaults
    ]);
    _helpersSegmentJs.d.set(scope, itemDefaults);
    if (item.defaultRoutes) routeDefaults(scope, item.defaultRoutes);
    if (item.descriptors) _helpersSegmentJs.d.describe(scope, item.descriptors);
}
function routeDefaults(scope, routes) {
    Object.keys(routes).forEach((property)=>{
        const propertyParts = property.split('.');
        const sourceName = propertyParts.pop();
        const sourceScope = [
            scope
        ].concat(propertyParts).join('.');
        const parts = routes[property].split('.');
        const targetName = parts.pop();
        const targetScope = parts.join('.');
        _helpersSegmentJs.d.route(sourceScope, sourceName, targetScope, targetName);
    });
}
function isIChartComponent(proto) {
    return 'id' in proto && 'defaults' in proto;
}
class Registry {
    add(...args) {
        this._each('register', args);
    }
    remove(...args) {
        this._each('unregister', args);
    }
    addControllers(...args) {
        this._each('register', args, this.controllers);
    }
    addElements(...args) {
        this._each('register', args, this.elements);
    }
    addPlugins(...args) {
        this._each('register', args, this.plugins);
    }
    addScales(...args) {
        this._each('register', args, this.scales);
    }
    getController(id) {
        return this._get(id, this.controllers, 'controller');
    }
    getElement(id) {
        return this._get(id, this.elements, 'element');
    }
    getPlugin(id) {
        return this._get(id, this.plugins, 'plugin');
    }
    getScale(id) {
        return this._get(id, this.scales, 'scale');
    }
    removeControllers(...args) {
        this._each('unregister', args, this.controllers);
    }
    removeElements(...args) {
        this._each('unregister', args, this.elements);
    }
    removePlugins(...args) {
        this._each('unregister', args, this.plugins);
    }
    removeScales(...args) {
        this._each('unregister', args, this.scales);
    }
    _each(method, args, typedRegistry) {
        [
            ...args
        ].forEach((arg)=>{
            const reg = typedRegistry || this._getRegistryForType(arg);
            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) this._exec(method, reg, arg);
            else _helpersSegmentJs.D(arg, (item)=>{
                const itemReg = typedRegistry || this._getRegistryForType(item);
                this._exec(method, itemReg, item);
            });
        });
    }
    _exec(method, registry1, component) {
        const camelMethod = _helpersSegmentJs.a3(method);
        _helpersSegmentJs.O(component['before' + camelMethod], [], component);
        registry1[method](component);
        _helpersSegmentJs.O(component['after' + camelMethod], [], component);
    }
    _getRegistryForType(type) {
        for(let i = 0; i < this._typedRegistries.length; i++){
            const reg = this._typedRegistries[i];
            if (reg.isForType(type)) return reg;
        }
        return this.plugins;
    }
    _get(id, typedRegistry, type) {
        const item = typedRegistry.get(id);
        if (item === undefined) throw new Error('"' + id + '" is not a registered ' + type + '.');
        return item;
    }
    constructor(){
        this.controllers = new TypedRegistry(DatasetController, 'datasets', true);
        this.elements = new TypedRegistry(Element, 'elements');
        this.plugins = new TypedRegistry(Object, 'plugins');
        this.scales = new TypedRegistry(Scale, 'scales');
        this._typedRegistries = [
            this.controllers,
            this.scales,
            this.elements
        ];
    }
}
var registry = new Registry();
class PluginService {
    notify(chart, hook, args, filter) {
        if (hook === 'beforeInit') {
            this._init = this._createDescriptors(chart, true);
            this._notify(this._init, chart, 'install');
        }
        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
        const result = this._notify(descriptors, chart, hook, args);
        if (hook === 'afterDestroy') {
            this._notify(descriptors, chart, 'stop');
            this._notify(this._init, chart, 'uninstall');
        }
        return result;
    }
    _notify(descriptors, chart, hook, args) {
        args = args || {};
        for (const descriptor of descriptors){
            const plugin = descriptor.plugin;
            const method = plugin[hook];
            const params = [
                chart,
                args,
                descriptor.options
            ];
            if (_helpersSegmentJs.O(method, params, plugin) === false && args.cancelable) return false;
        }
        return true;
    }
    invalidate() {
        if (!_helpersSegmentJs.k(this._cache)) {
            this._oldCache = this._cache;
            this._cache = undefined;
        }
    }
    _descriptors(chart) {
        if (this._cache) return this._cache;
        const descriptors = this._cache = this._createDescriptors(chart);
        this._notifyStateChanges(chart);
        return descriptors;
    }
    _createDescriptors(chart, all) {
        const config = chart && chart.config;
        const options = _helpersSegmentJs.v(config.options && config.options.plugins, {});
        const plugins1 = allPlugins(config);
        return options === false && !all ? [] : createDescriptors(chart, plugins1, options, all);
    }
    _notifyStateChanges(chart) {
        const previousDescriptors = this._oldCache || [];
        const descriptors = this._cache;
        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id
                )
            )
        ;
        this._notify(diff(previousDescriptors, descriptors), chart, 'stop');
        this._notify(diff(descriptors, previousDescriptors), chart, 'start');
    }
    constructor(){
        this._init = [];
    }
}
function allPlugins(config) {
    const plugins2 = [];
    const keys = Object.keys(registry.plugins.items);
    for(let i = 0; i < keys.length; i++)plugins2.push(registry.getPlugin(keys[i]));
    const local = config.plugins || [];
    for(let i3 = 0; i3 < local.length; i3++){
        const plugin = local[i3];
        if (plugins2.indexOf(plugin) === -1) plugins2.push(plugin);
    }
    return plugins2;
}
function getOpts(options, all) {
    if (!all && options === false) return null;
    if (options === true) return {};
    return options;
}
function createDescriptors(chart, plugins3, options, all) {
    const result = [];
    const context = chart.getContext();
    for(let i = 0; i < plugins3.length; i++){
        const plugin = plugins3[i];
        const id = plugin.id;
        const opts = getOpts(options[id], all);
        if (opts === null) continue;
        result.push({
            plugin,
            options: pluginOpts(chart.config, plugin, opts, context)
        });
    }
    return result;
}
function pluginOpts(config, plugin, opts, context) {
    const keys = config.pluginScopeKeys(plugin);
    const scopes = config.getOptionScopes(opts, keys);
    return config.createResolver(scopes, context, [
        ''
    ], {
        scriptable: false,
        indexable: false,
        allKeys: true
    });
}
function getIndexAxis(type, options) {
    const datasetDefaults = _helpersSegmentJs.d.datasets[type] || {};
    const datasetOptions = (options.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';
}
function getAxisFromDefaultScaleID(id, indexAxis) {
    let axis = id;
    if (id === '_index_') axis = indexAxis;
    else if (id === '_value_') axis = indexAxis === 'x' ? 'y' : 'x';
    return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? '_index_' : '_value_';
}
function axisFromPosition(position) {
    if (position === 'top' || position === 'bottom') return 'x';
    if (position === 'left' || position === 'right') return 'y';
}
function determineAxis(id, scaleOptions) {
    if (id === 'x' || id === 'y') return id;
    return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
}
function mergeScaleConfig(config, options) {
    const chartDefaults = _helpersSegmentJs.a1[config.type] || {
        scales: {}
    };
    const configScales = options.scales || {};
    const chartIndexAxis = getIndexAxis(config.type, options);
    const firstIDs = Object.create(null);
    const scales3 = Object.create(null);
    Object.keys(configScales).forEach((id)=>{
        const scaleConf = configScales[id];
        if (!_helpersSegmentJs.i(scaleConf)) return console.error(`Invalid scale configuration for scale: ${id}`);
        if (scaleConf._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
        const axis = determineAxis(id, scaleConf);
        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
        const defaultScaleOptions = chartDefaults.scales || {};
        firstIDs[axis] = firstIDs[axis] || id;
        scales3[id] = _helpersSegmentJs.a9(Object.create(null), [
            {
                axis
            },
            scaleConf,
            defaultScaleOptions[axis],
            defaultScaleOptions[defaultId]
        ]);
    });
    config.data.datasets.forEach((dataset)=>{
        const type = dataset.type || config.type;
        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
        const datasetDefaults = _helpersSegmentJs.a1[type] || {};
        const defaultScaleOptions = datasetDefaults.scales || {};
        Object.keys(defaultScaleOptions).forEach((defaultID)=>{
            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
            const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;
            scales3[id] = scales3[id] || Object.create(null);
            _helpersSegmentJs.a9(scales3[id], [
                {
                    axis
                },
                configScales[id],
                defaultScaleOptions[defaultID]
            ]);
        });
    });
    Object.keys(scales3).forEach((key)=>{
        const scale = scales3[key];
        _helpersSegmentJs.a9(scale, [
            _helpersSegmentJs.d.scales[scale.type],
            _helpersSegmentJs.d.scale
        ]);
    });
    return scales3;
}
function initOptions(config) {
    const options = config.options || (config.options = {});
    options.plugins = _helpersSegmentJs.v(options.plugins, {});
    options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
    data = data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    return data;
}
function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
}
const keyCache = new Map();
const keysCached = new Set();
function cachedKeys(cacheKey, generate) {
    let keys = keyCache.get(cacheKey);
    if (!keys) {
        keys = generate();
        keyCache.set(cacheKey, keys);
        keysCached.add(keys);
    }
    return keys;
}
const addIfFound = (set, obj, key)=>{
    const opts = _helpersSegmentJs.f(obj, key);
    if (opts !== undefined) set.add(opts);
};
class Config {
    get platform() {
        return this._config.platform;
    }
    get type() {
        return this._config.type;
    }
    set type(type) {
        this._config.type = type;
    }
    get data() {
        return this._config.data;
    }
    set data(data) {
        this._config.data = initData(data);
    }
    get options() {
        return this._config.options;
    }
    set options(options) {
        this._config.options = options;
    }
    get plugins() {
        return this._config.plugins;
    }
    update() {
        const config = this._config;
        this.clearCache();
        initOptions(config);
    }
    clearCache() {
        this._scopeCache.clear();
        this._resolverCache.clear();
    }
    datasetScopeKeys(datasetType) {
        return cachedKeys(datasetType, ()=>[
                [
                    `datasets.${datasetType}`,
                    ''
                ]
            ]
        );
    }
    datasetAnimationScopeKeys(datasetType, transition) {
        return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[
                [
                    `datasets.${datasetType}.transitions.${transition}`,
                    `transitions.${transition}`, 
                ],
                [
                    `datasets.${datasetType}`,
                    ''
                ]
            ]
        );
    }
    datasetElementScopeKeys(datasetType, elementType) {
        return cachedKeys(`${datasetType}-${elementType}`, ()=>[
                [
                    `datasets.${datasetType}.elements.${elementType}`,
                    `datasets.${datasetType}`,
                    `elements.${elementType}`,
                    ''
                ]
            ]
        );
    }
    pluginScopeKeys(plugin) {
        const id = plugin.id;
        const type = this.type;
        return cachedKeys(`${type}-plugin-${id}`, ()=>[
                [
                    `plugins.${id}`,
                    ...plugin.additionalOptionScopes || [], 
                ]
            ]
        );
    }
    _cachedScopes(mainScope, resetCache) {
        const _scopeCache = this._scopeCache;
        let cache = _scopeCache.get(mainScope);
        if (!cache || resetCache) {
            cache = new Map();
            _scopeCache.set(mainScope, cache);
        }
        return cache;
    }
    getOptionScopes(mainScope, keyLists, resetCache) {
        const { options , type  } = this;
        const cache = this._cachedScopes(mainScope, resetCache);
        const cached = cache.get(keyLists);
        if (cached) return cached;
        const scopes = new Set();
        keyLists.forEach((keys)=>{
            if (mainScope) {
                scopes.add(mainScope);
                keys.forEach((key)=>addIfFound(scopes, mainScope, key)
                );
            }
            keys.forEach((key)=>addIfFound(scopes, options, key)
            );
            keys.forEach((key)=>addIfFound(scopes, _helpersSegmentJs.a1[type] || {}, key)
            );
            keys.forEach((key)=>addIfFound(scopes, _helpersSegmentJs.d, key)
            );
            keys.forEach((key)=>addIfFound(scopes, _helpersSegmentJs.a4, key)
            );
        });
        const array = Array.from(scopes);
        if (array.length === 0) array.push(Object.create(null));
        if (keysCached.has(keyLists)) cache.set(keyLists, array);
        return array;
    }
    chartOptionScopes() {
        const { options , type  } = this;
        return [
            options,
            _helpersSegmentJs.a1[type] || {},
            _helpersSegmentJs.d.datasets[type] || {},
            {
                type
            },
            _helpersSegmentJs.d,
            _helpersSegmentJs.a4
        ];
    }
    resolveNamedOptions(scopes, names, context, prefixes = [
        ''
    ]) {
        const result = {
            $shared: true
        };
        const { resolver , subPrefixes  } = getResolver(this._resolverCache, scopes, prefixes);
        let options = resolver;
        if (needContext(resolver, names)) {
            result.$shared = false;
            context = _helpersSegmentJs.a5(context) ? context() : context;
            const subResolver = this.createResolver(scopes, context, subPrefixes);
            options = _helpersSegmentJs.a6(resolver, context, subResolver);
        }
        for (const prop of names)result[prop] = options[prop];
        return result;
    }
    createResolver(scopes, context, prefixes = [
        ''
    ], descriptorDefaults) {
        const { resolver  } = getResolver(this._resolverCache, scopes, prefixes);
        return _helpersSegmentJs.i(context) ? _helpersSegmentJs.a6(resolver, context, undefined, descriptorDefaults) : resolver;
    }
    constructor(config){
        this._config = initConfig(config);
        this._scopeCache = new Map();
        this._resolverCache = new Map();
    }
}
function getResolver(resolverCache, scopes, prefixes) {
    let cache = resolverCache.get(scopes);
    if (!cache) {
        cache = new Map();
        resolverCache.set(scopes, cache);
    }
    const cacheKey = prefixes.join();
    let cached = cache.get(cacheKey);
    if (!cached) {
        const resolver = _helpersSegmentJs.a7(scopes, prefixes);
        cached = {
            resolver,
            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes('hover')
            )
        };
        cache.set(cacheKey, cached);
    }
    return cached;
}
const hasFunction = (value)=>_helpersSegmentJs.i(value) && Object.getOwnPropertyNames(value).reduce((acc, key)=>acc || _helpersSegmentJs.a5(value[key])
    , false)
;
function needContext(proxy, names) {
    const { isScriptable , isIndexable  } = _helpersSegmentJs.a8(proxy);
    for (const prop of names){
        const scriptable = isScriptable(prop);
        const indexable = isIndexable(prop);
        const value = (indexable || scriptable) && proxy[prop];
        if (scriptable && (_helpersSegmentJs.a5(value) || hasFunction(value)) || indexable && _helpersSegmentJs.b(value)) return true;
    }
    return false;
}
var version = "3.7.1";
const KNOWN_POSITIONS = [
    'top',
    'bottom',
    'left',
    'right',
    'chartArea'
];
function positionIsHorizontal(position, axis) {
    return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';
}
function compare2Level(l1, l2) {
    return function(a, b) {
        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
    };
}
function onAnimationsComplete(context) {
    const chart = context.chart;
    const animationOptions1 = chart.options.animation;
    chart.notifyPlugins('afterRender');
    _helpersSegmentJs.O(animationOptions1 && animationOptions1.onComplete, [
        context
    ], chart);
}
function onAnimationProgress(context) {
    const chart = context.chart;
    const animationOptions2 = chart.options.animation;
    _helpersSegmentJs.O(animationOptions2 && animationOptions2.onProgress, [
        context
    ], chart);
}
function getCanvas(item) {
    if (_helpersSegmentJs.K() && typeof item === 'string') item = document.getElementById(item);
    else if (item && item.length) item = item[0];
    if (item && item.canvas) item = item.canvas;
    return item;
}
const instances = {};
const getChart = (key)=>{
    const canvas = getCanvas(key);
    return Object.values(instances).filter((c)=>c.canvas === canvas
    ).pop();
};
function moveNumericKeys(obj, start, move) {
    const keys = Object.keys(obj);
    for (const key of keys){
        const intKey = +key;
        if (intKey >= start) {
            const value = obj[key];
            delete obj[key];
            if (move > 0 || intKey > start) obj[intKey + move] = value;
        }
    }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e.type === 'mouseout') return null;
    if (isClick) return lastEvent;
    return e;
}
class Chart {
    get aspectRatio() {
        const { options: { aspectRatio , maintainAspectRatio  } , width , height , _aspectRatio  } = this;
        if (!_helpersSegmentJs.k(aspectRatio)) return aspectRatio;
        if (maintainAspectRatio && _aspectRatio) return _aspectRatio;
        return height ? width / height : null;
    }
    get data() {
        return this.config.data;
    }
    set data(data) {
        this.config.data = data;
    }
    get options() {
        return this._options;
    }
    set options(options) {
        this.config.options = options;
    }
    _initialize() {
        this.notifyPlugins('beforeInit');
        if (this.options.responsive) this.resize();
        else _helpersSegmentJs.ac(this, this.options.devicePixelRatio);
        this.bindEvents();
        this.notifyPlugins('afterInit');
        return this;
    }
    clear() {
        _helpersSegmentJs.ad(this.canvas, this.ctx);
        return this;
    }
    stop() {
        animator.stop(this);
        return this;
    }
    resize(width, height) {
        if (!animator.running(this)) this._resize(width, height);
        else this._resizeBeforeDraw = {
            width,
            height
        };
    }
    _resize(width, height) {
        const options = this.options;
        const canvas = this.canvas;
        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
        const mode = this.width ? 'resize' : 'attach';
        this.width = newSize.width;
        this.height = newSize.height;
        this._aspectRatio = this.aspectRatio;
        if (!_helpersSegmentJs.ac(this, newRatio, true)) return;
        this.notifyPlugins('resize', {
            size: newSize
        });
        _helpersSegmentJs.O(options.onResize, [
            this,
            newSize
        ], this);
        if (this.attached) {
            if (this._doResize(mode)) this.render();
        }
    }
    ensureScalesHaveIDs() {
        const options = this.options;
        const scalesOptions = options.scales || {};
        _helpersSegmentJs.D(scalesOptions, (axisOptions, axisID)=>{
            axisOptions.id = axisID;
        });
    }
    buildOrUpdateScales() {
        const options = this.options;
        const scaleOpts = options.scales;
        const scales4 = this.scales;
        const updated = Object.keys(scales4).reduce((obj, id)=>{
            obj[id] = false;
            return obj;
        }, {});
        let items = [];
        if (scaleOpts) items = items.concat(Object.keys(scaleOpts).map((id)=>{
            const scaleOptions = scaleOpts[id];
            const axis = determineAxis(id, scaleOptions);
            const isRadial = axis === 'r';
            const isHorizontal = axis === 'x';
            return {
                options: scaleOptions,
                dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',
                dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'
            };
        }));
        _helpersSegmentJs.D(items, (item)=>{
            const scaleOptions = item.options;
            const id = scaleOptions.id;
            const axis = determineAxis(id, scaleOptions);
            const scaleType = _helpersSegmentJs.v(scaleOptions.type, item.dtype);
            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) scaleOptions.position = item.dposition;
            updated[id] = true;
            let scale = null;
            if (id in scales4 && scales4[id].type === scaleType) scale = scales4[id];
            else {
                const scaleClass = registry.getScale(scaleType);
                scale = new scaleClass({
                    id,
                    type: scaleType,
                    ctx: this.ctx,
                    chart: this
                });
                scales4[scale.id] = scale;
            }
            scale.init(scaleOptions, options);
        });
        _helpersSegmentJs.D(updated, (hasUpdated, id)=>{
            if (!hasUpdated) delete scales4[id];
        });
        _helpersSegmentJs.D(scales4, (scale)=>{
            layouts.configure(this, scale, scale.options);
            layouts.addBox(this, scale);
        });
    }
    _updateMetasets() {
        const metasets = this._metasets;
        const numData = this.data.datasets.length;
        const numMeta = metasets.length;
        metasets.sort((a, b)=>a.index - b.index
        );
        if (numMeta > numData) {
            for(let i = numData; i < numMeta; ++i)this._destroyDatasetMeta(i);
            metasets.splice(numData, numMeta - numData);
        }
        this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));
    }
    _removeUnreferencedMetasets() {
        const { _metasets: metasets , data: { datasets  }  } = this;
        if (metasets.length > datasets.length) delete this._stacks;
        metasets.forEach((meta, index)=>{
            if (datasets.filter((x)=>x === meta._dataset
            ).length === 0) this._destroyDatasetMeta(index);
        });
    }
    buildOrUpdateControllers() {
        const newControllers = [];
        const datasets = this.data.datasets;
        let i, ilen;
        this._removeUnreferencedMetasets();
        for(i = 0, ilen = datasets.length; i < ilen; i++){
            const dataset = datasets[i];
            let meta = this.getDatasetMeta(i);
            const type = dataset.type || this.config.type;
            if (meta.type && meta.type !== type) {
                this._destroyDatasetMeta(i);
                meta = this.getDatasetMeta(i);
            }
            meta.type = type;
            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
            meta.order = dataset.order || 0;
            meta.index = i;
            meta.label = '' + dataset.label;
            meta.visible = this.isDatasetVisible(i);
            if (meta.controller) {
                meta.controller.updateIndex(i);
                meta.controller.linkScales();
            } else {
                const ControllerClass = registry.getController(type);
                const { datasetElementType , dataElementType  } = _helpersSegmentJs.d.datasets[type];
                Object.assign(ControllerClass.prototype, {
                    dataElementType: registry.getElement(dataElementType),
                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)
                });
                meta.controller = new ControllerClass(this, i);
                newControllers.push(meta.controller);
            }
        }
        this._updateMetasets();
        return newControllers;
    }
    _resetElements() {
        _helpersSegmentJs.D(this.data.datasets, (dataset, datasetIndex)=>{
            this.getDatasetMeta(datasetIndex).controller.reset();
        }, this);
    }
    reset() {
        this._resetElements();
        this.notifyPlugins('reset');
    }
    update(mode) {
        const config = this.config;
        config.update();
        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
        const animsDisabled = this._animationsDisabled = !options.animation;
        this._updateScales();
        this._checkEventBindings();
        this._updateHiddenIndices();
        this._plugins.invalidate();
        if (this.notifyPlugins('beforeUpdate', {
            mode,
            cancelable: true
        }) === false) return;
        const newControllers = this.buildOrUpdateControllers();
        this.notifyPlugins('beforeElementsUpdate');
        let minPadding = 0;
        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){
            const { controller  } = this.getDatasetMeta(i);
            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
            controller.buildOrUpdateElements(reset);
            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
        }
        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
        this._updateLayout(minPadding);
        if (!animsDisabled) _helpersSegmentJs.D(newControllers, (controller)=>{
            controller.reset();
        });
        this._updateDatasets(mode);
        this.notifyPlugins('afterUpdate', {
            mode
        });
        this._layers.sort(compare2Level('z', '_idx'));
        const { _active , _lastEvent  } = this;
        if (_lastEvent) this._eventHandler(_lastEvent, true);
        else if (_active.length) this._updateHoverStyles(_active, _active, true);
        this.render();
    }
    _updateScales() {
        _helpersSegmentJs.D(this.scales, (scale)=>{
            layouts.removeBox(this, scale);
        });
        this.ensureScalesHaveIDs();
        this.buildOrUpdateScales();
    }
    _checkEventBindings() {
        const options = this.options;
        const existingEvents = new Set(Object.keys(this._listeners));
        const newEvents = new Set(options.events);
        if (!_helpersSegmentJs.ae(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
            this.unbindEvents();
            this.bindEvents();
        }
    }
    _updateHiddenIndices() {
        const { _hiddenIndices  } = this;
        const changes = this._getUniformDataChanges() || [];
        for (const { method , start , count  } of changes){
            const move = method === '_removeElements' ? -count : count;
            moveNumericKeys(_hiddenIndices, start, move);
        }
    }
    _getUniformDataChanges() {
        const _dataChanges = this._dataChanges;
        if (!_dataChanges || !_dataChanges.length) return;
        this._dataChanges = [];
        const datasetCount = this.data.datasets.length;
        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx
            ).map((c, i)=>i + ',' + c.splice(1).join(',')
            ))
        ;
        const changeSet = makeSet(0);
        for(let i4 = 1; i4 < datasetCount; i4++){
            if (!_helpersSegmentJs.ae(changeSet, makeSet(i4))) return;
        }
        return Array.from(changeSet).map((c)=>c.split(',')
        ).map((a)=>({
                method: a[1],
                start: +a[2],
                count: +a[3]
            })
        );
    }
    _updateLayout(minPadding) {
        if (this.notifyPlugins('beforeLayout', {
            cancelable: true
        }) === false) return;
        layouts.update(this, this.width, this.height, minPadding);
        const area = this.chartArea;
        const noArea = area.width <= 0 || area.height <= 0;
        this._layers = [];
        _helpersSegmentJs.D(this.boxes, (box)=>{
            if (noArea && box.position === 'chartArea') return;
            if (box.configure) box.configure();
            this._layers.push(...box._layers());
        }, this);
        this._layers.forEach((item, index)=>{
            item._idx = index;
        });
        this.notifyPlugins('afterLayout');
    }
    _updateDatasets(mode) {
        if (this.notifyPlugins('beforeDatasetsUpdate', {
            mode,
            cancelable: true
        }) === false) return;
        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i)this.getDatasetMeta(i).controller.configure();
        for(let i5 = 0, ilen1 = this.data.datasets.length; i5 < ilen1; ++i5)this._updateDataset(i5, _helpersSegmentJs.a5(mode) ? mode({
            datasetIndex: i5
        }) : mode);
        this.notifyPlugins('afterDatasetsUpdate', {
            mode
        });
    }
    _updateDataset(index, mode) {
        const meta = this.getDatasetMeta(index);
        const args = {
            meta,
            index,
            mode,
            cancelable: true
        };
        if (this.notifyPlugins('beforeDatasetUpdate', args) === false) return;
        meta.controller._update(mode);
        args.cancelable = false;
        this.notifyPlugins('afterDatasetUpdate', args);
    }
    render() {
        if (this.notifyPlugins('beforeRender', {
            cancelable: true
        }) === false) return;
        if (animator.has(this)) {
            if (this.attached && !animator.running(this)) animator.start(this);
        } else {
            this.draw();
            onAnimationsComplete({
                chart: this
            });
        }
    }
    draw() {
        let i;
        if (this._resizeBeforeDraw) {
            const { width , height  } = this._resizeBeforeDraw;
            this._resize(width, height);
            this._resizeBeforeDraw = null;
        }
        this.clear();
        if (this.width <= 0 || this.height <= 0) return;
        if (this.notifyPlugins('beforeDraw', {
            cancelable: true
        }) === false) return;
        const layers = this._layers;
        for(i = 0; i < layers.length && layers[i].z <= 0; ++i)layers[i].draw(this.chartArea);
        this._drawDatasets();
        for(; i < layers.length; ++i)layers[i].draw(this.chartArea);
        this.notifyPlugins('afterDraw');
    }
    _getSortedDatasetMetas(filterVisible) {
        const metasets = this._sortedMetasets;
        const result = [];
        let i, ilen;
        for(i = 0, ilen = metasets.length; i < ilen; ++i){
            const meta = metasets[i];
            if (!filterVisible || meta.visible) result.push(meta);
        }
        return result;
    }
    getSortedVisibleDatasetMetas() {
        return this._getSortedDatasetMetas(true);
    }
    _drawDatasets() {
        if (this.notifyPlugins('beforeDatasetsDraw', {
            cancelable: true
        }) === false) return;
        const metasets = this.getSortedVisibleDatasetMetas();
        for(let i = metasets.length - 1; i >= 0; --i)this._drawDataset(metasets[i]);
        this.notifyPlugins('afterDatasetsDraw');
    }
    _drawDataset(meta) {
        const ctx = this.ctx;
        const clip = meta._clip;
        const useClip = !clip.disabled;
        const area = this.chartArea;
        const args = {
            meta,
            index: meta.index,
            cancelable: true
        };
        if (this.notifyPlugins('beforeDatasetDraw', args) === false) return;
        if (useClip) _helpersSegmentJs.W(ctx, {
            left: clip.left === false ? 0 : area.left - clip.left,
            right: clip.right === false ? this.width : area.right + clip.right,
            top: clip.top === false ? 0 : area.top - clip.top,
            bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
        });
        meta.controller.draw();
        if (useClip) _helpersSegmentJs.Y(ctx);
        args.cancelable = false;
        this.notifyPlugins('afterDatasetDraw', args);
    }
    getElementsAtEventForMode(e, mode, options, useFinalPosition) {
        const method = Interaction.modes[mode];
        if (typeof method === 'function') return method(this, e, options, useFinalPosition);
        return [];
    }
    getDatasetMeta(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        const metasets = this._metasets;
        let meta = metasets.filter((x)=>x && x._dataset === dataset
        ).pop();
        if (!meta) {
            meta = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: dataset && dataset.order || 0,
                index: datasetIndex,
                _dataset: dataset,
                _parsed: [],
                _sorted: false
            };
            metasets.push(meta);
        }
        return meta;
    }
    getContext() {
        return this.$context || (this.$context = _helpersSegmentJs.h(null, {
            chart: this,
            type: 'chart'
        }));
    }
    getVisibleDatasetCount() {
        return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        if (!dataset) return false;
        const meta = this.getDatasetMeta(datasetIndex);
        return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;
    }
    setDatasetVisibility(datasetIndex, visible) {
        const meta = this.getDatasetMeta(datasetIndex);
        meta.hidden = !visible;
    }
    toggleDataVisibility(index) {
        this._hiddenIndices[index] = !this._hiddenIndices[index];
    }
    getDataVisibility(index) {
        return !this._hiddenIndices[index];
    }
    _updateVisibility(datasetIndex, dataIndex, visible) {
        const mode = visible ? 'show' : 'hide';
        const meta = this.getDatasetMeta(datasetIndex);
        const anims = meta.controller._resolveAnimations(undefined, mode);
        if (_helpersSegmentJs.j(dataIndex)) {
            meta.data[dataIndex].hidden = !visible;
            this.update();
        } else {
            this.setDatasetVisibility(datasetIndex, visible);
            anims.update(meta, {
                visible
            });
            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined
            );
        }
    }
    hide(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, false);
    }
    show(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, true);
    }
    _destroyDatasetMeta(datasetIndex) {
        const meta = this._metasets[datasetIndex];
        if (meta && meta.controller) meta.controller._destroy();
        delete this._metasets[datasetIndex];
    }
    _stop() {
        let i, ilen;
        this.stop();
        animator.remove(this);
        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i)this._destroyDatasetMeta(i);
    }
    destroy() {
        this.notifyPlugins('beforeDestroy');
        const { canvas , ctx  } = this;
        this._stop();
        this.config.clearCache();
        if (canvas) {
            this.unbindEvents();
            _helpersSegmentJs.ad(canvas, ctx);
            this.platform.releaseContext(ctx);
            this.canvas = null;
            this.ctx = null;
        }
        this.notifyPlugins('destroy');
        delete instances[this.id];
        this.notifyPlugins('afterDestroy');
    }
    toBase64Image(...args) {
        return this.canvas.toDataURL(...args);
    }
    bindEvents() {
        this.bindUserEvents();
        if (this.options.responsive) this.bindResponsiveEvents();
        else this.attached = true;
    }
    bindUserEvents() {
        const listeners = this._listeners;
        const platform = this.platform;
        const _add = (type, listener)=>{
            platform.addEventListener(this, type, listener);
            listeners[type] = listener;
        };
        const listener1 = (e, x, y)=>{
            e.offsetX = x;
            e.offsetY = y;
            this._eventHandler(e);
        };
        _helpersSegmentJs.D(this.options.events, (type)=>_add(type, listener1)
        );
    }
    bindResponsiveEvents() {
        if (!this._responsiveListeners) this._responsiveListeners = {};
        const listeners = this._responsiveListeners;
        const platform = this.platform;
        const _add = (type, listener)=>{
            platform.addEventListener(this, type, listener);
            listeners[type] = listener;
        };
        const _remove = (type, listener)=>{
            if (listeners[type]) {
                platform.removeEventListener(this, type, listener);
                delete listeners[type];
            }
        };
        const listener2 = (width, height)=>{
            if (this.canvas) this.resize(width, height);
        };
        let detached;
        const attached = ()=>{
            _remove('attach', attached);
            this.attached = true;
            this.resize();
            _add('resize', listener2);
            _add('detach', detached);
        };
        detached = ()=>{
            this.attached = false;
            _remove('resize', listener2);
            this._stop();
            this._resize(0, 0);
            _add('attach', attached);
        };
        if (platform.isAttached(this.canvas)) attached();
        else detached();
    }
    unbindEvents() {
        _helpersSegmentJs.D(this._listeners, (listener, type)=>{
            this.platform.removeEventListener(this, type, listener);
        });
        this._listeners = {};
        _helpersSegmentJs.D(this._responsiveListeners, (listener, type)=>{
            this.platform.removeEventListener(this, type, listener);
        });
        this._responsiveListeners = undefined;
    }
    updateHoverStyle(items, mode, enabled) {
        const prefix = enabled ? 'set' : 'remove';
        let meta, item, i, ilen;
        if (mode === 'dataset') {
            meta = this.getDatasetMeta(items[0].datasetIndex);
            meta.controller['_' + prefix + 'DatasetHoverStyle']();
        }
        for(i = 0, ilen = items.length; i < ilen; ++i){
            item = items[i];
            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
            if (controller) controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);
        }
    }
    getActiveElements() {
        return this._active || [];
    }
    setActiveElements(activeElements) {
        const lastActive = this._active || [];
        const active = activeElements.map(({ datasetIndex , index  })=>{
            const meta = this.getDatasetMeta(datasetIndex);
            if (!meta) throw new Error('No dataset found at index ' + datasetIndex);
            return {
                datasetIndex,
                element: meta.data[index],
                index
            };
        });
        const changed = !_helpersSegmentJs.af(active, lastActive);
        if (changed) {
            this._active = active;
            this._lastEvent = null;
            this._updateHoverStyles(active, lastActive);
        }
    }
    notifyPlugins(hook, args, filter) {
        return this._plugins.notify(this, hook, args, filter);
    }
    _updateHoverStyles(active, lastActive, replay) {
        const hoverOptions = this.options.hover;
        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index
                )
            )
        ;
        const deactivated = diff(lastActive, active);
        const activated = replay ? active : diff(active, lastActive);
        if (deactivated.length) this.updateHoverStyle(deactivated, hoverOptions.mode, false);
        if (activated.length && hoverOptions.mode) this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
    _eventHandler(e, replay) {
        const args = {
            event: e,
            replay,
            cancelable: true,
            inChartArea: _helpersSegmentJs.z(e, this.chartArea, this._minPadding)
        };
        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type)
        ;
        if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) return;
        const changed = this._handleEvent(e, replay, args.inChartArea);
        args.cancelable = false;
        this.notifyPlugins('afterEvent', args, eventFilter);
        if (changed || args.changed) this.render();
        return this;
    }
    _handleEvent(e, replay, inChartArea) {
        const { _active: lastActive = [] , options  } = this;
        const useFinalPosition = replay;
        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
        const isClick = _helpersSegmentJs.ag(e);
        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
        if (inChartArea) {
            this._lastEvent = null;
            _helpersSegmentJs.O(options.onHover, [
                e,
                active,
                this
            ], this);
            if (isClick) _helpersSegmentJs.O(options.onClick, [
                e,
                active,
                this
            ], this);
        }
        const changed = !_helpersSegmentJs.af(active, lastActive);
        if (changed || replay) {
            this._active = active;
            this._updateHoverStyles(active, lastActive, replay);
        }
        this._lastEvent = lastEvent;
        return changed;
    }
    _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
        if (e.type === 'mouseout') return [];
        if (!inChartArea) return lastActive;
        const hoverOptions = this.options.hover;
        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
    }
    constructor(item, userConfig){
        const config = this.config = new Config(userConfig);
        const initialCanvas = getCanvas(item);
        const existingChart = getChart(initialCanvas);
        if (existingChart) throw new Error('Canvas is already in use. Chart with ID \'' + existingChart.id + '\'' + ' must be destroyed before the canvas can be reused.');
        const options = config.createResolver(config.chartOptionScopes(), this.getContext());
        this.platform = new (config.platform || _detectPlatform(initialCanvas))();
        this.platform.updateConfig(config);
        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
        const canvas = context && context.canvas;
        const height = canvas && canvas.height;
        const width = canvas && canvas.width;
        this.id = _helpersSegmentJs.aa();
        this.ctx = context;
        this.canvas = canvas;
        this.width = width;
        this.height = height;
        this._options = options;
        this._aspectRatio = this.aspectRatio;
        this._layers = [];
        this._metasets = [];
        this._stacks = undefined;
        this.boxes = [];
        this.currentDevicePixelRatio = undefined;
        this.chartArea = undefined;
        this._active = [];
        this._lastEvent = undefined;
        this._listeners = {};
        this._responsiveListeners = undefined;
        this._sortedMetasets = [];
        this.scales = {};
        this._plugins = new PluginService();
        this.$proxies = {};
        this._hiddenIndices = {};
        this.attached = false;
        this._animationsDisabled = undefined;
        this.$context = undefined;
        this._doResize = _helpersSegmentJs.ab((mode)=>this.update(mode)
        , options.resizeDelay || 0);
        this._dataChanges = [];
        instances[this.id] = this;
        if (!context || !canvas) {
            console.error("Failed to create chart: can't acquire context from the given item");
            return;
        }
        animator.listen(this, 'complete', onAnimationsComplete);
        animator.listen(this, 'progress', onAnimationProgress);
        this._initialize();
        if (this.attached) this.update();
    }
}
const invalidatePlugins = ()=>_helpersSegmentJs.D(Chart.instances, (chart)=>chart._plugins.invalidate()
    )
;
const enumerable = true;
Object.defineProperties(Chart, {
    defaults: {
        enumerable,
        value: _helpersSegmentJs.d
    },
    instances: {
        enumerable,
        value: instances
    },
    overrides: {
        enumerable,
        value: _helpersSegmentJs.a1
    },
    registry: {
        enumerable,
        value: registry
    },
    version: {
        enumerable,
        value: version
    },
    getChart: {
        enumerable,
        value: getChart
    },
    register: {
        enumerable,
        value: (...items)=>{
            registry.add(...items);
            invalidatePlugins();
        }
    },
    unregister: {
        enumerable,
        value: (...items)=>{
            registry.remove(...items);
            invalidatePlugins();
        }
    }
});
function clipArc(ctx, element, endAngle) {
    const { startAngle , pixelMargin , x , y , outerRadius , innerRadius  } = element;
    let angleMargin = pixelMargin / outerRadius;
    ctx.beginPath();
    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
        angleMargin = pixelMargin / innerRadius;
        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else ctx.arc(x, y, pixelMargin, endAngle + _helpersSegmentJs.H, startAngle - _helpersSegmentJs.H);
    ctx.closePath();
    ctx.clip();
}
function toRadiusCorners(value) {
    return _helpersSegmentJs.ai(value, [
        'outerStart',
        'outerEnd',
        'innerStart',
        'innerEnd'
    ]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    const o = toRadiusCorners(arc.options.borderRadius);
    const halfThickness = (outerRadius - innerRadius) / 2;
    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
    const computeOuterLimit = (val)=>{
        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
        return _helpersSegmentJs.w(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
        outerStart: computeOuterLimit(o.outerStart),
        outerEnd: computeOuterLimit(o.outerEnd),
        innerStart: _helpersSegmentJs.w(o.innerStart, 0, innerLimit),
        innerEnd: _helpersSegmentJs.w(o.innerEnd, 0, innerLimit)
    };
}
function rThetaToXY(r, theta, x, y) {
    return {
        x: x + r * Math.cos(theta),
        y: y + r * Math.sin(theta)
    };
}
function pathArc(ctx, element, offset, spacing, end) {
    const { x , y , startAngle: start , pixelMargin , innerRadius: innerR  } = element;
    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
    let spacingOffset = 0;
    const alpha = end - start;
    if (spacing) {
        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
        spacingOffset = (alpha - adjustedAngle) / 2;
    }
    const beta = Math.max(0.001, alpha * outerRadius - offset / _helpersSegmentJs.P) / outerRadius;
    const angleOffset = (alpha - beta) / 2;
    const startAngle = start + angleOffset + spacingOffset;
    const endAngle = end - angleOffset - spacingOffset;
    const { outerStart , outerEnd , innerStart , innerEnd  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
    const outerStartAdjustedRadius = outerRadius - outerStart;
    const outerEndAdjustedRadius = outerRadius - outerEnd;
    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    const innerStartAdjustedRadius = innerRadius + innerStart;
    const innerEndAdjustedRadius = innerRadius + innerEnd;
    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
        const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + _helpersSegmentJs.H);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
        const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + _helpersSegmentJs.H, innerEndAdjustedAngle + Math.PI);
    }
    ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
        const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - _helpersSegmentJs.H);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
        const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - _helpersSegmentJs.H, outerStartAdjustedAngle);
    }
    ctx.closePath();
}
function drawArc(ctx, element, offset, spacing) {
    const { fullCircles , startAngle , circumference  } = element;
    let endAngle = element.endAngle;
    if (fullCircles) {
        pathArc(ctx, element, offset, spacing, startAngle + _helpersSegmentJs.T);
        for(let i = 0; i < fullCircles; ++i)ctx.fill();
        if (!isNaN(circumference)) {
            endAngle = startAngle + circumference % _helpersSegmentJs.T;
            if (circumference % _helpersSegmentJs.T === 0) endAngle += _helpersSegmentJs.T;
        }
    }
    pathArc(ctx, element, offset, spacing, endAngle);
    ctx.fill();
    return endAngle;
}
function drawFullCircleBorders(ctx, element, inner) {
    const { x , y , startAngle , pixelMargin , fullCircles  } = element;
    const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
    const innerRadius = element.innerRadius + pixelMargin;
    let i;
    if (inner) clipArc(ctx, element, startAngle + _helpersSegmentJs.T);
    ctx.beginPath();
    ctx.arc(x, y, innerRadius, startAngle + _helpersSegmentJs.T, startAngle, true);
    for(i = 0; i < fullCircles; ++i)ctx.stroke();
    ctx.beginPath();
    ctx.arc(x, y, outerRadius, startAngle, startAngle + _helpersSegmentJs.T);
    for(i = 0; i < fullCircles; ++i)ctx.stroke();
}
function drawBorder(ctx, element, offset, spacing, endAngle) {
    const { options  } = element;
    const { borderWidth , borderJoinStyle  } = options;
    const inner = options.borderAlign === 'inner';
    if (!borderWidth) return;
    if (inner) {
        ctx.lineWidth = borderWidth * 2;
        ctx.lineJoin = borderJoinStyle || 'round';
    } else {
        ctx.lineWidth = borderWidth;
        ctx.lineJoin = borderJoinStyle || 'bevel';
    }
    if (element.fullCircles) drawFullCircleBorders(ctx, element, inner);
    if (inner) clipArc(ctx, element, endAngle);
    pathArc(ctx, element, offset, spacing, endAngle);
    ctx.stroke();
}
class ArcElement extends Element {
    inRange(chartX, chartY, useFinalPosition) {
        const point = this.getProps([
            'x',
            'y'
        ], useFinalPosition);
        const { angle , distance  } = _helpersSegmentJs.B(point, {
            x: chartX,
            y: chartY
        });
        const { startAngle , endAngle , innerRadius , outerRadius , circumference  } = this.getProps([
            'startAngle',
            'endAngle',
            'innerRadius',
            'outerRadius',
            'circumference'
        ], useFinalPosition);
        const rAdjust = this.options.spacing / 2;
        const _circumference = _helpersSegmentJs.v(circumference, endAngle - startAngle);
        const betweenAngles = _circumference >= _helpersSegmentJs.T || _helpersSegmentJs.p(angle, startAngle, endAngle);
        const withinRadius = _helpersSegmentJs.ah(distance, innerRadius + rAdjust, outerRadius + rAdjust);
        return betweenAngles && withinRadius;
    }
    getCenterPoint(useFinalPosition) {
        const { x , y , startAngle , endAngle , innerRadius , outerRadius  } = this.getProps([
            'x',
            'y',
            'startAngle',
            'endAngle',
            'innerRadius',
            'outerRadius',
            'circumference', 
        ], useFinalPosition);
        const { offset , spacing  } = this.options;
        const halfAngle = (startAngle + endAngle) / 2;
        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
        return {
            x: x + Math.cos(halfAngle) * halfRadius,
            y: y + Math.sin(halfAngle) * halfRadius
        };
    }
    tooltipPosition(useFinalPosition) {
        return this.getCenterPoint(useFinalPosition);
    }
    draw(ctx) {
        const { options , circumference  } = this;
        const offset = (options.offset || 0) / 2;
        const spacing = (options.spacing || 0) / 2;
        this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;
        this.fullCircles = circumference > _helpersSegmentJs.T ? Math.floor(circumference / _helpersSegmentJs.T) : 0;
        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) return;
        ctx.save();
        let radiusOffset = 0;
        if (offset) {
            radiusOffset = offset / 2;
            const halfAngle = (this.startAngle + this.endAngle) / 2;
            ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
            if (this.circumference >= _helpersSegmentJs.P) radiusOffset = offset;
        }
        ctx.fillStyle = options.backgroundColor;
        ctx.strokeStyle = options.borderColor;
        const endAngle = drawArc(ctx, this, radiusOffset, spacing);
        drawBorder(ctx, this, radiusOffset, spacing, endAngle);
        ctx.restore();
    }
    constructor(cfg){
        super();
        this.options = undefined;
        this.circumference = undefined;
        this.startAngle = undefined;
        this.endAngle = undefined;
        this.innerRadius = undefined;
        this.outerRadius = undefined;
        this.pixelMargin = 0;
        this.fullCircles = 0;
        if (cfg) Object.assign(this, cfg);
    }
}
ArcElement.id = 'arc';
ArcElement.defaults = {
    borderAlign: 'center',
    borderColor: '#fff',
    borderJoinStyle: undefined,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: undefined
};
ArcElement.defaultRoutes = {
    backgroundColor: 'backgroundColor'
};
function setStyle(ctx, options, style = options) {
    ctx.lineCap = _helpersSegmentJs.v(style.borderCapStyle, options.borderCapStyle);
    ctx.setLineDash(_helpersSegmentJs.v(style.borderDash, options.borderDash));
    ctx.lineDashOffset = _helpersSegmentJs.v(style.borderDashOffset, options.borderDashOffset);
    ctx.lineJoin = _helpersSegmentJs.v(style.borderJoinStyle, options.borderJoinStyle);
    ctx.lineWidth = _helpersSegmentJs.v(style.borderWidth, options.borderWidth);
    ctx.strokeStyle = _helpersSegmentJs.v(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
    if (options.stepped) return _helpersSegmentJs.ap;
    if (options.tension || options.cubicInterpolationMode === 'monotone') return _helpersSegmentJs.aq;
    return lineTo;
}
function pathVars(points, segment, params = {}) {
    const count = points.length;
    const { start: paramsStart = 0 , end: paramsEnd = count - 1  } = params;
    const { start: segmentStart , end: segmentEnd  } = segment;
    const start = Math.max(paramsStart, segmentStart);
    const end = Math.min(paramsEnd, segmentEnd);
    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
        count,
        start,
        loop: segment.loop,
        ilen: end < start && !outside ? count + end - start : end - start
    };
}
function pathSegment(ctx, line, segment, params) {
    const { points , options  } = line;
    const { count , start , loop , ilen  } = pathVars(points, segment, params);
    const lineMethod = getLineMethod(options);
    let { move =true , reverse  } = params || {};
    let i, point, prev;
    for(i = 0; i <= ilen; ++i){
        point = points[(start + (reverse ? ilen - i : i)) % count];
        if (point.skip) continue;
        else if (move) {
            ctx.moveTo(point.x, point.y);
            move = false;
        } else lineMethod(ctx, prev, point, reverse, options.stepped);
        prev = point;
    }
    if (loop) {
        point = points[(start + (reverse ? ilen : 0)) % count];
        lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
    const points = line.points;
    const { count , start , ilen  } = pathVars(points, segment, params);
    const { move =true , reverse  } = params || {};
    let avgX = 0;
    let countX = 0;
    let i, point, prevX, minY, maxY, lastY;
    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count
    ;
    const drawX = ()=>{
        if (minY !== maxY) {
            ctx.lineTo(avgX, maxY);
            ctx.lineTo(avgX, minY);
            ctx.lineTo(avgX, lastY);
        }
    };
    if (move) {
        point = points[pointIndex(0)];
        ctx.moveTo(point.x, point.y);
    }
    for(i = 0; i <= ilen; ++i){
        point = points[pointIndex(i)];
        if (point.skip) continue;
        const x = point.x;
        const y = point.y;
        const truncX = x | 0;
        if (truncX === prevX) {
            if (y < minY) minY = y;
            else if (y > maxY) maxY = y;
            avgX = (countX * avgX + x) / ++countX;
        } else {
            drawX();
            ctx.lineTo(x, y);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
        }
        lastY = y;
    }
    drawX();
}
function _getSegmentMethod(line) {
    const opts = line.options;
    const borderDash = opts.borderDash && opts.borderDash.length;
    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
    if (options.stepped) return _helpersSegmentJs.am;
    if (options.tension || options.cubicInterpolationMode === 'monotone') return _helpersSegmentJs.an;
    return _helpersSegmentJs.ao;
}
function strokePathWithCache(ctx, line, start, count) {
    let path = line._path;
    if (!path) {
        path = line._path = new Path2D();
        if (line.path(path, start, count)) path.closePath();
    }
    setStyle(ctx, line.options);
    ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
    const { segments , options  } = line;
    const segmentMethod = _getSegmentMethod(line);
    for (const segment of segments){
        setStyle(ctx, options, segment.style);
        ctx.beginPath();
        if (segmentMethod(ctx, line, segment, {
            start,
            end: start + count - 1
        })) ctx.closePath();
        ctx.stroke();
    }
}
const usePath2D = typeof Path2D === 'function';
function draw(ctx, line, start, count) {
    if (usePath2D && !line.options.segment) strokePathWithCache(ctx, line, start, count);
    else strokePathDirect(ctx, line, start, count);
}
class LineElement extends Element {
    updateControlPoints(chartArea, indexAxis) {
        const options = this.options;
        if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {
            const loop = options.spanGaps ? this._loop : this._fullLoop;
            _helpersSegmentJs.aj(this._points, options, chartArea, loop, indexAxis);
            this._pointsUpdated = true;
        }
    }
    set points(points) {
        this._points = points;
        delete this._segments;
        delete this._path;
        this._pointsUpdated = false;
    }
    get points() {
        return this._points;
    }
    get segments() {
        return this._segments || (this._segments = _helpersSegmentJs.ak(this, this.options.segment));
    }
    first() {
        const segments = this.segments;
        const points = this.points;
        return segments.length && points[segments[0].start];
    }
    last() {
        const segments = this.segments;
        const points = this.points;
        const count = segments.length;
        return count && points[segments[count - 1].end];
    }
    interpolate(point, property) {
        const options = this.options;
        const value = point[property];
        const points = this.points;
        const segments = _helpersSegmentJs.al(this, {
            property,
            start: value,
            end: value
        });
        if (!segments.length) return;
        const result = [];
        const _interpolate = _getInterpolationMethod(options);
        let i, ilen;
        for(i = 0, ilen = segments.length; i < ilen; ++i){
            const { start , end  } = segments[i];
            const p1 = points[start];
            const p2 = points[end];
            if (p1 === p2) {
                result.push(p1);
                continue;
            }
            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
            const interpolated = _interpolate(p1, p2, t, options.stepped);
            interpolated[property] = point[property];
            result.push(interpolated);
        }
        return result.length === 1 ? result[0] : result;
    }
    pathSegment(ctx, segment, params) {
        const segmentMethod = _getSegmentMethod(this);
        return segmentMethod(ctx, this, segment, params);
    }
    path(ctx, start, count) {
        const segments = this.segments;
        const segmentMethod = _getSegmentMethod(this);
        let loop = this._loop;
        start = start || 0;
        count = count || this.points.length - start;
        for (const segment of segments)loop &= segmentMethod(ctx, this, segment, {
            start,
            end: start + count - 1
        });
        return !!loop;
    }
    draw(ctx, chartArea, start, count) {
        const options = this.options || {};
        const points = this.points || [];
        if (points.length && options.borderWidth) {
            ctx.save();
            draw(ctx, this, start, count);
            ctx.restore();
        }
        if (this.animated) {
            this._pointsUpdated = false;
            this._path = undefined;
        }
    }
    constructor(cfg){
        super();
        this.animated = true;
        this.options = undefined;
        this._chart = undefined;
        this._loop = undefined;
        this._fullLoop = undefined;
        this._path = undefined;
        this._points = undefined;
        this._segments = undefined;
        this._decimated = false;
        this._pointsUpdated = false;
        this._datasetIndex = undefined;
        if (cfg) Object.assign(this, cfg);
    }
}
LineElement.id = 'line';
LineElement.defaults = {
    borderCapStyle: 'butt',
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: 'miter',
    borderWidth: 3,
    capBezierPoints: true,
    cubicInterpolationMode: 'default',
    fill: false,
    spanGaps: false,
    stepped: false,
    tension: 0
};
LineElement.defaultRoutes = {
    backgroundColor: 'backgroundColor',
    borderColor: 'borderColor'
};
LineElement.descriptors = {
    _scriptable: true,
    _indexable: (name)=>name !== 'borderDash' && name !== 'fill'
};
function inRange$1(el, pos, axis, useFinalPosition) {
    const options = el.options;
    const { [axis]: value  } = el.getProps([
        axis
    ], useFinalPosition);
    return Math.abs(pos - value) < options.radius + options.hitRadius;
}
class PointElement extends Element {
    inRange(mouseX, mouseY, useFinalPosition) {
        const options = this.options;
        const { x , y  } = this.getProps([
            'x',
            'y'
        ], useFinalPosition);
        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
    }
    inXRange(mouseX, useFinalPosition) {
        return inRange$1(this, mouseX, 'x', useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
        return inRange$1(this, mouseY, 'y', useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
        const { x , y  } = this.getProps([
            'x',
            'y'
        ], useFinalPosition);
        return {
            x,
            y
        };
    }
    size(options) {
        options = options || this.options || {};
        let radius = options.radius || 0;
        radius = Math.max(radius, radius && options.hoverRadius || 0);
        const borderWidth = radius && options.borderWidth || 0;
        return (radius + borderWidth) * 2;
    }
    draw(ctx, area) {
        const options = this.options;
        if (this.skip || options.radius < 0.1 || !_helpersSegmentJs.z(this, area, this.size(options) / 2)) return;
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.fillStyle = options.backgroundColor;
        _helpersSegmentJs.ar(ctx, options, this.x, this.y);
    }
    getRange() {
        const options = this.options || {};
        return options.radius + options.hitRadius;
    }
    constructor(cfg){
        super();
        this.options = undefined;
        this.parsed = undefined;
        this.skip = undefined;
        this.stop = undefined;
        if (cfg) Object.assign(this, cfg);
    }
}
PointElement.id = 'point';
PointElement.defaults = {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: 'circle',
    radius: 3,
    rotation: 0
};
PointElement.defaultRoutes = {
    backgroundColor: 'backgroundColor',
    borderColor: 'borderColor'
};
function getBarBounds(bar, useFinalPosition) {
    const { x , y , base , width , height  } = bar.getProps([
        'x',
        'y',
        'base',
        'width',
        'height'
    ], useFinalPosition);
    let left, right, top, bottom, half;
    if (bar.horizontal) {
        half = height / 2;
        left = Math.min(x, base);
        right = Math.max(x, base);
        top = y - half;
        bottom = y + half;
    } else {
        half = width / 2;
        left = x - half;
        right = x + half;
        top = Math.min(y, base);
        bottom = Math.max(y, base);
    }
    return {
        left,
        top,
        right,
        bottom
    };
}
function skipOrLimit(skip1, value, min, max) {
    return skip1 ? 0 : _helpersSegmentJs.w(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
    const value = bar.options.borderWidth;
    const skip2 = bar.borderSkipped;
    const o = _helpersSegmentJs.at(value);
    return {
        t: skipOrLimit(skip2.top, o.top, 0, maxH),
        r: skipOrLimit(skip2.right, o.right, 0, maxW),
        b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
        l: skipOrLimit(skip2.left, o.left, 0, maxW)
    };
}
function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius  } = bar.getProps([
        'enableBorderRadius'
    ]);
    const value = bar.options.borderRadius;
    const o = _helpersSegmentJs.au(value);
    const maxR = Math.min(maxW, maxH);
    const skip3 = bar.borderSkipped;
    const enableBorder = enableBorderRadius || _helpersSegmentJs.i(value);
    return {
        topLeft: skipOrLimit(!enableBorder || skip3.top || skip3.left, o.topLeft, 0, maxR),
        topRight: skipOrLimit(!enableBorder || skip3.top || skip3.right, o.topRight, 0, maxR),
        bottomLeft: skipOrLimit(!enableBorder || skip3.bottom || skip3.left, o.bottomLeft, 0, maxR),
        bottomRight: skipOrLimit(!enableBorder || skip3.bottom || skip3.right, o.bottomRight, 0, maxR)
    };
}
function boundingRects(bar) {
    const bounds = getBarBounds(bar);
    const width = bounds.right - bounds.left;
    const height = bounds.bottom - bounds.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
        outer: {
            x: bounds.left,
            y: bounds.top,
            w: width,
            h: height,
            radius
        },
        inner: {
            x: bounds.left + border.l,
            y: bounds.top + border.t,
            w: width - border.l - border.r,
            h: height - border.t - border.b,
            radius: {
                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
            }
        }
    };
}
function inRange(bar, x, y, useFinalPosition) {
    const skipX = x === null;
    const skipY = y === null;
    const skipBoth = skipX && skipY;
    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds && (skipX || _helpersSegmentJs.ah(x, bounds.left, bounds.right)) && (skipY || _helpersSegmentJs.ah(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
    const x = rect.x !== refRect.x ? -amount : 0;
    const y = rect.y !== refRect.y ? -amount : 0;
    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
    return {
        x: rect.x + x,
        y: rect.y + y,
        w: rect.w + w,
        h: rect.h + h,
        radius: rect.radius
    };
}
class BarElement extends Element {
    draw(ctx) {
        const { inflateAmount , options: { borderColor , backgroundColor  }  } = this;
        const { inner , outer  } = boundingRects(this);
        const addRectPath = hasRadius(outer.radius) ? _helpersSegmentJs.as : addNormalRectPath;
        ctx.save();
        if (outer.w !== inner.w || outer.h !== inner.h) {
            ctx.beginPath();
            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
            ctx.clip();
            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
            ctx.fillStyle = borderColor;
            ctx.fill('evenodd');
        }
        ctx.beginPath();
        addRectPath(ctx, inflateRect(inner, inflateAmount));
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
    }
    inRange(mouseX, mouseY, useFinalPosition) {
        return inRange(this, mouseX, mouseY, useFinalPosition);
    }
    inXRange(mouseX, useFinalPosition) {
        return inRange(this, mouseX, null, useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
        return inRange(this, null, mouseY, useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
        const { x , y , base , horizontal  } = this.getProps([
            'x',
            'y',
            'base',
            'horizontal'
        ], useFinalPosition);
        return {
            x: horizontal ? (x + base) / 2 : x,
            y: horizontal ? y : (y + base) / 2
        };
    }
    getRange(axis) {
        return axis === 'x' ? this.width / 2 : this.height / 2;
    }
    constructor(cfg){
        super();
        this.options = undefined;
        this.horizontal = undefined;
        this.base = undefined;
        this.width = undefined;
        this.height = undefined;
        this.inflateAmount = undefined;
        if (cfg) Object.assign(this, cfg);
    }
}
BarElement.id = 'bar';
BarElement.defaults = {
    borderSkipped: 'start',
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: 'auto',
    pointStyle: undefined
};
BarElement.defaultRoutes = {
    backgroundColor: 'backgroundColor',
    borderColor: 'borderColor'
};
var elements = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ArcElement: ArcElement,
    LineElement: LineElement,
    PointElement: PointElement,
    BarElement: BarElement
});
function lttbDecimation(data, start, count, availableWidth, options) {
    const samples = options.samples || availableWidth;
    if (samples >= count) return data.slice(start, start + count);
    const decimated = [];
    const bucketWidth = (count - 2) / (samples - 2);
    let sampledIndex = 0;
    const endIndex = start + count - 1;
    let a = start;
    let i, maxAreaPoint, maxArea, area, nextA;
    decimated[sampledIndex++] = data[a];
    for(i = 0; i < samples - 2; i++){
        let avgX = 0;
        let avgY = 0;
        let j;
        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
        const avgRangeLength = avgRangeEnd - avgRangeStart;
        for(j = avgRangeStart; j < avgRangeEnd; j++){
            avgX += data[j].x;
            avgY += data[j].y;
        }
        avgX /= avgRangeLength;
        avgY /= avgRangeLength;
        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
        const { x: pointAx , y: pointAy  } = data[a];
        maxArea = area = -1;
        for(j = rangeOffs; j < rangeTo; j++){
            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
            if (area > maxArea) {
                maxArea = area;
                maxAreaPoint = data[j];
                nextA = j;
            }
        }
        decimated[sampledIndex++] = maxAreaPoint;
        a = nextA;
    }
    decimated[sampledIndex++] = data[endIndex];
    return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
    let avgX = 0;
    let countX = 0;
    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
    const decimated = [];
    const endIndex = start + count - 1;
    const xMin = data[start].x;
    const xMax = data[endIndex].x;
    const dx = xMax - xMin;
    for(i = start; i < start + count; ++i){
        point = data[i];
        x = (point.x - xMin) / dx * availableWidth;
        y = point.y;
        const truncX = x | 0;
        if (truncX === prevX) {
            if (y < minY) {
                minY = y;
                minIndex = i;
            } else if (y > maxY) {
                maxY = y;
                maxIndex = i;
            }
            avgX = (countX * avgX + point.x) / ++countX;
        } else {
            const lastIndex = i - 1;
            if (!_helpersSegmentJs.k(minIndex) && !_helpersSegmentJs.k(maxIndex)) {
                const intermediateIndex1 = Math.min(minIndex, maxIndex);
                const intermediateIndex2 = Math.max(minIndex, maxIndex);
                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) decimated.push({
                    ...data[intermediateIndex1],
                    x: avgX
                });
                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) decimated.push({
                    ...data[intermediateIndex2],
                    x: avgX
                });
            }
            if (i > 0 && lastIndex !== startIndex) decimated.push(data[lastIndex]);
            decimated.push(point);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
            minIndex = maxIndex = startIndex = i;
        }
    }
    return decimated;
}
function cleanDecimatedDataset(dataset) {
    if (dataset._decimated) {
        const data = dataset._data;
        delete dataset._decimated;
        delete dataset._data;
        Object.defineProperty(dataset, 'data', {
            value: data
        });
    }
}
function cleanDecimatedData(chart) {
    chart.data.datasets.forEach((dataset)=>{
        cleanDecimatedDataset(dataset);
    });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
    const pointCount = points.length;
    let start = 0;
    let count;
    const { iScale  } = meta;
    const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();
    if (minDefined) start = _helpersSegmentJs.w(_helpersSegmentJs.x(points, iScale.axis, min).lo, 0, pointCount - 1);
    if (maxDefined) count = _helpersSegmentJs.w(_helpersSegmentJs.x(points, iScale.axis, max).hi + 1, start, pointCount) - start;
    else count = pointCount - start;
    return {
        start,
        count
    };
}
var plugin_decimation = {
    id: 'decimation',
    defaults: {
        algorithm: 'min-max',
        enabled: false
    },
    beforeElementsUpdate: (chart, args, options)=>{
        if (!options.enabled) {
            cleanDecimatedData(chart);
            return;
        }
        const availableWidth = chart.width;
        chart.data.datasets.forEach((dataset, datasetIndex)=>{
            const { _data , indexAxis  } = dataset;
            const meta = chart.getDatasetMeta(datasetIndex);
            const data = _data || dataset.data;
            if (_helpersSegmentJs.a([
                indexAxis,
                chart.options.indexAxis
            ]) === 'y') return;
            if (meta.type !== 'line') return;
            const xAxis = chart.scales[meta.xAxisID];
            if (xAxis.type !== 'linear' && xAxis.type !== 'time') return;
            if (chart.options.parsing) return;
            let { start , count  } = getStartAndCountOfVisiblePointsSimplified(meta, data);
            const threshold = options.threshold || 4 * availableWidth;
            if (count <= threshold) {
                cleanDecimatedDataset(dataset);
                return;
            }
            if (_helpersSegmentJs.k(_data)) {
                dataset._data = data;
                delete dataset.data;
                Object.defineProperty(dataset, 'data', {
                    configurable: true,
                    enumerable: true,
                    get: function() {
                        return this._decimated;
                    },
                    set: function(d) {
                        this._data = d;
                    }
                });
            }
            let decimated;
            switch(options.algorithm){
                case 'lttb':
                    decimated = lttbDecimation(data, start, count, availableWidth, options);
                    break;
                case 'min-max':
                    decimated = minMaxDecimation(data, start, count, availableWidth);
                    break;
                default:
                    throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
            }
            dataset._decimated = decimated;
        });
    },
    destroy (chart) {
        cleanDecimatedData(chart);
    }
};
function getLineByIndex(chart, index) {
    const meta = chart.getDatasetMeta(index);
    const visible = meta && chart.isDatasetVisible(index);
    return visible ? meta.dataset : null;
}
function parseFillOption(line) {
    const options = line.options;
    const fillOption = options.fill;
    let fill = _helpersSegmentJs.v(fillOption && fillOption.target, fillOption);
    if (fill === undefined) fill = !!options.backgroundColor;
    if (fill === false || fill === null) return false;
    if (fill === true) return 'origin';
    return fill;
}
function decodeFill(line, index, count) {
    const fill = parseFillOption(line);
    if (_helpersSegmentJs.i(fill)) return isNaN(fill.value) ? false : fill;
    let target = parseFloat(fill);
    if (_helpersSegmentJs.g(target) && Math.floor(target) === target) {
        if (fill[0] === '-' || fill[0] === '+') target = index + target;
        if (target === index || target < 0 || target >= count) return false;
        return target;
    }
    return [
        'origin',
        'start',
        'end',
        'stack',
        'shape'
    ].indexOf(fill) >= 0 && fill;
}
function computeLinearBoundary(source) {
    const { scale ={} , fill  } = source;
    let target = null;
    let horizontal;
    if (fill === 'start') target = scale.bottom;
    else if (fill === 'end') target = scale.top;
    else if (_helpersSegmentJs.i(fill)) target = scale.getPixelForValue(fill.value);
    else if (scale.getBasePixel) target = scale.getBasePixel();
    if (_helpersSegmentJs.g(target)) {
        horizontal = scale.isHorizontal();
        return {
            x: horizontal ? target : null,
            y: horizontal ? null : target
        };
    }
    return null;
}
class simpleArc {
    pathSegment(ctx, bounds, opts) {
        const { x , y , radius  } = this;
        bounds = bounds || {
            start: 0,
            end: _helpersSegmentJs.T
        };
        ctx.arc(x, y, radius, bounds.end, bounds.start, true);
        return !opts.bounds;
    }
    interpolate(point) {
        const { x , y , radius  } = this;
        const angle = point.angle;
        return {
            x: x + Math.cos(angle) * radius,
            y: y + Math.sin(angle) * radius,
            angle
        };
    }
    constructor(opts){
        this.x = opts.x;
        this.y = opts.y;
        this.radius = opts.radius;
    }
}
function computeCircularBoundary(source) {
    const { scale , fill  } = source;
    const options = scale.options;
    const length = scale.getLabels().length;
    const target = [];
    const start = options.reverse ? scale.max : scale.min;
    const end = options.reverse ? scale.min : scale.max;
    let i, center, value;
    if (fill === 'start') value = start;
    else if (fill === 'end') value = end;
    else if (_helpersSegmentJs.i(fill)) value = fill.value;
    else value = scale.getBaseValue();
    if (options.grid.circular) {
        center = scale.getPointPositionForValue(0, start);
        return new simpleArc({
            x: center.x,
            y: center.y,
            radius: scale.getDistanceFromCenterForValue(value)
        });
    }
    for(i = 0; i < length; ++i)target.push(scale.getPointPositionForValue(i, value));
    return target;
}
function computeBoundary(source) {
    const scale = source.scale || {};
    if (scale.getPointPositionForValue) return computeCircularBoundary(source);
    return computeLinearBoundary(source);
}
function findSegmentEnd(start, end, points) {
    for(; end > start; end--){
        const point = points[end];
        if (!isNaN(point.x) && !isNaN(point.y)) break;
    }
    return end;
}
function pointsFromSegments(boundary, line) {
    const { x =null , y =null  } = boundary || {};
    const linePoints = line.points;
    const points = [];
    line.segments.forEach(({ start , end  })=>{
        end = findSegmentEnd(start, end, linePoints);
        const first = linePoints[start];
        const last = linePoints[end];
        if (y !== null) {
            points.push({
                x: first.x,
                y
            });
            points.push({
                x: last.x,
                y
            });
        } else if (x !== null) {
            points.push({
                x,
                y: first.y
            });
            points.push({
                x,
                y: last.y
            });
        }
    });
    return points;
}
function buildStackLine(source) {
    const { scale , index , line  } = source;
    const points = [];
    const segments = line.segments;
    const sourcePoints = line.points;
    const linesBelow = getLinesBelow(scale, index);
    linesBelow.push(createBoundaryLine({
        x: null,
        y: scale.bottom
    }, line));
    for(let i = 0; i < segments.length; i++){
        const segment = segments[i];
        for(let j = segment.start; j <= segment.end; j++)addPointsBelow(points, sourcePoints[j], linesBelow);
    }
    return new LineElement({
        points,
        options: {}
    });
}
function getLinesBelow(scale, index) {
    const below = [];
    const metas = scale.getMatchingVisibleMetas('line');
    for(let i = 0; i < metas.length; i++){
        const meta = metas[i];
        if (meta.index === index) break;
        if (!meta.hidden) below.unshift(meta.dataset);
    }
    return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
    const postponed = [];
    for(let j = 0; j < linesBelow.length; j++){
        const line = linesBelow[j];
        const { first , last , point  } = findPoint(line, sourcePoint, 'x');
        if (!point || first && last) continue;
        if (first) postponed.unshift(point);
        else {
            points.push(point);
            if (!last) break;
        }
    }
    points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
    const point = line.interpolate(sourcePoint, property);
    if (!point) return {};
    const pointValue = point[property];
    const segments = line.segments;
    const linePoints = line.points;
    let first = false;
    let last = false;
    for(let i = 0; i < segments.length; i++){
        const segment = segments[i];
        const firstValue = linePoints[segment.start][property];
        const lastValue = linePoints[segment.end][property];
        if (_helpersSegmentJs.ah(pointValue, firstValue, lastValue)) {
            first = pointValue === firstValue;
            last = pointValue === lastValue;
            break;
        }
    }
    return {
        first,
        last,
        point
    };
}
function getTarget(source) {
    const { chart , fill , line  } = source;
    if (_helpersSegmentJs.g(fill)) return getLineByIndex(chart, fill);
    if (fill === 'stack') return buildStackLine(source);
    if (fill === 'shape') return true;
    const boundary = computeBoundary(source);
    if (boundary instanceof simpleArc) return boundary;
    return createBoundaryLine(boundary, line);
}
function createBoundaryLine(boundary, line) {
    let points = [];
    let _loop = false;
    if (_helpersSegmentJs.b(boundary)) {
        _loop = true;
        points = boundary;
    } else points = pointsFromSegments(boundary, line);
    return points.length ? new LineElement({
        points,
        options: {
            tension: 0
        },
        _loop,
        _fullLoop: _loop
    }) : null;
}
function resolveTarget(sources, index, propagate) {
    const source = sources[index];
    let fill = source.fill;
    const visited = [
        index
    ];
    let target;
    if (!propagate) return fill;
    while(fill !== false && visited.indexOf(fill) === -1){
        if (!_helpersSegmentJs.g(fill)) return fill;
        target = sources[fill];
        if (!target) return false;
        if (target.visible) return fill;
        visited.push(fill);
        fill = target.fill;
    }
    return false;
}
function _clip(ctx, target, clipY) {
    const { segments , points  } = target;
    let first = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments){
        const { start , end  } = segment;
        const firstPoint = points[start];
        const lastPoint = points[findSegmentEnd(start, end, points)];
        if (first) {
            ctx.moveTo(firstPoint.x, firstPoint.y);
            first = false;
        } else {
            ctx.lineTo(firstPoint.x, clipY);
            ctx.lineTo(firstPoint.x, firstPoint.y);
        }
        lineLoop = !!target.pathSegment(ctx, segment, {
            move: lineLoop
        });
        if (lineLoop) ctx.closePath();
        else ctx.lineTo(lastPoint.x, clipY);
    }
    ctx.lineTo(target.first().x, clipY);
    ctx.closePath();
    ctx.clip();
}
function getBounds(property, first, last, loop) {
    if (loop) return;
    let start = first[property];
    let end = last[property];
    if (property === 'angle') {
        start = _helpersSegmentJs.aw(start);
        end = _helpersSegmentJs.aw(end);
    }
    return {
        property,
        start,
        end
    };
}
function _getEdge(a, b, prop, fn) {
    if (a && b) return fn(a[prop], b[prop]);
    return a ? a[prop] : b ? b[prop] : 0;
}
function _segments(line, target, property) {
    const segments = line.segments;
    const points = line.points;
    const tpoints = target.points;
    const parts = [];
    for (const segment of segments){
        let { start , end  } = segment;
        end = findSegmentEnd(start, end, points);
        const bounds = getBounds(property, points[start], points[end], segment.loop);
        if (!target.segments) {
            parts.push({
                source: segment,
                target: bounds,
                start: points[start],
                end: points[end]
            });
            continue;
        }
        const targetSegments = _helpersSegmentJs.al(target, bounds);
        for (const tgt of targetSegments){
            const subBounds = getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
            const fillSources = _helpersSegmentJs.av(segment, points, subBounds);
            for (const fillSource of fillSources)parts.push({
                source: fillSource,
                target: tgt,
                start: {
                    [property]: _getEdge(bounds, subBounds, 'start', Math.max)
                },
                end: {
                    [property]: _getEdge(bounds, subBounds, 'end', Math.min)
                }
            });
        }
    }
    return parts;
}
function clipBounds(ctx, scale, bounds) {
    const { top , bottom  } = scale.chart.chartArea;
    const { property , start , end  } = bounds || {};
    if (property === 'x') {
        ctx.beginPath();
        ctx.rect(start, top, end - start, bottom - top);
        ctx.clip();
    }
}
function interpolatedLineTo(ctx, target, point, property) {
    const interpolatedPoint = target.interpolate(point, property);
    if (interpolatedPoint) ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
}
function _fill(ctx, cfg) {
    const { line , target , property , color , scale  } = cfg;
    const segments = _segments(line, target, property);
    for (const { source: src , target: tgt , start , end  } of segments){
        const { style: { backgroundColor =color  } = {}  } = src;
        const notShape = target !== true;
        ctx.save();
        ctx.fillStyle = backgroundColor;
        clipBounds(ctx, scale, notShape && getBounds(property, start, end));
        ctx.beginPath();
        const lineLoop = !!line.pathSegment(ctx, src);
        let loop;
        if (notShape) {
            if (lineLoop) ctx.closePath();
            else interpolatedLineTo(ctx, target, end, property);
            const targetLoop = !!target.pathSegment(ctx, tgt, {
                move: lineLoop,
                reverse: true
            });
            loop = lineLoop && targetLoop;
            if (!loop) interpolatedLineTo(ctx, target, start, property);
        }
        ctx.closePath();
        ctx.fill(loop ? 'evenodd' : 'nonzero');
        ctx.restore();
    }
}
function doFill(ctx, cfg) {
    const { line , target , above , below , area , scale  } = cfg;
    const property = line._loop ? 'angle' : cfg.axis;
    ctx.save();
    if (property === 'x' && below !== above) {
        _clip(ctx, target, area.top);
        _fill(ctx, {
            line,
            target,
            color: above,
            scale,
            property
        });
        ctx.restore();
        ctx.save();
        _clip(ctx, target, area.bottom);
    }
    _fill(ctx, {
        line,
        target,
        color: below,
        scale,
        property
    });
    ctx.restore();
}
function drawfill(ctx, source, area) {
    const target = getTarget(source);
    const { line , scale , axis  } = source;
    const lineOpts = line.options;
    const fillOption = lineOpts.fill;
    const color = lineOpts.backgroundColor;
    const { above =color , below =color  } = fillOption || {};
    if (target && line.points.length) {
        _helpersSegmentJs.W(ctx, area);
        doFill(ctx, {
            line,
            target,
            above,
            below,
            area,
            scale,
            axis
        });
        _helpersSegmentJs.Y(ctx);
    }
}
var plugin_filler = {
    id: 'filler',
    afterDatasetsUpdate (chart, _args, options) {
        const count = (chart.data.datasets || []).length;
        const sources = [];
        let meta, i, line, source;
        for(i = 0; i < count; ++i){
            meta = chart.getDatasetMeta(i);
            line = meta.dataset;
            source = null;
            if (line && line.options && line instanceof LineElement) source = {
                visible: chart.isDatasetVisible(i),
                index: i,
                fill: decodeFill(line, i, count),
                chart,
                axis: meta.controller.options.indexAxis,
                scale: meta.vScale,
                line
            };
            meta.$filler = source;
            sources.push(source);
        }
        for(i = 0; i < count; ++i){
            source = sources[i];
            if (!source || source.fill === false) continue;
            source.fill = resolveTarget(sources, i, options.propagate);
        }
    },
    beforeDraw (chart, _args, options) {
        const draw2 = options.drawTime === 'beforeDraw';
        const metasets = chart.getSortedVisibleDatasetMetas();
        const area = chart.chartArea;
        for(let i = metasets.length - 1; i >= 0; --i){
            const source = metasets[i].$filler;
            if (!source) continue;
            source.line.updateControlPoints(area, source.axis);
            if (draw2) drawfill(chart.ctx, source, area);
        }
    },
    beforeDatasetsDraw (chart, _args, options) {
        if (options.drawTime !== 'beforeDatasetsDraw') return;
        const metasets = chart.getSortedVisibleDatasetMetas();
        for(let i = metasets.length - 1; i >= 0; --i){
            const source = metasets[i].$filler;
            if (source) drawfill(chart.ctx, source, chart.chartArea);
        }
    },
    beforeDatasetDraw (chart, args, options) {
        const source = args.meta.$filler;
        if (!source || source.fill === false || options.drawTime !== 'beforeDatasetDraw') return;
        drawfill(chart.ctx, source, chart.chartArea);
    },
    defaults: {
        propagate: true,
        drawTime: 'beforeDatasetDraw'
    }
};
const getBoxSize = (labelOpts, fontSize)=>{
    let { boxHeight =fontSize , boxWidth =fontSize  } = labelOpts;
    if (labelOpts.usePointStyle) {
        boxHeight = Math.min(boxHeight, fontSize);
        boxWidth = Math.min(boxWidth, fontSize);
    }
    return {
        boxWidth,
        boxHeight,
        itemHeight: Math.max(fontSize, boxHeight)
    };
};
const itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index
;
class Legend extends Element {
    update(maxWidth, maxHeight, margins) {
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins;
        this.setDimensions();
        this.buildLabels();
        this.fit();
    }
    setDimensions() {
        if (this.isHorizontal()) {
            this.width = this.maxWidth;
            this.left = this._margins.left;
            this.right = this.width;
        } else {
            this.height = this.maxHeight;
            this.top = this._margins.top;
            this.bottom = this.height;
        }
    }
    buildLabels() {
        const labelOpts = this.options.labels || {};
        let legendItems = _helpersSegmentJs.O(labelOpts.generateLabels, [
            this.chart
        ], this) || [];
        if (labelOpts.filter) legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data)
        );
        if (labelOpts.sort) legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data)
        );
        if (this.options.reverse) legendItems.reverse();
        this.legendItems = legendItems;
    }
    fit() {
        const { options , ctx  } = this;
        if (!options.display) {
            this.width = this.height = 0;
            return;
        }
        const labelOpts = options.labels;
        const labelFont = _helpersSegmentJs.Z(labelOpts.font);
        const fontSize = labelFont.size;
        const titleHeight = this._computeTitleHeight();
        const { boxWidth , itemHeight  } = getBoxSize(labelOpts, fontSize);
        let width, height;
        ctx.font = labelFont.string;
        if (this.isHorizontal()) {
            width = this.maxWidth;
            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
        } else {
            height = this.maxHeight;
            width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
        }
        this.width = Math.min(width, options.maxWidth || this.maxWidth);
        this.height = Math.min(height, options.maxHeight || this.maxHeight);
    }
    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
        const { ctx , maxWidth , options: { labels: { padding  }  }  } = this;
        const hitboxes = this.legendHitBoxes = [];
        const lineWidths = this.lineWidths = [
            0
        ];
        const lineHeight = itemHeight + padding;
        let totalHeight = titleHeight;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        let row = -1;
        let top = -lineHeight;
        this.legendItems.forEach((legendItem, i)=>{
            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
                totalHeight += lineHeight;
                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                top += lineHeight;
                row++;
            }
            hitboxes[i] = {
                left: 0,
                top,
                row,
                width: itemWidth,
                height: itemHeight
            };
            lineWidths[lineWidths.length - 1] += itemWidth + padding;
        });
        return totalHeight;
    }
    _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
        const { ctx , maxHeight , options: { labels: { padding  }  }  } = this;
        const hitboxes = this.legendHitBoxes = [];
        const columnSizes = this.columnSizes = [];
        const heightLimit = maxHeight - titleHeight;
        let totalWidth = padding;
        let currentColWidth = 0;
        let currentColHeight = 0;
        let left = 0;
        let col = 0;
        this.legendItems.forEach((legendItem, i)=>{
            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
                totalWidth += currentColWidth + padding;
                columnSizes.push({
                    width: currentColWidth,
                    height: currentColHeight
                });
                left += currentColWidth + padding;
                col++;
                currentColWidth = currentColHeight = 0;
            }
            hitboxes[i] = {
                left,
                top: currentColHeight,
                col,
                width: itemWidth,
                height: itemHeight
            };
            currentColWidth = Math.max(currentColWidth, itemWidth);
            currentColHeight += itemHeight + padding;
        });
        totalWidth += currentColWidth;
        columnSizes.push({
            width: currentColWidth,
            height: currentColHeight
        });
        return totalWidth;
    }
    adjustHitBoxes() {
        if (!this.options.display) return;
        const titleHeight = this._computeTitleHeight();
        const { legendHitBoxes: hitboxes , options: { align , labels: { padding  } , rtl  }  } = this;
        const rtlHelper = _helpersSegmentJs.ax(rtl, this.left, this.width);
        if (this.isHorizontal()) {
            let row = 0;
            let left = _helpersSegmentJs.a0(align, this.left + padding, this.right - this.lineWidths[row]);
            for (const hitbox of hitboxes){
                if (row !== hitbox.row) {
                    row = hitbox.row;
                    left = _helpersSegmentJs.a0(align, this.left + padding, this.right - this.lineWidths[row]);
                }
                hitbox.top += this.top + titleHeight + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
                left += hitbox.width + padding;
            }
        } else {
            let col = 0;
            let top = _helpersSegmentJs.a0(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
            for (const hitbox of hitboxes){
                if (hitbox.col !== col) {
                    col = hitbox.col;
                    top = _helpersSegmentJs.a0(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                }
                hitbox.top = top;
                hitbox.left += this.left + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
                top += hitbox.height + padding;
            }
        }
    }
    isHorizontal() {
        return this.options.position === 'top' || this.options.position === 'bottom';
    }
    draw() {
        if (this.options.display) {
            const ctx = this.ctx;
            _helpersSegmentJs.W(ctx, this);
            this._draw();
            _helpersSegmentJs.Y(ctx);
        }
    }
    _draw() {
        const { options: opts , columnSizes , lineWidths , ctx  } = this;
        const { align , labels: labelOpts  } = opts;
        const defaultColor = _helpersSegmentJs.d.color;
        const rtlHelper = _helpersSegmentJs.ax(opts.rtl, this.left, this.width);
        const labelFont = _helpersSegmentJs.Z(labelOpts.font);
        const { color: fontColor , padding  } = labelOpts;
        const fontSize = labelFont.size;
        const halfFontSize = fontSize / 2;
        let cursor;
        this.drawTitle();
        ctx.textAlign = rtlHelper.textAlign('left');
        ctx.textBaseline = 'middle';
        ctx.lineWidth = 0.5;
        ctx.font = labelFont.string;
        const { boxWidth , boxHeight , itemHeight  } = getBoxSize(labelOpts, fontSize);
        const drawLegendBox = function(x, y, legendItem) {
            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) return;
            ctx.save();
            const lineWidth = _helpersSegmentJs.v(legendItem.lineWidth, 1);
            ctx.fillStyle = _helpersSegmentJs.v(legendItem.fillStyle, defaultColor);
            ctx.lineCap = _helpersSegmentJs.v(legendItem.lineCap, 'butt');
            ctx.lineDashOffset = _helpersSegmentJs.v(legendItem.lineDashOffset, 0);
            ctx.lineJoin = _helpersSegmentJs.v(legendItem.lineJoin, 'miter');
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = _helpersSegmentJs.v(legendItem.strokeStyle, defaultColor);
            ctx.setLineDash(_helpersSegmentJs.v(legendItem.lineDash, []));
            if (labelOpts.usePointStyle) {
                const drawOptions = {
                    radius: boxWidth * Math.SQRT2 / 2,
                    pointStyle: legendItem.pointStyle,
                    rotation: legendItem.rotation,
                    borderWidth: lineWidth
                };
                const centerX = rtlHelper.xPlus(x, boxWidth / 2);
                const centerY = y + halfFontSize;
                _helpersSegmentJs.ar(ctx, drawOptions, centerX, centerY);
            } else {
                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
                const borderRadius = _helpersSegmentJs.au(legendItem.borderRadius);
                ctx.beginPath();
                if (Object.values(borderRadius).some((v)=>v !== 0
                )) _helpersSegmentJs.as(ctx, {
                    x: xBoxLeft,
                    y: yBoxTop,
                    w: boxWidth,
                    h: boxHeight,
                    radius: borderRadius
                });
                else ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
                ctx.fill();
                if (lineWidth !== 0) ctx.stroke();
            }
            ctx.restore();
        };
        const fillText = function(x, y, legendItem) {
            _helpersSegmentJs.X(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
                strikethrough: legendItem.hidden,
                textAlign: rtlHelper.textAlign(legendItem.textAlign)
            });
        };
        const isHorizontal = this.isHorizontal();
        const titleHeight = this._computeTitleHeight();
        if (isHorizontal) cursor = {
            x: _helpersSegmentJs.a0(align, this.left + padding, this.right - lineWidths[0]),
            y: this.top + padding + titleHeight,
            line: 0
        };
        else cursor = {
            x: this.left + padding,
            y: _helpersSegmentJs.a0(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
            line: 0
        };
        _helpersSegmentJs.ay(this.ctx, opts.textDirection);
        const lineHeight = itemHeight + padding;
        this.legendItems.forEach((legendItem, i)=>{
            ctx.strokeStyle = legendItem.fontColor || fontColor;
            ctx.fillStyle = legendItem.fontColor || fontColor;
            const textWidth = ctx.measureText(legendItem.text).width;
            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
            const width = boxWidth + halfFontSize + textWidth;
            let x = cursor.x;
            let y = cursor.y;
            rtlHelper.setWidth(this.width);
            if (isHorizontal) {
                if (i > 0 && x + width + padding > this.right) {
                    y = cursor.y += lineHeight;
                    cursor.line++;
                    x = cursor.x = _helpersSegmentJs.a0(align, this.left + padding, this.right - lineWidths[cursor.line]);
                }
            } else if (i > 0 && y + lineHeight > this.bottom) {
                x = cursor.x = x + columnSizes[cursor.line].width + padding;
                cursor.line++;
                y = cursor.y = _helpersSegmentJs.a0(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
            }
            const realX = rtlHelper.x(x);
            drawLegendBox(realX, y, legendItem);
            x = _helpersSegmentJs.az(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
            fillText(rtlHelper.x(x), y, legendItem);
            if (isHorizontal) cursor.x += width + padding;
            else cursor.y += lineHeight;
        });
        _helpersSegmentJs.aA(this.ctx, opts.textDirection);
    }
    drawTitle() {
        const opts = this.options;
        const titleOpts = opts.title;
        const titleFont = _helpersSegmentJs.Z(titleOpts.font);
        const titlePadding = _helpersSegmentJs.C(titleOpts.padding);
        if (!titleOpts.display) return;
        const rtlHelper = _helpersSegmentJs.ax(opts.rtl, this.left, this.width);
        const ctx = this.ctx;
        const position = titleOpts.position;
        const halfFontSize = titleFont.size / 2;
        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
        let y;
        let left = this.left;
        let maxWidth = this.width;
        if (this.isHorizontal()) {
            maxWidth = Math.max(...this.lineWidths);
            y = this.top + topPaddingPlusHalfFontSize;
            left = _helpersSegmentJs.a0(opts.align, left, this.right - maxWidth);
        } else {
            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height)
            , 0);
            y = topPaddingPlusHalfFontSize + _helpersSegmentJs.a0(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
        }
        const x = _helpersSegmentJs.a0(position, left, left + maxWidth);
        ctx.textAlign = rtlHelper.textAlign(_helpersSegmentJs.$(position));
        ctx.textBaseline = 'middle';
        ctx.strokeStyle = titleOpts.color;
        ctx.fillStyle = titleOpts.color;
        ctx.font = titleFont.string;
        _helpersSegmentJs.X(ctx, titleOpts.text, x, y, titleFont);
    }
    _computeTitleHeight() {
        const titleOpts = this.options.title;
        const titleFont = _helpersSegmentJs.Z(titleOpts.font);
        const titlePadding = _helpersSegmentJs.C(titleOpts.padding);
        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
    }
    _getLegendItemAt(x, y) {
        let i, hitBox, lh;
        if (_helpersSegmentJs.ah(x, this.left, this.right) && _helpersSegmentJs.ah(y, this.top, this.bottom)) {
            lh = this.legendHitBoxes;
            for(i = 0; i < lh.length; ++i){
                hitBox = lh[i];
                if (_helpersSegmentJs.ah(x, hitBox.left, hitBox.left + hitBox.width) && _helpersSegmentJs.ah(y, hitBox.top, hitBox.top + hitBox.height)) return this.legendItems[i];
            }
        }
        return null;
    }
    handleEvent(e) {
        const opts = this.options;
        if (!isListened(e.type, opts)) return;
        const hoveredItem = this._getLegendItemAt(e.x, e.y);
        if (e.type === 'mousemove') {
            const previous = this._hoveredItem;
            const sameItem = itemsEqual(previous, hoveredItem);
            if (previous && !sameItem) _helpersSegmentJs.O(opts.onLeave, [
                e,
                previous,
                this
            ], this);
            this._hoveredItem = hoveredItem;
            if (hoveredItem && !sameItem) _helpersSegmentJs.O(opts.onHover, [
                e,
                hoveredItem,
                this
            ], this);
        } else if (hoveredItem) _helpersSegmentJs.O(opts.onClick, [
            e,
            hoveredItem,
            this
        ], this);
    }
    constructor(config){
        super();
        this._added = false;
        this.legendHitBoxes = [];
        this._hoveredItem = null;
        this.doughnutMode = false;
        this.chart = config.chart;
        this.options = config.options;
        this.ctx = config.ctx;
        this.legendItems = undefined;
        this.columnSizes = undefined;
        this.lineWidths = undefined;
        this.maxHeight = undefined;
        this.maxWidth = undefined;
        this.top = undefined;
        this.bottom = undefined;
        this.left = undefined;
        this.right = undefined;
        this.height = undefined;
        this.width = undefined;
        this._margins = undefined;
        this.position = undefined;
        this.weight = undefined;
        this.fullSize = undefined;
    }
}
function isListened(type, opts) {
    if (type === 'mousemove' && (opts.onHover || opts.onLeave)) return true;
    if (opts.onClick && (type === 'click' || type === 'mouseup')) return true;
    return false;
}
var plugin_legend = {
    id: 'legend',
    _element: Legend,
    start (chart, _args, options) {
        const legend = chart.legend = new Legend({
            ctx: chart.ctx,
            options,
            chart
        });
        layouts.configure(chart, legend, options);
        layouts.addBox(chart, legend);
    },
    stop (chart) {
        layouts.removeBox(chart, chart.legend);
        delete chart.legend;
    },
    beforeUpdate (chart, _args, options) {
        const legend = chart.legend;
        layouts.configure(chart, legend, options);
        legend.options = options;
    },
    afterUpdate (chart) {
        const legend = chart.legend;
        legend.buildLabels();
        legend.adjustHitBoxes();
    },
    afterEvent (chart, args) {
        if (!args.replay) chart.legend.handleEvent(args.event);
    },
    defaults: {
        display: true,
        position: 'top',
        align: 'center',
        fullSize: true,
        reverse: false,
        weight: 1000,
        onClick (e, legendItem, legend) {
            const index = legendItem.datasetIndex;
            const ci = legend.chart;
            if (ci.isDatasetVisible(index)) {
                ci.hide(index);
                legendItem.hidden = true;
            } else {
                ci.show(index);
                legendItem.hidden = false;
            }
        },
        onHover: null,
        onLeave: null,
        labels: {
            color: (ctx)=>ctx.chart.options.color
            ,
            boxWidth: 40,
            padding: 10,
            generateLabels (chart) {
                const datasets = chart.data.datasets;
                const { labels: { usePointStyle , pointStyle , textAlign , color  }  } = chart.legend.options;
                return chart._getSortedDatasetMetas().map((meta)=>{
                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
                    const borderWidth = _helpersSegmentJs.C(style.borderWidth);
                    return {
                        text: datasets[meta.index].label,
                        fillStyle: style.backgroundColor,
                        fontColor: color,
                        hidden: !meta.visible,
                        lineCap: style.borderCapStyle,
                        lineDash: style.borderDash,
                        lineDashOffset: style.borderDashOffset,
                        lineJoin: style.borderJoinStyle,
                        lineWidth: (borderWidth.width + borderWidth.height) / 4,
                        strokeStyle: style.borderColor,
                        pointStyle: pointStyle || style.pointStyle,
                        rotation: style.rotation,
                        textAlign: textAlign || style.textAlign,
                        borderRadius: 0,
                        datasetIndex: meta.index
                    };
                }, this);
            }
        },
        title: {
            color: (ctx)=>ctx.chart.options.color
            ,
            display: false,
            position: 'center',
            text: ''
        }
    },
    descriptors: {
        _scriptable: (name)=>!name.startsWith('on')
        ,
        labels: {
            _scriptable: (name)=>![
                    'generateLabels',
                    'filter',
                    'sort'
                ].includes(name)
        }
    }
};
class Title extends Element {
    update(maxWidth, maxHeight) {
        const opts = this.options;
        this.left = 0;
        this.top = 0;
        if (!opts.display) {
            this.width = this.height = this.right = this.bottom = 0;
            return;
        }
        this.width = this.right = maxWidth;
        this.height = this.bottom = maxHeight;
        const lineCount = _helpersSegmentJs.b(opts.text) ? opts.text.length : 1;
        this._padding = _helpersSegmentJs.C(opts.padding);
        const textSize = lineCount * _helpersSegmentJs.Z(opts.font).lineHeight + this._padding.height;
        if (this.isHorizontal()) this.height = textSize;
        else this.width = textSize;
    }
    isHorizontal() {
        const pos = this.options.position;
        return pos === 'top' || pos === 'bottom';
    }
    _drawArgs(offset) {
        const { top , left , bottom , right , options  } = this;
        const align = options.align;
        let rotation = 0;
        let maxWidth, titleX, titleY;
        if (this.isHorizontal()) {
            titleX = _helpersSegmentJs.a0(align, left, right);
            titleY = top + offset;
            maxWidth = right - left;
        } else {
            if (options.position === 'left') {
                titleX = left + offset;
                titleY = _helpersSegmentJs.a0(align, bottom, top);
                rotation = _helpersSegmentJs.P * -0.5;
            } else {
                titleX = right - offset;
                titleY = _helpersSegmentJs.a0(align, top, bottom);
                rotation = _helpersSegmentJs.P * 0.5;
            }
            maxWidth = bottom - top;
        }
        return {
            titleX,
            titleY,
            maxWidth,
            rotation
        };
    }
    draw() {
        const ctx = this.ctx;
        const opts = this.options;
        if (!opts.display) return;
        const fontOpts = _helpersSegmentJs.Z(opts.font);
        const lineHeight = fontOpts.lineHeight;
        const offset = lineHeight / 2 + this._padding.top;
        const { titleX , titleY , maxWidth , rotation  } = this._drawArgs(offset);
        _helpersSegmentJs.X(ctx, opts.text, 0, 0, fontOpts, {
            color: opts.color,
            maxWidth,
            rotation,
            textAlign: _helpersSegmentJs.$(opts.align),
            textBaseline: 'middle',
            translation: [
                titleX,
                titleY
            ]
        });
    }
    constructor(config){
        super();
        this.chart = config.chart;
        this.options = config.options;
        this.ctx = config.ctx;
        this._padding = undefined;
        this.top = undefined;
        this.bottom = undefined;
        this.left = undefined;
        this.right = undefined;
        this.width = undefined;
        this.height = undefined;
        this.position = undefined;
        this.weight = undefined;
        this.fullSize = undefined;
    }
}
function createTitle(chart, titleOpts) {
    const title = new Title({
        ctx: chart.ctx,
        options: titleOpts,
        chart
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
}
var plugin_title = {
    id: 'title',
    _element: Title,
    start (chart, _args, options) {
        createTitle(chart, options);
    },
    stop (chart) {
        const titleBlock = chart.titleBlock;
        layouts.removeBox(chart, titleBlock);
        delete chart.titleBlock;
    },
    beforeUpdate (chart, _args, options) {
        const title = chart.titleBlock;
        layouts.configure(chart, title, options);
        title.options = options;
    },
    defaults: {
        align: 'center',
        display: false,
        font: {
            weight: 'bold'
        },
        fullSize: true,
        padding: 10,
        position: 'top',
        text: '',
        weight: 2000
    },
    defaultRoutes: {
        color: 'color'
    },
    descriptors: {
        _scriptable: true,
        _indexable: false
    }
};
const map = new WeakMap();
var plugin_subtitle = {
    id: 'subtitle',
    start (chart, _args, options) {
        const title = new Title({
            ctx: chart.ctx,
            options,
            chart
        });
        layouts.configure(chart, title, options);
        layouts.addBox(chart, title);
        map.set(chart, title);
    },
    stop (chart) {
        layouts.removeBox(chart, map.get(chart));
        map.delete(chart);
    },
    beforeUpdate (chart, _args, options) {
        const title = map.get(chart);
        layouts.configure(chart, title, options);
        title.options = options;
    },
    defaults: {
        align: 'center',
        display: false,
        font: {
            weight: 'normal'
        },
        fullSize: true,
        padding: 0,
        position: 'top',
        text: '',
        weight: 1500
    },
    defaultRoutes: {
        color: 'color'
    },
    descriptors: {
        _scriptable: true,
        _indexable: false
    }
};
const positioners = {
    average (items) {
        if (!items.length) return false;
        let i, len;
        let x = 0;
        let y = 0;
        let count = 0;
        for(i = 0, len = items.length; i < len; ++i){
            const el = items[i].element;
            if (el && el.hasValue()) {
                const pos = el.tooltipPosition();
                x += pos.x;
                y += pos.y;
                ++count;
            }
        }
        return {
            x: x / count,
            y: y / count
        };
    },
    nearest (items, eventPosition) {
        if (!items.length) return false;
        let x = eventPosition.x;
        let y = eventPosition.y;
        let minDistance = Number.POSITIVE_INFINITY;
        let i, len, nearestElement;
        for(i = 0, len = items.length; i < len; ++i){
            const el = items[i].element;
            if (el && el.hasValue()) {
                const center = el.getCenterPoint();
                const d = _helpersSegmentJs.aC(eventPosition, center);
                if (d < minDistance) {
                    minDistance = d;
                    nearestElement = el;
                }
            }
        }
        if (nearestElement) {
            const tp = nearestElement.tooltipPosition();
            x = tp.x;
            y = tp.y;
        }
        return {
            x,
            y
        };
    }
};
function pushOrConcat(base, toPush) {
    if (toPush) {
        if (_helpersSegmentJs.b(toPush)) Array.prototype.push.apply(base, toPush);
        else base.push(toPush);
    }
    return base;
}
function splitNewlines(str) {
    if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) return str.split('\n');
    return str;
}
function createTooltipItem(chart, item) {
    const { element , datasetIndex , index  } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label , value  } = controller.getLabelAndValue(index);
    return {
        chart,
        label,
        parsed: controller.getParsed(index),
        raw: chart.data.datasets[datasetIndex].data[index],
        formattedValue: value,
        dataset: controller.getDataset(),
        dataIndex: index,
        datasetIndex,
        element
    };
}
function getTooltipSize(tooltip, options) {
    const ctx = tooltip.chart.ctx;
    const { body , footer , title  } = tooltip;
    const { boxWidth , boxHeight  } = options;
    const bodyFont = _helpersSegmentJs.Z(options.bodyFont);
    const titleFont = _helpersSegmentJs.Z(options.titleFont);
    const footerFont = _helpersSegmentJs.Z(options.footerFont);
    const titleLineCount = title.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = _helpersSegmentJs.C(options.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length
    , 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
    if (combinedBodyLength) {
        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
    }
    if (footerLineCount) height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
    let widthPadding = 0;
    const maxLineWidth = function(line) {
        width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    _helpersSegmentJs.D(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    _helpersSegmentJs.D(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
    _helpersSegmentJs.D(body, (bodyItem)=>{
        _helpersSegmentJs.D(bodyItem.before, maxLineWidth);
        _helpersSegmentJs.D(bodyItem.lines, maxLineWidth);
        _helpersSegmentJs.D(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    _helpersSegmentJs.D(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return {
        width,
        height
    };
}
function determineYAlign(chart, size) {
    const { y , height  } = size;
    if (y < height / 2) return 'top';
    else if (y > chart.height - height / 2) return 'bottom';
    return 'center';
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
    const { x , width  } = size;
    const caret = options.caretSize + options.caretPadding;
    if (xAlign === 'left' && x + width + caret > chart.width) return true;
    if (xAlign === 'right' && x - width - caret < 0) return true;
}
function determineXAlign(chart, options, size, yAlign) {
    const { x , width  } = size;
    const { width: chartWidth , chartArea: { left , right  }  } = chart;
    let xAlign = 'center';
    if (yAlign === 'center') xAlign = x <= (left + right) / 2 ? 'left' : 'right';
    else if (x <= width / 2) xAlign = 'left';
    else if (x >= chartWidth - width / 2) xAlign = 'right';
    if (doesNotFitWithAlign(xAlign, chart, options, size)) xAlign = 'center';
    return xAlign;
}
function determineAlignment(chart, options, size) {
    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
    return {
        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
        yAlign
    };
}
function alignX(size, xAlign) {
    let { x , width  } = size;
    if (xAlign === 'right') x -= width;
    else if (xAlign === 'center') x -= width / 2;
    return x;
}
function alignY(size, yAlign, paddingAndSize) {
    let { y , height  } = size;
    if (yAlign === 'top') y += paddingAndSize;
    else if (yAlign === 'bottom') y -= height + paddingAndSize;
    else y -= height / 2;
    return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
    const { caretSize , caretPadding , cornerRadius  } = options;
    const { xAlign , yAlign  } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft , topRight , bottomLeft , bottomRight  } = _helpersSegmentJs.au(cornerRadius);
    let x = alignX(size, xAlign);
    const y = alignY(size, yAlign, paddingAndSize);
    if (yAlign === 'center') {
        if (xAlign === 'left') x += paddingAndSize;
        else if (xAlign === 'right') x -= paddingAndSize;
    } else if (xAlign === 'left') x -= Math.max(topLeft, bottomLeft) + caretSize;
    else if (xAlign === 'right') x += Math.max(topRight, bottomRight) + caretSize;
    return {
        x: _helpersSegmentJs.w(x, 0, chart.width - size.width),
        y: _helpersSegmentJs.w(y, 0, chart.height - size.height)
    };
}
function getAlignedX(tooltip, align, options) {
    const padding = _helpersSegmentJs.C(options.padding);
    return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback) {
    return pushOrConcat([], splitNewlines(callback));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
    return _helpersSegmentJs.h(parent, {
        tooltip,
        tooltipItems,
        type: 'tooltip'
    });
}
function overrideCallbacks(callbacks, context) {
    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
}
class Tooltip extends Element {
    initialize(options) {
        this.options = options;
        this._cachedAnimations = undefined;
        this.$context = undefined;
    }
    _resolveAnimations() {
        const cached = this._cachedAnimations;
        if (cached) return cached;
        const chart = this.chart;
        const options = this.options.setContext(this.getContext());
        const opts = options.enabled && chart.options.animation && options.animations;
        const animations = new Animations(this.chart, opts);
        if (opts._cacheable) this._cachedAnimations = Object.freeze(animations);
        return animations;
    }
    getContext() {
        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(context, options) {
        const { callbacks  } = options;
        const beforeTitle = callbacks.beforeTitle.apply(this, [
            context
        ]);
        const title = callbacks.title.apply(this, [
            context
        ]);
        const afterTitle = callbacks.afterTitle.apply(this, [
            context
        ]);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
        lines = pushOrConcat(lines, splitNewlines(title));
        lines = pushOrConcat(lines, splitNewlines(afterTitle));
        return lines;
    }
    getBeforeBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [
            tooltipItems
        ]));
    }
    getBody(tooltipItems, options) {
        const { callbacks  } = options;
        const bodyItems = [];
        _helpersSegmentJs.D(tooltipItems, (context)=>{
            const bodyItem = {
                before: [],
                lines: [],
                after: []
            };
            const scoped = overrideCallbacks(callbacks, context);
            pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
            pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
            pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
            bodyItems.push(bodyItem);
        });
        return bodyItems;
    }
    getAfterBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [
            tooltipItems
        ]));
    }
    getFooter(tooltipItems, options) {
        const { callbacks  } = options;
        const beforeFooter = callbacks.beforeFooter.apply(this, [
            tooltipItems
        ]);
        const footer = callbacks.footer.apply(this, [
            tooltipItems
        ]);
        const afterFooter = callbacks.afterFooter.apply(this, [
            tooltipItems
        ]);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
        lines = pushOrConcat(lines, splitNewlines(footer));
        lines = pushOrConcat(lines, splitNewlines(afterFooter));
        return lines;
    }
    _createItems(options) {
        const active = this._active;
        const data = this.chart.data;
        const labelColors = [];
        const labelPointStyles = [];
        const labelTextColors = [];
        let tooltipItems = [];
        let i, len;
        for(i = 0, len = active.length; i < len; ++i)tooltipItems.push(createTooltipItem(this.chart, active[i]));
        if (options.filter) tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data)
        );
        if (options.itemSort) tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data)
        );
        _helpersSegmentJs.D(tooltipItems, (context)=>{
            const scoped = overrideCallbacks(options.callbacks, context);
            labelColors.push(scoped.labelColor.call(this, context));
            labelPointStyles.push(scoped.labelPointStyle.call(this, context));
            labelTextColors.push(scoped.labelTextColor.call(this, context));
        });
        this.labelColors = labelColors;
        this.labelPointStyles = labelPointStyles;
        this.labelTextColors = labelTextColors;
        this.dataPoints = tooltipItems;
        return tooltipItems;
    }
    update(changed, replay) {
        const options = this.options.setContext(this.getContext());
        const active = this._active;
        let properties;
        let tooltipItems = [];
        if (!active.length) {
            if (this.opacity !== 0) properties = {
                opacity: 0
            };
        } else {
            const position = positioners[options.position].call(this, active, this._eventPosition);
            tooltipItems = this._createItems(options);
            this.title = this.getTitle(tooltipItems, options);
            this.beforeBody = this.getBeforeBody(tooltipItems, options);
            this.body = this.getBody(tooltipItems, options);
            this.afterBody = this.getAfterBody(tooltipItems, options);
            this.footer = this.getFooter(tooltipItems, options);
            const size = this._size = getTooltipSize(this, options);
            const positionAndSize = Object.assign({}, position, size);
            const alignment = determineAlignment(this.chart, options, positionAndSize);
            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
            this.xAlign = alignment.xAlign;
            this.yAlign = alignment.yAlign;
            properties = {
                opacity: 1,
                x: backgroundPoint.x,
                y: backgroundPoint.y,
                width: size.width,
                height: size.height,
                caretX: position.x,
                caretY: position.y
            };
        }
        this._tooltipItems = tooltipItems;
        this.$context = undefined;
        if (properties) this._resolveAnimations().update(this, properties);
        if (changed && options.external) options.external.call(this, {
            chart: this.chart,
            tooltip: this,
            replay
        });
    }
    drawCaret(tooltipPoint, ctx, size, options) {
        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
        ctx.lineTo(caretPosition.x1, caretPosition.y1);
        ctx.lineTo(caretPosition.x2, caretPosition.y2);
        ctx.lineTo(caretPosition.x3, caretPosition.y3);
    }
    getCaretPosition(tooltipPoint, size, options) {
        const { xAlign , yAlign  } = this;
        const { caretSize , cornerRadius  } = options;
        const { topLeft , topRight , bottomLeft , bottomRight  } = _helpersSegmentJs.au(cornerRadius);
        const { x: ptX , y: ptY  } = tooltipPoint;
        const { width , height  } = size;
        let x1, x2, x3, y1, y2, y3;
        if (yAlign === 'center') {
            y2 = ptY + height / 2;
            if (xAlign === 'left') {
                x1 = ptX;
                x2 = x1 - caretSize;
                y1 = y2 + caretSize;
                y3 = y2 - caretSize;
            } else {
                x1 = ptX + width;
                x2 = x1 + caretSize;
                y1 = y2 - caretSize;
                y3 = y2 + caretSize;
            }
            x3 = x1;
        } else {
            if (xAlign === 'left') x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
            else if (xAlign === 'right') x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
            else x2 = this.caretX;
            if (yAlign === 'top') {
                y1 = ptY;
                y2 = y1 - caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
            } else {
                y1 = ptY + height;
                y2 = y1 + caretSize;
                x1 = x2 + caretSize;
                x3 = x2 - caretSize;
            }
            y3 = y1;
        }
        return {
            x1,
            x2,
            x3,
            y1,
            y2,
            y3
        };
    }
    drawTitle(pt, ctx, options) {
        const title = this.title;
        const length = title.length;
        let titleFont, titleSpacing, i;
        if (length) {
            const rtlHelper = _helpersSegmentJs.ax(options.rtl, this.x, this.width);
            pt.x = getAlignedX(this, options.titleAlign, options);
            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
            ctx.textBaseline = 'middle';
            titleFont = _helpersSegmentJs.Z(options.titleFont);
            titleSpacing = options.titleSpacing;
            ctx.fillStyle = options.titleColor;
            ctx.font = titleFont.string;
            for(i = 0; i < length; ++i){
                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
                pt.y += titleFont.lineHeight + titleSpacing;
                if (i + 1 === length) pt.y += options.titleMarginBottom - titleSpacing;
            }
        }
    }
    _drawColorBox(ctx, pt, i, rtlHelper, options) {
        const labelColors = this.labelColors[i];
        const labelPointStyle = this.labelPointStyles[i];
        const { boxHeight , boxWidth , boxPadding  } = options;
        const bodyFont = _helpersSegmentJs.Z(options.bodyFont);
        const colorX = getAlignedX(this, 'left', options);
        const rtlColorX = rtlHelper.x(colorX);
        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
        const colorY = pt.y + yOffSet;
        if (options.usePointStyle) {
            const drawOptions = {
                radius: Math.min(boxWidth, boxHeight) / 2,
                pointStyle: labelPointStyle.pointStyle,
                rotation: labelPointStyle.rotation,
                borderWidth: 1
            };
            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
            const centerY = colorY + boxHeight / 2;
            ctx.strokeStyle = options.multiKeyBackground;
            ctx.fillStyle = options.multiKeyBackground;
            _helpersSegmentJs.ar(ctx, drawOptions, centerX, centerY);
            ctx.strokeStyle = labelColors.borderColor;
            ctx.fillStyle = labelColors.backgroundColor;
            _helpersSegmentJs.ar(ctx, drawOptions, centerX, centerY);
        } else {
            ctx.lineWidth = labelColors.borderWidth || 1;
            ctx.strokeStyle = labelColors.borderColor;
            ctx.setLineDash(labelColors.borderDash || []);
            ctx.lineDashOffset = labelColors.borderDashOffset || 0;
            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
            const borderRadius = _helpersSegmentJs.au(labelColors.borderRadius);
            if (Object.values(borderRadius).some((v)=>v !== 0
            )) {
                ctx.beginPath();
                ctx.fillStyle = options.multiKeyBackground;
                _helpersSegmentJs.as(ctx, {
                    x: outerX,
                    y: colorY,
                    w: boxWidth,
                    h: boxHeight,
                    radius: borderRadius
                });
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = labelColors.backgroundColor;
                ctx.beginPath();
                _helpersSegmentJs.as(ctx, {
                    x: innerX,
                    y: colorY + 1,
                    w: boxWidth - 2,
                    h: boxHeight - 2,
                    radius: borderRadius
                });
                ctx.fill();
            } else {
                ctx.fillStyle = options.multiKeyBackground;
                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
                ctx.fillStyle = labelColors.backgroundColor;
                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
            }
        }
        ctx.fillStyle = this.labelTextColors[i];
    }
    drawBody(pt, ctx, options) {
        const { body  } = this;
        const { bodySpacing , bodyAlign , displayColors , boxHeight , boxWidth , boxPadding  } = options;
        const bodyFont = _helpersSegmentJs.Z(options.bodyFont);
        let bodyLineHeight = bodyFont.lineHeight;
        let xLinePadding = 0;
        const rtlHelper = _helpersSegmentJs.ax(options.rtl, this.x, this.width);
        const fillLineOfText = function(line) {
            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
            pt.y += bodyLineHeight + bodySpacing;
        };
        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
        let bodyItem, textColor, lines, i, j, ilen, jlen;
        ctx.textAlign = bodyAlign;
        ctx.textBaseline = 'middle';
        ctx.font = bodyFont.string;
        pt.x = getAlignedX(this, bodyAlignForCalculation, options);
        ctx.fillStyle = options.bodyColor;
        _helpersSegmentJs.D(this.beforeBody, fillLineOfText);
        xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
        for(i = 0, ilen = body.length; i < ilen; ++i){
            bodyItem = body[i];
            textColor = this.labelTextColors[i];
            ctx.fillStyle = textColor;
            _helpersSegmentJs.D(bodyItem.before, fillLineOfText);
            lines = bodyItem.lines;
            if (displayColors && lines.length) {
                this._drawColorBox(ctx, pt, i, rtlHelper, options);
                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
            }
            for(j = 0, jlen = lines.length; j < jlen; ++j){
                fillLineOfText(lines[j]);
                bodyLineHeight = bodyFont.lineHeight;
            }
            _helpersSegmentJs.D(bodyItem.after, fillLineOfText);
        }
        xLinePadding = 0;
        bodyLineHeight = bodyFont.lineHeight;
        _helpersSegmentJs.D(this.afterBody, fillLineOfText);
        pt.y -= bodySpacing;
    }
    drawFooter(pt, ctx, options) {
        const footer = this.footer;
        const length = footer.length;
        let footerFont, i;
        if (length) {
            const rtlHelper = _helpersSegmentJs.ax(options.rtl, this.x, this.width);
            pt.x = getAlignedX(this, options.footerAlign, options);
            pt.y += options.footerMarginTop;
            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
            ctx.textBaseline = 'middle';
            footerFont = _helpersSegmentJs.Z(options.footerFont);
            ctx.fillStyle = options.footerColor;
            ctx.font = footerFont.string;
            for(i = 0; i < length; ++i){
                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
                pt.y += footerFont.lineHeight + options.footerSpacing;
            }
        }
    }
    drawBackground(pt, ctx, tooltipSize, options) {
        const { xAlign , yAlign  } = this;
        const { x , y  } = pt;
        const { width , height  } = tooltipSize;
        const { topLeft , topRight , bottomLeft , bottomRight  } = _helpersSegmentJs.au(options.cornerRadius);
        ctx.fillStyle = options.backgroundColor;
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.beginPath();
        ctx.moveTo(x + topLeft, y);
        if (yAlign === 'top') this.drawCaret(pt, ctx, tooltipSize, options);
        ctx.lineTo(x + width - topRight, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
        if (yAlign === 'center' && xAlign === 'right') this.drawCaret(pt, ctx, tooltipSize, options);
        ctx.lineTo(x + width, y + height - bottomRight);
        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
        if (yAlign === 'bottom') this.drawCaret(pt, ctx, tooltipSize, options);
        ctx.lineTo(x + bottomLeft, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
        if (yAlign === 'center' && xAlign === 'left') this.drawCaret(pt, ctx, tooltipSize, options);
        ctx.lineTo(x, y + topLeft);
        ctx.quadraticCurveTo(x, y, x + topLeft, y);
        ctx.closePath();
        ctx.fill();
        if (options.borderWidth > 0) ctx.stroke();
    }
    _updateAnimationTarget(options) {
        const chart = this.chart;
        const anims = this.$animations;
        const animX = anims && anims.x;
        const animY = anims && anims.y;
        if (animX || animY) {
            const position = positioners[options.position].call(this, this._active, this._eventPosition);
            if (!position) return;
            const size = this._size = getTooltipSize(this, options);
            const positionAndSize = Object.assign({}, position, this._size);
            const alignment = determineAlignment(chart, options, positionAndSize);
            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
            if (animX._to !== point.x || animY._to !== point.y) {
                this.xAlign = alignment.xAlign;
                this.yAlign = alignment.yAlign;
                this.width = size.width;
                this.height = size.height;
                this.caretX = position.x;
                this.caretY = position.y;
                this._resolveAnimations().update(this, point);
            }
        }
    }
    draw(ctx) {
        const options = this.options.setContext(this.getContext());
        let opacity = this.opacity;
        if (!opacity) return;
        this._updateAnimationTarget(options);
        const tooltipSize = {
            width: this.width,
            height: this.height
        };
        const pt = {
            x: this.x,
            y: this.y
        };
        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
        const padding = _helpersSegmentJs.C(options.padding);
        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
        if (options.enabled && hasTooltipContent) {
            ctx.save();
            ctx.globalAlpha = opacity;
            this.drawBackground(pt, ctx, tooltipSize, options);
            _helpersSegmentJs.ay(ctx, options.textDirection);
            pt.y += padding.top;
            this.drawTitle(pt, ctx, options);
            this.drawBody(pt, ctx, options);
            this.drawFooter(pt, ctx, options);
            _helpersSegmentJs.aA(ctx, options.textDirection);
            ctx.restore();
        }
    }
    getActiveElements() {
        return this._active || [];
    }
    setActiveElements(activeElements, eventPosition) {
        const lastActive = this._active;
        const active = activeElements.map(({ datasetIndex , index  })=>{
            const meta = this.chart.getDatasetMeta(datasetIndex);
            if (!meta) throw new Error('Cannot find a dataset at index ' + datasetIndex);
            return {
                datasetIndex,
                element: meta.data[index],
                index
            };
        });
        const changed = !_helpersSegmentJs.af(lastActive, active);
        const positionChanged = this._positionChanged(active, eventPosition);
        if (changed || positionChanged) {
            this._active = active;
            this._eventPosition = eventPosition;
            this._ignoreReplayEvents = true;
            this.update(true);
        }
    }
    handleEvent(e, replay, inChartArea = true) {
        if (replay && this._ignoreReplayEvents) return false;
        this._ignoreReplayEvents = false;
        const options = this.options;
        const lastActive = this._active || [];
        const active = this._getActiveElements(e, lastActive, replay, inChartArea);
        const positionChanged = this._positionChanged(active, e);
        const changed = replay || !_helpersSegmentJs.af(active, lastActive) || positionChanged;
        if (changed) {
            this._active = active;
            if (options.enabled || options.external) {
                this._eventPosition = {
                    x: e.x,
                    y: e.y
                };
                this.update(true, replay);
            }
        }
        return changed;
    }
    _getActiveElements(e, lastActive, replay, inChartArea) {
        const options = this.options;
        if (e.type === 'mouseout') return [];
        if (!inChartArea) return lastActive;
        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
        if (options.reverse) active.reverse();
        return active;
    }
    _positionChanged(active, e) {
        const { caretX , caretY , options  } = this;
        const position = positioners[options.position].call(this, active, e);
        return position !== false && (caretX !== position.x || caretY !== position.y);
    }
    constructor(config){
        super();
        this.opacity = 0;
        this._active = [];
        this._eventPosition = undefined;
        this._size = undefined;
        this._cachedAnimations = undefined;
        this._tooltipItems = [];
        this.$animations = undefined;
        this.$context = undefined;
        this.chart = config.chart || config._chart;
        this._chart = this.chart;
        this.options = config.options;
        this.dataPoints = undefined;
        this.title = undefined;
        this.beforeBody = undefined;
        this.body = undefined;
        this.afterBody = undefined;
        this.footer = undefined;
        this.xAlign = undefined;
        this.yAlign = undefined;
        this.x = undefined;
        this.y = undefined;
        this.height = undefined;
        this.width = undefined;
        this.caretX = undefined;
        this.caretY = undefined;
        this.labelColors = undefined;
        this.labelPointStyles = undefined;
        this.labelTextColors = undefined;
    }
}
Tooltip.positioners = positioners;
var plugin_tooltip = {
    id: 'tooltip',
    _element: Tooltip,
    positioners,
    afterInit (chart, _args, options) {
        if (options) chart.tooltip = new Tooltip({
            chart,
            options
        });
    },
    beforeUpdate (chart, _args, options) {
        if (chart.tooltip) chart.tooltip.initialize(options);
    },
    reset (chart, _args, options) {
        if (chart.tooltip) chart.tooltip.initialize(options);
    },
    afterDraw (chart) {
        const tooltip = chart.tooltip;
        const args = {
            tooltip
        };
        if (chart.notifyPlugins('beforeTooltipDraw', args) === false) return;
        if (tooltip) tooltip.draw(chart.ctx);
        chart.notifyPlugins('afterTooltipDraw', args);
    },
    afterEvent (chart, args) {
        if (chart.tooltip) {
            const useFinalPosition = args.replay;
            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) args.changed = true;
        }
    },
    defaults: {
        enabled: true,
        external: null,
        position: 'average',
        backgroundColor: 'rgba(0,0,0,0.8)',
        titleColor: '#fff',
        titleFont: {
            weight: 'bold'
        },
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleAlign: 'left',
        bodyColor: '#fff',
        bodySpacing: 2,
        bodyFont: {},
        bodyAlign: 'left',
        footerColor: '#fff',
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFont: {
            weight: 'bold'
        },
        footerAlign: 'left',
        padding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        boxHeight: (ctx, opts)=>opts.bodyFont.size
        ,
        boxWidth: (ctx, opts)=>opts.bodyFont.size
        ,
        multiKeyBackground: '#fff',
        displayColors: true,
        boxPadding: 0,
        borderColor: 'rgba(0,0,0,0)',
        borderWidth: 0,
        animation: {
            duration: 400,
            easing: 'easeOutQuart'
        },
        animations: {
            numbers: {
                type: 'number',
                properties: [
                    'x',
                    'y',
                    'width',
                    'height',
                    'caretX',
                    'caretY'
                ]
            },
            opacity: {
                easing: 'linear',
                duration: 200
            }
        },
        callbacks: {
            beforeTitle: _helpersSegmentJs.aB,
            title (tooltipItems) {
                if (tooltipItems.length > 0) {
                    const item = tooltipItems[0];
                    const labels = item.chart.data.labels;
                    const labelCount = labels ? labels.length : 0;
                    if (this && this.options && this.options.mode === 'dataset') return item.dataset.label || '';
                    else if (item.label) return item.label;
                    else if (labelCount > 0 && item.dataIndex < labelCount) return labels[item.dataIndex];
                }
                return '';
            },
            afterTitle: _helpersSegmentJs.aB,
            beforeBody: _helpersSegmentJs.aB,
            beforeLabel: _helpersSegmentJs.aB,
            label (tooltipItem) {
                if (this && this.options && this.options.mode === 'dataset') return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;
                let label = tooltipItem.dataset.label || '';
                if (label) label += ': ';
                const value = tooltipItem.formattedValue;
                if (!_helpersSegmentJs.k(value)) label += value;
                return label;
            },
            labelColor (tooltipItem) {
                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
                const options = meta.controller.getStyle(tooltipItem.dataIndex);
                return {
                    borderColor: options.borderColor,
                    backgroundColor: options.backgroundColor,
                    borderWidth: options.borderWidth,
                    borderDash: options.borderDash,
                    borderDashOffset: options.borderDashOffset,
                    borderRadius: 0
                };
            },
            labelTextColor () {
                return this.options.bodyColor;
            },
            labelPointStyle (tooltipItem) {
                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
                const options = meta.controller.getStyle(tooltipItem.dataIndex);
                return {
                    pointStyle: options.pointStyle,
                    rotation: options.rotation
                };
            },
            afterLabel: _helpersSegmentJs.aB,
            afterBody: _helpersSegmentJs.aB,
            beforeFooter: _helpersSegmentJs.aB,
            footer: _helpersSegmentJs.aB,
            afterFooter: _helpersSegmentJs.aB
        }
    },
    defaultRoutes: {
        bodyFont: 'font',
        footerFont: 'font',
        titleFont: 'font'
    },
    descriptors: {
        _scriptable: (name)=>name !== 'filter' && name !== 'itemSort' && name !== 'external'
        ,
        _indexable: false,
        callbacks: {
            _scriptable: false,
            _indexable: false
        },
        animation: {
            _fallback: false
        },
        animations: {
            _fallback: 'animation'
        }
    },
    additionalOptionScopes: [
        'interaction'
    ]
};
var plugins = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Decimation: plugin_decimation,
    Filler: plugin_filler,
    Legend: plugin_legend,
    SubTitle: plugin_subtitle,
    Title: plugin_title,
    Tooltip: plugin_tooltip
});
const addIfString = (labels, raw, index, addedLabels)=>{
    if (typeof raw === 'string') {
        index = labels.push(raw) - 1;
        addedLabels.unshift({
            index,
            label: raw
        });
    } else if (isNaN(raw)) index = null;
    return index;
};
function findOrAddLabel(labels, raw, index, addedLabels) {
    const first = labels.indexOf(raw);
    if (first === -1) return addIfString(labels, raw, index, addedLabels);
    const last = labels.lastIndexOf(raw);
    return first !== last ? index : first;
}
const validIndex = (index, max)=>index === null ? null : _helpersSegmentJs.w(Math.round(index), 0, max)
;
class CategoryScale extends Scale {
    init(scaleOptions) {
        const added = this._addedLabels;
        if (added.length) {
            const labels = this.getLabels();
            for (const { index , label  } of added)if (labels[index] === label) labels.splice(index, 1);
            this._addedLabels = [];
        }
        super.init(scaleOptions);
    }
    parse(raw, index) {
        if (_helpersSegmentJs.k(raw)) return null;
        const labels = this.getLabels();
        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, _helpersSegmentJs.v(index, raw), this._addedLabels);
        return validIndex(index, labels.length - 1);
    }
    determineDataLimits() {
        const { minDefined , maxDefined  } = this.getUserBounds();
        let { min , max  } = this.getMinMax(true);
        if (this.options.bounds === 'ticks') {
            if (!minDefined) min = 0;
            if (!maxDefined) max = this.getLabels().length - 1;
        }
        this.min = min;
        this.max = max;
    }
    buildTicks() {
        const min = this.min;
        const max = this.max;
        const offset = this.options.offset;
        const ticks = [];
        let labels = this.getLabels();
        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
        this._startValue = this.min - (offset ? 0.5 : 0);
        for(let value = min; value <= max; value++)ticks.push({
            value
        });
        return ticks;
    }
    getLabelForValue(value) {
        const labels = this.getLabels();
        if (value >= 0 && value < labels.length) return labels[value];
        return value;
    }
    configure() {
        super.configure();
        if (!this.isHorizontal()) this._reversePixels = !this._reversePixels;
    }
    getPixelForValue(value) {
        if (typeof value !== 'number') value = this.parse(value);
        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getPixelForTick(index) {
        const ticks = this.ticks;
        if (index < 0 || index > ticks.length - 1) return null;
        return this.getPixelForValue(ticks[index].value);
    }
    getValueForPixel(pixel) {
        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
    }
    getBasePixel() {
        return this.bottom;
    }
    constructor(cfg){
        super(cfg);
        this._startValue = undefined;
        this._valueRange = 0;
        this._addedLabels = [];
    }
}
CategoryScale.id = 'category';
CategoryScale.defaults = {
    ticks: {
        callback: CategoryScale.prototype.getLabelForValue
    }
};
function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds , step , min , max , precision , count , maxTicks , maxDigits , includeBounds  } = generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin , max: rmax  } = dataRange;
    const minDefined = !_helpersSegmentJs.k(min);
    const maxDefined = !_helpersSegmentJs.k(max);
    const countDefined = !_helpersSegmentJs.k(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = _helpersSegmentJs.aE((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) return [
        {
            value: rmin
        },
        {
            value: rmax
        }
    ];
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) spacing = _helpersSegmentJs.aE(numSpaces * spacing / maxSpaces / unit) * unit;
    if (!_helpersSegmentJs.k(precision)) {
        factor = Math.pow(10, precision);
        spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === 'ticks') {
        niceMin = Math.floor(rmin / spacing) * spacing;
        niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
        niceMin = rmin;
        niceMax = rmax;
    }
    if (minDefined && maxDefined && step && _helpersSegmentJs.aF((max - min) / step, spacing / 1000)) {
        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
        spacing = (max - min) / numSpaces;
        niceMin = min;
        niceMax = max;
    } else if (countDefined) {
        niceMin = minDefined ? min : niceMin;
        niceMax = maxDefined ? max : niceMax;
        numSpaces = count - 1;
        spacing = (niceMax - niceMin) / numSpaces;
    } else {
        numSpaces = (niceMax - niceMin) / spacing;
        if (_helpersSegmentJs.aG(numSpaces, Math.round(numSpaces), spacing / 1000)) numSpaces = Math.round(numSpaces);
        else numSpaces = Math.ceil(numSpaces);
    }
    const decimalPlaces = Math.max(_helpersSegmentJs.aH(spacing), _helpersSegmentJs.aH(niceMin));
    factor = Math.pow(10, _helpersSegmentJs.k(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j = 0;
    if (minDefined) {
        if (includeBounds && niceMin !== min) {
            ticks.push({
                value: min
            });
            if (niceMin < min) j++;
            if (_helpersSegmentJs.aG(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) j++;
        } else if (niceMin < min) j++;
    }
    for(; j < numSpaces; ++j)ticks.push({
        value: Math.round((niceMin + j * spacing) * factor) / factor
    });
    if (maxDefined && includeBounds && niceMax !== max) {
        if (ticks.length && _helpersSegmentJs.aG(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) ticks[ticks.length - 1].value = max;
        else ticks.push({
            value: max
        });
    } else if (!maxDefined || niceMax === max) ticks.push({
        value: niceMax
    });
    return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal , minRotation  }) {
    const rad = _helpersSegmentJs.t(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;
    const length = 0.75 * minSpacing * ('' + value).length;
    return Math.min(minSpacing / ratio, length);
}
class LinearScaleBase extends Scale {
    parse(raw, index) {
        if (_helpersSegmentJs.k(raw)) return null;
        if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) return null;
        return +raw;
    }
    handleTickRangeOptions() {
        const { beginAtZero  } = this.options;
        const { minDefined , maxDefined  } = this.getUserBounds();
        let { min , max  } = this;
        const setMin = (v)=>min = minDefined ? min : v
        ;
        const setMax = (v)=>max = maxDefined ? max : v
        ;
        if (beginAtZero) {
            const minSign = _helpersSegmentJs.s(min);
            const maxSign = _helpersSegmentJs.s(max);
            if (minSign < 0 && maxSign < 0) setMax(0);
            else if (minSign > 0 && maxSign > 0) setMin(0);
        }
        if (min === max) {
            let offset = 1;
            if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) offset = Math.abs(max * 0.05);
            setMax(max + offset);
            if (!beginAtZero) setMin(min - offset);
        }
        this.min = min;
        this.max = max;
    }
    getTickLimit() {
        const tickOpts = this.options.ticks;
        let { maxTicksLimit , stepSize  } = tickOpts;
        let maxTicks;
        if (stepSize) {
            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
            if (maxTicks > 1000) {
                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
                maxTicks = 1000;
            }
        } else {
            maxTicks = this.computeTickLimit();
            maxTicksLimit = maxTicksLimit || 11;
        }
        if (maxTicksLimit) maxTicks = Math.min(maxTicksLimit, maxTicks);
        return maxTicks;
    }
    computeTickLimit() {
        return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
        const opts = this.options;
        const tickOpts = opts.ticks;
        let maxTicks = this.getTickLimit();
        maxTicks = Math.max(2, maxTicks);
        const numericGeneratorOptions = {
            maxTicks,
            bounds: opts.bounds,
            min: opts.min,
            max: opts.max,
            precision: tickOpts.precision,
            step: tickOpts.stepSize,
            count: tickOpts.count,
            maxDigits: this._maxDigits(),
            horizontal: this.isHorizontal(),
            minRotation: tickOpts.minRotation || 0,
            includeBounds: tickOpts.includeBounds !== false
        };
        const dataRange = this._range || this;
        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
        if (opts.bounds === 'ticks') _helpersSegmentJs.aD(ticks, this, 'value');
        if (opts.reverse) {
            ticks.reverse();
            this.start = this.max;
            this.end = this.min;
        } else {
            this.start = this.min;
            this.end = this.max;
        }
        return ticks;
    }
    configure() {
        const ticks = this.ticks;
        let start = this.min;
        let end = this.max;
        super.configure();
        if (this.options.offset && ticks.length) {
            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
            start -= offset;
            end += offset;
        }
        this._startValue = start;
        this._endValue = end;
        this._valueRange = end - start;
    }
    getLabelForValue(value) {
        return _helpersSegmentJs.o(value, this.chart.options.locale, this.options.ticks.format);
    }
    constructor(cfg){
        super(cfg);
        this.start = undefined;
        this.end = undefined;
        this._startValue = undefined;
        this._endValue = undefined;
        this._valueRange = 0;
    }
}
class LinearScale extends LinearScaleBase {
    determineDataLimits() {
        const { min , max  } = this.getMinMax(true);
        this.min = _helpersSegmentJs.g(min) ? min : 0;
        this.max = _helpersSegmentJs.g(max) ? max : 1;
        this.handleTickRangeOptions();
    }
    computeTickLimit() {
        const horizontal = this.isHorizontal();
        const length = horizontal ? this.width : this.height;
        const minRotation = _helpersSegmentJs.t(this.options.ticks.minRotation);
        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;
        const tickFont = this._resolveTickFontOptions(0);
        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
    }
    getPixelForValue(value) {
        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    }
}
LinearScale.id = 'linear';
LinearScale.defaults = {
    ticks: {
        callback: Ticks.formatters.numeric
    }
};
function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, Math.floor(_helpersSegmentJs.L(tickVal)));
    return remain === 1;
}
function generateTicks(generationOptions, dataRange) {
    const endExp = Math.floor(_helpersSegmentJs.L(dataRange.max));
    const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
    const ticks = [];
    let tickVal = _helpersSegmentJs.N(generationOptions.min, Math.pow(10, Math.floor(_helpersSegmentJs.L(dataRange.min))));
    let exp = Math.floor(_helpersSegmentJs.L(tickVal));
    let significand = Math.floor(tickVal / Math.pow(10, exp));
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    do {
        ticks.push({
            value: tickVal,
            major: isMajor(tickVal)
        });
        ++significand;
        if (significand === 10) {
            significand = 1;
            ++exp;
            precision = exp >= 0 ? 1 : precision;
        }
        tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
    }while (exp < endExp || exp === endExp && significand < endSignificand)
    const lastTick = _helpersSegmentJs.N(generationOptions.max, tickVal);
    ticks.push({
        value: lastTick,
        major: isMajor(tickVal)
    });
    return ticks;
}
class LogarithmicScale extends Scale {
    parse(raw, index) {
        const value = LinearScaleBase.prototype.parse.apply(this, [
            raw,
            index
        ]);
        if (value === 0) {
            this._zero = true;
            return undefined;
        }
        return _helpersSegmentJs.g(value) && value > 0 ? value : null;
    }
    determineDataLimits() {
        const { min , max  } = this.getMinMax(true);
        this.min = _helpersSegmentJs.g(min) ? Math.max(0, min) : null;
        this.max = _helpersSegmentJs.g(max) ? Math.max(0, max) : null;
        if (this.options.beginAtZero) this._zero = true;
        this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
        const { minDefined , maxDefined  } = this.getUserBounds();
        let min = this.min;
        let max = this.max;
        const setMin = (v)=>min = minDefined ? min : v
        ;
        const setMax = (v)=>max = maxDefined ? max : v
        ;
        const exp = (v, m)=>Math.pow(10, Math.floor(_helpersSegmentJs.L(v)) + m)
        ;
        if (min === max) {
            if (min <= 0) {
                setMin(1);
                setMax(10);
            } else {
                setMin(exp(min, -1));
                setMax(exp(max, 1));
            }
        }
        if (min <= 0) setMin(exp(max, -1));
        if (max <= 0) setMax(exp(min, 1));
        if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) setMin(exp(min, -1));
        this.min = min;
        this.max = max;
    }
    buildTicks() {
        const opts = this.options;
        const generationOptions = {
            min: this._userMin,
            max: this._userMax
        };
        const ticks = generateTicks(generationOptions, this);
        if (opts.bounds === 'ticks') _helpersSegmentJs.aD(ticks, this, 'value');
        if (opts.reverse) {
            ticks.reverse();
            this.start = this.max;
            this.end = this.min;
        } else {
            this.start = this.min;
            this.end = this.max;
        }
        return ticks;
    }
    getLabelForValue(value) {
        return value === undefined ? '0' : _helpersSegmentJs.o(value, this.chart.options.locale, this.options.ticks.format);
    }
    configure() {
        const start = this.min;
        super.configure();
        this._startValue = _helpersSegmentJs.L(start);
        this._valueRange = _helpersSegmentJs.L(this.max) - _helpersSegmentJs.L(start);
    }
    getPixelForValue(value) {
        if (value === undefined || value === 0) value = this.min;
        if (value === null || isNaN(value)) return NaN;
        return this.getPixelForDecimal(value === this.min ? 0 : (_helpersSegmentJs.L(value) - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
        const decimal = this.getDecimalForPixel(pixel);
        return Math.pow(10, this._startValue + decimal * this._valueRange);
    }
    constructor(cfg){
        super(cfg);
        this.start = undefined;
        this.end = undefined;
        this._startValue = undefined;
        this._valueRange = 0;
    }
}
LogarithmicScale.id = 'logarithmic';
LogarithmicScale.defaults = {
    ticks: {
        callback: Ticks.formatters.logarithmic,
        major: {
            enabled: true
        }
    }
};
function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
        const padding = _helpersSegmentJs.C(tickOpts.backdropPadding);
        return _helpersSegmentJs.v(tickOpts.font && tickOpts.font.size, _helpersSegmentJs.d.font.size) + padding.height;
    }
    return 0;
}
function measureLabelSize(ctx, font, label) {
    label = _helpersSegmentJs.b(label) ? label : [
        label
    ];
    return {
        w: _helpersSegmentJs.aI(ctx, font.string, label),
        h: label.length * font.lineHeight
    };
}
function determineLimits(angle, pos, size, min, max) {
    if (angle === min || angle === max) return {
        start: pos - size / 2,
        end: pos + size / 2
    };
    else if (angle < min || angle > max) return {
        start: pos - size,
        end: pos
    };
    return {
        start: pos,
        end: pos + size
    };
}
function fitWithPointLabels(scale) {
    const orig = {
        l: scale.left + scale._padding.left,
        r: scale.right - scale._padding.right,
        t: scale.top + scale._padding.top,
        b: scale.bottom - scale._padding.bottom
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale._pointLabels.length;
    const pointLabelOpts = scale.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? _helpersSegmentJs.P / valueCount : 0;
    for(let i = 0; i < valueCount; i++){
        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
        padding[i] = opts.padding;
        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
        const plFont = _helpersSegmentJs.Z(opts.font);
        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
        labelSizes[i] = textSize;
        const angleRadians = _helpersSegmentJs.aw(scale.getIndexAngle(i) + additionalAngle);
        const angle = Math.round(_helpersSegmentJs.R(angleRadians));
        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
        updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x = 0;
    let y = 0;
    if (hLimits.start < orig.l) {
        x = (orig.l - hLimits.start) / sin;
        limits.l = Math.min(limits.l, orig.l - x);
    } else if (hLimits.end > orig.r) {
        x = (hLimits.end - orig.r) / sin;
        limits.r = Math.max(limits.r, orig.r + x);
    }
    if (vLimits.start < orig.t) {
        y = (orig.t - vLimits.start) / cos;
        limits.t = Math.min(limits.t, orig.t - y);
    } else if (vLimits.end > orig.b) {
        y = (vLimits.end - orig.b) / cos;
        limits.b = Math.max(limits.b, orig.b + y);
    }
}
function buildPointLabelItems(scale, labelSizes, padding) {
    const items = [];
    const valueCount = scale._pointLabels.length;
    const opts = scale.options;
    const extra = getTickBackdropHeight(opts) / 2;
    const outerDistance = scale.drawingArea;
    const additionalAngle = opts.pointLabels.centerPointLabels ? _helpersSegmentJs.P / valueCount : 0;
    for(let i = 0; i < valueCount; i++){
        const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
        const angle = Math.round(_helpersSegmentJs.R(_helpersSegmentJs.aw(pointLabelPosition.angle + _helpersSegmentJs.H)));
        const size = labelSizes[i];
        const y = yForAngle(pointLabelPosition.y, size.h, angle);
        const textAlign = getTextAlignForAngle(angle);
        const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
        items.push({
            x: pointLabelPosition.x,
            y,
            textAlign,
            left,
            top: y,
            right: left + size.w,
            bottom: y + size.h
        });
    }
    return items;
}
function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) return 'center';
    else if (angle < 180) return 'left';
    return 'right';
}
function leftForTextAlign(x, w, align) {
    if (align === 'right') x -= w;
    else if (align === 'center') x -= w / 2;
    return x;
}
function yForAngle(y, h, angle) {
    if (angle === 90 || angle === 270) y -= h / 2;
    else if (angle > 270 || angle < 90) y -= h;
    return y;
}
function drawPointLabels(scale, labelCount) {
    const { ctx , options: { pointLabels  }  } = scale;
    for(let i = labelCount - 1; i >= 0; i--){
        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
        const plFont = _helpersSegmentJs.Z(optsAtIndex.font);
        const { x , y , textAlign , left , top , right , bottom  } = scale._pointLabelItems[i];
        const { backdropColor  } = optsAtIndex;
        if (!_helpersSegmentJs.k(backdropColor)) {
            const padding = _helpersSegmentJs.C(optsAtIndex.backdropPadding);
            ctx.fillStyle = backdropColor;
            ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height);
        }
        _helpersSegmentJs.X(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
            color: optsAtIndex.color,
            textAlign: textAlign,
            textBaseline: 'middle'
        });
    }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
    const { ctx  } = scale;
    if (circular) ctx.arc(scale.xCenter, scale.yCenter, radius, 0, _helpersSegmentJs.T);
    else {
        let pointPosition = scale.getPointPosition(0, radius);
        ctx.moveTo(pointPosition.x, pointPosition.y);
        for(let i = 1; i < labelCount; i++){
            pointPosition = scale.getPointPosition(i, radius);
            ctx.lineTo(pointPosition.x, pointPosition.y);
        }
    }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
    const ctx = scale.ctx;
    const circular = gridLineOpts.circular;
    const { color , lineWidth  } = gridLineOpts;
    if (!circular && !labelCount || !color || !lineWidth || radius < 0) return;
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(gridLineOpts.borderDash);
    ctx.lineDashOffset = gridLineOpts.borderDashOffset;
    ctx.beginPath();
    pathRadiusLine(scale, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
}
function createPointLabelContext(parent, index, label) {
    return _helpersSegmentJs.h(parent, {
        label,
        index,
        type: 'pointLabel'
    });
}
class RadialLinearScale extends LinearScaleBase {
    setDimensions() {
        const padding = this._padding = _helpersSegmentJs.C(getTickBackdropHeight(this.options) / 2);
        const w = this.width = this.maxWidth - padding.width;
        const h = this.height = this.maxHeight - padding.height;
        this.xCenter = Math.floor(this.left + w / 2 + padding.left);
        this.yCenter = Math.floor(this.top + h / 2 + padding.top);
        this.drawingArea = Math.floor(Math.min(w, h) / 2);
    }
    determineDataLimits() {
        const { min , max  } = this.getMinMax(false);
        this.min = _helpersSegmentJs.g(min) && !isNaN(min) ? min : 0;
        this.max = _helpersSegmentJs.g(max) && !isNaN(max) ? max : 0;
        this.handleTickRangeOptions();
    }
    computeTickLimit() {
        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    }
    generateTickLabels(ticks) {
        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
        this._pointLabels = this.getLabels().map((value, index)=>{
            const label = _helpersSegmentJs.O(this.options.pointLabels.callback, [
                value,
                index
            ], this);
            return label || label === 0 ? label : '';
        }).filter((v, i)=>this.chart.getDataVisibility(i)
        );
    }
    fit() {
        const opts = this.options;
        if (opts.display && opts.pointLabels.display) fitWithPointLabels(this);
        else this.setCenterPoint(0, 0, 0, 0);
    }
    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
    }
    getIndexAngle(index) {
        const angleMultiplier = _helpersSegmentJs.T / (this._pointLabels.length || 1);
        const startAngle = this.options.startAngle || 0;
        return _helpersSegmentJs.aw(index * angleMultiplier + _helpersSegmentJs.t(startAngle));
    }
    getDistanceFromCenterForValue(value) {
        if (_helpersSegmentJs.k(value)) return NaN;
        const scalingFactor = this.drawingArea / (this.max - this.min);
        if (this.options.reverse) return (this.max - value) * scalingFactor;
        return (value - this.min) * scalingFactor;
    }
    getValueForDistanceFromCenter(distance) {
        if (_helpersSegmentJs.k(distance)) return NaN;
        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
    }
    getPointLabelContext(index) {
        const pointLabels = this._pointLabels || [];
        if (index >= 0 && index < pointLabels.length) {
            const pointLabel = pointLabels[index];
            return createPointLabelContext(this.getContext(), index, pointLabel);
        }
    }
    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
        const angle = this.getIndexAngle(index) - _helpersSegmentJs.H + additionalAngle;
        return {
            x: Math.cos(angle) * distanceFromCenter + this.xCenter,
            y: Math.sin(angle) * distanceFromCenter + this.yCenter,
            angle
        };
    }
    getPointPositionForValue(index, value) {
        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
    }
    getBasePosition(index) {
        return this.getPointPositionForValue(index || 0, this.getBaseValue());
    }
    getPointLabelPosition(index) {
        const { left , top , right , bottom  } = this._pointLabelItems[index];
        return {
            left,
            top,
            right,
            bottom
        };
    }
    drawBackground() {
        const { backgroundColor , grid: { circular  }  } = this.options;
        if (backgroundColor) {
            const ctx = this.ctx;
            ctx.save();
            ctx.beginPath();
            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
            ctx.closePath();
            ctx.fillStyle = backgroundColor;
            ctx.fill();
            ctx.restore();
        }
    }
    drawGrid() {
        const ctx = this.ctx;
        const opts = this.options;
        const { angleLines , grid  } = opts;
        const labelCount = this._pointLabels.length;
        let i, offset, position;
        if (opts.pointLabels.display) drawPointLabels(this, labelCount);
        if (grid.display) this.ticks.forEach((tick, index)=>{
            if (index !== 0) {
                offset = this.getDistanceFromCenterForValue(tick.value);
                const optsAtIndex = grid.setContext(this.getContext(index - 1));
                drawRadiusLine(this, optsAtIndex, offset, labelCount);
            }
        });
        if (angleLines.display) {
            ctx.save();
            for(i = labelCount - 1; i >= 0; i--){
                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
                const { color , lineWidth  } = optsAtIndex;
                if (!lineWidth || !color) continue;
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = color;
                ctx.setLineDash(optsAtIndex.borderDash);
                ctx.lineDashOffset = optsAtIndex.borderDashOffset;
                offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
                position = this.getPointPosition(i, offset);
                ctx.beginPath();
                ctx.moveTo(this.xCenter, this.yCenter);
                ctx.lineTo(position.x, position.y);
                ctx.stroke();
            }
            ctx.restore();
        }
    }
    drawBorder() {}
    drawLabels() {
        const ctx = this.ctx;
        const opts = this.options;
        const tickOpts = opts.ticks;
        if (!tickOpts.display) return;
        const startAngle = this.getIndexAngle(0);
        let offset, width;
        ctx.save();
        ctx.translate(this.xCenter, this.yCenter);
        ctx.rotate(startAngle);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        this.ticks.forEach((tick, index)=>{
            if (index === 0 && !opts.reverse) return;
            const optsAtIndex = tickOpts.setContext(this.getContext(index));
            const tickFont = _helpersSegmentJs.Z(optsAtIndex.font);
            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
            if (optsAtIndex.showLabelBackdrop) {
                ctx.font = tickFont.string;
                width = ctx.measureText(tick.label).width;
                ctx.fillStyle = optsAtIndex.backdropColor;
                const padding = _helpersSegmentJs.C(optsAtIndex.backdropPadding);
                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
            }
            _helpersSegmentJs.X(ctx, tick.label, 0, -offset, tickFont, {
                color: optsAtIndex.color
            });
        });
        ctx.restore();
    }
    drawTitle() {}
    constructor(cfg){
        super(cfg);
        this.xCenter = undefined;
        this.yCenter = undefined;
        this.drawingArea = undefined;
        this._pointLabels = [];
        this._pointLabelItems = [];
    }
}
RadialLinearScale.id = 'radialLinear';
RadialLinearScale.defaults = {
    display: true,
    animate: true,
    position: 'chartArea',
    angleLines: {
        display: true,
        lineWidth: 1,
        borderDash: [],
        borderDashOffset: 0.0
    },
    grid: {
        circular: false
    },
    startAngle: 0,
    ticks: {
        showLabelBackdrop: true,
        callback: Ticks.formatters.numeric
    },
    pointLabels: {
        backdropColor: undefined,
        backdropPadding: 2,
        display: true,
        font: {
            size: 10
        },
        callback (label) {
            return label;
        },
        padding: 5,
        centerPointLabels: false
    }
};
RadialLinearScale.defaultRoutes = {
    'angleLines.color': 'borderColor',
    'pointLabels.color': 'color',
    'ticks.color': 'color'
};
RadialLinearScale.descriptors = {
    angleLines: {
        _fallback: 'grid'
    }
};
const INTERVALS = {
    millisecond: {
        common: true,
        size: 1,
        steps: 1000
    },
    second: {
        common: true,
        size: 1000,
        steps: 60
    },
    minute: {
        common: true,
        size: 60000,
        steps: 60
    },
    hour: {
        common: true,
        size: 3600000,
        steps: 24
    },
    day: {
        common: true,
        size: 86400000,
        steps: 30
    },
    week: {
        common: false,
        size: 604800000,
        steps: 4
    },
    month: {
        common: true,
        size: 2.628e9,
        steps: 12
    },
    quarter: {
        common: false,
        size: 7.884e9,
        steps: 4
    },
    year: {
        common: true,
        size: 3.154e10
    }
};
const UNITS = Object.keys(INTERVALS);
function sorter(a, b) {
    return a - b;
}
function parse(scale, input) {
    if (_helpersSegmentJs.k(input)) return null;
    const adapter = scale._adapter;
    const { parser , round , isoWeekday  } = scale._parseOpts;
    let value = input;
    if (typeof parser === 'function') value = parser(value);
    if (!_helpersSegmentJs.g(value)) value = typeof parser === 'string' ? adapter.parse(value, parser) : adapter.parse(value);
    if (value === null) return null;
    if (round) value = round === 'week' && (_helpersSegmentJs.q(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);
    return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
    const ilen = UNITS.length;
    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){
        const interval = INTERVALS[UNITS[i]];
        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) return UNITS[i];
    }
    return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){
        const unit = UNITS[i];
        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) return unit;
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){
        if (INTERVALS[UNITS[i]].common) return UNITS[i];
    }
}
function addTick(ticks, time, timestamps) {
    if (!timestamps) ticks[time] = true;
    else if (timestamps.length) {
        const { lo , hi  } = _helpersSegmentJs.aK(timestamps, time);
        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
        ticks[timestamp] = true;
    }
}
function setMajorTicks(scale, ticks, map1, majorUnit) {
    const adapter = scale._adapter;
    const first = +adapter.startOf(ticks[0].value, majorUnit);
    const last = ticks[ticks.length - 1].value;
    let major, index;
    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){
        index = map1[major];
        if (index >= 0) ticks[index].major = true;
    }
    return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
    const ticks = [];
    const map2 = {};
    const ilen = values.length;
    let i, value;
    for(i = 0; i < ilen; ++i){
        value = values[i];
        map2[value] = i;
        ticks.push({
            value,
            major: false
        });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map2, majorUnit);
}
class TimeScale extends Scale {
    init(scaleOpts, opts) {
        const time = scaleOpts.time || (scaleOpts.time = {});
        const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
        _helpersSegmentJs.a9(time.displayFormats, adapter.formats());
        this._parseOpts = {
            parser: time.parser,
            round: time.round,
            isoWeekday: time.isoWeekday
        };
        super.init(scaleOpts);
        this._normalized = opts.normalized;
    }
    parse(raw, index) {
        if (raw === undefined) return null;
        return parse(this, raw);
    }
    beforeLayout() {
        super.beforeLayout();
        this._cache = {
            data: [],
            labels: [],
            all: []
        };
    }
    determineDataLimits() {
        const options = this.options;
        const adapter = this._adapter;
        const unit = options.time.unit || 'day';
        let { min , max , minDefined , maxDefined  } = this.getUserBounds();
        function _applyBounds(bounds) {
            if (!minDefined && !isNaN(bounds.min)) min = Math.min(min, bounds.min);
            if (!maxDefined && !isNaN(bounds.max)) max = Math.max(max, bounds.max);
        }
        if (!minDefined || !maxDefined) {
            _applyBounds(this._getLabelBounds());
            if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') _applyBounds(this.getMinMax(false));
        }
        min = _helpersSegmentJs.g(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
        max = _helpersSegmentJs.g(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
        this.min = Math.min(min, max - 1);
        this.max = Math.max(min + 1, max);
    }
    _getLabelBounds() {
        const arr = this.getLabelTimestamps();
        let min = Number.POSITIVE_INFINITY;
        let max = Number.NEGATIVE_INFINITY;
        if (arr.length) {
            min = arr[0];
            max = arr[arr.length - 1];
        }
        return {
            min,
            max
        };
    }
    buildTicks() {
        const options = this.options;
        const timeOpts = options.time;
        const tickOpts = options.ticks;
        const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();
        if (options.bounds === 'ticks' && timestamps.length) {
            this.min = this._userMin || timestamps[0];
            this.max = this._userMax || timestamps[timestamps.length - 1];
        }
        const min = this.min;
        const max = this.max;
        const ticks = _helpersSegmentJs.aJ(timestamps, min, max);
        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
        this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined : determineMajorUnit(this._unit);
        this.initOffsets(timestamps);
        if (options.reverse) ticks.reverse();
        return ticksFromTimestamps(this, ticks, this._majorUnit);
    }
    initOffsets(timestamps) {
        let start = 0;
        let end = 0;
        let first, last;
        if (this.options.offset && timestamps.length) {
            first = this.getDecimalForValue(timestamps[0]);
            if (timestamps.length === 1) start = 1 - first;
            else start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
            if (timestamps.length === 1) end = last;
            else end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
        }
        const limit = timestamps.length < 3 ? 0.5 : 0.25;
        start = _helpersSegmentJs.w(start, 0, limit);
        end = _helpersSegmentJs.w(end, 0, limit);
        this._offsets = {
            start,
            end,
            factor: 1 / (start + 1 + end)
        };
    }
    _generate() {
        const adapter = this._adapter;
        const min = this.min;
        const max = this.max;
        const options = this.options;
        const timeOpts = options.time;
        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
        const stepSize = _helpersSegmentJs.v(timeOpts.stepSize, 1);
        const weekday = minor === 'week' ? timeOpts.isoWeekday : false;
        const hasWeekday = _helpersSegmentJs.q(weekday) || weekday === true;
        const ticks = {};
        let first = min;
        let time, count;
        if (hasWeekday) first = +adapter.startOf(first, 'isoWeek', weekday);
        first = +adapter.startOf(first, hasWeekday ? 'day' : minor);
        if (adapter.diff(max, min, minor) > 100000 * stepSize) throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);
        const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();
        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++)addTick(ticks, time, timestamps);
        if (time === max || options.bounds === 'ticks' || count === 1) addTick(ticks, time, timestamps);
        return Object.keys(ticks).sort((a, b)=>a - b
        ).map((x)=>+x
        );
    }
    getLabelForValue(value) {
        const adapter = this._adapter;
        const timeOpts = this.options.time;
        if (timeOpts.tooltipFormat) return adapter.format(value, timeOpts.tooltipFormat);
        return adapter.format(value, timeOpts.displayFormats.datetime);
    }
    _tickFormatFunction(time, index, ticks, format) {
        const options = this.options;
        const formats = options.time.displayFormats;
        const unit = this._unit;
        const majorUnit = this._majorUnit;
        const minorFormat = unit && formats[unit];
        const majorFormat = majorUnit && formats[majorUnit];
        const tick = ticks[index];
        const major = majorUnit && majorFormat && tick && tick.major;
        const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
        const formatter = options.ticks.callback;
        return formatter ? _helpersSegmentJs.O(formatter, [
            label,
            index,
            ticks
        ], this) : label;
    }
    generateTickLabels(ticks) {
        let i, ilen, tick;
        for(i = 0, ilen = ticks.length; i < ilen; ++i){
            tick = ticks[i];
            tick.label = this._tickFormatFunction(tick.value, i, ticks);
        }
    }
    getDecimalForValue(value) {
        return value === null ? NaN : (value - this.min) / (this.max - this.min);
    }
    getPixelForValue(value) {
        const offsets = this._offsets;
        const pos = this.getDecimalForValue(value);
        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    }
    getValueForPixel(pixel) {
        const offsets = this._offsets;
        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return this.min + pos * (this.max - this.min);
    }
    _getLabelSize(label) {
        const ticksOpts = this.options.ticks;
        const tickLabelWidth = this.ctx.measureText(label).width;
        const angle = _helpersSegmentJs.t(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
        const cosRotation = Math.cos(angle);
        const sinRotation = Math.sin(angle);
        const tickFontSize = this._resolveTickFontOptions(0).size;
        return {
            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
        };
    }
    _getLabelCapacity(exampleTime) {
        const timeOpts = this.options.time;
        const displayFormats = timeOpts.displayFormats;
        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
            exampleTime
        ], this._majorUnit), format);
        const size = this._getLabelSize(exampleLabel);
        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
        return capacity > 0 ? capacity : 1;
    }
    getDataTimestamps() {
        let timestamps = this._cache.data || [];
        let i, ilen;
        if (timestamps.length) return timestamps;
        const metas = this.getMatchingVisibleMetas();
        if (this._normalized && metas.length) return this._cache.data = metas[0].controller.getAllParsedValues(this);
        for(i = 0, ilen = metas.length; i < ilen; ++i)timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
        return this._cache.data = this.normalize(timestamps);
    }
    getLabelTimestamps() {
        const timestamps = this._cache.labels || [];
        let i, ilen;
        if (timestamps.length) return timestamps;
        const labels = this.getLabels();
        for(i = 0, ilen = labels.length; i < ilen; ++i)timestamps.push(parse(this, labels[i]));
        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
    }
    normalize(values) {
        return _helpersSegmentJs._(values.sort(sorter));
    }
    constructor(props){
        super(props);
        this._cache = {
            data: [],
            labels: [],
            all: []
        };
        this._unit = 'day';
        this._majorUnit = undefined;
        this._offsets = {};
        this._normalized = false;
        this._parseOpts = undefined;
    }
}
TimeScale.id = 'time';
TimeScale.defaults = {
    bounds: 'data',
    adapters: {},
    time: {
        parser: false,
        unit: false,
        round: false,
        isoWeekday: false,
        minUnit: 'millisecond',
        displayFormats: {}
    },
    ticks: {
        source: 'auto',
        major: {
            enabled: false
        }
    }
};
function interpolate(table, val, reverse) {
    let lo = 0;
    let hi = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
        if (val >= table[lo].pos && val <= table[hi].pos) ({ lo , hi  } = _helpersSegmentJs.x(table, 'pos', val));
        ({ pos: prevSource , time: prevTarget  } = table[lo]);
        ({ pos: nextSource , time: nextTarget  } = table[hi]);
    } else {
        if (val >= table[lo].time && val <= table[hi].time) ({ lo , hi  } = _helpersSegmentJs.x(table, 'time', val));
        ({ time: prevSource , pos: prevTarget  } = table[lo]);
        ({ time: nextSource , pos: nextTarget  } = table[hi]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
class TimeSeriesScale extends TimeScale {
    initOffsets() {
        const timestamps = this._getTimestampsForTable();
        const table = this._table = this.buildLookupTable(timestamps);
        this._minPos = interpolate(table, this.min);
        this._tableRange = interpolate(table, this.max) - this._minPos;
        super.initOffsets(timestamps);
    }
    buildLookupTable(timestamps) {
        const { min , max  } = this;
        const items = [];
        const table = [];
        let i, ilen, prev, curr, next;
        for(i = 0, ilen = timestamps.length; i < ilen; ++i){
            curr = timestamps[i];
            if (curr >= min && curr <= max) items.push(curr);
        }
        if (items.length < 2) return [
            {
                time: min,
                pos: 0
            },
            {
                time: max,
                pos: 1
            }
        ];
        for(i = 0, ilen = items.length; i < ilen; ++i){
            next = items[i + 1];
            prev = items[i - 1];
            curr = items[i];
            if (Math.round((next + prev) / 2) !== curr) table.push({
                time: curr,
                pos: i / (ilen - 1)
            });
        }
        return table;
    }
    _getTimestampsForTable() {
        let timestamps = this._cache.all || [];
        if (timestamps.length) return timestamps;
        const data = this.getDataTimestamps();
        const label = this.getLabelTimestamps();
        if (data.length && label.length) timestamps = this.normalize(data.concat(label));
        else timestamps = data.length ? data : label;
        timestamps = this._cache.all = timestamps;
        return timestamps;
    }
    getDecimalForValue(value) {
        return (interpolate(this._table, value) - this._minPos) / this._tableRange;
    }
    getValueForPixel(pixel) {
        const offsets = this._offsets;
        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
    }
    constructor(props){
        super(props);
        this._table = [];
        this._minPos = undefined;
        this._tableRange = undefined;
    }
}
TimeSeriesScale.id = 'timeseries';
TimeSeriesScale.defaults = TimeScale.defaults;
var scales = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    CategoryScale: CategoryScale,
    LinearScale: LinearScale,
    LogarithmicScale: LogarithmicScale,
    RadialLinearScale: RadialLinearScale,
    TimeScale: TimeScale,
    TimeSeriesScale: TimeSeriesScale
});
const registerables = [
    controllers,
    elements,
    plugins,
    scales, 
];

},{"./chunks/helpers.segment.js":"ed236","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"ed236":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "$", ()=>_toLeftRightCenter
);
parcelHelpers.export(exports, "A", ()=>_rlookupByKey
);
parcelHelpers.export(exports, "B", ()=>getAngleFromPoint
);
parcelHelpers.export(exports, "C", ()=>toPadding
);
parcelHelpers.export(exports, "D", ()=>each
);
parcelHelpers.export(exports, "E", ()=>getMaximumSize
);
parcelHelpers.export(exports, "F", ()=>_getParentNode
);
parcelHelpers.export(exports, "G", ()=>readUsedSize
);
parcelHelpers.export(exports, "H", ()=>HALF_PI
);
parcelHelpers.export(exports, "I", ()=>throttled
);
parcelHelpers.export(exports, "J", ()=>supportsEventListenerOptions
);
parcelHelpers.export(exports, "K", ()=>_isDomSupported
);
parcelHelpers.export(exports, "L", ()=>log10
);
parcelHelpers.export(exports, "M", ()=>_factorize
);
parcelHelpers.export(exports, "N", ()=>finiteOrDefault
);
parcelHelpers.export(exports, "O", ()=>callback
);
parcelHelpers.export(exports, "P", ()=>PI
);
parcelHelpers.export(exports, "Q", ()=>_addGrace
);
parcelHelpers.export(exports, "R", ()=>toDegrees
);
parcelHelpers.export(exports, "S", ()=>_measureText
);
parcelHelpers.export(exports, "T", ()=>TAU
);
parcelHelpers.export(exports, "U", ()=>_int16Range
);
parcelHelpers.export(exports, "V", ()=>_alignPixel
);
parcelHelpers.export(exports, "W", ()=>clipArea
);
parcelHelpers.export(exports, "X", ()=>renderText
);
parcelHelpers.export(exports, "Y", ()=>unclipArea
);
parcelHelpers.export(exports, "Z", ()=>toFont
);
parcelHelpers.export(exports, "_", ()=>_arrayUnique
);
parcelHelpers.export(exports, "a", ()=>resolve
);
parcelHelpers.export(exports, "a$", ()=>_angleDiff
);
parcelHelpers.export(exports, "a0", ()=>_alignStartEnd
);
parcelHelpers.export(exports, "a1", ()=>overrides
);
parcelHelpers.export(exports, "a2", ()=>merge
);
parcelHelpers.export(exports, "a3", ()=>_capitalize
);
parcelHelpers.export(exports, "a4", ()=>descriptors
);
parcelHelpers.export(exports, "a5", ()=>isFunction
);
parcelHelpers.export(exports, "a6", ()=>_attachContext
);
parcelHelpers.export(exports, "a7", ()=>_createResolver
);
parcelHelpers.export(exports, "a8", ()=>_descriptors
);
parcelHelpers.export(exports, "a9", ()=>mergeIf
);
parcelHelpers.export(exports, "aA", ()=>restoreTextDirection
);
parcelHelpers.export(exports, "aB", ()=>noop
);
parcelHelpers.export(exports, "aC", ()=>distanceBetweenPoints
);
parcelHelpers.export(exports, "aD", ()=>_setMinAndMaxByKey
);
parcelHelpers.export(exports, "aE", ()=>niceNum
);
parcelHelpers.export(exports, "aF", ()=>almostWhole
);
parcelHelpers.export(exports, "aG", ()=>almostEquals
);
parcelHelpers.export(exports, "aH", ()=>_decimalPlaces
);
parcelHelpers.export(exports, "aI", ()=>_longestText
);
parcelHelpers.export(exports, "aJ", ()=>_filterBetween
);
parcelHelpers.export(exports, "aK", ()=>_lookup
);
parcelHelpers.export(exports, "aL", ()=>getHoverColor
);
parcelHelpers.export(exports, "aM", ()=>clone$1
);
parcelHelpers.export(exports, "aN", ()=>_merger
);
parcelHelpers.export(exports, "aO", ()=>_mergerIf
);
parcelHelpers.export(exports, "aP", ()=>_deprecated
);
parcelHelpers.export(exports, "aQ", ()=>toFontString
);
parcelHelpers.export(exports, "aR", ()=>splineCurve
);
parcelHelpers.export(exports, "aS", ()=>splineCurveMonotone
);
parcelHelpers.export(exports, "aT", ()=>getStyle
);
parcelHelpers.export(exports, "aU", ()=>fontString
);
parcelHelpers.export(exports, "aV", ()=>toLineHeight
);
parcelHelpers.export(exports, "aW", ()=>PITAU
);
parcelHelpers.export(exports, "aX", ()=>INFINITY
);
parcelHelpers.export(exports, "aY", ()=>RAD_PER_DEG
);
parcelHelpers.export(exports, "aZ", ()=>QUARTER_PI
);
parcelHelpers.export(exports, "a_", ()=>TWO_THIRDS_PI
);
parcelHelpers.export(exports, "aa", ()=>uid
);
parcelHelpers.export(exports, "ab", ()=>debounce
);
parcelHelpers.export(exports, "ac", ()=>retinaScale
);
parcelHelpers.export(exports, "ad", ()=>clearCanvas
);
parcelHelpers.export(exports, "ae", ()=>setsEqual
);
parcelHelpers.export(exports, "af", ()=>_elementsEqual
);
parcelHelpers.export(exports, "ag", ()=>_isClickEvent
);
parcelHelpers.export(exports, "ah", ()=>_isBetween
);
parcelHelpers.export(exports, "ai", ()=>_readValueToProps
);
parcelHelpers.export(exports, "aj", ()=>_updateBezierControlPoints
);
parcelHelpers.export(exports, "ak", ()=>_computeSegments
);
parcelHelpers.export(exports, "al", ()=>_boundSegments
);
parcelHelpers.export(exports, "am", ()=>_steppedInterpolation
);
parcelHelpers.export(exports, "an", ()=>_bezierInterpolation
);
parcelHelpers.export(exports, "ao", ()=>_pointInLine
);
parcelHelpers.export(exports, "ap", ()=>_steppedLineTo
);
parcelHelpers.export(exports, "aq", ()=>_bezierCurveTo
);
parcelHelpers.export(exports, "ar", ()=>drawPoint
);
parcelHelpers.export(exports, "as", ()=>addRoundedRectPath
);
parcelHelpers.export(exports, "at", ()=>toTRBL
);
parcelHelpers.export(exports, "au", ()=>toTRBLCorners
);
parcelHelpers.export(exports, "av", ()=>_boundSegment
);
parcelHelpers.export(exports, "aw", ()=>_normalizeAngle
);
parcelHelpers.export(exports, "ax", ()=>getRtlAdapter
);
parcelHelpers.export(exports, "ay", ()=>overrideTextDirection
);
parcelHelpers.export(exports, "az", ()=>_textX
);
parcelHelpers.export(exports, "b", ()=>isArray
);
parcelHelpers.export(exports, "c", ()=>color
);
parcelHelpers.export(exports, "d", ()=>defaults
);
parcelHelpers.export(exports, "e", ()=>effects
);
parcelHelpers.export(exports, "f", ()=>resolveObjectKey
);
parcelHelpers.export(exports, "g", ()=>isNumberFinite
);
parcelHelpers.export(exports, "h", ()=>createContext
);
parcelHelpers.export(exports, "i", ()=>isObject
);
parcelHelpers.export(exports, "j", ()=>defined
);
parcelHelpers.export(exports, "k", ()=>isNullOrUndef
);
parcelHelpers.export(exports, "l", ()=>listenArrayEvents
);
parcelHelpers.export(exports, "m", ()=>toPercentage
);
parcelHelpers.export(exports, "n", ()=>toDimension
);
parcelHelpers.export(exports, "o", ()=>formatNumber
);
parcelHelpers.export(exports, "p", ()=>_angleBetween
);
parcelHelpers.export(exports, "q", ()=>isNumber
);
parcelHelpers.export(exports, "r", ()=>requestAnimFrame
);
parcelHelpers.export(exports, "s", ()=>sign
);
parcelHelpers.export(exports, "t", ()=>toRadians
);
parcelHelpers.export(exports, "u", ()=>unlistenArrayEvents
);
parcelHelpers.export(exports, "v", ()=>valueOrDefault
);
parcelHelpers.export(exports, "w", ()=>_limitValue
);
parcelHelpers.export(exports, "x", ()=>_lookupByKey
);
parcelHelpers.export(exports, "y", ()=>getRelativePosition
);
parcelHelpers.export(exports, "z", ()=>_isPointInArea
);
/*!
 * Chart.js v3.7.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */ function fontString(pixelSize, fontStyle, fontFamily) {
    return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
}
const requestAnimFrame = function() {
    if (typeof window === 'undefined') return function(callback1) {
        return callback1();
    };
    return window.requestAnimationFrame;
}();
function throttled(fn, thisArg, updateFn) {
    const updateArgs = updateFn || ((args)=>Array.prototype.slice.call(args)
    );
    let ticking = false;
    let args1 = [];
    return function(...rest) {
        args1 = updateArgs(rest);
        if (!ticking) {
            ticking = true;
            requestAnimFrame.call(window, ()=>{
                ticking = false;
                fn.apply(thisArg, args1);
            });
        }
    };
}
function debounce(fn, delay) {
    let timeout;
    return function(...args) {
        if (delay) {
            clearTimeout(timeout);
            timeout = setTimeout(fn, delay, args);
        } else fn.apply(this, args);
        return delay;
    };
}
const _toLeftRightCenter = (align)=>align === 'start' ? 'left' : align === 'end' ? 'right' : 'center'
;
const _alignStartEnd = (align, start, end)=>align === 'start' ? start : align === 'end' ? end : (start + end) / 2
;
const _textX = (align, left, right, rtl)=>{
    const check = rtl ? 'left' : 'right';
    return align === check ? right : align === 'center' ? (left + right) / 2 : left;
};
function noop() {}
const uid = function() {
    let id = 0;
    return function() {
        return id++;
    };
}();
function isNullOrUndef(value) {
    return value === null || typeof value === 'undefined';
}
function isArray(value) {
    if (Array.isArray && Array.isArray(value)) return true;
    const type = Object.prototype.toString.call(value);
    if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') return true;
    return false;
}
function isObject(value) {
    return value !== null && Object.prototype.toString.call(value) === '[object Object]';
}
const isNumberFinite = (value)=>(typeof value === 'number' || value instanceof Number) && isFinite(+value)
;
function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
    return typeof value === 'undefined' ? defaultValue : value;
}
const toPercentage = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : value / dimension
;
const toDimension = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value
;
function callback(fn, args, thisArg) {
    if (fn && typeof fn.call === 'function') return fn.apply(thisArg, args);
}
function each(loopable, fn, thisArg, reverse) {
    let i, len, keys;
    if (isArray(loopable)) {
        len = loopable.length;
        if (reverse) for(i = len - 1; i >= 0; i--)fn.call(thisArg, loopable[i], i);
        else for(i = 0; i < len; i++)fn.call(thisArg, loopable[i], i);
    } else if (isObject(loopable)) {
        keys = Object.keys(loopable);
        len = keys.length;
        for(i = 0; i < len; i++)fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
}
function _elementsEqual(a0, a1) {
    let i, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) return false;
    for(i = 0, ilen = a0.length; i < ilen; ++i){
        v0 = a0[i];
        v1 = a1[i];
        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) return false;
    }
    return true;
}
function clone$1(source) {
    if (isArray(source)) return source.map(clone$1);
    if (isObject(source)) {
        const target = Object.create(null);
        const keys = Object.keys(source);
        const klen = keys.length;
        let k = 0;
        for(; k < klen; ++k)target[keys[k]] = clone$1(source[keys[k]]);
        return target;
    }
    return source;
}
function isValidKey(key) {
    return [
        '__proto__',
        'prototype',
        'constructor'
    ].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
    if (!isValidKey(key)) return;
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) merge(tval, sval, options);
    else target[key] = clone$1(sval);
}
function merge(target, source, options) {
    const sources = isArray(source) ? source : [
        source
    ];
    const ilen = sources.length;
    if (!isObject(target)) return target;
    options = options || {};
    const merger = options.merger || _merger;
    for(let i = 0; i < ilen; ++i){
        source = sources[i];
        if (!isObject(source)) continue;
        const keys = Object.keys(source);
        for(let k = 0, klen = keys.length; k < klen; ++k)merger(keys[k], target, source, options);
    }
    return target;
}
function mergeIf(target, source) {
    return merge(target, source, {
        merger: _mergerIf
    });
}
function _mergerIf(key, target, source) {
    if (!isValidKey(key)) return;
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) mergeIf(tval, sval);
    else if (!Object.prototype.hasOwnProperty.call(target, key)) target[key] = clone$1(sval);
}
function _deprecated(scope, value, previous, current) {
    if (value !== undefined) console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
}
const emptyString = '';
const dot = '.';
function indexOfDotOrLength(key, start) {
    const idx = key.indexOf(dot, start);
    return idx === -1 ? key.length : idx;
}
function resolveObjectKey(obj, key) {
    if (key === emptyString) return obj;
    let pos = 0;
    let idx = indexOfDotOrLength(key, pos);
    while(obj && idx > pos){
        obj = obj[key.substr(pos, idx - pos)];
        pos = idx + 1;
        idx = indexOfDotOrLength(key, pos);
    }
    return obj;
}
function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
const defined = (value)=>typeof value !== 'undefined'
;
const isFunction = (value)=>typeof value === 'function'
;
const setsEqual = (a, b)=>{
    if (a.size !== b.size) return false;
    for (const item of a){
        if (!b.has(item)) return false;
    }
    return true;
};
function _isClickEvent(e) {
    return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';
}
const PI = Math.PI;
const TAU = 2 * PI;
const PITAU = TAU + PI;
const INFINITY = Number.POSITIVE_INFINITY;
const RAD_PER_DEG = PI / 180;
const HALF_PI = PI / 2;
const QUARTER_PI = PI / 4;
const TWO_THIRDS_PI = PI * 2 / 3;
const log10 = Math.log10;
const sign = Math.sign;
function niceNum(range) {
    const roundedRange = Math.round(range);
    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;
    const niceRange = Math.pow(10, Math.floor(log10(range)));
    const fraction = range / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
}
function _factorize(value) {
    const result = [];
    const sqrt = Math.sqrt(value);
    let i;
    for(i = 1; i < sqrt; i++)if (value % i === 0) {
        result.push(i);
        result.push(value / i);
    }
    if (sqrt === (sqrt | 0)) result.push(sqrt);
    result.sort((a, b)=>a - b
    ).pop();
    return result;
}
function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostEquals(x, y, epsilon) {
    return Math.abs(x - y) < epsilon;
}
function almostWhole(x, epsilon) {
    const rounded = Math.round(x);
    return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array, target, property) {
    let i, ilen, value;
    for(i = 0, ilen = array.length; i < ilen; i++){
        value = array[i][property];
        if (!isNaN(value)) {
            target.min = Math.min(target.min, value);
            target.max = Math.max(target.max, value);
        }
    }
}
function toRadians(degrees) {
    return degrees * (PI / 180);
}
function toDegrees(radians) {
    return radians * (180 / PI);
}
function _decimalPlaces(x) {
    if (!isNumberFinite(x)) return;
    let e = 1;
    let p = 0;
    while(Math.round(x * e) / e !== x){
        e *= 10;
        p++;
    }
    return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) angle += TAU;
    return {
        angle,
        distance: radialDistanceFromCenter
    };
}
function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
    return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
    return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
    const a = _normalizeAngle(angle);
    const s = _normalizeAngle(start);
    const e = _normalizeAngle(end);
    const angleToStart = _normalizeAngle(s - a);
    const angleToEnd = _normalizeAngle(e - a);
    const startToAngle = _normalizeAngle(a - s);
    const endToAngle = _normalizeAngle(a - e);
    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
    return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
const atEdge = (t)=>t === 0 || t === 1
;
const elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p))
;
const elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1
;
const effects = {
    linear: (t)=>t
    ,
    easeInQuad: (t)=>t * t
    ,
    easeOutQuad: (t)=>-t * (t - 2)
    ,
    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1)
    ,
    easeInCubic: (t)=>t * t * t
    ,
    easeOutCubic: (t)=>(t -= 1) * t * t + 1
    ,
    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2)
    ,
    easeInQuart: (t)=>t * t * t * t
    ,
    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1)
    ,
    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2)
    ,
    easeInQuint: (t)=>t * t * t * t * t
    ,
    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1
    ,
    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2)
    ,
    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1
    ,
    easeOutSine: (t)=>Math.sin(t * HALF_PI)
    ,
    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1)
    ,
    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1))
    ,
    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1
    ,
    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2)
    ,
    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1)
    ,
    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t)
    ,
    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
    ,
    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3)
    ,
    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3)
    ,
    easeInOutElastic (t) {
        const s = 0.1125;
        const p = 0.45;
        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
    },
    easeInBack (t) {
        const s = 1.70158;
        return t * t * ((s + 1) * t - s);
    },
    easeOutBack (t) {
        const s = 1.70158;
        return (t -= 1) * t * ((s + 1) * t + s) + 1;
    },
    easeInOutBack (t) {
        let s = 1.70158;
        if ((t /= 0.5) < 1) return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
    },
    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t)
    ,
    easeOutBounce (t) {
        const m = 7.5625;
        const d = 2.75;
        if (t < 1 / d) return m * t * t;
        if (t < 2 / d) return m * (t -= 1.5 / d) * t + 0.75;
        if (t < 2.5 / d) return m * (t -= 2.25 / d) * t + 0.9375;
        return m * (t -= 2.625 / d) * t + 0.984375;
    },
    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
/*!
 * @kurkle/color v0.1.9
 * https://github.com/kurkle/color#readme
 * (c) 2020 Jukka Kurkela
 * Released under the MIT License
 */ const map = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
};
const hex = '0123456789ABCDEF';
const h1 = (b)=>hex[b & 0xF]
;
const h2 = (b)=>hex[(b & 0xF0) >> 4] + hex[b & 0xF]
;
const eq = (b)=>(b & 0xF0) >> 4 === (b & 0xF)
;
function isShort(v) {
    return eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
}
function hexParse(str) {
    var len = str.length;
    var ret;
    if (str[0] === '#') {
        if (len === 4 || len === 5) ret = {
            r: 255 & map[str[1]] * 17,
            g: 255 & map[str[2]] * 17,
            b: 255 & map[str[3]] * 17,
            a: len === 5 ? map[str[4]] * 17 : 255
        };
        else if (len === 7 || len === 9) ret = {
            r: map[str[1]] << 4 | map[str[2]],
            g: map[str[3]] << 4 | map[str[4]],
            b: map[str[5]] << 4 | map[str[6]],
            a: len === 9 ? map[str[7]] << 4 | map[str[8]] : 255
        };
    }
    return ret;
}
function hexString(v) {
    var f = isShort(v) ? h1 : h2;
    return v ? '#' + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : '') : v;
}
function round(v) {
    return v + 0.5 | 0;
}
const lim = (v, l, h)=>Math.max(Math.min(v, h), l)
;
function p2b(v) {
    return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
    return lim(round(v * 255), 0, 255);
}
function b2n(v) {
    return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
    return lim(round(v * 100), 0, 100);
}
const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
    const m = RGB_RE.exec(str);
    let a = 255;
    let r, g, b;
    if (!m) return;
    if (m[7] !== r) {
        const v = +m[7];
        a = 255 & (m[8] ? p2b(v) : v * 255);
    }
    r = +m[1];
    g = +m[3];
    b = +m[5];
    r = 255 & (m[2] ? p2b(r) : r);
    g = 255 & (m[4] ? p2b(g) : g);
    b = 255 & (m[6] ? p2b(b) : b);
    return {
        r: r,
        g: g,
        b: b,
        a: a
    };
}
function rgbString(v) {
    return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
    const a = s * Math.min(l, 1 - l);
    const f = (n, k = (n + h / 30) % 12)=>l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1)
    ;
    return [
        f(0),
        f(8),
        f(4)
    ];
}
function hsv2rgbn(h, s, v) {
    const f = (n, k = (n + h / 60) % 6)=>v - v * s * Math.max(Math.min(k, 4 - k, 1), 0)
    ;
    return [
        f(5),
        f(3),
        f(1)
    ];
}
function hwb2rgbn(h, w, b) {
    const rgb = hsl2rgbn(h, 1, 0.5);
    let i;
    if (w + b > 1) {
        i = 1 / (w + b);
        w *= i;
        b *= i;
    }
    for(i = 0; i < 3; i++){
        rgb[i] *= 1 - w - b;
        rgb[i] += w;
    }
    return rgb;
}
function rgb2hsl(v) {
    const range = 255;
    const r = v.r / range;
    const g = v.g / range;
    const b = v.b / range;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const l = (max + min) / 2;
    let h, s, d;
    if (max !== min) {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
        h = h * 60 + 0.5;
    }
    return [
        h | 0,
        s || 0,
        l
    ];
}
function calln(f, a, b, c) {
    return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h, s, l) {
    return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
    return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
    return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
    return (h % 360 + 360) % 360;
}
function hueParse(str) {
    const m = HUE_RE.exec(str);
    let a = 255;
    let v;
    if (!m) return;
    if (m[5] !== v) a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
    const h = hue(+m[2]);
    const p1 = +m[3] / 100;
    const p2 = +m[4] / 100;
    if (m[1] === 'hwb') v = hwb2rgb(h, p1, p2);
    else if (m[1] === 'hsv') v = hsv2rgb(h, p1, p2);
    else v = hsl2rgb(h, p1, p2);
    return {
        r: v[0],
        g: v[1],
        b: v[2],
        a: a
    };
}
function rotate(v, deg) {
    var h = rgb2hsl(v);
    h[0] = hue(h[0] + deg);
    h = hsl2rgb(h);
    v.r = h[0];
    v.g = h[1];
    v.b = h[2];
}
function hslString(v) {
    if (!v) return;
    const a = rgb2hsl(v);
    const h = a[0];
    const s = n2p(a[1]);
    const l = n2p(a[2]);
    return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
}
const map$1 = {
    x: 'dark',
    Z: 'light',
    Y: 're',
    X: 'blu',
    W: 'gr',
    V: 'medium',
    U: 'slate',
    A: 'ee',
    T: 'ol',
    S: 'or',
    B: 'ra',
    C: 'lateg',
    D: 'ights',
    R: 'in',
    Q: 'turquois',
    E: 'hi',
    P: 'ro',
    O: 'al',
    N: 'le',
    M: 'de',
    L: 'yello',
    F: 'en',
    K: 'ch',
    G: 'arks',
    H: 'ea',
    I: 'ightg',
    J: 'wh'
};
const names = {
    OiceXe: 'f0f8ff',
    antiquewEte: 'faebd7',
    aqua: 'ffff',
    aquamarRe: '7fffd4',
    azuY: 'f0ffff',
    beige: 'f5f5dc',
    bisque: 'ffe4c4',
    black: '0',
    blanKedOmond: 'ffebcd',
    Xe: 'ff',
    XeviTet: '8a2be2',
    bPwn: 'a52a2a',
    burlywood: 'deb887',
    caMtXe: '5f9ea0',
    KartYuse: '7fff00',
    KocTate: 'd2691e',
    cSO: 'ff7f50',
    cSnflowerXe: '6495ed',
    cSnsilk: 'fff8dc',
    crimson: 'dc143c',
    cyan: 'ffff',
    xXe: '8b',
    xcyan: '8b8b',
    xgTMnPd: 'b8860b',
    xWay: 'a9a9a9',
    xgYF: '6400',
    xgYy: 'a9a9a9',
    xkhaki: 'bdb76b',
    xmagFta: '8b008b',
    xTivegYF: '556b2f',
    xSange: 'ff8c00',
    xScEd: '9932cc',
    xYd: '8b0000',
    xsOmon: 'e9967a',
    xsHgYF: '8fbc8f',
    xUXe: '483d8b',
    xUWay: '2f4f4f',
    xUgYy: '2f4f4f',
    xQe: 'ced1',
    xviTet: '9400d3',
    dAppRk: 'ff1493',
    dApskyXe: 'bfff',
    dimWay: '696969',
    dimgYy: '696969',
    dodgerXe: '1e90ff',
    fiYbrick: 'b22222',
    flSOwEte: 'fffaf0',
    foYstWAn: '228b22',
    fuKsia: 'ff00ff',
    gaRsbSo: 'dcdcdc',
    ghostwEte: 'f8f8ff',
    gTd: 'ffd700',
    gTMnPd: 'daa520',
    Way: '808080',
    gYF: '8000',
    gYFLw: 'adff2f',
    gYy: '808080',
    honeyMw: 'f0fff0',
    hotpRk: 'ff69b4',
    RdianYd: 'cd5c5c',
    Rdigo: '4b0082',
    ivSy: 'fffff0',
    khaki: 'f0e68c',
    lavFMr: 'e6e6fa',
    lavFMrXsh: 'fff0f5',
    lawngYF: '7cfc00',
    NmoncEffon: 'fffacd',
    ZXe: 'add8e6',
    ZcSO: 'f08080',
    Zcyan: 'e0ffff',
    ZgTMnPdLw: 'fafad2',
    ZWay: 'd3d3d3',
    ZgYF: '90ee90',
    ZgYy: 'd3d3d3',
    ZpRk: 'ffb6c1',
    ZsOmon: 'ffa07a',
    ZsHgYF: '20b2aa',
    ZskyXe: '87cefa',
    ZUWay: '778899',
    ZUgYy: '778899',
    ZstAlXe: 'b0c4de',
    ZLw: 'ffffe0',
    lime: 'ff00',
    limegYF: '32cd32',
    lRF: 'faf0e6',
    magFta: 'ff00ff',
    maPon: '800000',
    VaquamarRe: '66cdaa',
    VXe: 'cd',
    VScEd: 'ba55d3',
    VpurpN: '9370db',
    VsHgYF: '3cb371',
    VUXe: '7b68ee',
    VsprRggYF: 'fa9a',
    VQe: '48d1cc',
    VviTetYd: 'c71585',
    midnightXe: '191970',
    mRtcYam: 'f5fffa',
    mistyPse: 'ffe4e1',
    moccasR: 'ffe4b5',
    navajowEte: 'ffdead',
    navy: '80',
    Tdlace: 'fdf5e6',
    Tive: '808000',
    TivedBb: '6b8e23',
    Sange: 'ffa500',
    SangeYd: 'ff4500',
    ScEd: 'da70d6',
    pOegTMnPd: 'eee8aa',
    pOegYF: '98fb98',
    pOeQe: 'afeeee',
    pOeviTetYd: 'db7093',
    papayawEp: 'ffefd5',
    pHKpuff: 'ffdab9',
    peru: 'cd853f',
    pRk: 'ffc0cb',
    plum: 'dda0dd',
    powMrXe: 'b0e0e6',
    purpN: '800080',
    YbeccapurpN: '663399',
    Yd: 'ff0000',
    Psybrown: 'bc8f8f',
    PyOXe: '4169e1',
    saddNbPwn: '8b4513',
    sOmon: 'fa8072',
    sandybPwn: 'f4a460',
    sHgYF: '2e8b57',
    sHshell: 'fff5ee',
    siFna: 'a0522d',
    silver: 'c0c0c0',
    skyXe: '87ceeb',
    UXe: '6a5acd',
    UWay: '708090',
    UgYy: '708090',
    snow: 'fffafa',
    sprRggYF: 'ff7f',
    stAlXe: '4682b4',
    tan: 'd2b48c',
    teO: '8080',
    tEstN: 'd8bfd8',
    tomato: 'ff6347',
    Qe: '40e0d0',
    viTet: 'ee82ee',
    JHt: 'f5deb3',
    wEte: 'ffffff',
    wEtesmoke: 'f5f5f5',
    Lw: 'ffff00',
    LwgYF: '9acd32'
};
function unpack() {
    const unpacked = {};
    const keys = Object.keys(names);
    const tkeys = Object.keys(map$1);
    let i, j, k, ok, nk;
    for(i = 0; i < keys.length; i++){
        ok = nk = keys[i];
        for(j = 0; j < tkeys.length; j++){
            k = tkeys[j];
            nk = nk.replace(k, map$1[k]);
        }
        k = parseInt(names[ok], 16);
        unpacked[nk] = [
            k >> 16 & 0xFF,
            k >> 8 & 0xFF,
            k & 0xFF
        ];
    }
    return unpacked;
}
let names$1;
function nameParse(str) {
    if (!names$1) {
        names$1 = unpack();
        names$1.transparent = [
            0,
            0,
            0,
            0
        ];
    }
    const a = names$1[str.toLowerCase()];
    return a && {
        r: a[0],
        g: a[1],
        b: a[2],
        a: a.length === 4 ? a[3] : 255
    };
}
function modHSL(v, i, ratio) {
    if (v) {
        let tmp = rgb2hsl(v);
        tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
        tmp = hsl2rgb(tmp);
        v.r = tmp[0];
        v.g = tmp[1];
        v.b = tmp[2];
    }
}
function clone(v, proto) {
    return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
    var v = {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    };
    if (Array.isArray(input)) {
        if (input.length >= 3) {
            v = {
                r: input[0],
                g: input[1],
                b: input[2],
                a: 255
            };
            if (input.length > 3) v.a = n2b(input[3]);
        }
    } else {
        v = clone(input, {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        });
        v.a = n2b(v.a);
    }
    return v;
}
function functionParse(str) {
    if (str.charAt(0) === 'r') return rgbParse(str);
    return hueParse(str);
}
class Color {
    get valid() {
        return this._valid;
    }
    get rgb() {
        var v = clone(this._rgb);
        if (v) v.a = b2n(v.a);
        return v;
    }
    set rgb(obj) {
        this._rgb = fromObject(obj);
    }
    rgbString() {
        return this._valid ? rgbString(this._rgb) : this._rgb;
    }
    hexString() {
        return this._valid ? hexString(this._rgb) : this._rgb;
    }
    hslString() {
        return this._valid ? hslString(this._rgb) : this._rgb;
    }
    mix(color1, weight) {
        const me = this;
        if (color1) {
            const c1 = me.rgb;
            const c2 = color1.rgb;
            let w2;
            const p = weight === w2 ? 0.5 : weight;
            const w = 2 * p - 1;
            const a = c1.a - c2.a;
            const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
            w2 = 1 - w1;
            c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;
            c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;
            c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;
            c1.a = p * c1.a + (1 - p) * c2.a;
            me.rgb = c1;
        }
        return me;
    }
    clone() {
        return new Color(this.rgb);
    }
    alpha(a) {
        this._rgb.a = n2b(a);
        return this;
    }
    clearer(ratio) {
        const rgb = this._rgb;
        rgb.a *= 1 - ratio;
        return this;
    }
    greyscale() {
        const rgb = this._rgb;
        const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
        rgb.r = rgb.g = rgb.b = val;
        return this;
    }
    opaquer(ratio) {
        const rgb = this._rgb;
        rgb.a *= 1 + ratio;
        return this;
    }
    negate() {
        const v = this._rgb;
        v.r = 255 - v.r;
        v.g = 255 - v.g;
        v.b = 255 - v.b;
        return this;
    }
    lighten(ratio) {
        modHSL(this._rgb, 2, ratio);
        return this;
    }
    darken(ratio) {
        modHSL(this._rgb, 2, -ratio);
        return this;
    }
    saturate(ratio) {
        modHSL(this._rgb, 1, ratio);
        return this;
    }
    desaturate(ratio) {
        modHSL(this._rgb, 1, -ratio);
        return this;
    }
    rotate(deg) {
        rotate(this._rgb, deg);
        return this;
    }
    constructor(input){
        if (input instanceof Color) return input;
        const type = typeof input;
        let v;
        if (type === 'object') v = fromObject(input);
        else if (type === 'string') v = hexParse(input) || nameParse(input) || functionParse(input);
        this._rgb = v;
        this._valid = !!v;
    }
}
function index_esm(input) {
    return new Color(input);
}
const isPatternOrGradient = (value)=>value instanceof CanvasGradient || value instanceof CanvasPattern
;
function color(value) {
    return isPatternOrGradient(value) ? value : index_esm(value);
}
function getHoverColor(value) {
    return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
}
const overrides = Object.create(null);
const descriptors = Object.create(null);
function getScope$1(node, key) {
    if (!key) return node;
    const keys = key.split('.');
    for(let i = 0, n = keys.length; i < n; ++i){
        const k = keys[i];
        node = node[k] || (node[k] = Object.create(null));
    }
    return node;
}
function set(root, scope, values) {
    if (typeof scope === 'string') return merge(getScope$1(root, scope), values);
    return merge(getScope$1(root, ''), scope);
}
class Defaults {
    set(scope, values) {
        return set(this, scope, values);
    }
    get(scope) {
        return getScope$1(this, scope);
    }
    describe(scope, values) {
        return set(descriptors, scope, values);
    }
    override(scope, values) {
        return set(overrides, scope, values);
    }
    route(scope, name, targetScope, targetName) {
        const scopeObject = getScope$1(this, scope);
        const targetScopeObject = getScope$1(this, targetScope);
        const privateName = '_' + name;
        Object.defineProperties(scopeObject, {
            [privateName]: {
                value: scopeObject[name],
                writable: true
            },
            [name]: {
                enumerable: true,
                get () {
                    const local = this[privateName];
                    const target = targetScopeObject[targetName];
                    if (isObject(local)) return Object.assign({}, target, local);
                    return valueOrDefault(local, target);
                },
                set (value) {
                    this[privateName] = value;
                }
            }
        });
    }
    constructor(_descriptors1){
        this.animation = undefined;
        this.backgroundColor = 'rgba(0,0,0,0.1)';
        this.borderColor = 'rgba(0,0,0,0.1)';
        this.color = '#666';
        this.datasets = {};
        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio()
        ;
        this.elements = {};
        this.events = [
            'mousemove',
            'mouseout',
            'click',
            'touchstart',
            'touchmove'
        ];
        this.font = {
            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            size: 12,
            style: 'normal',
            lineHeight: 1.2,
            weight: null
        };
        this.hover = {};
        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor)
        ;
        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor)
        ;
        this.hoverColor = (ctx, options)=>getHoverColor(options.color)
        ;
        this.indexAxis = 'x';
        this.interaction = {
            mode: 'nearest',
            intersect: true
        };
        this.maintainAspectRatio = true;
        this.onHover = null;
        this.onClick = null;
        this.parsing = true;
        this.plugins = {};
        this.responsive = true;
        this.scale = undefined;
        this.scales = {};
        this.showLine = true;
        this.drawActiveElementsOnTop = true;
        this.describe(_descriptors1);
    }
}
var defaults = new Defaults({
    _scriptable: (name)=>!name.startsWith('on')
    ,
    _indexable: (name)=>name !== 'events'
    ,
    hover: {
        _fallback: 'interaction'
    },
    interaction: {
        _scriptable: false,
        _indexable: false
    }
});
function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) return null;
    return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
    let textWidth = data[string];
    if (!textWidth) {
        textWidth = data[string] = ctx.measureText(string).width;
        gc.push(string);
    }
    if (textWidth > longest) longest = textWidth;
    return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
    cache = cache || {};
    let data = cache.data = cache.data || {};
    let gc = cache.garbageCollect = cache.garbageCollect || [];
    if (cache.font !== font) {
        data = cache.data = {};
        gc = cache.garbageCollect = [];
        cache.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i, j, jlen, thing, nestedThing;
    for(i = 0; i < ilen; i++){
        thing = arrayOfThings[i];
        if (thing !== undefined && thing !== null && isArray(thing) !== true) longest = _measureText(ctx, data, gc, longest, thing);
        else if (isArray(thing)) for(j = 0, jlen = thing.length; j < jlen; j++){
            nestedThing = thing[j];
            if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
    }
    ctx.restore();
    const gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
        for(i = 0; i < gcLen; i++)delete data[gc[i]];
        gc.splice(0, gcLen);
    }
    return longest;
}
function _alignPixel(chart, pixel, width) {
    const devicePixelRatio = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
    ctx = ctx || canvas.getContext('2d');
    ctx.save();
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
}
function drawPoint(ctx, options, x, y) {
    let type, xOffset, yOffset, size, cornerRadius;
    const style = options.pointStyle;
    const rotation = options.rotation;
    const radius = options.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === 'object') {
        type = style.toString();
        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rad);
            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
            ctx.restore();
            return;
        }
    }
    if (isNaN(radius) || radius <= 0) return;
    ctx.beginPath();
    switch(style){
        default:
            ctx.arc(x, y, radius, 0, TAU);
            ctx.closePath();
            break;
        case 'triangle':
            ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            ctx.closePath();
            break;
        case 'rectRounded':
            cornerRadius = radius * 0.516;
            size = radius - cornerRadius;
            xOffset = Math.cos(rad + QUARTER_PI) * size;
            yOffset = Math.sin(rad + QUARTER_PI) * size;
            ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
            ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
            ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
            ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
            ctx.closePath();
            break;
        case 'rect':
            if (!rotation) {
                size = Math.SQRT1_2 * radius;
                ctx.rect(x - size, y - size, 2 * size, 2 * size);
                break;
            }
            rad += QUARTER_PI;
        case 'rectRot':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + yOffset, y - xOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            ctx.closePath();
            break;
        case 'crossRot':
            rad += QUARTER_PI;
        case 'cross':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;
        case 'star':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            rad += QUARTER_PI;
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;
        case 'line':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            break;
        case 'dash':
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
            break;
    }
    ctx.fill();
    if (options.borderWidth > 0) ctx.stroke();
}
function _isPointInArea(point, area, margin) {
    margin = margin || 0.5;
    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
}
function unclipArea(ctx) {
    ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
    if (!previous) return ctx.lineTo(target.x, target.y);
    if (mode === 'middle') {
        const midpoint = (previous.x + target.x) / 2.0;
        ctx.lineTo(midpoint, previous.y);
        ctx.lineTo(midpoint, target.y);
    } else if (mode === 'after' !== !!flip) ctx.lineTo(previous.x, target.y);
    else ctx.lineTo(target.x, previous.y);
    ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
    if (!previous) return ctx.lineTo(target.x, target.y);
    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function renderText(ctx, text, x, y, font, opts = {}) {
    const lines = isArray(text) ? text : [
        text
    ];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';
    let i, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for(i = 0; i < lines.length; ++i){
        line = lines[i];
        if (stroke) {
            if (opts.strokeColor) ctx.strokeStyle = opts.strokeColor;
            if (!isNullOrUndef(opts.strokeWidth)) ctx.lineWidth = opts.strokeWidth;
            ctx.strokeText(line, x, y, opts.maxWidth);
        }
        ctx.fillText(line, x, y, opts.maxWidth);
        decorateText(ctx, x, y, line, opts);
        y += font.lineHeight;
    }
    ctx.restore();
}
function setRenderOpts(ctx, opts) {
    if (opts.translation) ctx.translate(opts.translation[0], opts.translation[1]);
    if (!isNullOrUndef(opts.rotation)) ctx.rotate(opts.rotation);
    if (opts.color) ctx.fillStyle = opts.color;
    if (opts.textAlign) ctx.textAlign = opts.textAlign;
    if (opts.textBaseline) ctx.textBaseline = opts.textBaseline;
}
function decorateText(ctx, x, y, line, opts) {
    if (opts.strikethrough || opts.underline) {
        const metrics = ctx.measureText(line);
        const left = x - metrics.actualBoundingBoxLeft;
        const right = x + metrics.actualBoundingBoxRight;
        const top = y - metrics.actualBoundingBoxAscent;
        const bottom = y + metrics.actualBoundingBoxDescent;
        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
        ctx.strokeStyle = ctx.fillStyle;
        ctx.beginPath();
        ctx.lineWidth = opts.decorationWidth || 2;
        ctx.moveTo(left, yDecoration);
        ctx.lineTo(right, yDecoration);
        ctx.stroke();
    }
}
function addRoundedRectPath(ctx, rect) {
    const { x , y , w , h , radius  } = rect;
    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
    ctx.lineTo(x, y + h - radius.bottomLeft);
    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    ctx.lineTo(x + w - radius.bottomRight, y + h);
    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    ctx.lineTo(x + w, y + radius.topRight);
    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    ctx.lineTo(x + radius.topLeft, y);
}
const LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
const FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
function toLineHeight(value, size) {
    const matches = ('' + value).match(LINE_HEIGHT);
    if (!matches || matches[1] === 'normal') return size * 1.2;
    value = +matches[2];
    switch(matches[3]){
        case 'px':
            return value;
        case '%':
            value /= 100;
            break;
    }
    return size * value;
}
const numberOrZero = (v)=>+v || 0
;
function _readValueToProps(value, props) {
    const ret = {};
    const objProps = isObject(props);
    const keys = objProps ? Object.keys(props) : props;
    const read = isObject(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]])
     : (prop)=>value[prop]
     : ()=>value
    ;
    for (const prop1 of keys)ret[prop1] = numberOrZero(read(prop1));
    return ret;
}
function toTRBL(value) {
    return _readValueToProps(value, {
        top: 'y',
        right: 'x',
        bottom: 'y',
        left: 'x'
    });
}
function toTRBLCorners(value) {
    return _readValueToProps(value, [
        'topLeft',
        'topRight',
        'bottomLeft',
        'bottomRight'
    ]);
}
function toPadding(value) {
    const obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
}
function toFont(options, fallback) {
    options = options || {};
    fallback = fallback || defaults.font;
    let size = valueOrDefault(options.size, fallback.size);
    if (typeof size === 'string') size = parseInt(size, 10);
    let style = valueOrDefault(options.style, fallback.style);
    if (style && !('' + style).match(FONT_STYLE)) {
        console.warn('Invalid font style specified: "' + style + '"');
        style = '';
    }
    const font = {
        family: valueOrDefault(options.family, fallback.family),
        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
        size,
        style,
        weight: valueOrDefault(options.weight, fallback.weight),
        string: ''
    };
    font.string = toFontString(font);
    return font;
}
function resolve(inputs, context, index, info) {
    let cacheable = true;
    let i, ilen, value;
    for(i = 0, ilen = inputs.length; i < ilen; ++i){
        value = inputs[i];
        if (value === undefined) continue;
        if (context !== undefined && typeof value === 'function') {
            value = value(context);
            cacheable = false;
        }
        if (index !== undefined && isArray(value)) {
            value = value[index % value.length];
            cacheable = false;
        }
        if (value !== undefined) {
            if (info && !cacheable) info.cacheable = false;
            return value;
        }
    }
}
function _addGrace(minmax, grace, beginAtZero) {
    const { min , max  } = minmax;
    const change = toDimension(grace, (max - min) / 2);
    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add
    ;
    return {
        min: keepZero(min, -Math.abs(change)),
        max: keepZero(max, change)
    };
}
function createContext(parentContext, context) {
    return Object.assign(Object.create(parentContext), context);
}
function _lookup(table, value, cmp) {
    cmp = cmp || ((index)=>table[index] < value
    );
    let hi = table.length - 1;
    let lo = 0;
    let mid;
    while(hi - lo > 1){
        mid = lo + hi >> 1;
        if (cmp(mid)) lo = mid;
        else hi = mid;
    }
    return {
        lo,
        hi
    };
}
const _lookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] < value
    )
;
const _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value
    )
;
function _filterBetween(values, min, max) {
    let start = 0;
    let end = values.length;
    while(start < end && values[start] < min)start++;
    while(end > start && values[end - 1] > max)end--;
    return start > 0 || end < values.length ? values.slice(start, end) : values;
}
const arrayEvents = [
    'push',
    'pop',
    'shift',
    'splice',
    'unshift'
];
function listenArrayEvents(array, listener) {
    if (array._chartjs) {
        array._chartjs.listeners.push(listener);
        return;
    }
    Object.defineProperty(array, '_chartjs', {
        configurable: true,
        enumerable: false,
        value: {
            listeners: [
                listener
            ]
        }
    });
    arrayEvents.forEach((key)=>{
        const method = '_onData' + _capitalize(key);
        const base = array[key];
        Object.defineProperty(array, key, {
            configurable: true,
            enumerable: false,
            value (...args) {
                const res = base.apply(this, args);
                array._chartjs.listeners.forEach((object)=>{
                    if (typeof object[method] === 'function') object[method](...args);
                });
                return res;
            }
        });
    });
}
function unlistenArrayEvents(array, listener) {
    const stub = array._chartjs;
    if (!stub) return;
    const listeners = stub.listeners;
    const index = listeners.indexOf(listener);
    if (index !== -1) listeners.splice(index, 1);
    if (listeners.length > 0) return;
    arrayEvents.forEach((key)=>{
        delete array[key];
    });
    delete array._chartjs;
}
function _arrayUnique(items) {
    const set1 = new Set();
    let i, ilen;
    for(i = 0, ilen = items.length; i < ilen; ++i)set1.add(items[i]);
    if (set1.size === ilen) return items;
    return Array.from(set1);
}
function _createResolver(scopes, prefixes = [
    ''
], rootScopes = scopes, fallback, getTarget = ()=>scopes[0]
) {
    if (!defined(fallback)) fallback = _resolve('_fallback', scopes);
    const cache = {
        [Symbol.toStringTag]: 'Object',
        _cacheable: true,
        _scopes: scopes,
        _rootScopes: rootScopes,
        _fallback: fallback,
        _getTarget: getTarget,
        override: (scope)=>_createResolver([
                scope,
                ...scopes
            ], prefixes, rootScopes, fallback)
    };
    return new Proxy(cache, {
        deleteProperty (target, prop) {
            delete target[prop];
            delete target._keys;
            delete scopes[0][prop];
            return true;
        },
        get (target, prop) {
            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target)
            );
        },
        getOwnPropertyDescriptor (target, prop) {
            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
        },
        getPrototypeOf () {
            return Reflect.getPrototypeOf(scopes[0]);
        },
        has (target, prop) {
            return getKeysFromAllScopes(target).includes(prop);
        },
        ownKeys (target) {
            return getKeysFromAllScopes(target);
        },
        set (target, prop, value) {
            const storage = target._storage || (target._storage = getTarget());
            target[prop] = storage[prop] = value;
            delete target._keys;
            return true;
        }
    });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
    const cache = {
        _cacheable: false,
        _proxy: proxy,
        _context: context,
        _subProxy: subProxy,
        _stack: new Set(),
        _descriptors: _descriptors(proxy, descriptorDefaults),
        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults)
        ,
        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
    };
    return new Proxy(cache, {
        deleteProperty (target, prop) {
            delete target[prop];
            delete proxy[prop];
            return true;
        },
        get (target, prop, receiver) {
            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver)
            );
        },
        getOwnPropertyDescriptor (target, prop) {
            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
                enumerable: true,
                configurable: true
            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);
        },
        getPrototypeOf () {
            return Reflect.getPrototypeOf(proxy);
        },
        has (target, prop) {
            return Reflect.has(proxy, prop);
        },
        ownKeys () {
            return Reflect.ownKeys(proxy);
        },
        set (target, prop, value) {
            proxy[prop] = value;
            delete target[prop];
            return true;
        }
    });
}
function _descriptors(proxy, defaults1 = {
    scriptable: true,
    indexable: true
}) {
    const { _scriptable =defaults1.scriptable , _indexable =defaults1.indexable , _allKeys =defaults1.allKeys  } = proxy;
    return {
        allKeys: _allKeys,
        scriptable: _scriptable,
        indexable: _indexable,
        isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable
        ,
        isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable
    };
}
const readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name
;
const needsSubResolver = (prop, value)=>isObject(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object)
;
function _cached(target, prop, resolve1) {
    if (Object.prototype.hasOwnProperty.call(target, prop)) return target[prop];
    const value = resolve1();
    target[prop] = value;
    return value;
}
function _resolveWithContext(target, prop, receiver) {
    const { _proxy , _context , _subProxy , _descriptors: descriptors1  } = target;
    let value = _proxy[prop];
    if (isFunction(value) && descriptors1.isScriptable(prop)) value = _resolveScriptable(prop, value, target, receiver);
    if (isArray(value) && value.length) value = _resolveArray(prop, value, target, descriptors1.isIndexable);
    if (needsSubResolver(prop, value)) value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors1);
    return value;
}
function _resolveScriptable(prop, value, target, receiver) {
    const { _proxy , _context , _subProxy , _stack  } = target;
    if (_stack.has(prop)) throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);
    _stack.add(prop);
    value = value(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    return value;
}
function _resolveArray(prop, value, target, isIndexable) {
    const { _proxy , _context , _subProxy , _descriptors: descriptors2  } = target;
    if (defined(_context.index) && isIndexable(prop)) value = value[_context.index % value.length];
    else if (isObject(value[0])) {
        const arr = value;
        const scopes = _proxy._scopes.filter((s)=>s !== arr
        );
        value = [];
        for (const item of arr){
            const resolver = createSubResolver(scopes, _proxy, prop, item);
            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
        }
    }
    return value;
}
function resolveFallback(fallback, prop, value) {
    return isFunction(fallback) ? fallback(prop, value) : fallback;
}
const getScope = (key, parent)=>key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined
;
function addScopes(set2, parentScopes, key, parentFallback, value) {
    for (const parent of parentScopes){
        const scope = getScope(key, parent);
        if (scope) {
            set2.add(scope);
            const fallback = resolveFallback(scope._fallback, key, value);
            if (defined(fallback) && fallback !== key && fallback !== parentFallback) return fallback;
        } else if (scope === false && defined(parentFallback) && key !== parentFallback) return null;
    }
    return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value);
    const allScopes = [
        ...parentScopes,
        ...rootScopes
    ];
    const set3 = new Set();
    set3.add(value);
    let key = addScopesFromKey(set3, allScopes, prop, fallback || prop, value);
    if (key === null) return false;
    if (defined(fallback) && fallback !== prop) {
        key = addScopesFromKey(set3, allScopes, fallback, key, value);
        if (key === null) return false;
    }
    return _createResolver(Array.from(set3), [
        ''
    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value)
    );
}
function addScopesFromKey(set4, allScopes, key, fallback, item) {
    while(key)key = addScopes(set4, allScopes, key, fallback, item);
    return key;
}
function subGetTarget(resolver, prop, value) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) parent[prop] = {};
    const target = parent[prop];
    if (isArray(target) && isObject(value)) return value;
    return target;
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value;
    for (const prefix of prefixes){
        value = _resolve(readKey(prefix, prop), scopes);
        if (defined(value)) return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
}
function _resolve(key, scopes) {
    for (const scope of scopes){
        if (!scope) continue;
        const value = scope[key];
        if (defined(value)) return value;
    }
}
function getKeysFromAllScopes(target) {
    let keys = target._keys;
    if (!keys) keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    return keys;
}
function resolveKeysFromAllScopes(scopes) {
    const set5 = new Set();
    for (const scope of scopes)for (const key of Object.keys(scope).filter((k)=>!k.startsWith('_')
    ))set5.add(key);
    return Array.from(set5);
}
const EPSILON = Number.EPSILON || 1e-14;
const getPoint = (points, i)=>i < points.length && !points[i].skip && points[i]
;
const getValueAxis = (indexAxis)=>indexAxis === 'x' ? 'y' : 'x'
;
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
    const previous = firstPoint.skip ? middlePoint : firstPoint;
    const current = middlePoint;
    const next = afterPoint.skip ? middlePoint : afterPoint;
    const d01 = distanceBetweenPoints(current, previous);
    const d12 = distanceBetweenPoints(next, current);
    let s01 = d01 / (d01 + d12);
    let s12 = d12 / (d01 + d12);
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    const fa = t * s01;
    const fb = t * s12;
    return {
        previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
        },
        next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
        }
    };
}
function monotoneAdjust(points, deltaK, mK) {
    const pointsLen = points.length;
    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for(let i = 0; i < pointsLen - 1; ++i){
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent || !pointAfter) continue;
        if (almostEquals(deltaK[i], 0, EPSILON)) {
            mK[i] = mK[i + 1] = 0;
            continue;
        }
        alphaK = mK[i] / deltaK[i];
        betaK = mK[i + 1] / deltaK[i];
        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
        if (squaredMagnitude <= 9) continue;
        tauK = 3 / Math.sqrt(squaredMagnitude);
        mK[i] = alphaK * tauK * deltaK[i];
        mK[i + 1] = betaK * tauK * deltaK[i];
    }
}
function monotoneCompute(points, mK, indexAxis = 'x') {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    let delta, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for(let i = 0; i < pointsLen; ++i){
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent) continue;
        const iPixel = pointCurrent[indexAxis];
        const vPixel = pointCurrent[valueAxis];
        if (pointBefore) {
            delta = (iPixel - pointBefore[indexAxis]) / 3;
            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
        }
        if (pointAfter) {
            delta = (pointAfter[indexAxis] - iPixel) / 3;
            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
        }
    }
}
function splineCurveMonotone(points, indexAxis = 'x') {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    const deltaK = Array(pointsLen).fill(0);
    const mK = Array(pointsLen);
    let i, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for(i = 0; i < pointsLen; ++i){
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent) continue;
        if (pointAfter) {
            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
        }
        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
    return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
    let i, ilen, point, inArea, inAreaPrev;
    let inAreaNext = _isPointInArea(points[0], area);
    for(i = 0, ilen = points.length; i < ilen; ++i){
        inAreaPrev = inArea;
        inArea = inAreaNext;
        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
        if (!inArea) continue;
        point = points[i];
        if (inAreaPrev) {
            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
        }
        if (inAreaNext) {
            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
        }
    }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
    let i, ilen, point, controlPoints;
    if (options.spanGaps) points = points.filter((pt)=>!pt.skip
    );
    if (options.cubicInterpolationMode === 'monotone') splineCurveMonotone(points, indexAxis);
    else {
        let prev = loop ? points[points.length - 1] : points[0];
        for(i = 0, ilen = points.length; i < ilen; ++i){
            point = points[i];
            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
            point.cp1x = controlPoints.previous.x;
            point.cp1y = controlPoints.previous.y;
            point.cp2x = controlPoints.next.x;
            point.cp2y = controlPoints.next.y;
            prev = point;
        }
    }
    if (options.capBezierPoints) capBezierPoints(points, area);
}
function _isDomSupported() {
    return typeof window !== 'undefined' && typeof document !== 'undefined';
}
function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === '[object ShadowRoot]') parent = parent.host;
    return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === 'string') {
        valueInPixels = parseInt(styleValue, 10);
        if (styleValue.indexOf('%') !== -1) valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    } else valueInPixels = styleValue;
    return valueInPixels;
}
const getComputedStyle = (element)=>window.getComputedStyle(element, null)
;
function getStyle(el, property) {
    return getComputedStyle(el).getPropertyValue(property);
}
const positions = [
    'top',
    'right',
    'bottom',
    'left'
];
function getPositionedStyle(styles, style, suffix) {
    const result = {};
    suffix = suffix ? '-' + suffix : '';
    for(let i = 0; i < 4; i++){
        const pos = positions[i];
        result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
}
const useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot)
;
function getCanvasPosition(evt, canvas) {
    const e = evt.native || evt;
    const touches = e.touches;
    const source = touches && touches.length ? touches[0] : e;
    const { offsetX , offsetY  } = source;
    let box = false;
    let x, y;
    if (useOffsetPos(offsetX, offsetY, e.target)) {
        x = offsetX;
        y = offsetY;
    } else {
        const rect = canvas.getBoundingClientRect();
        x = source.clientX - rect.left;
        y = source.clientY - rect.top;
        box = true;
    }
    return {
        x,
        y,
        box
    };
}
function getRelativePosition(evt, chart) {
    const { canvas , currentDevicePixelRatio  } = chart;
    const style = getComputedStyle(canvas);
    const borderBox = style.boxSizing === 'border-box';
    const paddings = getPositionedStyle(style, 'padding');
    const borders = getPositionedStyle(style, 'border', 'width');
    const { x , y , box  } = getCanvasPosition(evt, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width , height  } = chart;
    if (borderBox) {
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
    }
    return {
        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
}
function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === undefined || height === undefined) {
        const container = _getParentNode(canvas);
        if (!container) {
            width = canvas.clientWidth;
            height = canvas.clientHeight;
        } else {
            const rect = container.getBoundingClientRect();
            const containerStyle = getComputedStyle(container);
            const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');
            const containerPadding = getPositionedStyle(containerStyle, 'padding');
            width = rect.width - containerPadding.width - containerBorder.width;
            height = rect.height - containerPadding.height - containerBorder.height;
            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');
            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');
        }
    }
    return {
        width,
        height,
        maxWidth: maxWidth || INFINITY,
        maxHeight: maxHeight || INFINITY
    };
}
const round1 = (v)=>Math.round(v * 10) / 10
;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style = getComputedStyle(canvas);
    const margins = getPositionedStyle(style, 'margin');
    const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;
    const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width , height  } = containerSize;
    if (style.boxSizing === 'content-box') {
        const borders = getPositionedStyle(style, 'border', 'width');
        const paddings = getPositionedStyle(style, 'padding');
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) height = round1(width / 2);
    return {
        width,
        height
    };
}
function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = Math.floor(chart.height * pixelRatio);
    const deviceWidth = Math.floor(chart.width * pixelRatio);
    chart.height = deviceHeight / pixelRatio;
    chart.width = deviceWidth / pixelRatio;
    const canvas = chart.canvas;
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
        canvas.style.height = `${chart.height}px`;
        canvas.style.width = `${chart.width}px`;
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
        chart.currentDevicePixelRatio = pixelRatio;
        canvas.height = deviceHeight;
        canvas.width = deviceWidth;
        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        return true;
    }
    return false;
}
const supportsEventListenerOptions = function() {
    let passiveSupported = false;
    try {
        const options = {
            get passive () {
                passiveSupported = true;
                return false;
            }
        };
        window.addEventListener('test', null, options);
        window.removeEventListener('test', null, options);
    } catch (e) {}
    return passiveSupported;
}();
function readUsedSize(element, property) {
    const value = getStyle(element, property);
    const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches ? +matches[1] : undefined;
}
function _pointInLine(p1, p2, t, mode) {
    return {
        x: p1.x + t * (p2.x - p1.x),
        y: p1.y + t * (p2.y - p1.y)
    };
}
function _steppedInterpolation(p1, p2, t, mode) {
    return {
        x: p1.x + t * (p2.x - p1.x),
        y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
    };
}
function _bezierInterpolation(p1, p2, t, mode) {
    const cp1 = {
        x: p1.cp2x,
        y: p1.cp2y
    };
    const cp2 = {
        x: p2.cp1x,
        y: p2.cp1y
    };
    const a = _pointInLine(p1, cp1, t);
    const b = _pointInLine(cp1, cp2, t);
    const c = _pointInLine(cp2, p2, t);
    const d = _pointInLine(a, b, t);
    const e = _pointInLine(b, c, t);
    return _pointInLine(d, e, t);
}
const intlCache = new Map();
function getNumberFormat(locale, options) {
    options = options || {};
    const cacheKey = locale + JSON.stringify(options);
    let formatter = intlCache.get(cacheKey);
    if (!formatter) {
        formatter = new Intl.NumberFormat(locale, options);
        intlCache.set(cacheKey, formatter);
    }
    return formatter;
}
function formatNumber(num, locale, options) {
    return getNumberFormat(locale, options).format(num);
}
const getRightToLeftAdapter = function(rectX, width) {
    return {
        x (x) {
            return rectX + rectX + width - x;
        },
        setWidth (w) {
            width = w;
        },
        textAlign (align) {
            if (align === 'center') return align;
            return align === 'right' ? 'left' : 'right';
        },
        xPlus (x, value) {
            return x - value;
        },
        leftForLtr (x, itemWidth) {
            return x - itemWidth;
        }
    };
};
const getLeftToRightAdapter = function() {
    return {
        x (x) {
            return x;
        },
        setWidth (w) {},
        textAlign (align) {
            return align;
        },
        xPlus (x, value) {
            return x + value;
        },
        leftForLtr (x, _itemWidth) {
            return x;
        }
    };
};
function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
    let style, original;
    if (direction === 'ltr' || direction === 'rtl') {
        style = ctx.canvas.style;
        original = [
            style.getPropertyValue('direction'),
            style.getPropertyPriority('direction'), 
        ];
        style.setProperty('direction', direction, 'important');
        ctx.prevTextDirection = original;
    }
}
function restoreTextDirection(ctx, original) {
    if (original !== undefined) {
        delete ctx.prevTextDirection;
        ctx.canvas.style.setProperty('direction', original[0], original[1]);
    }
}
function propertyFn(property) {
    if (property === 'angle') return {
        between: _angleBetween,
        compare: _angleDiff,
        normalize: _normalizeAngle
    };
    return {
        between: _isBetween,
        compare: (a, b)=>a - b
        ,
        normalize: (x)=>x
    };
}
function normalizeSegment({ start , end , count , loop , style  }) {
    return {
        start: start % count,
        end: end % count,
        loop: loop && (end - start + 1) % count === 0,
        style
    };
}
function getSegment(segment, points, bounds) {
    const { property , start: startBound , end: endBound  } = bounds;
    const { between , normalize  } = propertyFn(property);
    const count = points.length;
    let { start , end , loop  } = segment;
    let i, ilen;
    if (loop) {
        start += count;
        end += count;
        for(i = 0, ilen = count; i < ilen; ++i){
            if (!between(normalize(points[start % count][property]), startBound, endBound)) break;
            start--;
            end--;
        }
        start %= count;
        end %= count;
    }
    if (end < start) end += count;
    return {
        start,
        end,
        loop,
        style: segment.style
    };
}
function _boundSegment(segment, points, bounds) {
    if (!bounds) return [
        segment
    ];
    const { property , start: startBound , end: endBound  } = bounds;
    const count = points.length;
    const { compare , between , normalize  } = propertyFn(property);
    const { start , end , loop , style  } = getSegment(segment, points, bounds);
    const result = [];
    let inside = false;
    let subStart = null;
    let value, point, prevValue;
    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0
    ;
    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value)
    ;
    const shouldStart = ()=>inside || startIsBefore()
    ;
    const shouldStop = ()=>!inside || endIsBefore()
    ;
    for(let i = start, prev = start; i <= end; ++i){
        point = points[i % count];
        if (point.skip) continue;
        value = normalize(point[property]);
        if (value === prevValue) continue;
        inside = between(value, startBound, endBound);
        if (subStart === null && shouldStart()) subStart = compare(value, startBound) === 0 ? i : prev;
        if (subStart !== null && shouldStop()) {
            result.push(normalizeSegment({
                start: subStart,
                end: i,
                loop,
                count,
                style
            }));
            subStart = null;
        }
        prev = i;
        prevValue = value;
    }
    if (subStart !== null) result.push(normalizeSegment({
        start: subStart,
        end,
        loop,
        count,
        style
    }));
    return result;
}
function _boundSegments(line, bounds) {
    const result = [];
    const segments = line.segments;
    for(let i = 0; i < segments.length; i++){
        const sub = _boundSegment(segments[i], line.points, bounds);
        if (sub.length) result.push(...sub);
    }
    return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
    let start = 0;
    let end = count - 1;
    if (loop && !spanGaps) while(start < count && !points[start].skip)start++;
    while(start < count && points[start].skip)start++;
    start %= count;
    if (loop) end += start;
    while(end > start && points[end % count].skip)end--;
    end %= count;
    return {
        start,
        end
    };
}
function solidSegments(points, start, max, loop) {
    const count = points.length;
    const result = [];
    let last = start;
    let prev = points[start];
    let end;
    for(end = start + 1; end <= max; ++end){
        const cur = points[end % count];
        if (cur.skip || cur.stop) {
            if (!prev.skip) {
                loop = false;
                result.push({
                    start: start % count,
                    end: (end - 1) % count,
                    loop
                });
                start = last = cur.stop ? end : null;
            }
        } else {
            last = end;
            if (prev.skip) start = end;
        }
        prev = cur;
    }
    if (last !== null) result.push({
        start: start % count,
        end: last % count,
        loop
    });
    return result;
}
function _computeSegments(line, segmentOptions) {
    const points = line.points;
    const spanGaps = line.options.spanGaps;
    const count = points.length;
    if (!count) return [];
    const loop = !!line._loop;
    const { start , end  } = findStartAndEnd(points, count, loop, spanGaps);
    if (spanGaps === true) return splitByStyles(line, [
        {
            start,
            end,
            loop
        }
    ], points, segmentOptions);
    const max = end < start ? end + count : end;
    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) return segments;
    return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
    const chartContext = line._chart.getContext();
    const baseStyle = readStyle(line.options);
    const { _datasetIndex: datasetIndex , options: { spanGaps  }  } = line;
    const count = points.length;
    const result = [];
    let prevStyle = baseStyle;
    let start = segments[0].start;
    let i = start;
    function addStyle(s, e, l, st) {
        const dir = spanGaps ? -1 : 1;
        if (s === e) return;
        s += count;
        while(points[s % count].skip)s -= dir;
        while(points[e % count].skip)e += dir;
        if (s % count !== e % count) {
            result.push({
                start: s % count,
                end: e % count,
                loop: l,
                style: st
            });
            prevStyle = st;
            start = e % count;
        }
    }
    for (const segment of segments){
        start = spanGaps ? start : segment.start;
        let prev = points[start % count];
        let style;
        for(i = start + 1; i <= segment.end; i++){
            const pt = points[i % count];
            style = readStyle(segmentOptions.setContext(createContext(chartContext, {
                type: 'segment',
                p0: prev,
                p1: pt,
                p0DataIndex: (i - 1) % count,
                p1DataIndex: i % count,
                datasetIndex
            })));
            if (styleChanged(style, prevStyle)) addStyle(start, i - 1, segment.loop, prevStyle);
            prev = pt;
            prevStyle = style;
        }
        if (start < i - 1) addStyle(start, i - 1, segment.loop, prevStyle);
    }
    return result;
}
function readStyle(options) {
    return {
        backgroundColor: options.backgroundColor,
        borderCapStyle: options.borderCapStyle,
        borderDash: options.borderDash,
        borderDashOffset: options.borderDashOffset,
        borderJoinStyle: options.borderJoinStyle,
        borderWidth: options.borderWidth,
        borderColor: options.borderColor
    };
}
function styleChanged(style, prevStyle) {
    return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"koWJM":[function(require,module,exports) {
(function webpackUniversalModuleDefinition(root, factory) {
    var a, i;
    module.exports = factory();
})(self, function() {
    return /******/ function() {
        /******/ var __webpack_modules__ = {
            /***/ 3099: /***/ function(module) {
                module.exports = function(it) {
                    if (typeof it != 'function') throw TypeError(String(it) + ' is not a function');
                    return it;
                };
            /***/ },
            /***/ 6077: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var isObject = __webpack_require__(111);
                module.exports = function(it) {
                    if (!isObject(it) && it !== null) throw TypeError("Can't set " + String(it) + ' as a prototype');
                    return it;
                };
            /***/ },
            /***/ 1223: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var wellKnownSymbol = __webpack_require__(5112);
                var create = __webpack_require__(30);
                var definePropertyModule = __webpack_require__(3070);
                var UNSCOPABLES = wellKnownSymbol('unscopables');
                var ArrayPrototype = Array.prototype;
                // Array.prototype[@@unscopables]
                // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
                if (ArrayPrototype[UNSCOPABLES] == undefined) definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
                    configurable: true,
                    value: create(null)
                });
                // add a key to Array.prototype[@@unscopables]
                module.exports = function(key) {
                    ArrayPrototype[UNSCOPABLES][key] = true;
                };
            /***/ },
            /***/ 1530: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var charAt = __webpack_require__(8710).charAt;
                // `AdvanceStringIndex` abstract operation
                // https://tc39.es/ecma262/#sec-advancestringindex
                module.exports = function(S, index, unicode) {
                    return index + (unicode ? charAt(S, index).length : 1);
                };
            /***/ },
            /***/ 5787: /***/ function(module) {
                module.exports = function(it, Constructor, name) {
                    if (!(it instanceof Constructor)) throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
                    return it;
                };
            /***/ },
            /***/ 9670: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var isObject = __webpack_require__(111);
                module.exports = function(it) {
                    if (!isObject(it)) throw TypeError(String(it) + ' is not an object');
                    return it;
                };
            /***/ },
            /***/ 4019: /***/ function(module) {
                module.exports = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';
            /***/ },
            /***/ 260: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var NATIVE_ARRAY_BUFFER = __webpack_require__(4019);
                var DESCRIPTORS = __webpack_require__(9781);
                var global = __webpack_require__(7854);
                var isObject = __webpack_require__(111);
                var has = __webpack_require__(6656);
                var classof = __webpack_require__(648);
                var createNonEnumerableProperty = __webpack_require__(8880);
                var redefine = __webpack_require__(1320);
                var defineProperty = __webpack_require__(3070).f;
                var getPrototypeOf = __webpack_require__(9518);
                var setPrototypeOf = __webpack_require__(7674);
                var wellKnownSymbol = __webpack_require__(5112);
                var uid = __webpack_require__(9711);
                var Int8Array = global.Int8Array;
                var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
                var Uint8ClampedArray = global.Uint8ClampedArray;
                var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
                var TypedArray = Int8Array && getPrototypeOf(Int8Array);
                var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
                var ObjectPrototype = Object.prototype;
                var isPrototypeOf = ObjectPrototype.isPrototypeOf;
                var TO_STRING_TAG = wellKnownSymbol('toStringTag');
                var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
                // Fixing native typed arrays in Opera Presto crashes the browser, see #595
                var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
                var TYPED_ARRAY_TAG_REQIRED = false;
                var NAME;
                var TypedArrayConstructorsList = {
                    Int8Array: 1,
                    Uint8Array: 1,
                    Uint8ClampedArray: 1,
                    Int16Array: 2,
                    Uint16Array: 2,
                    Int32Array: 4,
                    Uint32Array: 4,
                    Float32Array: 4,
                    Float64Array: 8
                };
                var BigIntArrayConstructorsList = {
                    BigInt64Array: 8,
                    BigUint64Array: 8
                };
                var isView = function isView(it) {
                    if (!isObject(it)) return false;
                    var klass = classof(it);
                    return klass === 'DataView' || has(TypedArrayConstructorsList, klass) || has(BigIntArrayConstructorsList, klass);
                };
                var isTypedArray = function(it) {
                    if (!isObject(it)) return false;
                    var klass = classof(it);
                    return has(TypedArrayConstructorsList, klass) || has(BigIntArrayConstructorsList, klass);
                };
                var aTypedArray = function(it) {
                    if (isTypedArray(it)) return it;
                    throw TypeError('Target is not a typed array');
                };
                var aTypedArrayConstructor = function(C) {
                    if (setPrototypeOf) {
                        if (isPrototypeOf.call(TypedArray, C)) return C;
                    } else for(var ARRAY in TypedArrayConstructorsList)if (has(TypedArrayConstructorsList, NAME)) {
                        var TypedArrayConstructor = global[ARRAY];
                        if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) return C;
                    }
                    throw TypeError('Target is not a typed array constructor');
                };
                var exportTypedArrayMethod = function(KEY, property, forced) {
                    if (!DESCRIPTORS) return;
                    if (forced) for(var ARRAY in TypedArrayConstructorsList){
                        var TypedArrayConstructor = global[ARRAY];
                        if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) delete TypedArrayConstructor.prototype[KEY];
                    }
                    if (!TypedArrayPrototype[KEY] || forced) redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
                };
                var exportTypedArrayStaticMethod = function(KEY, property, forced) {
                    var ARRAY, TypedArrayConstructor;
                    if (!DESCRIPTORS) return;
                    if (setPrototypeOf) {
                        if (forced) for(ARRAY in TypedArrayConstructorsList){
                            TypedArrayConstructor = global[ARRAY];
                            if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) delete TypedArrayConstructor[KEY];
                        }
                        if (!TypedArray[KEY] || forced) // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
                        try {
                            return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY] || property);
                        } catch (error) {}
                        else return;
                    }
                    for(ARRAY in TypedArrayConstructorsList){
                        TypedArrayConstructor = global[ARRAY];
                        if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) redefine(TypedArrayConstructor, KEY, property);
                    }
                };
                for(NAME in TypedArrayConstructorsList)if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
                // WebKit bug - typed arrays constructors prototype is Object.prototype
                if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
                    // eslint-disable-next-line no-shadow -- safe
                    TypedArray = function TypedArray() {
                        throw TypeError('Incorrect invocation');
                    };
                    if (NATIVE_ARRAY_BUFFER_VIEWS) {
                        for(NAME in TypedArrayConstructorsList)if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
                    }
                }
                if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
                    TypedArrayPrototype = TypedArray.prototype;
                    if (NATIVE_ARRAY_BUFFER_VIEWS) {
                        for(NAME in TypedArrayConstructorsList)if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
                    }
                }
                // WebKit bug - one more object in Uint8ClampedArray prototype chain
                if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
                if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
                    TYPED_ARRAY_TAG_REQIRED = true;
                    defineProperty(TypedArrayPrototype, TO_STRING_TAG, {
                        get: function() {
                            return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
                        }
                    });
                    for(NAME in TypedArrayConstructorsList)if (global[NAME]) createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
                }
                module.exports = {
                    NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
                    TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
                    aTypedArray: aTypedArray,
                    aTypedArrayConstructor: aTypedArrayConstructor,
                    exportTypedArrayMethod: exportTypedArrayMethod,
                    exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
                    isView: isView,
                    isTypedArray: isTypedArray,
                    TypedArray: TypedArray,
                    TypedArrayPrototype: TypedArrayPrototype
                };
            /***/ },
            /***/ 3331: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var global = __webpack_require__(7854);
                var DESCRIPTORS = __webpack_require__(9781);
                var NATIVE_ARRAY_BUFFER = __webpack_require__(4019);
                var createNonEnumerableProperty = __webpack_require__(8880);
                var redefineAll = __webpack_require__(2248);
                var fails = __webpack_require__(7293);
                var anInstance = __webpack_require__(5787);
                var toInteger = __webpack_require__(9958);
                var toLength = __webpack_require__(7466);
                var toIndex = __webpack_require__(7067);
                var IEEE754 = __webpack_require__(1179);
                var getPrototypeOf = __webpack_require__(9518);
                var setPrototypeOf = __webpack_require__(7674);
                var getOwnPropertyNames = __webpack_require__(8006).f;
                var defineProperty = __webpack_require__(3070).f;
                var arrayFill = __webpack_require__(1285);
                var setToStringTag = __webpack_require__(8003);
                var InternalStateModule = __webpack_require__(9909);
                var getInternalState = InternalStateModule.get;
                var setInternalState = InternalStateModule.set;
                var ARRAY_BUFFER = 'ArrayBuffer';
                var DATA_VIEW = 'DataView';
                var PROTOTYPE = 'prototype';
                var WRONG_LENGTH = 'Wrong length';
                var WRONG_INDEX = 'Wrong index';
                var NativeArrayBuffer = global[ARRAY_BUFFER];
                var $ArrayBuffer = NativeArrayBuffer;
                var $DataView = global[DATA_VIEW];
                var $DataViewPrototype = $DataView && $DataView[PROTOTYPE];
                var ObjectPrototype = Object.prototype;
                var RangeError = global.RangeError;
                var packIEEE754 = IEEE754.pack;
                var unpackIEEE754 = IEEE754.unpack;
                var packInt8 = function(number) {
                    return [
                        number & 0xFF
                    ];
                };
                var packInt16 = function(number) {
                    return [
                        number & 0xFF,
                        number >> 8 & 0xFF
                    ];
                };
                var packInt32 = function(number) {
                    return [
                        number & 0xFF,
                        number >> 8 & 0xFF,
                        number >> 16 & 0xFF,
                        number >> 24 & 0xFF
                    ];
                };
                var unpackInt32 = function(buffer) {
                    return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
                };
                var packFloat32 = function(number) {
                    return packIEEE754(number, 23, 4);
                };
                var packFloat64 = function(number) {
                    return packIEEE754(number, 52, 8);
                };
                var addGetter = function(Constructor, key) {
                    defineProperty(Constructor[PROTOTYPE], key, {
                        get: function() {
                            return getInternalState(this)[key];
                        }
                    });
                };
                var get = function(view, count, index, isLittleEndian) {
                    var intIndex = toIndex(index);
                    var store = getInternalState(view);
                    if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
                    var bytes = getInternalState(store.buffer).bytes;
                    var start = intIndex + store.byteOffset;
                    var pack = bytes.slice(start, start + count);
                    return isLittleEndian ? pack : pack.reverse();
                };
                var set = function(view, count, index, conversion, value, isLittleEndian) {
                    var intIndex = toIndex(index);
                    var store = getInternalState(view);
                    if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
                    var bytes = getInternalState(store.buffer).bytes;
                    var start = intIndex + store.byteOffset;
                    var pack = conversion(+value);
                    for(var i = 0; i < count; i++)bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
                };
                if (!NATIVE_ARRAY_BUFFER) {
                    $ArrayBuffer = function ArrayBuffer(length) {
                        anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
                        var byteLength = toIndex(length);
                        setInternalState(this, {
                            bytes: arrayFill.call(new Array(byteLength), 0),
                            byteLength: byteLength
                        });
                        if (!DESCRIPTORS) this.byteLength = byteLength;
                    };
                    $DataView = function DataView(buffer, byteOffset, byteLength) {
                        anInstance(this, $DataView, DATA_VIEW);
                        anInstance(buffer, $ArrayBuffer, DATA_VIEW);
                        var bufferLength = getInternalState(buffer).byteLength;
                        var offset = toInteger(byteOffset);
                        if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
                        byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
                        if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
                        setInternalState(this, {
                            buffer: buffer,
                            byteLength: byteLength,
                            byteOffset: offset
                        });
                        if (!DESCRIPTORS) {
                            this.buffer = buffer;
                            this.byteLength = byteLength;
                            this.byteOffset = offset;
                        }
                    };
                    if (DESCRIPTORS) {
                        addGetter($ArrayBuffer, 'byteLength');
                        addGetter($DataView, 'buffer');
                        addGetter($DataView, 'byteLength');
                        addGetter($DataView, 'byteOffset');
                    }
                    redefineAll($DataView[PROTOTYPE], {
                        getInt8: function getInt8(byteOffset) {
                            return get(this, 1, byteOffset)[0] << 24 >> 24;
                        },
                        getUint8: function getUint8(byteOffset) {
                            return get(this, 1, byteOffset)[0];
                        },
                        getInt16: function getInt16(byteOffset /* , littleEndian */ ) {
                            var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
                            return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
                        },
                        getUint16: function getUint16(byteOffset /* , littleEndian */ ) {
                            var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
                            return bytes[1] << 8 | bytes[0];
                        },
                        getInt32: function getInt32(byteOffset /* , littleEndian */ ) {
                            return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
                        },
                        getUint32: function getUint32(byteOffset /* , littleEndian */ ) {
                            return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
                        },
                        getFloat32: function getFloat32(byteOffset /* , littleEndian */ ) {
                            return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
                        },
                        getFloat64: function getFloat64(byteOffset /* , littleEndian */ ) {
                            return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
                        },
                        setInt8: function setInt8(byteOffset, value) {
                            set(this, 1, byteOffset, packInt8, value);
                        },
                        setUint8: function setUint8(byteOffset, value) {
                            set(this, 1, byteOffset, packInt8, value);
                        },
                        setInt16: function setInt16(byteOffset, value /* , littleEndian */ ) {
                            set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
                        },
                        setUint16: function setUint16(byteOffset, value /* , littleEndian */ ) {
                            set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
                        },
                        setInt32: function setInt32(byteOffset, value /* , littleEndian */ ) {
                            set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
                        },
                        setUint32: function setUint32(byteOffset, value /* , littleEndian */ ) {
                            set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
                        },
                        setFloat32: function setFloat32(byteOffset, value /* , littleEndian */ ) {
                            set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
                        },
                        setFloat64: function setFloat64(byteOffset, value /* , littleEndian */ ) {
                            set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
                        }
                    });
                } else {
                    /* eslint-disable no-new -- required for testing */ if (!fails(function() {
                        NativeArrayBuffer(1);
                    }) || !fails(function() {
                        new NativeArrayBuffer(-1);
                    }) || fails(function() {
                        new NativeArrayBuffer();
                        new NativeArrayBuffer(1.5);
                        new NativeArrayBuffer(NaN);
                        return NativeArrayBuffer.name != ARRAY_BUFFER;
                    })) {
                        /* eslint-enable no-new -- required for testing */ $ArrayBuffer = function ArrayBuffer(length) {
                            anInstance(this, $ArrayBuffer);
                            return new NativeArrayBuffer(toIndex(length));
                        };
                        var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];
                        for(var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key1; keys.length > j;)if (!((key1 = keys[j++]) in $ArrayBuffer)) createNonEnumerableProperty($ArrayBuffer, key1, NativeArrayBuffer[key1]);
                        ArrayBufferPrototype.constructor = $ArrayBuffer;
                    }
                    // WebKit bug - the same parent prototype for typed arrays and data view
                    if (setPrototypeOf && getPrototypeOf($DataViewPrototype) !== ObjectPrototype) setPrototypeOf($DataViewPrototype, ObjectPrototype);
                    // iOS Safari 7.x bug
                    var testView = new $DataView(new $ArrayBuffer(2));
                    var nativeSetInt8 = $DataViewPrototype.setInt8;
                    testView.setInt8(0, 2147483648);
                    testView.setInt8(1, 2147483649);
                    if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
                        setInt8: function setInt8(byteOffset, value) {
                            nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
                        },
                        setUint8: function setUint8(byteOffset, value) {
                            nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
                        }
                    }, {
                        unsafe: true
                    });
                }
                setToStringTag($ArrayBuffer, ARRAY_BUFFER);
                setToStringTag($DataView, DATA_VIEW);
                module.exports = {
                    ArrayBuffer: $ArrayBuffer,
                    DataView: $DataView
                };
            /***/ },
            /***/ 1048: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var toObject = __webpack_require__(7908);
                var toAbsoluteIndex = __webpack_require__(1400);
                var toLength = __webpack_require__(7466);
                var min = Math.min;
                // `Array.prototype.copyWithin` method implementation
                // https://tc39.es/ecma262/#sec-array.prototype.copywithin
                module.exports = [].copyWithin || function copyWithin(target /* = 0 */ , start /* = 0, end = @length */ ) {
                    var O = toObject(this);
                    var len = toLength(O.length);
                    var to = toAbsoluteIndex(target, len);
                    var from = toAbsoluteIndex(start, len);
                    var end = arguments.length > 2 ? arguments[2] : undefined;
                    var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
                    var inc = 1;
                    if (from < to && to < from + count) {
                        inc = -1;
                        from += count - 1;
                        to += count - 1;
                    }
                    while(count-- > 0){
                        if (from in O) O[to] = O[from];
                        else delete O[to];
                        to += inc;
                        from += inc;
                    }
                    return O;
                };
            /***/ },
            /***/ 1285: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var toObject = __webpack_require__(7908);
                var toAbsoluteIndex = __webpack_require__(1400);
                var toLength = __webpack_require__(7466);
                // `Array.prototype.fill` method implementation
                // https://tc39.es/ecma262/#sec-array.prototype.fill
                module.exports = function fill(value /* , start = 0, end = @length */ ) {
                    var O = toObject(this);
                    var length = toLength(O.length);
                    var argumentsLength = arguments.length;
                    var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
                    var end = argumentsLength > 2 ? arguments[2] : undefined;
                    var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
                    while(endPos > index)O[index++] = value;
                    return O;
                };
            /***/ },
            /***/ 8533: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var $forEach = __webpack_require__(2092).forEach;
                var arrayMethodIsStrict = __webpack_require__(9341);
                var STRICT_METHOD = arrayMethodIsStrict('forEach');
                // `Array.prototype.forEach` method implementation
                // https://tc39.es/ecma262/#sec-array.prototype.foreach
                module.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */ ) {
                    return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
                } : [].forEach;
            /***/ },
            /***/ 8457: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var bind = __webpack_require__(9974);
                var toObject = __webpack_require__(7908);
                var callWithSafeIterationClosing = __webpack_require__(3411);
                var isArrayIteratorMethod = __webpack_require__(7659);
                var toLength = __webpack_require__(7466);
                var createProperty = __webpack_require__(6135);
                var getIteratorMethod = __webpack_require__(1246);
                // `Array.from` method implementation
                // https://tc39.es/ecma262/#sec-array.from
                module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */ ) {
                    var O = toObject(arrayLike);
                    var C = typeof this == 'function' ? this : Array;
                    var argumentsLength = arguments.length;
                    var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
                    var mapping = mapfn !== undefined;
                    var iteratorMethod = getIteratorMethod(O);
                    var index = 0;
                    var length, result, step, iterator, next, value;
                    if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
                    // if the target is not iterable or it's an array with the default iterator - use a simple case
                    if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
                        iterator = iteratorMethod.call(O);
                        next = iterator.next;
                        result = new C();
                        for(; !(step = next.call(iterator)).done; index++){
                            value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [
                                step.value,
                                index
                            ], true) : step.value;
                            createProperty(result, index, value);
                        }
                    } else {
                        length = toLength(O.length);
                        result = new C(length);
                        for(; length > index; index++){
                            value = mapping ? mapfn(O[index], index) : O[index];
                            createProperty(result, index, value);
                        }
                    }
                    result.length = index;
                    return result;
                };
            /***/ },
            /***/ 1318: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var toIndexedObject = __webpack_require__(5656);
                var toLength = __webpack_require__(7466);
                var toAbsoluteIndex = __webpack_require__(1400);
                // `Array.prototype.{ indexOf, includes }` methods implementation
                var createMethod = function(IS_INCLUDES) {
                    return function($this, el, fromIndex) {
                        var O = toIndexedObject($this);
                        var length = toLength(O.length);
                        var index = toAbsoluteIndex(fromIndex, length);
                        var value;
                        // Array#includes uses SameValueZero equality algorithm
                        // eslint-disable-next-line no-self-compare -- NaN check
                        if (IS_INCLUDES && el != el) while(length > index){
                            value = O[index++];
                            // eslint-disable-next-line no-self-compare -- NaN check
                            if (value != value) return true;
                        // Array#indexOf ignores holes, Array#includes - not
                        }
                        else for(; length > index; index++){
                            if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
                        }
                        return !IS_INCLUDES && -1;
                    };
                };
                module.exports = {
                    // `Array.prototype.includes` method
                    // https://tc39.es/ecma262/#sec-array.prototype.includes
                    includes: createMethod(true),
                    // `Array.prototype.indexOf` method
                    // https://tc39.es/ecma262/#sec-array.prototype.indexof
                    indexOf: createMethod(false)
                };
            /***/ },
            /***/ 2092: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var bind = __webpack_require__(9974);
                var IndexedObject = __webpack_require__(8361);
                var toObject = __webpack_require__(7908);
                var toLength = __webpack_require__(7466);
                var arraySpeciesCreate = __webpack_require__(5417);
                var push = [].push;
                // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation
                var createMethod = function(TYPE) {
                    var IS_MAP = TYPE == 1;
                    var IS_FILTER = TYPE == 2;
                    var IS_SOME = TYPE == 3;
                    var IS_EVERY = TYPE == 4;
                    var IS_FIND_INDEX = TYPE == 6;
                    var IS_FILTER_OUT = TYPE == 7;
                    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
                    return function($this, callbackfn, that, specificCreate) {
                        var O = toObject($this);
                        var self = IndexedObject(O);
                        var boundFunction = bind(callbackfn, that, 3);
                        var length = toLength(self.length);
                        var index = 0;
                        var create = specificCreate || arraySpeciesCreate;
                        var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;
                        var value, result;
                        for(; length > index; index++)if (NO_HOLES || index in self) {
                            value = self[index];
                            result = boundFunction(value, index, O);
                            if (TYPE) {
                                if (IS_MAP) target[index] = result; // map
                                else if (result) switch(TYPE){
                                    case 3:
                                        return true; // some
                                    case 5:
                                        return value; // find
                                    case 6:
                                        return index; // findIndex
                                    case 2:
                                        push.call(target, value); // filter
                                }
                                else switch(TYPE){
                                    case 4:
                                        return false; // every
                                    case 7:
                                        push.call(target, value); // filterOut
                                }
                            }
                        }
                        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
                    };
                };
                module.exports = {
                    // `Array.prototype.forEach` method
                    // https://tc39.es/ecma262/#sec-array.prototype.foreach
                    forEach: createMethod(0),
                    // `Array.prototype.map` method
                    // https://tc39.es/ecma262/#sec-array.prototype.map
                    map: createMethod(1),
                    // `Array.prototype.filter` method
                    // https://tc39.es/ecma262/#sec-array.prototype.filter
                    filter: createMethod(2),
                    // `Array.prototype.some` method
                    // https://tc39.es/ecma262/#sec-array.prototype.some
                    some: createMethod(3),
                    // `Array.prototype.every` method
                    // https://tc39.es/ecma262/#sec-array.prototype.every
                    every: createMethod(4),
                    // `Array.prototype.find` method
                    // https://tc39.es/ecma262/#sec-array.prototype.find
                    find: createMethod(5),
                    // `Array.prototype.findIndex` method
                    // https://tc39.es/ecma262/#sec-array.prototype.findIndex
                    findIndex: createMethod(6),
                    // `Array.prototype.filterOut` method
                    // https://github.com/tc39/proposal-array-filtering
                    filterOut: createMethod(7)
                };
            /***/ },
            /***/ 6583: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var toIndexedObject = __webpack_require__(5656);
                var toInteger = __webpack_require__(9958);
                var toLength = __webpack_require__(7466);
                var arrayMethodIsStrict = __webpack_require__(9341);
                var min = Math.min;
                var nativeLastIndexOf = [].lastIndexOf;
                var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [
                    1
                ].lastIndexOf(1, -0) < 0;
                var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
                var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;
                // `Array.prototype.lastIndexOf` method implementation
                // https://tc39.es/ecma262/#sec-array.prototype.lastindexof
                module.exports = FORCED ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */ ) {
                    // convert -0 to +0
                    if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
                    var O = toIndexedObject(this);
                    var length = toLength(O.length);
                    var index = length - 1;
                    if (arguments.length > 1) index = min(index, toInteger(arguments[1]));
                    if (index < 0) index = length + index;
                    for(; index >= 0; index--)if (index in O && O[index] === searchElement) return index || 0;
                    return -1;
                } : nativeLastIndexOf;
            /***/ },
            /***/ 1194: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var fails = __webpack_require__(7293);
                var wellKnownSymbol = __webpack_require__(5112);
                var V8_VERSION = __webpack_require__(7392);
                var SPECIES = wellKnownSymbol('species');
                module.exports = function(METHOD_NAME) {
                    // We can't use this feature detection in V8 since it causes
                    // deoptimization and serious performance degradation
                    // https://github.com/zloirock/core-js/issues/677
                    return V8_VERSION >= 51 || !fails(function() {
                        var array = [];
                        var constructor = array.constructor = {};
                        constructor[SPECIES] = function() {
                            return {
                                foo: 1
                            };
                        };
                        return array[METHOD_NAME](Boolean).foo !== 1;
                    });
                };
            /***/ },
            /***/ 9341: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var fails = __webpack_require__(7293);
                module.exports = function(METHOD_NAME, argument) {
                    var method = [][METHOD_NAME];
                    return !!method && fails(function() {
                        // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
                        method.call(null, argument || function() {
                            throw 1;
                        }, 1);
                    });
                };
            /***/ },
            /***/ 3671: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var aFunction = __webpack_require__(3099);
                var toObject = __webpack_require__(7908);
                var IndexedObject = __webpack_require__(8361);
                var toLength = __webpack_require__(7466);
                // `Array.prototype.{ reduce, reduceRight }` methods implementation
                var createMethod = function(IS_RIGHT) {
                    return function(that, callbackfn, argumentsLength, memo) {
                        aFunction(callbackfn);
                        var O = toObject(that);
                        var self = IndexedObject(O);
                        var length = toLength(O.length);
                        var index = IS_RIGHT ? length - 1 : 0;
                        var i = IS_RIGHT ? -1 : 1;
                        if (argumentsLength < 2) while(true){
                            if (index in self) {
                                memo = self[index];
                                index += i;
                                break;
                            }
                            index += i;
                            if (IS_RIGHT ? index < 0 : length <= index) throw TypeError('Reduce of empty array with no initial value');
                        }
                        for(; IS_RIGHT ? index >= 0 : length > index; index += i)if (index in self) memo = callbackfn(memo, self[index], index, O);
                        return memo;
                    };
                };
                module.exports = {
                    // `Array.prototype.reduce` method
                    // https://tc39.es/ecma262/#sec-array.prototype.reduce
                    left: createMethod(false),
                    // `Array.prototype.reduceRight` method
                    // https://tc39.es/ecma262/#sec-array.prototype.reduceright
                    right: createMethod(true)
                };
            /***/ },
            /***/ 5417: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var isObject = __webpack_require__(111);
                var isArray = __webpack_require__(3157);
                var wellKnownSymbol = __webpack_require__(5112);
                var SPECIES = wellKnownSymbol('species');
                // `ArraySpeciesCreate` abstract operation
                // https://tc39.es/ecma262/#sec-arrayspeciescreate
                module.exports = function(originalArray, length) {
                    var C;
                    if (isArray(originalArray)) {
                        C = originalArray.constructor;
                        // cross-realm fallback
                        if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
                        else if (isObject(C)) {
                            C = C[SPECIES];
                            if (C === null) C = undefined;
                        }
                    }
                    return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
                };
            /***/ },
            /***/ 3411: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var anObject = __webpack_require__(9670);
                var iteratorClose = __webpack_require__(9212);
                // call something on iterator step with safe closing on error
                module.exports = function(iterator, fn, value, ENTRIES) {
                    try {
                        return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
                    // 7.4.6 IteratorClose(iterator, completion)
                    } catch (error) {
                        iteratorClose(iterator);
                        throw error;
                    }
                };
            /***/ },
            /***/ 7072: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var wellKnownSymbol = __webpack_require__(5112);
                var ITERATOR = wellKnownSymbol('iterator');
                var SAFE_CLOSING = false;
                try {
                    var called = 0;
                    var iteratorWithReturn = {
                        next: function() {
                            return {
                                done: !!called++
                            };
                        },
                        'return': function() {
                            SAFE_CLOSING = true;
                        }
                    };
                    iteratorWithReturn[ITERATOR] = function() {
                        return this;
                    };
                    // eslint-disable-next-line no-throw-literal -- required for testing
                    Array.from(iteratorWithReturn, function() {
                        throw 2;
                    });
                } catch (error) {}
                module.exports = function(exec, SKIP_CLOSING) {
                    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
                    var ITERATION_SUPPORT = false;
                    try {
                        var object = {};
                        object[ITERATOR] = function() {
                            return {
                                next: function() {
                                    return {
                                        done: ITERATION_SUPPORT = true
                                    };
                                }
                            };
                        };
                        exec(object);
                    } catch (error) {}
                    return ITERATION_SUPPORT;
                };
            /***/ },
            /***/ 4326: /***/ function(module) {
                var toString = {}.toString;
                module.exports = function(it) {
                    return toString.call(it).slice(8, -1);
                };
            /***/ },
            /***/ 648: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var TO_STRING_TAG_SUPPORT = __webpack_require__(1694);
                var classofRaw = __webpack_require__(4326);
                var wellKnownSymbol = __webpack_require__(5112);
                var TO_STRING_TAG = wellKnownSymbol('toStringTag');
                // ES3 wrong here
                var CORRECT_ARGUMENTS = classofRaw(function() {
                    return arguments;
                }()) == 'Arguments';
                // fallback for IE11 Script Access Denied error
                var tryGet = function(it, key) {
                    try {
                        return it[key];
                    } catch (error) {}
                };
                // getting tag from ES6+ `Object.prototype.toString`
                module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
                    var O, tag, result;
                    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
                };
            /***/ },
            /***/ 9920: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var has = __webpack_require__(6656);
                var ownKeys = __webpack_require__(3887);
                var getOwnPropertyDescriptorModule = __webpack_require__(1236);
                var definePropertyModule = __webpack_require__(3070);
                module.exports = function(target, source) {
                    var keys = ownKeys(source);
                    var defineProperty = definePropertyModule.f;
                    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                    for(var i = 0; i < keys.length; i++){
                        var key = keys[i];
                        if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
                    }
                };
            /***/ },
            /***/ 8544: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var fails = __webpack_require__(7293);
                module.exports = !fails(function() {
                    function F() {}
                    F.prototype.constructor = null;
                    return Object.getPrototypeOf(new F()) !== F.prototype;
                });
            /***/ },
            /***/ 4994: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var IteratorPrototype = __webpack_require__(3383).IteratorPrototype;
                var create = __webpack_require__(30);
                var createPropertyDescriptor = __webpack_require__(9114);
                var setToStringTag = __webpack_require__(8003);
                var Iterators = __webpack_require__(7497);
                var returnThis = function() {
                    return this;
                };
                module.exports = function(IteratorConstructor, NAME, next) {
                    var TO_STRING_TAG = NAME + ' Iterator';
                    IteratorConstructor.prototype = create(IteratorPrototype, {
                        next: createPropertyDescriptor(1, next)
                    });
                    setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
                    Iterators[TO_STRING_TAG] = returnThis;
                    return IteratorConstructor;
                };
            /***/ },
            /***/ 8880: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var DESCRIPTORS = __webpack_require__(9781);
                var definePropertyModule = __webpack_require__(3070);
                var createPropertyDescriptor = __webpack_require__(9114);
                module.exports = DESCRIPTORS ? function(object, key, value) {
                    return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
                } : function(object, key, value) {
                    object[key] = value;
                    return object;
                };
            /***/ },
            /***/ 9114: /***/ function(module) {
                module.exports = function(bitmap, value) {
                    return {
                        enumerable: !(bitmap & 1),
                        configurable: !(bitmap & 2),
                        writable: !(bitmap & 4),
                        value: value
                    };
                };
            /***/ },
            /***/ 6135: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var toPrimitive = __webpack_require__(7593);
                var definePropertyModule = __webpack_require__(3070);
                var createPropertyDescriptor = __webpack_require__(9114);
                module.exports = function(object, key, value) {
                    var propertyKey = toPrimitive(key);
                    if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
                    else object[propertyKey] = value;
                };
            /***/ },
            /***/ 654: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var $ = __webpack_require__(2109);
                var createIteratorConstructor = __webpack_require__(4994);
                var getPrototypeOf = __webpack_require__(9518);
                var setPrototypeOf = __webpack_require__(7674);
                var setToStringTag = __webpack_require__(8003);
                var createNonEnumerableProperty = __webpack_require__(8880);
                var redefine = __webpack_require__(1320);
                var wellKnownSymbol = __webpack_require__(5112);
                var IS_PURE = __webpack_require__(1913);
                var Iterators = __webpack_require__(7497);
                var IteratorsCore = __webpack_require__(3383);
                var IteratorPrototype = IteratorsCore.IteratorPrototype;
                var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
                var ITERATOR = wellKnownSymbol('iterator');
                var KEYS = 'keys';
                var VALUES = 'values';
                var ENTRIES = 'entries';
                var returnThis = function() {
                    return this;
                };
                module.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
                    createIteratorConstructor(IteratorConstructor, NAME, next);
                    var getIterationMethod = function(KIND) {
                        if (KIND === DEFAULT && defaultIterator) return defaultIterator;
                        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
                        switch(KIND){
                            case KEYS:
                                return function keys() {
                                    return new IteratorConstructor(this, KIND);
                                };
                            case VALUES:
                                return function values() {
                                    return new IteratorConstructor(this, KIND);
                                };
                            case ENTRIES:
                                return function entries() {
                                    return new IteratorConstructor(this, KIND);
                                };
                        }
                        return function() {
                            return new IteratorConstructor(this);
                        };
                    };
                    var TO_STRING_TAG = NAME + ' Iterator';
                    var INCORRECT_VALUES_NAME = false;
                    var IterablePrototype = Iterable.prototype;
                    var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
                    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
                    var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
                    var CurrentIteratorPrototype, methods, KEY;
                    // fix native
                    if (anyNativeIterator) {
                        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
                        if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                            if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                                if (setPrototypeOf) setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                                else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
                            }
                            // Set @@toStringTag to native iterators
                            setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                            if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
                        }
                    }
                    // fix Array#{values, @@iterator}.name in V8 / FF
                    if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
                        INCORRECT_VALUES_NAME = true;
                        defaultIterator = function values() {
                            return nativeIterator.call(this);
                        };
                    }
                    // define iterator
                    if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
                    Iterators[NAME] = defaultIterator;
                    // export additional methods
                    if (DEFAULT) {
                        methods = {
                            values: getIterationMethod(VALUES),
                            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                            entries: getIterationMethod(ENTRIES)
                        };
                        if (FORCED) {
                            for(KEY in methods)if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) redefine(IterablePrototype, KEY, methods[KEY]);
                        } else $({
                            target: NAME,
                            proto: true,
                            forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
                        }, methods);
                    }
                    return methods;
                };
            /***/ },
            /***/ 9781: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var fails = __webpack_require__(7293);
                // Detect IE8's incomplete defineProperty implementation
                module.exports = !fails(function() {
                    return Object.defineProperty({}, 1, {
                        get: function() {
                            return 7;
                        }
                    })[1] != 7;
                });
            /***/ },
            /***/ 317: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var global = __webpack_require__(7854);
                var isObject = __webpack_require__(111);
                var document = global.document;
                // typeof document.createElement is 'object' in old IE
                var EXISTS = isObject(document) && isObject(document.createElement);
                module.exports = function(it) {
                    return EXISTS ? document.createElement(it) : {};
                };
            /***/ },
            /***/ 8324: /***/ function(module) {
                // iterable DOM collections
                // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
                module.exports = {
                    CSSRuleList: 0,
                    CSSStyleDeclaration: 0,
                    CSSValueList: 0,
                    ClientRectList: 0,
                    DOMRectList: 0,
                    DOMStringList: 0,
                    DOMTokenList: 1,
                    DataTransferItemList: 0,
                    FileList: 0,
                    HTMLAllCollection: 0,
                    HTMLCollection: 0,
                    HTMLFormElement: 0,
                    HTMLSelectElement: 0,
                    MediaList: 0,
                    MimeTypeArray: 0,
                    NamedNodeMap: 0,
                    NodeList: 1,
                    PaintRequestList: 0,
                    Plugin: 0,
                    PluginArray: 0,
                    SVGLengthList: 0,
                    SVGNumberList: 0,
                    SVGPathSegList: 0,
                    SVGPointList: 0,
                    SVGStringList: 0,
                    SVGTransformList: 0,
                    SourceBufferList: 0,
                    StyleSheetList: 0,
                    TextTrackCueList: 0,
                    TextTrackList: 0,
                    TouchList: 0
                };
            /***/ },
            /***/ 8113: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var getBuiltIn = __webpack_require__(5005);
                module.exports = getBuiltIn('navigator', 'userAgent') || '';
            /***/ },
            /***/ 7392: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var global = __webpack_require__(7854);
                var userAgent = __webpack_require__(8113);
                var process = global.process;
                var versions = process && process.versions;
                var v8 = versions && versions.v8;
                var match, version;
                if (v8) {
                    match = v8.split('.');
                    version = match[0] + match[1];
                } else if (userAgent) {
                    match = userAgent.match(/Edge\/(\d+)/);
                    if (!match || match[1] >= 74) {
                        match = userAgent.match(/Chrome\/(\d+)/);
                        if (match) version = match[1];
                    }
                }
                module.exports = version && +version;
            /***/ },
            /***/ 748: /***/ function(module) {
                // IE8- don't enum bug keys
                module.exports = [
                    'constructor',
                    'hasOwnProperty',
                    'isPrototypeOf',
                    'propertyIsEnumerable',
                    'toLocaleString',
                    'toString',
                    'valueOf'
                ];
            /***/ },
            /***/ 2109: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var global = __webpack_require__(7854);
                var getOwnPropertyDescriptor = __webpack_require__(1236).f;
                var createNonEnumerableProperty = __webpack_require__(8880);
                var redefine = __webpack_require__(1320);
                var setGlobal = __webpack_require__(3505);
                var copyConstructorProperties = __webpack_require__(9920);
                var isForced = __webpack_require__(4705);
                /*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/ module.exports = function(options, source) {
                    var TARGET = options.target;
                    var GLOBAL = options.global;
                    var STATIC = options.stat;
                    var FORCED, target, key, targetProperty, sourceProperty, descriptor;
                    if (GLOBAL) target = global;
                    else if (STATIC) target = global[TARGET] || setGlobal(TARGET, {});
                    else target = (global[TARGET] || {}).prototype;
                    if (target) for(key in source){
                        sourceProperty = source[key];
                        if (options.noTargetGet) {
                            descriptor = getOwnPropertyDescriptor(target, key);
                            targetProperty = descriptor && descriptor.value;
                        } else targetProperty = target[key];
                        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
                        // contained in target
                        if (!FORCED && targetProperty !== undefined) {
                            if (typeof sourceProperty === typeof targetProperty) continue;
                            copyConstructorProperties(sourceProperty, targetProperty);
                        }
                        // add a flag to not completely full polyfills
                        if (options.sham || targetProperty && targetProperty.sham) createNonEnumerableProperty(sourceProperty, 'sham', true);
                        // extend global
                        redefine(target, key, sourceProperty, options);
                    }
                };
            /***/ },
            /***/ 7293: /***/ function(module) {
                module.exports = function(exec) {
                    try {
                        return !!exec();
                    } catch (error) {
                        return true;
                    }
                };
            /***/ },
            /***/ 7007: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                // TODO: Remove from `core-js@4` since it's moved to entry points
                __webpack_require__(4916);
                var redefine = __webpack_require__(1320);
                var fails = __webpack_require__(7293);
                var wellKnownSymbol = __webpack_require__(5112);
                var regexpExec = __webpack_require__(2261);
                var createNonEnumerableProperty = __webpack_require__(8880);
                var SPECIES = wellKnownSymbol('species');
                var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
                    // #replace needs built-in support for named groups.
                    // #match works fine because it just return the exec results, even if it has
                    // a "grops" property.
                    var re = /./;
                    re.exec = function() {
                        var result = [];
                        result.groups = {
                            a: '7'
                        };
                        return result;
                    };
                    return ''.replace(re, '$<a>') !== '7';
                });
                // IE <= 11 replaces $0 with the whole match, as if it was $&
                // https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
                var REPLACE_KEEPS_$0 = function() {
                    return 'a'.replace(/./, '$0') === '$0';
                }();
                var REPLACE = wellKnownSymbol('replace');
                // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
                var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
                    if (/./[REPLACE]) return /./[REPLACE]('a', '$0') === '';
                    return false;
                }();
                // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
                // Weex JS has frozen built-in prototypes, so use try / catch wrapper
                var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
                    // eslint-disable-next-line regexp/no-empty-group -- required for testing
                    var re = /(?:)/;
                    var originalExec = re.exec;
                    re.exec = function() {
                        return originalExec.apply(this, arguments);
                    };
                    var result = 'ab'.split(re);
                    return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
                });
                module.exports = function(KEY, length, exec, sham) {
                    var SYMBOL = wellKnownSymbol(KEY);
                    var DELEGATES_TO_SYMBOL = !fails(function() {
                        // String methods call symbol-named RegEp methods
                        var O = {};
                        O[SYMBOL] = function() {
                            return 7;
                        };
                        return ''[KEY](O) != 7;
                    });
                    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
                        // Symbol-named RegExp methods call .exec
                        var execCalled = false;
                        var re = /a/;
                        if (KEY === 'split') {
                            // We can't use real regex here since it causes deoptimization
                            // and serious performance degradation in V8
                            // https://github.com/zloirock/core-js/issues/306
                            re = {};
                            // RegExp[@@split] doesn't call the regex's exec method, but first creates
                            // a new one. We need to return the patched regex when creating the new one.
                            re.constructor = {};
                            re.constructor[SPECIES] = function() {
                                return re;
                            };
                            re.flags = '';
                            re[SYMBOL] = /./[SYMBOL];
                        }
                        re.exec = function() {
                            execCalled = true;
                            return null;
                        };
                        re[SYMBOL]('');
                        return !execCalled;
                    });
                    if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
                        var nativeRegExpMethod = /./[SYMBOL];
                        var methods = exec(SYMBOL, ''[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
                            if (regexp.exec === regexpExec) {
                                if (DELEGATES_TO_SYMBOL && !forceStringMethod) // The native String method already delegates to @@method (this
                                // polyfilled function), leasing to infinite recursion.
                                // We avoid it by directly calling the native @@method method.
                                return {
                                    done: true,
                                    value: nativeRegExpMethod.call(regexp, str, arg2)
                                };
                                return {
                                    done: true,
                                    value: nativeMethod.call(str, regexp, arg2)
                                };
                            }
                            return {
                                done: false
                            };
                        }, {
                            REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
                            REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
                        });
                        var stringMethod = methods[0];
                        var regexMethod = methods[1];
                        redefine(String.prototype, KEY, stringMethod);
                        redefine(RegExp.prototype, SYMBOL, length == 2 ? function(string, arg) {
                            return regexMethod.call(string, this, arg);
                        } : function(string) {
                            return regexMethod.call(string, this);
                        });
                    }
                    if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
                };
            /***/ },
            /***/ 9974: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var aFunction = __webpack_require__(3099);
                // optional / simple context binding
                module.exports = function(fn, that, length) {
                    aFunction(fn);
                    if (that === undefined) return fn;
                    switch(length){
                        case 0:
                            return function() {
                                return fn.call(that);
                            };
                        case 1:
                            return function(a) {
                                return fn.call(that, a);
                            };
                        case 2:
                            return function(a, b) {
                                return fn.call(that, a, b);
                            };
                        case 3:
                            return function(a, b, c) {
                                return fn.call(that, a, b, c);
                            };
                    }
                    return function() {
                        return fn.apply(that, arguments);
                    };
                };
            /***/ },
            /***/ 5005: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var path = __webpack_require__(857);
                var global = __webpack_require__(7854);
                var aFunction = function(variable) {
                    return typeof variable == 'function' ? variable : undefined;
                };
                module.exports = function(namespace, method) {
                    return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
                };
            /***/ },
            /***/ 1246: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var classof = __webpack_require__(648);
                var Iterators = __webpack_require__(7497);
                var wellKnownSymbol = __webpack_require__(5112);
                var ITERATOR = wellKnownSymbol('iterator');
                module.exports = function(it) {
                    if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
                };
            /***/ },
            /***/ 8554: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var anObject = __webpack_require__(9670);
                var getIteratorMethod = __webpack_require__(1246);
                module.exports = function(it) {
                    var iteratorMethod = getIteratorMethod(it);
                    if (typeof iteratorMethod != 'function') throw TypeError(String(it) + ' is not iterable');
                    return anObject(iteratorMethod.call(it));
                };
            /***/ },
            /***/ 647: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var toObject = __webpack_require__(7908);
                var floor = Math.floor;
                var replace = ''.replace;
                var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
                var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;
                // https://tc39.es/ecma262/#sec-getsubstitution
                module.exports = function(matched, str, position, captures, namedCaptures, replacement) {
                    var tailPos = position + matched.length;
                    var m = captures.length;
                    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
                    if (namedCaptures !== undefined) {
                        namedCaptures = toObject(namedCaptures);
                        symbols = SUBSTITUTION_SYMBOLS;
                    }
                    return replace.call(replacement, symbols, function(match, ch) {
                        var capture;
                        switch(ch.charAt(0)){
                            case '$':
                                return '$';
                            case '&':
                                return matched;
                            case '`':
                                return str.slice(0, position);
                            case "'":
                                return str.slice(tailPos);
                            case '<':
                                capture = namedCaptures[ch.slice(1, -1)];
                                break;
                            default:
                                var n = +ch;
                                if (n === 0) return match;
                                if (n > m) {
                                    var f = floor(n / 10);
                                    if (f === 0) return match;
                                    if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
                                    return match;
                                }
                                capture = captures[n - 1];
                        }
                        return capture === undefined ? '' : capture;
                    });
                };
            /***/ },
            /***/ 7854: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var check = function(it) {
                    return it && it.Math == Math && it;
                };
                // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
                module.exports = /* global globalThis -- safe */ check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) || // eslint-disable-next-line no-new-func -- fallback
                function() {
                    return this;
                }() || Function('return this')();
            /***/ },
            /***/ 6656: /***/ function(module) {
                var hasOwnProperty = {}.hasOwnProperty;
                module.exports = function(it, key) {
                    return hasOwnProperty.call(it, key);
                };
            /***/ },
            /***/ 3501: /***/ function(module) {
                module.exports = {};
            /***/ },
            /***/ 490: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var getBuiltIn = __webpack_require__(5005);
                module.exports = getBuiltIn('document', 'documentElement');
            /***/ },
            /***/ 4664: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var DESCRIPTORS = __webpack_require__(9781);
                var fails = __webpack_require__(7293);
                var createElement = __webpack_require__(317);
                // Thank's IE8 for his funny defineProperty
                module.exports = !DESCRIPTORS && !fails(function() {
                    return Object.defineProperty(createElement('div'), 'a', {
                        get: function() {
                            return 7;
                        }
                    }).a != 7;
                });
            /***/ },
            /***/ 1179: /***/ function(module) {
                // IEEE754 conversions based on https://github.com/feross/ieee754
                var abs = Math.abs;
                var pow = Math.pow;
                var floor = Math.floor;
                var log = Math.log;
                var LN2 = Math.LN2;
                var pack = function(number, mantissaLength, bytes) {
                    var buffer = new Array(bytes);
                    var exponentLength = bytes * 8 - mantissaLength - 1;
                    var eMax = (1 << exponentLength) - 1;
                    var eBias = eMax >> 1;
                    var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
                    var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
                    var index = 0;
                    var exponent, mantissa, c;
                    number = abs(number);
                    // eslint-disable-next-line no-self-compare -- NaN check
                    if (number != number || number === Infinity) {
                        // eslint-disable-next-line no-self-compare -- NaN check
                        mantissa = number != number ? 1 : 0;
                        exponent = eMax;
                    } else {
                        exponent = floor(log(number) / LN2);
                        if (number * (c = pow(2, -exponent)) < 1) {
                            exponent--;
                            c *= 2;
                        }
                        if (exponent + eBias >= 1) number += rt / c;
                        else number += rt * pow(2, 1 - eBias);
                        if (number * c >= 2) {
                            exponent++;
                            c /= 2;
                        }
                        if (exponent + eBias >= eMax) {
                            mantissa = 0;
                            exponent = eMax;
                        } else if (exponent + eBias >= 1) {
                            mantissa = (number * c - 1) * pow(2, mantissaLength);
                            exponent = exponent + eBias;
                        } else {
                            mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
                            exponent = 0;
                        }
                    }
                    for(; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
                    exponent = exponent << mantissaLength | mantissa;
                    exponentLength += mantissaLength;
                    for(; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
                    buffer[--index] |= sign * 128;
                    return buffer;
                };
                var unpack = function(buffer, mantissaLength) {
                    var bytes = buffer.length;
                    var exponentLength = bytes * 8 - mantissaLength - 1;
                    var eMax = (1 << exponentLength) - 1;
                    var eBias = eMax >> 1;
                    var nBits = exponentLength - 7;
                    var index = bytes - 1;
                    var sign = buffer[index--];
                    var exponent = sign & 127;
                    var mantissa;
                    sign >>= 7;
                    for(; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
                    mantissa = exponent & (1 << -nBits) - 1;
                    exponent >>= -nBits;
                    nBits += mantissaLength;
                    for(; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
                    if (exponent === 0) exponent = 1 - eBias;
                    else if (exponent === eMax) return mantissa ? NaN : sign ? -Infinity : Infinity;
                    else {
                        mantissa = mantissa + pow(2, mantissaLength);
                        exponent = exponent - eBias;
                    }
                    return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
                };
                module.exports = {
                    pack: pack,
                    unpack: unpack
                };
            /***/ },
            /***/ 8361: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var fails = __webpack_require__(7293);
                var classof = __webpack_require__(4326);
                var split = ''.split;
                // fallback for non-array-like ES3 and non-enumerable old V8 strings
                module.exports = fails(function() {
                    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
                    // eslint-disable-next-line no-prototype-builtins -- safe
                    return !Object('z').propertyIsEnumerable(0);
                }) ? function(it) {
                    return classof(it) == 'String' ? split.call(it, '') : Object(it);
                } : Object;
            /***/ },
            /***/ 9587: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var isObject = __webpack_require__(111);
                var setPrototypeOf = __webpack_require__(7674);
                // makes subclassing work correct for wrapped built-ins
                module.exports = function($this, dummy, Wrapper) {
                    var NewTarget, NewTargetPrototype;
                    if (// it can work only with native `setPrototypeOf`
                    setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
                    typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf($this, NewTargetPrototype);
                    return $this;
                };
            /***/ },
            /***/ 2788: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var store = __webpack_require__(5465);
                var functionToString = Function.toString;
                // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
                if (typeof store.inspectSource != 'function') store.inspectSource = function(it) {
                    return functionToString.call(it);
                };
                module.exports = store.inspectSource;
            /***/ },
            /***/ 9909: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var NATIVE_WEAK_MAP = __webpack_require__(8536);
                var global = __webpack_require__(7854);
                var isObject = __webpack_require__(111);
                var createNonEnumerableProperty = __webpack_require__(8880);
                var objectHas = __webpack_require__(6656);
                var shared = __webpack_require__(5465);
                var sharedKey = __webpack_require__(6200);
                var hiddenKeys = __webpack_require__(3501);
                var WeakMap = global.WeakMap;
                var set, get, has;
                var enforce = function(it) {
                    return has(it) ? get(it) : set(it, {});
                };
                var getterFor = function(TYPE) {
                    return function(it) {
                        var state;
                        if (!isObject(it) || (state = get(it)).type !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required');
                        return state;
                    };
                };
                if (NATIVE_WEAK_MAP) {
                    var store = shared.state || (shared.state = new WeakMap());
                    var wmget = store.get;
                    var wmhas = store.has;
                    var wmset = store.set;
                    set = function(it, metadata) {
                        metadata.facade = it;
                        wmset.call(store, it, metadata);
                        return metadata;
                    };
                    get = function(it) {
                        return wmget.call(store, it) || {};
                    };
                    has = function(it) {
                        return wmhas.call(store, it);
                    };
                } else {
                    var STATE = sharedKey('state');
                    hiddenKeys[STATE] = true;
                    set = function(it, metadata) {
                        metadata.facade = it;
                        createNonEnumerableProperty(it, STATE, metadata);
                        return metadata;
                    };
                    get = function(it) {
                        return objectHas(it, STATE) ? it[STATE] : {};
                    };
                    has = function(it) {
                        return objectHas(it, STATE);
                    };
                }
                module.exports = {
                    set: set,
                    get: get,
                    has: has,
                    enforce: enforce,
                    getterFor: getterFor
                };
            /***/ },
            /***/ 7659: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var wellKnownSymbol = __webpack_require__(5112);
                var Iterators = __webpack_require__(7497);
                var ITERATOR = wellKnownSymbol('iterator');
                var ArrayPrototype = Array.prototype;
                // check on default Array iterator
                module.exports = function(it) {
                    return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
                };
            /***/ },
            /***/ 3157: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var classof = __webpack_require__(4326);
                // `IsArray` abstract operation
                // https://tc39.es/ecma262/#sec-isarray
                module.exports = Array.isArray || function isArray(arg) {
                    return classof(arg) == 'Array';
                };
            /***/ },
            /***/ 4705: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var fails = __webpack_require__(7293);
                var replacement = /#|\.prototype\./;
                var isForced = function(feature, detection) {
                    var value = data[normalize(feature)];
                    return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
                };
                var normalize = isForced.normalize = function(string) {
                    return String(string).replace(replacement, '.').toLowerCase();
                };
                var data = isForced.data = {};
                var NATIVE = isForced.NATIVE = 'N';
                var POLYFILL = isForced.POLYFILL = 'P';
                module.exports = isForced;
            /***/ },
            /***/ 111: /***/ function(module) {
                module.exports = function(it) {
                    return typeof it === 'object' ? it !== null : typeof it === 'function';
                };
            /***/ },
            /***/ 1913: /***/ function(module) {
                module.exports = false;
            /***/ },
            /***/ 7850: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var isObject = __webpack_require__(111);
                var classof = __webpack_require__(4326);
                var wellKnownSymbol = __webpack_require__(5112);
                var MATCH = wellKnownSymbol('match');
                // `IsRegExp` abstract operation
                // https://tc39.es/ecma262/#sec-isregexp
                module.exports = function(it) {
                    var isRegExp;
                    return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
                };
            /***/ },
            /***/ 9212: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var anObject = __webpack_require__(9670);
                module.exports = function(iterator) {
                    var returnMethod = iterator['return'];
                    if (returnMethod !== undefined) return anObject(returnMethod.call(iterator)).value;
                };
            /***/ },
            /***/ 3383: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var fails = __webpack_require__(7293);
                var getPrototypeOf = __webpack_require__(9518);
                var createNonEnumerableProperty = __webpack_require__(8880);
                var has = __webpack_require__(6656);
                var wellKnownSymbol = __webpack_require__(5112);
                var IS_PURE = __webpack_require__(1913);
                var ITERATOR = wellKnownSymbol('iterator');
                var BUGGY_SAFARI_ITERATORS = false;
                var returnThis = function() {
                    return this;
                };
                // `%IteratorPrototype%` object
                // https://tc39.es/ecma262/#sec-%iteratorprototype%-object
                var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
                if ([].keys) {
                    arrayIterator = [].keys();
                    // Safari 8 has buggy iterators w/o `next`
                    if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
                    else {
                        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
                        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
                    }
                }
                var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function() {
                    var test = {};
                    // FF44- legacy iterators case
                    return IteratorPrototype[ITERATOR].call(test) !== test;
                });
                if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
                // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
                if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
                module.exports = {
                    IteratorPrototype: IteratorPrototype,
                    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
                };
            /***/ },
            /***/ 7497: /***/ function(module) {
                module.exports = {};
            /***/ },
            /***/ 133: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var fails = __webpack_require__(7293);
                module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
                    // Chrome 38 Symbol has incorrect toString conversion
                    /* global Symbol -- required for testing */ return !String(Symbol());
                });
            /***/ },
            /***/ 590: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var fails = __webpack_require__(7293);
                var wellKnownSymbol = __webpack_require__(5112);
                var IS_PURE = __webpack_require__(1913);
                var ITERATOR = wellKnownSymbol('iterator');
                module.exports = !fails(function() {
                    var url = new URL('b?a=1&b=2&c=3', 'http://a');
                    var searchParams = url.searchParams;
                    var result = '';
                    url.pathname = 'c%20d';
                    searchParams.forEach(function(value, key) {
                        searchParams['delete']('b');
                        result += key + value;
                    });
                    return IS_PURE && !url.toJSON || !searchParams.sort || url.href !== 'http://a/c%20d?a=1&c=3' || searchParams.get('c') !== '3' || String(new URLSearchParams('?a=1')) !== 'a=1' || !searchParams[ITERATOR] || new URL('https://a@b').username !== 'a' || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b' || new URL('http://Ñ‚ÐµÑÑ‚').host !== 'xn--e1aybc' || new URL('http://a#Ð±').hash !== '#%D0%B1' || result !== 'a1c3' || new URL('http://x', undefined).host !== 'x';
                });
            /***/ },
            /***/ 8536: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var global = __webpack_require__(7854);
                var inspectSource = __webpack_require__(2788);
                var WeakMap = global.WeakMap;
                module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));
            /***/ },
            /***/ 1574: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var DESCRIPTORS = __webpack_require__(9781);
                var fails = __webpack_require__(7293);
                var objectKeys = __webpack_require__(1956);
                var getOwnPropertySymbolsModule = __webpack_require__(5181);
                var propertyIsEnumerableModule = __webpack_require__(5296);
                var toObject = __webpack_require__(7908);
                var IndexedObject = __webpack_require__(8361);
                var nativeAssign = Object.assign;
                var defineProperty = Object.defineProperty;
                // `Object.assign` method
                // https://tc39.es/ecma262/#sec-object.assign
                module.exports = !nativeAssign || fails(function() {
                    // should have correct order of operations (Edge bug)
                    if (DESCRIPTORS && nativeAssign({
                        b: 1
                    }, nativeAssign(defineProperty({}, 'a', {
                        enumerable: true,
                        get: function() {
                            defineProperty(this, 'b', {
                                value: 3,
                                enumerable: false
                            });
                        }
                    }), {
                        b: 2
                    })).b !== 1) return true;
                    // should work with symbols and should have deterministic property order (V8 bug)
                    var A = {};
                    var B = {};
                    /* global Symbol -- required for testing */ var symbol = Symbol();
                    var alphabet = 'abcdefghijklmnopqrst';
                    A[symbol] = 7;
                    alphabet.split('').forEach(function(chr) {
                        B[chr] = chr;
                    });
                    return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
                }) ? function assign(target, source) {
                    var T = toObject(target);
                    var argumentsLength = arguments.length;
                    var index = 1;
                    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
                    var propertyIsEnumerable = propertyIsEnumerableModule.f;
                    while(argumentsLength > index){
                        var S = IndexedObject(arguments[index++]);
                        var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
                        var length = keys.length;
                        var j = 0;
                        var key;
                        while(length > j){
                            key = keys[j++];
                            if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];
                        }
                    }
                    return T;
                } : nativeAssign;
            /***/ },
            /***/ 30: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var anObject = __webpack_require__(9670);
                var defineProperties = __webpack_require__(6048);
                var enumBugKeys = __webpack_require__(748);
                var hiddenKeys = __webpack_require__(3501);
                var html = __webpack_require__(490);
                var documentCreateElement = __webpack_require__(317);
                var sharedKey = __webpack_require__(6200);
                var GT = '>';
                var LT = '<';
                var PROTOTYPE = 'prototype';
                var SCRIPT = 'script';
                var IE_PROTO = sharedKey('IE_PROTO');
                var EmptyConstructor = function() {};
                var scriptTag = function(content) {
                    return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
                };
                // Create object with fake `null` prototype: use ActiveX Object with cleared prototype
                var NullProtoObjectViaActiveX = function(activeXDocument) {
                    activeXDocument.write(scriptTag(''));
                    activeXDocument.close();
                    var temp = activeXDocument.parentWindow.Object;
                    activeXDocument = null; // avoid memory leak
                    return temp;
                };
                // Create object with fake `null` prototype: use iframe Object with cleared prototype
                var NullProtoObjectViaIFrame = function() {
                    // Thrash, waste and sodomy: IE GC bug
                    var iframe = documentCreateElement('iframe');
                    var JS = 'java' + SCRIPT + ':';
                    var iframeDocument;
                    iframe.style.display = 'none';
                    html.appendChild(iframe);
                    // https://github.com/zloirock/core-js/issues/475
                    iframe.src = String(JS);
                    iframeDocument = iframe.contentWindow.document;
                    iframeDocument.open();
                    iframeDocument.write(scriptTag('document.F=Object'));
                    iframeDocument.close();
                    return iframeDocument.F;
                };
                // Check for document.domain and active x support
                // No need to use active x approach when document.domain is not set
                // see https://github.com/es-shims/es5-shim/issues/150
                // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
                // avoid IE GC bug
                var activeXDocument1;
                var NullProtoObject = function() {
                    try {
                        /* global ActiveXObject -- old IE */ activeXDocument1 = document.domain && new ActiveXObject('htmlfile');
                    } catch (error) {}
                    NullProtoObject = activeXDocument1 ? NullProtoObjectViaActiveX(activeXDocument1) : NullProtoObjectViaIFrame();
                    var length = enumBugKeys.length;
                    while(length--)delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
                    return NullProtoObject();
                };
                hiddenKeys[IE_PROTO] = true;
                // `Object.create` method
                // https://tc39.es/ecma262/#sec-object.create
                module.exports = Object.create || function create(O, Properties) {
                    var result;
                    if (O !== null) {
                        EmptyConstructor[PROTOTYPE] = anObject(O);
                        result = new EmptyConstructor();
                        EmptyConstructor[PROTOTYPE] = null;
                        // add "__proto__" for Object.getPrototypeOf polyfill
                        result[IE_PROTO] = O;
                    } else result = NullProtoObject();
                    return Properties === undefined ? result : defineProperties(result, Properties);
                };
            /***/ },
            /***/ 6048: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var DESCRIPTORS = __webpack_require__(9781);
                var definePropertyModule = __webpack_require__(3070);
                var anObject = __webpack_require__(9670);
                var objectKeys = __webpack_require__(1956);
                // `Object.defineProperties` method
                // https://tc39.es/ecma262/#sec-object.defineproperties
                module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
                    anObject(O);
                    var keys = objectKeys(Properties);
                    var length = keys.length;
                    var index = 0;
                    var key;
                    while(length > index)definePropertyModule.f(O, key = keys[index++], Properties[key]);
                    return O;
                };
            /***/ },
            /***/ 3070: /***/ function(__unused_webpack_module, exports, __webpack_require__) {
                var DESCRIPTORS = __webpack_require__(9781);
                var IE8_DOM_DEFINE = __webpack_require__(4664);
                var anObject = __webpack_require__(9670);
                var toPrimitive = __webpack_require__(7593);
                var nativeDefineProperty = Object.defineProperty;
                // `Object.defineProperty` method
                // https://tc39.es/ecma262/#sec-object.defineproperty
                exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
                    anObject(O);
                    P = toPrimitive(P, true);
                    anObject(Attributes);
                    if (IE8_DOM_DEFINE) try {
                        return nativeDefineProperty(O, P, Attributes);
                    } catch (error) {}
                    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
                    if ('value' in Attributes) O[P] = Attributes.value;
                    return O;
                };
            /***/ },
            /***/ 1236: /***/ function(__unused_webpack_module, exports, __webpack_require__) {
                var DESCRIPTORS = __webpack_require__(9781);
                var propertyIsEnumerableModule = __webpack_require__(5296);
                var createPropertyDescriptor = __webpack_require__(9114);
                var toIndexedObject = __webpack_require__(5656);
                var toPrimitive = __webpack_require__(7593);
                var has = __webpack_require__(6656);
                var IE8_DOM_DEFINE = __webpack_require__(4664);
                var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
                // `Object.getOwnPropertyDescriptor` method
                // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
                exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
                    O = toIndexedObject(O);
                    P = toPrimitive(P, true);
                    if (IE8_DOM_DEFINE) try {
                        return nativeGetOwnPropertyDescriptor(O, P);
                    } catch (error) {}
                    if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
                };
            /***/ },
            /***/ 8006: /***/ function(__unused_webpack_module, exports, __webpack_require__) {
                var internalObjectKeys = __webpack_require__(6324);
                var enumBugKeys = __webpack_require__(748);
                var hiddenKeys = enumBugKeys.concat('length', 'prototype');
                // `Object.getOwnPropertyNames` method
                // https://tc39.es/ecma262/#sec-object.getownpropertynames
                exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
                    return internalObjectKeys(O, hiddenKeys);
                };
            /***/ },
            /***/ 5181: /***/ function(__unused_webpack_module, exports) {
                exports.f = Object.getOwnPropertySymbols;
            /***/ },
            /***/ 9518: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var has = __webpack_require__(6656);
                var toObject = __webpack_require__(7908);
                var sharedKey = __webpack_require__(6200);
                var CORRECT_PROTOTYPE_GETTER = __webpack_require__(8544);
                var IE_PROTO = sharedKey('IE_PROTO');
                var ObjectPrototype = Object.prototype;
                // `Object.getPrototypeOf` method
                // https://tc39.es/ecma262/#sec-object.getprototypeof
                module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
                    O = toObject(O);
                    if (has(O, IE_PROTO)) return O[IE_PROTO];
                    if (typeof O.constructor == 'function' && O instanceof O.constructor) return O.constructor.prototype;
                    return O instanceof Object ? ObjectPrototype : null;
                };
            /***/ },
            /***/ 6324: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var has = __webpack_require__(6656);
                var toIndexedObject = __webpack_require__(5656);
                var indexOf = __webpack_require__(1318).indexOf;
                var hiddenKeys = __webpack_require__(3501);
                module.exports = function(object, names) {
                    var O = toIndexedObject(object);
                    var i = 0;
                    var result = [];
                    var key;
                    for(key in O)!has(hiddenKeys, key) && has(O, key) && result.push(key);
                    // Don't enum bug & hidden keys
                    while(names.length > i)if (has(O, key = names[i++])) ~indexOf(result, key) || result.push(key);
                    return result;
                };
            /***/ },
            /***/ 1956: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var internalObjectKeys = __webpack_require__(6324);
                var enumBugKeys = __webpack_require__(748);
                // `Object.keys` method
                // https://tc39.es/ecma262/#sec-object.keys
                module.exports = Object.keys || function keys(O) {
                    return internalObjectKeys(O, enumBugKeys);
                };
            /***/ },
            /***/ 5296: /***/ function(__unused_webpack_module, exports) {
                "use strict";
                var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
                var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
                // Nashorn ~ JDK8 bug
                var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
                    1: 2
                }, 1);
                // `Object.prototype.propertyIsEnumerable` method implementation
                // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
                exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
                    var descriptor = getOwnPropertyDescriptor(this, V);
                    return !!descriptor && descriptor.enumerable;
                } : nativePropertyIsEnumerable;
            /***/ },
            /***/ 7674: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                /* eslint-disable no-proto -- safe */ var anObject = __webpack_require__(9670);
                var aPossiblePrototype = __webpack_require__(6077);
                // `Object.setPrototypeOf` method
                // https://tc39.es/ecma262/#sec-object.setprototypeof
                // Works with __proto__ only. Old v8 can't work with null proto objects.
                module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function() {
                    var CORRECT_SETTER = false;
                    var test = {};
                    var setter;
                    try {
                        setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
                        setter.call(test, []);
                        CORRECT_SETTER = test instanceof Array;
                    } catch (error) {}
                    return function setPrototypeOf(O, proto) {
                        anObject(O);
                        aPossiblePrototype(proto);
                        if (CORRECT_SETTER) setter.call(O, proto);
                        else O.__proto__ = proto;
                        return O;
                    };
                }() : undefined);
            /***/ },
            /***/ 288: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var TO_STRING_TAG_SUPPORT = __webpack_require__(1694);
                var classof = __webpack_require__(648);
                // `Object.prototype.toString` method implementation
                // https://tc39.es/ecma262/#sec-object.prototype.tostring
                module.exports = TO_STRING_TAG_SUPPORT ? ({}).toString : function toString() {
                    return '[object ' + classof(this) + ']';
                };
            /***/ },
            /***/ 3887: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var getBuiltIn = __webpack_require__(5005);
                var getOwnPropertyNamesModule = __webpack_require__(8006);
                var getOwnPropertySymbolsModule = __webpack_require__(5181);
                var anObject = __webpack_require__(9670);
                // all object keys, includes non-enumerable and symbols
                module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
                    var keys = getOwnPropertyNamesModule.f(anObject(it));
                    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
                    return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
                };
            /***/ },
            /***/ 857: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var global = __webpack_require__(7854);
                module.exports = global;
            /***/ },
            /***/ 2248: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var redefine = __webpack_require__(1320);
                module.exports = function(target, src, options) {
                    for(var key in src)redefine(target, key, src[key], options);
                    return target;
                };
            /***/ },
            /***/ 1320: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var global = __webpack_require__(7854);
                var createNonEnumerableProperty = __webpack_require__(8880);
                var has = __webpack_require__(6656);
                var setGlobal = __webpack_require__(3505);
                var inspectSource = __webpack_require__(2788);
                var InternalStateModule = __webpack_require__(9909);
                var getInternalState = InternalStateModule.get;
                var enforceInternalState = InternalStateModule.enforce;
                var TEMPLATE = String(String).split('String');
                (module.exports = function(O, key, value, options) {
                    var unsafe = options ? !!options.unsafe : false;
                    var simple = options ? !!options.enumerable : false;
                    var noTargetGet = options ? !!options.noTargetGet : false;
                    var state;
                    if (typeof value == 'function') {
                        if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
                        state = enforceInternalState(value);
                        if (!state.source) state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
                    }
                    if (O === global) {
                        if (simple) O[key] = value;
                        else setGlobal(key, value);
                        return;
                    } else if (!unsafe) delete O[key];
                    else if (!noTargetGet && O[key]) simple = true;
                    if (simple) O[key] = value;
                    else createNonEnumerableProperty(O, key, value);
                // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
                })(Function.prototype, 'toString', function toString() {
                    return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
                });
            /***/ },
            /***/ 7651: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var classof = __webpack_require__(4326);
                var regexpExec = __webpack_require__(2261);
                // `RegExpExec` abstract operation
                // https://tc39.es/ecma262/#sec-regexpexec
                module.exports = function(R, S) {
                    var exec = R.exec;
                    if (typeof exec === 'function') {
                        var result = exec.call(R, S);
                        if (typeof result !== 'object') throw TypeError('RegExp exec method returned something other than an Object or null');
                        return result;
                    }
                    if (classof(R) !== 'RegExp') throw TypeError('RegExp#exec called on incompatible receiver');
                    return regexpExec.call(R, S);
                };
            /***/ },
            /***/ 2261: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var regexpFlags = __webpack_require__(7066);
                var stickyHelpers = __webpack_require__(2999);
                var nativeExec = RegExp.prototype.exec;
                // This always refers to the native implementation, because the
                // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
                // which loads this file before patching the method.
                var nativeReplace = String.prototype.replace;
                var patchedExec = nativeExec;
                var UPDATES_LAST_INDEX_WRONG = function() {
                    var re1 = /a/;
                    var re2 = /b*/g;
                    nativeExec.call(re1, 'a');
                    nativeExec.call(re2, 'a');
                    return re1.lastIndex !== 0 || re2.lastIndex !== 0;
                }();
                var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;
                // nonparticipating capturing group, copied from es5-shim's String#split patch.
                // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing
                var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
                var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;
                if (PATCH) patchedExec = function exec(str) {
                    var re = this;
                    var lastIndex, reCopy, match, i;
                    var sticky = UNSUPPORTED_Y && re.sticky;
                    var flags = regexpFlags.call(re);
                    var source = re.source;
                    var charsAdded = 0;
                    var strCopy = str;
                    if (sticky) {
                        flags = flags.replace('y', '');
                        if (flags.indexOf('g') === -1) flags += 'g';
                        strCopy = String(str).slice(re.lastIndex);
                        // Support anchored sticky behavior.
                        if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
                            source = '(?: ' + source + ')';
                            strCopy = ' ' + strCopy;
                            charsAdded++;
                        }
                        // ^(? + rx + ) is needed, in combination with some str slicing, to
                        // simulate the 'y' flag.
                        reCopy = new RegExp('^(?:' + source + ')', flags);
                    }
                    if (NPCG_INCLUDED) reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
                    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
                    match = nativeExec.call(sticky ? reCopy : re, strCopy);
                    if (sticky) {
                        if (match) {
                            match.input = match.input.slice(charsAdded);
                            match[0] = match[0].slice(charsAdded);
                            match.index = re.lastIndex;
                            re.lastIndex += match[0].length;
                        } else re.lastIndex = 0;
                    } else if (UPDATES_LAST_INDEX_WRONG && match) re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
                    if (NPCG_INCLUDED && match && match.length > 1) // Fix browsers whose `exec` methods don't consistently return `undefined`
                    // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
                    nativeReplace.call(match[0], reCopy, function() {
                        for(i = 1; i < arguments.length - 2; i++)if (arguments[i] === undefined) match[i] = undefined;
                    });
                    return match;
                };
                module.exports = patchedExec;
            /***/ },
            /***/ 7066: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var anObject = __webpack_require__(9670);
                // `RegExp.prototype.flags` getter implementation
                // https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
                module.exports = function() {
                    var that = anObject(this);
                    var result = '';
                    if (that.global) result += 'g';
                    if (that.ignoreCase) result += 'i';
                    if (that.multiline) result += 'm';
                    if (that.dotAll) result += 's';
                    if (that.unicode) result += 'u';
                    if (that.sticky) result += 'y';
                    return result;
                };
            /***/ },
            /***/ 2999: /***/ function(__unused_webpack_module, exports, __webpack_require__) {
                "use strict";
                var fails = __webpack_require__(7293);
                // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
                // so we use an intermediate function.
                function RE(s, f) {
                    return RegExp(s, f);
                }
                exports.UNSUPPORTED_Y = fails(function() {
                    // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
                    var re = RE('a', 'y');
                    re.lastIndex = 2;
                    return re.exec('abcd') != null;
                });
                exports.BROKEN_CARET = fails(function() {
                    // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
                    var re = RE('^r', 'gy');
                    re.lastIndex = 2;
                    return re.exec('str') != null;
                });
            /***/ },
            /***/ 4488: /***/ function(module) {
                // `RequireObjectCoercible` abstract operation
                // https://tc39.es/ecma262/#sec-requireobjectcoercible
                module.exports = function(it) {
                    if (it == undefined) throw TypeError("Can't call method on " + it);
                    return it;
                };
            /***/ },
            /***/ 3505: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var global = __webpack_require__(7854);
                var createNonEnumerableProperty = __webpack_require__(8880);
                module.exports = function(key, value) {
                    try {
                        createNonEnumerableProperty(global, key, value);
                    } catch (error) {
                        global[key] = value;
                    }
                    return value;
                };
            /***/ },
            /***/ 6340: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var getBuiltIn = __webpack_require__(5005);
                var definePropertyModule = __webpack_require__(3070);
                var wellKnownSymbol = __webpack_require__(5112);
                var DESCRIPTORS = __webpack_require__(9781);
                var SPECIES = wellKnownSymbol('species');
                module.exports = function(CONSTRUCTOR_NAME) {
                    var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
                    var defineProperty = definePropertyModule.f;
                    if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) defineProperty(Constructor, SPECIES, {
                        configurable: true,
                        get: function() {
                            return this;
                        }
                    });
                };
            /***/ },
            /***/ 8003: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var defineProperty = __webpack_require__(3070).f;
                var has = __webpack_require__(6656);
                var wellKnownSymbol = __webpack_require__(5112);
                var TO_STRING_TAG = wellKnownSymbol('toStringTag');
                module.exports = function(it, TAG, STATIC) {
                    if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) defineProperty(it, TO_STRING_TAG, {
                        configurable: true,
                        value: TAG
                    });
                };
            /***/ },
            /***/ 6200: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var shared = __webpack_require__(2309);
                var uid = __webpack_require__(9711);
                var keys = shared('keys');
                module.exports = function(key) {
                    return keys[key] || (keys[key] = uid(key));
                };
            /***/ },
            /***/ 5465: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var global = __webpack_require__(7854);
                var setGlobal = __webpack_require__(3505);
                var SHARED = '__core-js_shared__';
                var store = global[SHARED] || setGlobal(SHARED, {});
                module.exports = store;
            /***/ },
            /***/ 2309: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var IS_PURE = __webpack_require__(1913);
                var store = __webpack_require__(5465);
                (module.exports = function(key, value) {
                    return store[key] || (store[key] = value !== undefined ? value : {});
                })('versions', []).push({
                    version: '3.9.0',
                    mode: IS_PURE ? 'pure' : 'global',
                    copyright: 'Â© 2021 Denis Pushkarev (zloirock.ru)'
                });
            /***/ },
            /***/ 6707: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var anObject = __webpack_require__(9670);
                var aFunction = __webpack_require__(3099);
                var wellKnownSymbol = __webpack_require__(5112);
                var SPECIES = wellKnownSymbol('species');
                // `SpeciesConstructor` abstract operation
                // https://tc39.es/ecma262/#sec-speciesconstructor
                module.exports = function(O, defaultConstructor) {
                    var C = anObject(O).constructor;
                    var S;
                    return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
                };
            /***/ },
            /***/ 8710: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var toInteger = __webpack_require__(9958);
                var requireObjectCoercible = __webpack_require__(4488);
                // `String.prototype.{ codePointAt, at }` methods implementation
                var createMethod = function(CONVERT_TO_STRING) {
                    return function($this, pos) {
                        var S = String(requireObjectCoercible($this));
                        var position = toInteger(pos);
                        var size = S.length;
                        var first, second;
                        if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
                        first = S.charCodeAt(position);
                        return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
                    };
                };
                module.exports = {
                    // `String.prototype.codePointAt` method
                    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
                    codeAt: createMethod(false),
                    // `String.prototype.at` method
                    // https://github.com/mathiasbynens/String.prototype.at
                    charAt: createMethod(true)
                };
            /***/ },
            /***/ 3197: /***/ function(module) {
                "use strict";
                // based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
                var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
                var base = 36;
                var tMin = 1;
                var tMax = 26;
                var skew = 38;
                var damp = 700;
                var initialBias = 72;
                var initialN = 128; // 0x80
                var delimiter = '-'; // '\x2D'
                var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
                var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
                var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
                var baseMinusTMin = base - tMin;
                var floor = Math.floor;
                var stringFromCharCode = String.fromCharCode;
                /**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 */ var ucs2decode = function(string) {
                    var output = [];
                    var counter = 0;
                    var length = string.length;
                    while(counter < length){
                        var value = string.charCodeAt(counter++);
                        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                            // It's a high surrogate, and there is a next character.
                            var extra = string.charCodeAt(counter++);
                            if ((extra & 0xFC00) == 0xDC00) output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                            else {
                                // It's an unmatched surrogate; only append this code unit, in case the
                                // next code unit is the high surrogate of a surrogate pair.
                                output.push(value);
                                counter--;
                            }
                        } else output.push(value);
                    }
                    return output;
                };
                /**
 * Converts a digit/integer into a basic code point.
 */ var digitToBasic = function(digit) {
                    //  0..25 map to ASCII a..z or A..Z
                    // 26..35 map to ASCII 0..9
                    return digit + 22 + 75 * (digit < 26);
                };
                /**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 */ var adapt = function(delta, numPoints, firstTime) {
                    var k = 0;
                    delta = firstTime ? floor(delta / damp) : delta >> 1;
                    delta += floor(delta / numPoints);
                    for(; delta > baseMinusTMin * tMax >> 1; k += base)delta = floor(delta / baseMinusTMin);
                    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                };
                /**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 */ // eslint-disable-next-line max-statements -- TODO
                var encode = function(input) {
                    var output = [];
                    // Convert the input in UCS-2 to an array of Unicode code points.
                    input = ucs2decode(input);
                    // Cache the length.
                    var inputLength = input.length;
                    // Initialize the state.
                    var n = initialN;
                    var delta = 0;
                    var bias = initialBias;
                    var i, currentValue;
                    // Handle the basic code points.
                    for(i = 0; i < input.length; i++){
                        currentValue = input[i];
                        if (currentValue < 0x80) output.push(stringFromCharCode(currentValue));
                    }
                    var basicLength = output.length; // number of basic code points.
                    var handledCPCount = basicLength; // number of code points that have been handled;
                    // Finish the basic string with a delimiter unless it's empty.
                    if (basicLength) output.push(delimiter);
                    // Main encoding loop:
                    while(handledCPCount < inputLength){
                        // All non-basic code points < n have been handled already. Find the next larger one:
                        var m = maxInt;
                        for(i = 0; i < input.length; i++){
                            currentValue = input[i];
                            if (currentValue >= n && currentValue < m) m = currentValue;
                        }
                        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
                        var handledCPCountPlusOne = handledCPCount + 1;
                        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) throw RangeError(OVERFLOW_ERROR);
                        delta += (m - n) * handledCPCountPlusOne;
                        n = m;
                        for(i = 0; i < input.length; i++){
                            currentValue = input[i];
                            if (currentValue < n && ++delta > maxInt) throw RangeError(OVERFLOW_ERROR);
                            if (currentValue == n) {
                                // Represent delta as a generalized variable-length integer.
                                var q = delta;
                                for(var k = base;; k += base){
                                    var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                    if (q < t) break;
                                    var qMinusT = q - t;
                                    var baseMinusT = base - t;
                                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
                                    q = floor(qMinusT / baseMinusT);
                                }
                                output.push(stringFromCharCode(digitToBasic(q)));
                                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                delta = 0;
                                ++handledCPCount;
                            }
                        }
                        ++delta;
                        ++n;
                    }
                    return output.join('');
                };
                module.exports = function(input) {
                    var encoded = [];
                    var labels = input.toLowerCase().replace(regexSeparators, '\u002E').split('.');
                    var i, label;
                    for(i = 0; i < labels.length; i++){
                        label = labels[i];
                        encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
                    }
                    return encoded.join('.');
                };
            /***/ },
            /***/ 6091: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var fails = __webpack_require__(7293);
                var whitespaces = __webpack_require__(1361);
                var non = '\u200B\u0085\u180E';
                // check that a method works with the correct list
                // of whitespaces and has a correct name
                module.exports = function(METHOD_NAME) {
                    return fails(function() {
                        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
                    });
                };
            /***/ },
            /***/ 3111: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var requireObjectCoercible = __webpack_require__(4488);
                var whitespaces = __webpack_require__(1361);
                var whitespace = '[' + whitespaces + ']';
                var ltrim = RegExp('^' + whitespace + whitespace + '*');
                var rtrim = RegExp(whitespace + whitespace + '*$');
                // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
                var createMethod = function(TYPE) {
                    return function($this) {
                        var string = String(requireObjectCoercible($this));
                        if (TYPE & 1) string = string.replace(ltrim, '');
                        if (TYPE & 2) string = string.replace(rtrim, '');
                        return string;
                    };
                };
                module.exports = {
                    // `String.prototype.{ trimLeft, trimStart }` methods
                    // https://tc39.es/ecma262/#sec-string.prototype.trimstart
                    start: createMethod(1),
                    // `String.prototype.{ trimRight, trimEnd }` methods
                    // https://tc39.es/ecma262/#sec-string.prototype.trimend
                    end: createMethod(2),
                    // `String.prototype.trim` method
                    // https://tc39.es/ecma262/#sec-string.prototype.trim
                    trim: createMethod(3)
                };
            /***/ },
            /***/ 1400: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var toInteger = __webpack_require__(9958);
                var max = Math.max;
                var min = Math.min;
                // Helper for a popular repeating case of the spec:
                // Let integer be ? ToInteger(index).
                // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
                module.exports = function(index, length) {
                    var integer = toInteger(index);
                    return integer < 0 ? max(integer + length, 0) : min(integer, length);
                };
            /***/ },
            /***/ 7067: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var toInteger = __webpack_require__(9958);
                var toLength = __webpack_require__(7466);
                // `ToIndex` abstract operation
                // https://tc39.es/ecma262/#sec-toindex
                module.exports = function(it) {
                    if (it === undefined) return 0;
                    var number = toInteger(it);
                    var length = toLength(number);
                    if (number !== length) throw RangeError('Wrong length or index');
                    return length;
                };
            /***/ },
            /***/ 5656: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                // toObject with fallback for non-array-like ES3 strings
                var IndexedObject = __webpack_require__(8361);
                var requireObjectCoercible = __webpack_require__(4488);
                module.exports = function(it) {
                    return IndexedObject(requireObjectCoercible(it));
                };
            /***/ },
            /***/ 9958: /***/ function(module) {
                var ceil = Math.ceil;
                var floor = Math.floor;
                // `ToInteger` abstract operation
                // https://tc39.es/ecma262/#sec-tointeger
                module.exports = function(argument) {
                    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
                };
            /***/ },
            /***/ 7466: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var toInteger = __webpack_require__(9958);
                var min = Math.min;
                // `ToLength` abstract operation
                // https://tc39.es/ecma262/#sec-tolength
                module.exports = function(argument) {
                    return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
                };
            /***/ },
            /***/ 7908: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var requireObjectCoercible = __webpack_require__(4488);
                // `ToObject` abstract operation
                // https://tc39.es/ecma262/#sec-toobject
                module.exports = function(argument) {
                    return Object(requireObjectCoercible(argument));
                };
            /***/ },
            /***/ 4590: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var toPositiveInteger = __webpack_require__(3002);
                module.exports = function(it, BYTES) {
                    var offset = toPositiveInteger(it);
                    if (offset % BYTES) throw RangeError('Wrong offset');
                    return offset;
                };
            /***/ },
            /***/ 3002: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var toInteger = __webpack_require__(9958);
                module.exports = function(it) {
                    var result = toInteger(it);
                    if (result < 0) throw RangeError("The argument can't be less than 0");
                    return result;
                };
            /***/ },
            /***/ 7593: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var isObject = __webpack_require__(111);
                // `ToPrimitive` abstract operation
                // https://tc39.es/ecma262/#sec-toprimitive
                // instead of the ES6 spec version, we didn't implement @@toPrimitive case
                // and the second argument - flag - preferred type is a string
                module.exports = function(input, PREFERRED_STRING) {
                    if (!isObject(input)) return input;
                    var fn, val;
                    if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
                    if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
                    if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
                    throw TypeError("Can't convert object to primitive value");
                };
            /***/ },
            /***/ 1694: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var wellKnownSymbol = __webpack_require__(5112);
                var TO_STRING_TAG = wellKnownSymbol('toStringTag');
                var test = {};
                test[TO_STRING_TAG] = 'z';
                module.exports = String(test) === '[object z]';
            /***/ },
            /***/ 9843: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var $ = __webpack_require__(2109);
                var global = __webpack_require__(7854);
                var DESCRIPTORS = __webpack_require__(9781);
                var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__(3832);
                var ArrayBufferViewCore = __webpack_require__(260);
                var ArrayBufferModule = __webpack_require__(3331);
                var anInstance = __webpack_require__(5787);
                var createPropertyDescriptor = __webpack_require__(9114);
                var createNonEnumerableProperty = __webpack_require__(8880);
                var toLength = __webpack_require__(7466);
                var toIndex = __webpack_require__(7067);
                var toOffset = __webpack_require__(4590);
                var toPrimitive = __webpack_require__(7593);
                var has = __webpack_require__(6656);
                var classof = __webpack_require__(648);
                var isObject = __webpack_require__(111);
                var create = __webpack_require__(30);
                var setPrototypeOf = __webpack_require__(7674);
                var getOwnPropertyNames = __webpack_require__(8006).f;
                var typedArrayFrom = __webpack_require__(7321);
                var forEach = __webpack_require__(2092).forEach;
                var setSpecies = __webpack_require__(6340);
                var definePropertyModule = __webpack_require__(3070);
                var getOwnPropertyDescriptorModule = __webpack_require__(1236);
                var InternalStateModule = __webpack_require__(9909);
                var inheritIfRequired = __webpack_require__(9587);
                var getInternalState = InternalStateModule.get;
                var setInternalState = InternalStateModule.set;
                var nativeDefineProperty = definePropertyModule.f;
                var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                var round = Math.round;
                var RangeError = global.RangeError;
                var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
                var DataView = ArrayBufferModule.DataView;
                var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
                var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
                var TypedArray = ArrayBufferViewCore.TypedArray;
                var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
                var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
                var isTypedArray = ArrayBufferViewCore.isTypedArray;
                var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
                var WRONG_LENGTH = 'Wrong length';
                var fromList = function(C, list) {
                    var index = 0;
                    var length = list.length;
                    var result = new (aTypedArrayConstructor(C))(length);
                    while(length > index)result[index] = list[index++];
                    return result;
                };
                var addGetter = function(it, key) {
                    nativeDefineProperty(it, key, {
                        get: function() {
                            return getInternalState(this)[key];
                        }
                    });
                };
                var isArrayBuffer = function(it) {
                    var klass;
                    return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
                };
                var isTypedArrayIndex = function(target, key) {
                    return isTypedArray(target) && typeof key != 'symbol' && key in target && String(+key) == String(key);
                };
                var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
                    return isTypedArrayIndex(target, key = toPrimitive(key, true)) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
                };
                var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
                    if (isTypedArrayIndex(target, key = toPrimitive(key, true)) && isObject(descriptor) && has(descriptor, 'value') && !has(descriptor, 'get') && !has(descriptor, 'set') && !descriptor.configurable && (!has(descriptor, 'writable') || descriptor.writable) && (!has(descriptor, 'enumerable') || descriptor.enumerable)) {
                        target[key] = descriptor.value;
                        return target;
                    }
                    return nativeDefineProperty(target, key, descriptor);
                };
                if (DESCRIPTORS) {
                    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
                        getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
                        definePropertyModule.f = wrappedDefineProperty;
                        addGetter(TypedArrayPrototype, 'buffer');
                        addGetter(TypedArrayPrototype, 'byteOffset');
                        addGetter(TypedArrayPrototype, 'byteLength');
                        addGetter(TypedArrayPrototype, 'length');
                    }
                    $({
                        target: 'Object',
                        stat: true,
                        forced: !NATIVE_ARRAY_BUFFER_VIEWS
                    }, {
                        getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
                        defineProperty: wrappedDefineProperty
                    });
                    module.exports = function(TYPE, wrapper, CLAMPED) {
                        var BYTES = TYPE.match(/\d+$/)[0] / 8;
                        var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
                        var GETTER = 'get' + TYPE;
                        var SETTER = 'set' + TYPE;
                        var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
                        var TypedArrayConstructor = NativeTypedArrayConstructor;
                        var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
                        var exported = {};
                        var getter = function(that, index) {
                            var data = getInternalState(that);
                            return data.view[GETTER](index * BYTES + data.byteOffset, true);
                        };
                        var setter = function(that, index, value) {
                            var data = getInternalState(that);
                            if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
                            data.view[SETTER](index * BYTES + data.byteOffset, value, true);
                        };
                        var addElement = function(that, index) {
                            nativeDefineProperty(that, index, {
                                get: function() {
                                    return getter(this, index);
                                },
                                set: function(value) {
                                    return setter(this, index, value);
                                },
                                enumerable: true
                            });
                        };
                        if (!NATIVE_ARRAY_BUFFER_VIEWS) {
                            TypedArrayConstructor = wrapper(function(that, data, offset, $length) {
                                anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
                                var index = 0;
                                var byteOffset = 0;
                                var buffer, byteLength, length;
                                if (!isObject(data)) {
                                    length = toIndex(data);
                                    byteLength = length * BYTES;
                                    buffer = new ArrayBuffer(byteLength);
                                } else if (isArrayBuffer(data)) {
                                    buffer = data;
                                    byteOffset = toOffset(offset, BYTES);
                                    var $len = data.byteLength;
                                    if ($length === undefined) {
                                        if ($len % BYTES) throw RangeError(WRONG_LENGTH);
                                        byteLength = $len - byteOffset;
                                        if (byteLength < 0) throw RangeError(WRONG_LENGTH);
                                    } else {
                                        byteLength = toLength($length) * BYTES;
                                        if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
                                    }
                                    length = byteLength / BYTES;
                                } else if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
                                else return typedArrayFrom.call(TypedArrayConstructor, data);
                                setInternalState(that, {
                                    buffer: buffer,
                                    byteOffset: byteOffset,
                                    byteLength: byteLength,
                                    length: length,
                                    view: new DataView(buffer)
                                });
                                while(index < length)addElement(that, index++);
                            });
                            if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
                            TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
                        } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
                            TypedArrayConstructor = wrapper(function(dummy, data, typedArrayOffset, $length) {
                                anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
                                return inheritIfRequired(function() {
                                    if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
                                    if (isArrayBuffer(data)) return $length !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
                                    if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
                                    return typedArrayFrom.call(TypedArrayConstructor, data);
                                }(), dummy, TypedArrayConstructor);
                            });
                            if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
                            forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function(key) {
                                if (!(key in TypedArrayConstructor)) createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
                            });
                            TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
                        }
                        if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
                        if (TYPED_ARRAY_TAG) createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
                        exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
                        $({
                            global: true,
                            forced: TypedArrayConstructor != NativeTypedArrayConstructor,
                            sham: !NATIVE_ARRAY_BUFFER_VIEWS
                        }, exported);
                        if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
                        if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
                        setSpecies(CONSTRUCTOR_NAME);
                    };
                } else module.exports = function() {};
            /***/ },
            /***/ 3832: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                /* eslint-disable no-new -- required for testing */ var global = __webpack_require__(7854);
                var fails = __webpack_require__(7293);
                var checkCorrectnessOfIteration = __webpack_require__(7072);
                var NATIVE_ARRAY_BUFFER_VIEWS = __webpack_require__(260).NATIVE_ARRAY_BUFFER_VIEWS;
                var ArrayBuffer = global.ArrayBuffer;
                var Int8Array = global.Int8Array;
                module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function() {
                    Int8Array(1);
                }) || !fails(function() {
                    new Int8Array(-1);
                }) || !checkCorrectnessOfIteration(function(iterable) {
                    new Int8Array();
                    new Int8Array(null);
                    new Int8Array(1.5);
                    new Int8Array(iterable);
                }, true) || fails(function() {
                    // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
                    return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
                });
            /***/ },
            /***/ 3074: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var aTypedArrayConstructor = __webpack_require__(260).aTypedArrayConstructor;
                var speciesConstructor = __webpack_require__(6707);
                module.exports = function(instance, list) {
                    var C = speciesConstructor(instance, instance.constructor);
                    var index = 0;
                    var length = list.length;
                    var result = new (aTypedArrayConstructor(C))(length);
                    while(length > index)result[index] = list[index++];
                    return result;
                };
            /***/ },
            /***/ 7321: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var toObject = __webpack_require__(7908);
                var toLength = __webpack_require__(7466);
                var getIteratorMethod = __webpack_require__(1246);
                var isArrayIteratorMethod = __webpack_require__(7659);
                var bind = __webpack_require__(9974);
                var aTypedArrayConstructor = __webpack_require__(260).aTypedArrayConstructor;
                module.exports = function from(source /* , mapfn, thisArg */ ) {
                    var O = toObject(source);
                    var argumentsLength = arguments.length;
                    var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
                    var mapping = mapfn !== undefined;
                    var iteratorMethod = getIteratorMethod(O);
                    var i, length, result, step, iterator, next;
                    if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
                        iterator = iteratorMethod.call(O);
                        next = iterator.next;
                        O = [];
                        while(!(step = next.call(iterator)).done)O.push(step.value);
                    }
                    if (mapping && argumentsLength > 2) mapfn = bind(mapfn, arguments[2], 2);
                    length = toLength(O.length);
                    result = new (aTypedArrayConstructor(this))(length);
                    for(i = 0; length > i; i++)result[i] = mapping ? mapfn(O[i], i) : O[i];
                    return result;
                };
            /***/ },
            /***/ 9711: /***/ function(module) {
                var id = 0;
                var postfix = Math.random();
                module.exports = function(key) {
                    return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
                };
            /***/ },
            /***/ 3307: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var NATIVE_SYMBOL = __webpack_require__(133);
                module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == 'symbol';
            /***/ },
            /***/ 5112: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                var global = __webpack_require__(7854);
                var shared = __webpack_require__(2309);
                var has = __webpack_require__(6656);
                var uid = __webpack_require__(9711);
                var NATIVE_SYMBOL = __webpack_require__(133);
                var USE_SYMBOL_AS_UID = __webpack_require__(3307);
                var WellKnownSymbolsStore = shared('wks');
                var Symbol = global.Symbol;
                var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;
                module.exports = function(name) {
                    if (!has(WellKnownSymbolsStore, name)) {
                        if (NATIVE_SYMBOL && has(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name];
                        else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
                    }
                    return WellKnownSymbolsStore[name];
                };
            /***/ },
            /***/ 1361: /***/ function(module) {
                // a string of all valid unicode whitespaces
                module.exports = "	\n\v\f\r \xa0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
            /***/ },
            /***/ 8264: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var $ = __webpack_require__(2109);
                var global = __webpack_require__(7854);
                var arrayBufferModule = __webpack_require__(3331);
                var setSpecies = __webpack_require__(6340);
                var ARRAY_BUFFER = 'ArrayBuffer';
                var ArrayBuffer = arrayBufferModule[ARRAY_BUFFER];
                var NativeArrayBuffer = global[ARRAY_BUFFER];
                // `ArrayBuffer` constructor
                // https://tc39.es/ecma262/#sec-arraybuffer-constructor
                $({
                    global: true,
                    forced: NativeArrayBuffer !== ArrayBuffer
                }, {
                    ArrayBuffer: ArrayBuffer
                });
                setSpecies(ARRAY_BUFFER);
            /***/ },
            /***/ 2222: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var $ = __webpack_require__(2109);
                var fails = __webpack_require__(7293);
                var isArray = __webpack_require__(3157);
                var isObject = __webpack_require__(111);
                var toObject = __webpack_require__(7908);
                var toLength = __webpack_require__(7466);
                var createProperty = __webpack_require__(6135);
                var arraySpeciesCreate = __webpack_require__(5417);
                var arrayMethodHasSpeciesSupport = __webpack_require__(1194);
                var wellKnownSymbol = __webpack_require__(5112);
                var V8_VERSION = __webpack_require__(7392);
                var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
                var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
                var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';
                // We can't use this feature detection in V8 since it causes
                // deoptimization and serious performance degradation
                // https://github.com/zloirock/core-js/issues/679
                var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
                    var array = [];
                    array[IS_CONCAT_SPREADABLE] = false;
                    return array.concat()[0] !== array;
                });
                var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');
                var isConcatSpreadable = function(O) {
                    if (!isObject(O)) return false;
                    var spreadable = O[IS_CONCAT_SPREADABLE];
                    return spreadable !== undefined ? !!spreadable : isArray(O);
                };
                var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
                // `Array.prototype.concat` method
                // https://tc39.es/ecma262/#sec-array.prototype.concat
                // with adding support of @@isConcatSpreadable and @@species
                $({
                    target: 'Array',
                    proto: true,
                    forced: FORCED
                }, {
                    // eslint-disable-next-line no-unused-vars -- required for `.length`
                    concat: function concat(arg) {
                        var O = toObject(this);
                        var A = arraySpeciesCreate(O, 0);
                        var n = 0;
                        var i, k, length, len, E;
                        for(i = -1, length = arguments.length; i < length; i++){
                            E = i === -1 ? O : arguments[i];
                            if (isConcatSpreadable(E)) {
                                len = toLength(E.length);
                                if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                                for(k = 0; k < len; k++, n++)if (k in E) createProperty(A, n, E[k]);
                            } else {
                                if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                                createProperty(A, n++, E);
                            }
                        }
                        A.length = n;
                        return A;
                    }
                });
            /***/ },
            /***/ 7327: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var $ = __webpack_require__(2109);
                var $filter = __webpack_require__(2092).filter;
                var arrayMethodHasSpeciesSupport = __webpack_require__(1194);
                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');
                // `Array.prototype.filter` method
                // https://tc39.es/ecma262/#sec-array.prototype.filter
                // with adding support of @@species
                $({
                    target: 'Array',
                    proto: true,
                    forced: !HAS_SPECIES_SUPPORT
                }, {
                    filter: function filter(callbackfn /* , thisArg */ ) {
                        return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
                    }
                });
            /***/ },
            /***/ 2772: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var $ = __webpack_require__(2109);
                var $indexOf = __webpack_require__(1318).indexOf;
                var arrayMethodIsStrict = __webpack_require__(9341);
                var nativeIndexOf = [].indexOf;
                var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [
                    1
                ].indexOf(1, -0) < 0;
                var STRICT_METHOD = arrayMethodIsStrict('indexOf');
                // `Array.prototype.indexOf` method
                // https://tc39.es/ecma262/#sec-array.prototype.indexof
                $({
                    target: 'Array',
                    proto: true,
                    forced: NEGATIVE_ZERO || !STRICT_METHOD
                }, {
                    indexOf: function indexOf(searchElement /* , fromIndex = 0 */ ) {
                        return NEGATIVE_ZERO ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
                    }
                });
            /***/ },
            /***/ 6992: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var toIndexedObject = __webpack_require__(5656);
                var addToUnscopables = __webpack_require__(1223);
                var Iterators = __webpack_require__(7497);
                var InternalStateModule = __webpack_require__(9909);
                var defineIterator = __webpack_require__(654);
                var ARRAY_ITERATOR = 'Array Iterator';
                var setInternalState = InternalStateModule.set;
                var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
                // `Array.prototype.entries` method
                // https://tc39.es/ecma262/#sec-array.prototype.entries
                // `Array.prototype.keys` method
                // https://tc39.es/ecma262/#sec-array.prototype.keys
                // `Array.prototype.values` method
                // https://tc39.es/ecma262/#sec-array.prototype.values
                // `Array.prototype[@@iterator]` method
                // https://tc39.es/ecma262/#sec-array.prototype-@@iterator
                // `CreateArrayIterator` internal method
                // https://tc39.es/ecma262/#sec-createarrayiterator
                module.exports = defineIterator(Array, 'Array', function(iterated, kind) {
                    setInternalState(this, {
                        type: ARRAY_ITERATOR,
                        target: toIndexedObject(iterated),
                        index: 0,
                        kind: kind // kind
                    });
                // `%ArrayIteratorPrototype%.next` method
                // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
                }, function() {
                    var state = getInternalState(this);
                    var target = state.target;
                    var kind = state.kind;
                    var index = state.index++;
                    if (!target || index >= target.length) {
                        state.target = undefined;
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    if (kind == 'keys') return {
                        value: index,
                        done: false
                    };
                    if (kind == 'values') return {
                        value: target[index],
                        done: false
                    };
                    return {
                        value: [
                            index,
                            target[index]
                        ],
                        done: false
                    };
                }, 'values');
                // argumentsList[@@iterator] is %ArrayProto_values%
                // https://tc39.es/ecma262/#sec-createunmappedargumentsobject
                // https://tc39.es/ecma262/#sec-createmappedargumentsobject
                Iterators.Arguments = Iterators.Array;
                // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
                addToUnscopables('keys');
                addToUnscopables('values');
                addToUnscopables('entries');
            /***/ },
            /***/ 1249: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var $ = __webpack_require__(2109);
                var $map = __webpack_require__(2092).map;
                var arrayMethodHasSpeciesSupport = __webpack_require__(1194);
                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');
                // `Array.prototype.map` method
                // https://tc39.es/ecma262/#sec-array.prototype.map
                // with adding support of @@species
                $({
                    target: 'Array',
                    proto: true,
                    forced: !HAS_SPECIES_SUPPORT
                }, {
                    map: function map(callbackfn /* , thisArg */ ) {
                        return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
                    }
                });
            /***/ },
            /***/ 7042: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var $ = __webpack_require__(2109);
                var isObject = __webpack_require__(111);
                var isArray = __webpack_require__(3157);
                var toAbsoluteIndex = __webpack_require__(1400);
                var toLength = __webpack_require__(7466);
                var toIndexedObject = __webpack_require__(5656);
                var createProperty = __webpack_require__(6135);
                var wellKnownSymbol = __webpack_require__(5112);
                var arrayMethodHasSpeciesSupport = __webpack_require__(1194);
                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');
                var SPECIES = wellKnownSymbol('species');
                var nativeSlice = [].slice;
                var max = Math.max;
                // `Array.prototype.slice` method
                // https://tc39.es/ecma262/#sec-array.prototype.slice
                // fallback for not array-like ES3 strings and DOM objects
                $({
                    target: 'Array',
                    proto: true,
                    forced: !HAS_SPECIES_SUPPORT
                }, {
                    slice: function slice(start, end) {
                        var O = toIndexedObject(this);
                        var length = toLength(O.length);
                        var k = toAbsoluteIndex(start, length);
                        var fin = toAbsoluteIndex(end === undefined ? length : end, length);
                        // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
                        var Constructor, result, n;
                        if (isArray(O)) {
                            Constructor = O.constructor;
                            // cross-realm fallback
                            if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) Constructor = undefined;
                            else if (isObject(Constructor)) {
                                Constructor = Constructor[SPECIES];
                                if (Constructor === null) Constructor = undefined;
                            }
                            if (Constructor === Array || Constructor === undefined) return nativeSlice.call(O, k, fin);
                        }
                        result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
                        for(n = 0; k < fin; k++, n++)if (k in O) createProperty(result, n, O[k]);
                        result.length = n;
                        return result;
                    }
                });
            /***/ },
            /***/ 561: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var $ = __webpack_require__(2109);
                var toAbsoluteIndex = __webpack_require__(1400);
                var toInteger = __webpack_require__(9958);
                var toLength = __webpack_require__(7466);
                var toObject = __webpack_require__(7908);
                var arraySpeciesCreate = __webpack_require__(5417);
                var createProperty = __webpack_require__(6135);
                var arrayMethodHasSpeciesSupport = __webpack_require__(1194);
                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
                var max = Math.max;
                var min = Math.min;
                var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
                var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';
                // `Array.prototype.splice` method
                // https://tc39.es/ecma262/#sec-array.prototype.splice
                // with adding support of @@species
                $({
                    target: 'Array',
                    proto: true,
                    forced: !HAS_SPECIES_SUPPORT
                }, {
                    splice: function splice(start, deleteCount /* , ...items */ ) {
                        var O = toObject(this);
                        var len = toLength(O.length);
                        var actualStart = toAbsoluteIndex(start, len);
                        var argumentsLength = arguments.length;
                        var insertCount, actualDeleteCount, A, k, from, to;
                        if (argumentsLength === 0) insertCount = actualDeleteCount = 0;
                        else if (argumentsLength === 1) {
                            insertCount = 0;
                            actualDeleteCount = len - actualStart;
                        } else {
                            insertCount = argumentsLength - 2;
                            actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
                        }
                        if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
                        A = arraySpeciesCreate(O, actualDeleteCount);
                        for(k = 0; k < actualDeleteCount; k++){
                            from = actualStart + k;
                            if (from in O) createProperty(A, k, O[from]);
                        }
                        A.length = actualDeleteCount;
                        if (insertCount < actualDeleteCount) {
                            for(k = actualStart; k < len - actualDeleteCount; k++){
                                from = k + actualDeleteCount;
                                to = k + insertCount;
                                if (from in O) O[to] = O[from];
                                else delete O[to];
                            }
                            for(k = len; k > len - actualDeleteCount + insertCount; k--)delete O[k - 1];
                        } else if (insertCount > actualDeleteCount) for(k = len - actualDeleteCount; k > actualStart; k--){
                            from = k + actualDeleteCount - 1;
                            to = k + insertCount - 1;
                            if (from in O) O[to] = O[from];
                            else delete O[to];
                        }
                        for(k = 0; k < insertCount; k++)O[k + actualStart] = arguments[k + 2];
                        O.length = len - actualDeleteCount + insertCount;
                        return A;
                    }
                });
            /***/ },
            /***/ 8309: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                var DESCRIPTORS = __webpack_require__(9781);
                var defineProperty = __webpack_require__(3070).f;
                var FunctionPrototype = Function.prototype;
                var FunctionPrototypeToString = FunctionPrototype.toString;
                var nameRE = /^\s*function ([^ (]*)/;
                var NAME = 'name';
                // Function instances `.name` property
                // https://tc39.es/ecma262/#sec-function-instances-name
                if (DESCRIPTORS && !(NAME in FunctionPrototype)) defineProperty(FunctionPrototype, NAME, {
                    configurable: true,
                    get: function() {
                        try {
                            return FunctionPrototypeToString.call(this).match(nameRE)[1];
                        } catch (error) {
                            return '';
                        }
                    }
                });
            /***/ },
            /***/ 489: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                var $ = __webpack_require__(2109);
                var fails = __webpack_require__(7293);
                var toObject = __webpack_require__(7908);
                var nativeGetPrototypeOf = __webpack_require__(9518);
                var CORRECT_PROTOTYPE_GETTER = __webpack_require__(8544);
                var FAILS_ON_PRIMITIVES = fails(function() {
                    nativeGetPrototypeOf(1);
                });
                // `Object.getPrototypeOf` method
                // https://tc39.es/ecma262/#sec-object.getprototypeof
                $({
                    target: 'Object',
                    stat: true,
                    forced: FAILS_ON_PRIMITIVES,
                    sham: !CORRECT_PROTOTYPE_GETTER
                }, {
                    getPrototypeOf: function getPrototypeOf(it) {
                        return nativeGetPrototypeOf(toObject(it));
                    }
                });
            /***/ },
            /***/ 1539: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                var TO_STRING_TAG_SUPPORT = __webpack_require__(1694);
                var redefine = __webpack_require__(1320);
                var toString = __webpack_require__(288);
                // `Object.prototype.toString` method
                // https://tc39.es/ecma262/#sec-object.prototype.tostring
                if (!TO_STRING_TAG_SUPPORT) redefine(Object.prototype, 'toString', toString, {
                    unsafe: true
                });
            /***/ },
            /***/ 4916: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var $ = __webpack_require__(2109);
                var exec = __webpack_require__(2261);
                // `RegExp.prototype.exec` method
                // https://tc39.es/ecma262/#sec-regexp.prototype.exec
                $({
                    target: 'RegExp',
                    proto: true,
                    forced: /./.exec !== exec
                }, {
                    exec: exec
                });
            /***/ },
            /***/ 9714: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var redefine = __webpack_require__(1320);
                var anObject = __webpack_require__(9670);
                var fails = __webpack_require__(7293);
                var flags = __webpack_require__(7066);
                var TO_STRING = 'toString';
                var RegExpPrototype = RegExp.prototype;
                var nativeToString = RegExpPrototype[TO_STRING];
                var NOT_GENERIC = fails(function() {
                    return nativeToString.call({
                        source: 'a',
                        flags: 'b'
                    }) != '/a/b';
                });
                // FF44- RegExp#toString has a wrong name
                var INCORRECT_NAME = nativeToString.name != TO_STRING;
                // `RegExp.prototype.toString` method
                // https://tc39.es/ecma262/#sec-regexp.prototype.tostring
                if (NOT_GENERIC || INCORRECT_NAME) redefine(RegExp.prototype, TO_STRING, function toString() {
                    var R = anObject(this);
                    var p = String(R.source);
                    var rf = R.flags;
                    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);
                    return '/' + p + '/' + f;
                }, {
                    unsafe: true
                });
            /***/ },
            /***/ 8783: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var charAt = __webpack_require__(8710).charAt;
                var InternalStateModule = __webpack_require__(9909);
                var defineIterator = __webpack_require__(654);
                var STRING_ITERATOR = 'String Iterator';
                var setInternalState = InternalStateModule.set;
                var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
                // `String.prototype[@@iterator]` method
                // https://tc39.es/ecma262/#sec-string.prototype-@@iterator
                defineIterator(String, 'String', function(iterated) {
                    setInternalState(this, {
                        type: STRING_ITERATOR,
                        string: String(iterated),
                        index: 0
                    });
                // `%StringIteratorPrototype%.next` method
                // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
                }, function next() {
                    var state = getInternalState(this);
                    var string = state.string;
                    var index = state.index;
                    var point;
                    if (index >= string.length) return {
                        value: undefined,
                        done: true
                    };
                    point = charAt(string, index);
                    state.index += point.length;
                    return {
                        value: point,
                        done: false
                    };
                });
            /***/ },
            /***/ 4723: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var fixRegExpWellKnownSymbolLogic = __webpack_require__(7007);
                var anObject = __webpack_require__(9670);
                var toLength = __webpack_require__(7466);
                var requireObjectCoercible = __webpack_require__(4488);
                var advanceStringIndex = __webpack_require__(1530);
                var regExpExec = __webpack_require__(7651);
                // @@match logic
                fixRegExpWellKnownSymbolLogic('match', 1, function(MATCH, nativeMatch, maybeCallNative) {
                    return [
                        // `String.prototype.match` method
                        // https://tc39.es/ecma262/#sec-string.prototype.match
                        function match(regexp) {
                            var O = requireObjectCoercible(this);
                            var matcher = regexp == undefined ? undefined : regexp[MATCH];
                            return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
                        },
                        // `RegExp.prototype[@@match]` method
                        // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
                        function(regexp) {
                            var res = maybeCallNative(nativeMatch, regexp, this);
                            if (res.done) return res.value;
                            var rx = anObject(regexp);
                            var S = String(this);
                            if (!rx.global) return regExpExec(rx, S);
                            var fullUnicode = rx.unicode;
                            rx.lastIndex = 0;
                            var A = [];
                            var n = 0;
                            var result;
                            while((result = regExpExec(rx, S)) !== null){
                                var matchStr = String(result[0]);
                                A[n] = matchStr;
                                if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                                n++;
                            }
                            return n === 0 ? null : A;
                        }
                    ];
                });
            /***/ },
            /***/ 5306: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var fixRegExpWellKnownSymbolLogic = __webpack_require__(7007);
                var anObject = __webpack_require__(9670);
                var toLength = __webpack_require__(7466);
                var toInteger = __webpack_require__(9958);
                var requireObjectCoercible = __webpack_require__(4488);
                var advanceStringIndex = __webpack_require__(1530);
                var getSubstitution = __webpack_require__(647);
                var regExpExec = __webpack_require__(7651);
                var max = Math.max;
                var min = Math.min;
                var maybeToString = function(it) {
                    return it === undefined ? it : String(it);
                };
                // @@replace logic
                fixRegExpWellKnownSymbolLogic('replace', 2, function(REPLACE, nativeReplace, maybeCallNative, reason) {
                    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
                    var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
                    var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';
                    return [
                        // `String.prototype.replace` method
                        // https://tc39.es/ecma262/#sec-string.prototype.replace
                        function replace(searchValue, replaceValue) {
                            var O = requireObjectCoercible(this);
                            var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
                            return replacer !== undefined ? replacer.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);
                        },
                        // `RegExp.prototype[@@replace]` method
                        // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
                        function(regexp, replaceValue) {
                            if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0 || typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
                                var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
                                if (res.done) return res.value;
                            }
                            var rx = anObject(regexp);
                            var S = String(this);
                            var functionalReplace = typeof replaceValue === 'function';
                            if (!functionalReplace) replaceValue = String(replaceValue);
                            var global = rx.global;
                            if (global) {
                                var fullUnicode = rx.unicode;
                                rx.lastIndex = 0;
                            }
                            var results = [];
                            while(true){
                                var result = regExpExec(rx, S);
                                if (result === null) break;
                                results.push(result);
                                if (!global) break;
                                var matchStr = String(result[0]);
                                if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                            }
                            var accumulatedResult = '';
                            var nextSourcePosition = 0;
                            for(var i = 0; i < results.length; i++){
                                result = results[i];
                                var matched = String(result[0]);
                                var position = max(min(toInteger(result.index), S.length), 0);
                                var captures = [];
                                // NOTE: This is equivalent to
                                //   captures = result.slice(1).map(maybeToString)
                                // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
                                // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
                                // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
                                for(var j = 1; j < result.length; j++)captures.push(maybeToString(result[j]));
                                var namedCaptures = result.groups;
                                if (functionalReplace) {
                                    var replacerArgs = [
                                        matched
                                    ].concat(captures, position, S);
                                    if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
                                    var replacement = String(replaceValue.apply(undefined, replacerArgs));
                                } else replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
                                if (position >= nextSourcePosition) {
                                    accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
                                    nextSourcePosition = position + matched.length;
                                }
                            }
                            return accumulatedResult + S.slice(nextSourcePosition);
                        }
                    ];
                });
            /***/ },
            /***/ 3123: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var fixRegExpWellKnownSymbolLogic = __webpack_require__(7007);
                var isRegExp = __webpack_require__(7850);
                var anObject = __webpack_require__(9670);
                var requireObjectCoercible = __webpack_require__(4488);
                var speciesConstructor = __webpack_require__(6707);
                var advanceStringIndex = __webpack_require__(1530);
                var toLength = __webpack_require__(7466);
                var callRegExpExec = __webpack_require__(7651);
                var regexpExec = __webpack_require__(2261);
                var fails = __webpack_require__(7293);
                var arrayPush = [].push;
                var min = Math.min;
                var MAX_UINT32 = 0xFFFFFFFF;
                // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
                var SUPPORTS_Y = !fails(function() {
                    return !RegExp(MAX_UINT32, 'y');
                });
                // @@split logic
                fixRegExpWellKnownSymbolLogic('split', 2, function(SPLIT, nativeSplit, maybeCallNative) {
                    var internalSplit;
                    if ('abbc'.split(/(b)*/)[1] == 'c' || // eslint-disable-next-line regexp/no-empty-group -- required for testing
                    'test'.split(/(?:)/, -1).length != 4 || 'ab'.split(/(?:ab)*/).length != 2 || '.'.split(/(.?)(.?)/).length != 4 || // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing
                    '.'.split(/()()/).length > 1 || ''.split(/.?/).length) // based on es5-shim implementation, need to rework it
                    internalSplit = function(separator, limit) {
                        var string = String(requireObjectCoercible(this));
                        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
                        if (lim === 0) return [];
                        if (separator === undefined) return [
                            string
                        ];
                        // If `separator` is not a regex, use native split
                        if (!isRegExp(separator)) return nativeSplit.call(string, separator, lim);
                        var output = [];
                        var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
                        var lastLastIndex = 0;
                        // Make `global` and avoid `lastIndex` issues by working with a copy
                        var separatorCopy = new RegExp(separator.source, flags + 'g');
                        var match, lastIndex, lastLength;
                        while(match = regexpExec.call(separatorCopy, string)){
                            lastIndex = separatorCopy.lastIndex;
                            if (lastIndex > lastLastIndex) {
                                output.push(string.slice(lastLastIndex, match.index));
                                if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
                                lastLength = match[0].length;
                                lastLastIndex = lastIndex;
                                if (output.length >= lim) break;
                            }
                            if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
                        }
                        if (lastLastIndex === string.length) {
                            if (lastLength || !separatorCopy.test('')) output.push('');
                        } else output.push(string.slice(lastLastIndex));
                        return output.length > lim ? output.slice(0, lim) : output;
                    };
                    else if ('0'.split(undefined, 0).length) internalSplit = function(separator, limit) {
                        return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
                    };
                    else internalSplit = nativeSplit;
                    return [
                        // `String.prototype.split` method
                        // https://tc39.es/ecma262/#sec-string.prototype.split
                        function split(separator, limit) {
                            var O = requireObjectCoercible(this);
                            var splitter = separator == undefined ? undefined : separator[SPLIT];
                            return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
                        },
                        // `RegExp.prototype[@@split]` method
                        // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
                        //
                        // NOTE: This cannot be properly polyfilled in engines that don't support
                        // the 'y' flag.
                        function(regexp, limit) {
                            var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
                            if (res.done) return res.value;
                            var rx = anObject(regexp);
                            var S = String(this);
                            var C = speciesConstructor(rx, RegExp);
                            var unicodeMatching = rx.unicode;
                            var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g');
                            // ^(? + rx + ) is needed, in combination with some S slicing, to
                            // simulate the 'y' flag.
                            var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
                            var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
                            if (lim === 0) return [];
                            if (S.length === 0) return callRegExpExec(splitter, S) === null ? [
                                S
                            ] : [];
                            var p = 0;
                            var q = 0;
                            var A = [];
                            while(q < S.length){
                                splitter.lastIndex = SUPPORTS_Y ? q : 0;
                                var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
                                var e;
                                if (z === null || (e = min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) q = advanceStringIndex(S, q, unicodeMatching);
                                else {
                                    A.push(S.slice(p, q));
                                    if (A.length === lim) return A;
                                    for(var i = 1; i <= z.length - 1; i++){
                                        A.push(z[i]);
                                        if (A.length === lim) return A;
                                    }
                                    q = p = e;
                                }
                            }
                            A.push(S.slice(p));
                            return A;
                        }
                    ];
                }, !SUPPORTS_Y);
            /***/ },
            /***/ 3210: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var $ = __webpack_require__(2109);
                var $trim = __webpack_require__(3111).trim;
                var forcedStringTrimMethod = __webpack_require__(6091);
                // `String.prototype.trim` method
                // https://tc39.es/ecma262/#sec-string.prototype.trim
                $({
                    target: 'String',
                    proto: true,
                    forced: forcedStringTrimMethod('trim')
                }, {
                    trim: function trim() {
                        return $trim(this);
                    }
                });
            /***/ },
            /***/ 2990: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var $copyWithin = __webpack_require__(1048);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                // `%TypedArray%.prototype.copyWithin` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
                exportTypedArrayMethod('copyWithin', function copyWithin(target, start /* , end */ ) {
                    return $copyWithin.call(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
                });
            /***/ },
            /***/ 8927: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var $every = __webpack_require__(2092).every;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                // `%TypedArray%.prototype.every` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
                exportTypedArrayMethod('every', function every(callbackfn /* , thisArg */ ) {
                    return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
                });
            /***/ },
            /***/ 3105: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var $fill = __webpack_require__(1285);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                // `%TypedArray%.prototype.fill` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
                // eslint-disable-next-line no-unused-vars -- required for `.length`
                exportTypedArrayMethod('fill', function fill(value /* , start, end */ ) {
                    return $fill.apply(aTypedArray(this), arguments);
                });
            /***/ },
            /***/ 5035: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var $filter = __webpack_require__(2092).filter;
                var fromSpeciesAndList = __webpack_require__(3074);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                // `%TypedArray%.prototype.filter` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
                exportTypedArrayMethod('filter', function filter(callbackfn /* , thisArg */ ) {
                    var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
                    return fromSpeciesAndList(this, list);
                });
            /***/ },
            /***/ 7174: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var $findIndex = __webpack_require__(2092).findIndex;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                // `%TypedArray%.prototype.findIndex` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
                exportTypedArrayMethod('findIndex', function findIndex(predicate /* , thisArg */ ) {
                    return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
                });
            /***/ },
            /***/ 4345: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var $find = __webpack_require__(2092).find;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                // `%TypedArray%.prototype.find` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
                exportTypedArrayMethod('find', function find(predicate /* , thisArg */ ) {
                    return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
                });
            /***/ },
            /***/ 2846: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var $forEach = __webpack_require__(2092).forEach;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                // `%TypedArray%.prototype.forEach` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
                exportTypedArrayMethod('forEach', function forEach(callbackfn /* , thisArg */ ) {
                    $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
                });
            /***/ },
            /***/ 4731: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var $includes = __webpack_require__(1318).includes;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                // `%TypedArray%.prototype.includes` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
                exportTypedArrayMethod('includes', function includes(searchElement /* , fromIndex */ ) {
                    return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
                });
            /***/ },
            /***/ 7209: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var $indexOf = __webpack_require__(1318).indexOf;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                // `%TypedArray%.prototype.indexOf` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
                exportTypedArrayMethod('indexOf', function indexOf(searchElement /* , fromIndex */ ) {
                    return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
                });
            /***/ },
            /***/ 6319: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var global = __webpack_require__(7854);
                var ArrayBufferViewCore = __webpack_require__(260);
                var ArrayIterators = __webpack_require__(6992);
                var wellKnownSymbol = __webpack_require__(5112);
                var ITERATOR = wellKnownSymbol('iterator');
                var Uint8Array = global.Uint8Array;
                var arrayValues = ArrayIterators.values;
                var arrayKeys = ArrayIterators.keys;
                var arrayEntries = ArrayIterators.entries;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR];
                var CORRECT_ITER_NAME = !!nativeTypedArrayIterator && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);
                var typedArrayValues = function values() {
                    return arrayValues.call(aTypedArray(this));
                };
                // `%TypedArray%.prototype.entries` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
                exportTypedArrayMethod('entries', function entries() {
                    return arrayEntries.call(aTypedArray(this));
                });
                // `%TypedArray%.prototype.keys` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
                exportTypedArrayMethod('keys', function keys() {
                    return arrayKeys.call(aTypedArray(this));
                });
                // `%TypedArray%.prototype.values` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
                exportTypedArrayMethod('values', typedArrayValues, !CORRECT_ITER_NAME);
                // `%TypedArray%.prototype[@@iterator]` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
                exportTypedArrayMethod(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);
            /***/ },
            /***/ 8867: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var $join = [].join;
                // `%TypedArray%.prototype.join` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
                // eslint-disable-next-line no-unused-vars -- required for `.length`
                exportTypedArrayMethod('join', function join(separator) {
                    return $join.apply(aTypedArray(this), arguments);
                });
            /***/ },
            /***/ 7789: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var $lastIndexOf = __webpack_require__(6583);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                // `%TypedArray%.prototype.lastIndexOf` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
                // eslint-disable-next-line no-unused-vars -- required for `.length`
                exportTypedArrayMethod('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */ ) {
                    return $lastIndexOf.apply(aTypedArray(this), arguments);
                });
            /***/ },
            /***/ 3739: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var $map = __webpack_require__(2092).map;
                var speciesConstructor = __webpack_require__(6707);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                // `%TypedArray%.prototype.map` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
                exportTypedArrayMethod('map', function map(mapfn /* , thisArg */ ) {
                    return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function(O, length) {
                        return new (aTypedArrayConstructor(speciesConstructor(O, O.constructor)))(length);
                    });
                });
            /***/ },
            /***/ 4483: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var $reduceRight = __webpack_require__(3671).right;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                // `%TypedArray%.prototype.reduceRicht` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
                exportTypedArrayMethod('reduceRight', function reduceRight(callbackfn /* , initialValue */ ) {
                    return $reduceRight(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
                });
            /***/ },
            /***/ 9368: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var $reduce = __webpack_require__(3671).left;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                // `%TypedArray%.prototype.reduce` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
                exportTypedArrayMethod('reduce', function reduce(callbackfn /* , initialValue */ ) {
                    return $reduce(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
                });
            /***/ },
            /***/ 2056: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var floor = Math.floor;
                // `%TypedArray%.prototype.reverse` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
                exportTypedArrayMethod('reverse', function reverse() {
                    var that = this;
                    var length = aTypedArray(that).length;
                    var middle = floor(length / 2);
                    var index = 0;
                    var value;
                    while(index < middle){
                        value = that[index];
                        that[index++] = that[--length];
                        that[length] = value;
                    }
                    return that;
                });
            /***/ },
            /***/ 3462: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var toLength = __webpack_require__(7466);
                var toOffset = __webpack_require__(4590);
                var toObject = __webpack_require__(7908);
                var fails = __webpack_require__(7293);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var FORCED = fails(function() {
                    /* global Int8Array -- safe */ new Int8Array(1).set({});
                });
                // `%TypedArray%.prototype.set` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
                exportTypedArrayMethod('set', function set(arrayLike /* , offset */ ) {
                    aTypedArray(this);
                    var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
                    var length = this.length;
                    var src = toObject(arrayLike);
                    var len = toLength(src.length);
                    var index = 0;
                    if (len + offset > length) throw RangeError('Wrong length');
                    while(index < len)this[offset + index] = src[index++];
                }, FORCED);
            /***/ },
            /***/ 678: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var speciesConstructor = __webpack_require__(6707);
                var fails = __webpack_require__(7293);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var $slice = [].slice;
                var FORCED = fails(function() {
                    /* global Int8Array -- safe */ new Int8Array(1).slice();
                });
                // `%TypedArray%.prototype.slice` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
                exportTypedArrayMethod('slice', function slice(start, end) {
                    var list = $slice.call(aTypedArray(this), start, end);
                    var C = speciesConstructor(this, this.constructor);
                    var index = 0;
                    var length = list.length;
                    var result = new (aTypedArrayConstructor(C))(length);
                    while(length > index)result[index] = list[index++];
                    return result;
                }, FORCED);
            /***/ },
            /***/ 7462: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var $some = __webpack_require__(2092).some;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                // `%TypedArray%.prototype.some` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
                exportTypedArrayMethod('some', function some(callbackfn /* , thisArg */ ) {
                    return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
                });
            /***/ },
            /***/ 3824: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var $sort = [].sort;
                // `%TypedArray%.prototype.sort` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
                exportTypedArrayMethod('sort', function sort(comparefn) {
                    return $sort.call(aTypedArray(this), comparefn);
                });
            /***/ },
            /***/ 5021: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__(260);
                var toLength = __webpack_require__(7466);
                var toAbsoluteIndex = __webpack_require__(1400);
                var speciesConstructor = __webpack_require__(6707);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                // `%TypedArray%.prototype.subarray` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
                exportTypedArrayMethod('subarray', function subarray(begin, end) {
                    var O = aTypedArray(this);
                    var length = O.length;
                    var beginIndex = toAbsoluteIndex(begin, length);
                    return new (speciesConstructor(O, O.constructor))(O.buffer, O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex));
                });
            /***/ },
            /***/ 2974: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var global = __webpack_require__(7854);
                var ArrayBufferViewCore = __webpack_require__(260);
                var fails = __webpack_require__(7293);
                var Int8Array = global.Int8Array;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var $toLocaleString = [].toLocaleString;
                var $slice = [].slice;
                // iOS Safari 6.x fails here
                var TO_LOCALE_STRING_BUG = !!Int8Array && fails(function() {
                    $toLocaleString.call(new Int8Array(1));
                });
                var FORCED = fails(function() {
                    return [
                        1,
                        2
                    ].toLocaleString() != new Int8Array([
                        1,
                        2
                    ]).toLocaleString();
                }) || !fails(function() {
                    Int8Array.prototype.toLocaleString.call([
                        1,
                        2
                    ]);
                });
                // `%TypedArray%.prototype.toLocaleString` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
                exportTypedArrayMethod('toLocaleString', function toLocaleString() {
                    return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice.call(aTypedArray(this)) : aTypedArray(this), arguments);
                }, FORCED);
            /***/ },
            /***/ 5016: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                var exportTypedArrayMethod = __webpack_require__(260).exportTypedArrayMethod;
                var fails = __webpack_require__(7293);
                var global = __webpack_require__(7854);
                var Uint8Array = global.Uint8Array;
                var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype || {};
                var arrayToString = [].toString;
                var arrayJoin = [].join;
                if (fails(function() {
                    arrayToString.call({});
                })) arrayToString = function toString() {
                    return arrayJoin.call(this);
                };
                var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;
                // `%TypedArray%.prototype.toString` method
                // https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring
                exportTypedArrayMethod('toString', arrayToString, IS_NOT_ARRAY_METHOD);
            /***/ },
            /***/ 2472: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                var createTypedArrayConstructor = __webpack_require__(9843);
                // `Uint8Array` constructor
                // https://tc39.es/ecma262/#sec-typedarray-objects
                createTypedArrayConstructor('Uint8', function(init) {
                    return function Uint8Array(data, byteOffset, length) {
                        return init(this, data, byteOffset, length);
                    };
                });
            /***/ },
            /***/ 4747: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                var global = __webpack_require__(7854);
                var DOMIterables = __webpack_require__(8324);
                var forEach = __webpack_require__(8533);
                var createNonEnumerableProperty = __webpack_require__(8880);
                for(var COLLECTION_NAME in DOMIterables){
                    var Collection = global[COLLECTION_NAME];
                    var CollectionPrototype = Collection && Collection.prototype;
                    // some Chrome versions have non-configurable methods on DOMTokenList
                    if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
                        createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
                    } catch (error) {
                        CollectionPrototype.forEach = forEach;
                    }
                }
            /***/ },
            /***/ 3948: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                var global = __webpack_require__(7854);
                var DOMIterables = __webpack_require__(8324);
                var ArrayIteratorMethods = __webpack_require__(6992);
                var createNonEnumerableProperty = __webpack_require__(8880);
                var wellKnownSymbol = __webpack_require__(5112);
                var ITERATOR = wellKnownSymbol('iterator');
                var TO_STRING_TAG = wellKnownSymbol('toStringTag');
                var ArrayValues = ArrayIteratorMethods.values;
                for(var COLLECTION_NAME in DOMIterables){
                    var Collection = global[COLLECTION_NAME];
                    var CollectionPrototype = Collection && Collection.prototype;
                    if (CollectionPrototype) {
                        // some Chrome versions have non-configurable methods on DOMTokenList
                        if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
                            createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
                        } catch (error) {
                            CollectionPrototype[ITERATOR] = ArrayValues;
                        }
                        if (!CollectionPrototype[TO_STRING_TAG]) createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
                        if (DOMIterables[COLLECTION_NAME]) for(var METHOD_NAME in ArrayIteratorMethods){
                            // some Chrome versions have non-configurable methods on DOMTokenList
                            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
                                createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
                            } catch (error) {
                                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
                            }
                        }
                    }
                }
            /***/ },
            /***/ 1637: /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                // TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
                __webpack_require__(6992);
                var $ = __webpack_require__(2109);
                var getBuiltIn = __webpack_require__(5005);
                var USE_NATIVE_URL = __webpack_require__(590);
                var redefine = __webpack_require__(1320);
                var redefineAll = __webpack_require__(2248);
                var setToStringTag = __webpack_require__(8003);
                var createIteratorConstructor = __webpack_require__(4994);
                var InternalStateModule = __webpack_require__(9909);
                var anInstance = __webpack_require__(5787);
                var hasOwn = __webpack_require__(6656);
                var bind = __webpack_require__(9974);
                var classof = __webpack_require__(648);
                var anObject = __webpack_require__(9670);
                var isObject = __webpack_require__(111);
                var create = __webpack_require__(30);
                var createPropertyDescriptor = __webpack_require__(9114);
                var getIterator = __webpack_require__(8554);
                var getIteratorMethod = __webpack_require__(1246);
                var wellKnownSymbol = __webpack_require__(5112);
                var $fetch = getBuiltIn('fetch');
                var Headers = getBuiltIn('Headers');
                var ITERATOR = wellKnownSymbol('iterator');
                var URL_SEARCH_PARAMS = 'URLSearchParams';
                var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
                var setInternalState = InternalStateModule.set;
                var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
                var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
                var plus = /\+/g;
                var sequences = Array(4);
                var percentSequence = function(bytes) {
                    return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
                };
                var percentDecode = function(sequence) {
                    try {
                        return decodeURIComponent(sequence);
                    } catch (error) {
                        return sequence;
                    }
                };
                var deserialize = function(it) {
                    var result = it.replace(plus, ' ');
                    var bytes = 4;
                    try {
                        return decodeURIComponent(result);
                    } catch (error) {
                        while(bytes)result = result.replace(percentSequence(bytes--), percentDecode);
                        return result;
                    }
                };
                var find = /[!'()~]|%20/g;
                var replace = {
                    '!': '%21',
                    "'": '%27',
                    '(': '%28',
                    ')': '%29',
                    '~': '%7E',
                    '%20': '+'
                };
                var replacer = function(match) {
                    return replace[match];
                };
                var serialize = function(it) {
                    return encodeURIComponent(it).replace(find, replacer);
                };
                var parseSearchParams = function(result, query) {
                    if (query) {
                        var attributes = query.split('&');
                        var index = 0;
                        var attribute, entry;
                        while(index < attributes.length){
                            attribute = attributes[index++];
                            if (attribute.length) {
                                entry = attribute.split('=');
                                result.push({
                                    key: deserialize(entry.shift()),
                                    value: deserialize(entry.join('='))
                                });
                            }
                        }
                    }
                };
                var updateSearchParams = function(query) {
                    this.entries.length = 0;
                    parseSearchParams(this.entries, query);
                };
                var validateArgumentsLength = function(passed, required) {
                    if (passed < required) throw TypeError('Not enough arguments');
                };
                var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
                    setInternalState(this, {
                        type: URL_SEARCH_PARAMS_ITERATOR,
                        iterator: getIterator(getInternalParamsState(params).entries),
                        kind: kind
                    });
                }, 'Iterator', function next() {
                    var state = getInternalIteratorState(this);
                    var kind = state.kind;
                    var step = state.iterator.next();
                    var entry = step.value;
                    if (!step.done) step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [
                        entry.key,
                        entry.value
                    ];
                    return step;
                });
                // `URLSearchParams` constructor
                // https://url.spec.whatwg.org/#interface-urlsearchparams
                var URLSearchParamsConstructor = function URLSearchParams() {
                    anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
                    var init = arguments.length > 0 ? arguments[0] : undefined;
                    var that = this;
                    var entries = [];
                    var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;
                    setInternalState(that, {
                        type: URL_SEARCH_PARAMS,
                        entries: entries,
                        updateURL: function() {},
                        updateSearchParams: updateSearchParams
                    });
                    if (init !== undefined) {
                        if (isObject(init)) {
                            iteratorMethod = getIteratorMethod(init);
                            if (typeof iteratorMethod === 'function') {
                                iterator = iteratorMethod.call(init);
                                next = iterator.next;
                                while(!(step = next.call(iterator)).done){
                                    entryIterator = getIterator(anObject(step.value));
                                    entryNext = entryIterator.next;
                                    if ((first = entryNext.call(entryIterator)).done || (second = entryNext.call(entryIterator)).done || !entryNext.call(entryIterator).done) throw TypeError('Expected sequence with length 2');
                                    entries.push({
                                        key: first.value + '',
                                        value: second.value + ''
                                    });
                                }
                            } else for(key in init)if (hasOwn(init, key)) entries.push({
                                key: key,
                                value: init[key] + ''
                            });
                        } else parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');
                    }
                };
                var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
                redefineAll(URLSearchParamsPrototype, {
                    // `URLSearchParams.prototype.append` method
                    // https://url.spec.whatwg.org/#dom-urlsearchparams-append
                    append: function append(name, value) {
                        validateArgumentsLength(arguments.length, 2);
                        var state = getInternalParamsState(this);
                        state.entries.push({
                            key: name + '',
                            value: value + ''
                        });
                        state.updateURL();
                    },
                    // `URLSearchParams.prototype.delete` method
                    // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
                    'delete': function(name) {
                        validateArgumentsLength(arguments.length, 1);
                        var state = getInternalParamsState(this);
                        var entries = state.entries;
                        var key = name + '';
                        var index = 0;
                        while(index < entries.length)if (entries[index].key === key) entries.splice(index, 1);
                        else index++;
                        state.updateURL();
                    },
                    // `URLSearchParams.prototype.get` method
                    // https://url.spec.whatwg.org/#dom-urlsearchparams-get
                    get: function get(name) {
                        validateArgumentsLength(arguments.length, 1);
                        var entries = getInternalParamsState(this).entries;
                        var key = name + '';
                        var index = 0;
                        for(; index < entries.length; index++){
                            if (entries[index].key === key) return entries[index].value;
                        }
                        return null;
                    },
                    // `URLSearchParams.prototype.getAll` method
                    // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
                    getAll: function getAll(name) {
                        validateArgumentsLength(arguments.length, 1);
                        var entries = getInternalParamsState(this).entries;
                        var key = name + '';
                        var result = [];
                        var index = 0;
                        for(; index < entries.length; index++)if (entries[index].key === key) result.push(entries[index].value);
                        return result;
                    },
                    // `URLSearchParams.prototype.has` method
                    // https://url.spec.whatwg.org/#dom-urlsearchparams-has
                    has: function has(name) {
                        validateArgumentsLength(arguments.length, 1);
                        var entries = getInternalParamsState(this).entries;
                        var key = name + '';
                        var index = 0;
                        while(index < entries.length){
                            if (entries[index++].key === key) return true;
                        }
                        return false;
                    },
                    // `URLSearchParams.prototype.set` method
                    // https://url.spec.whatwg.org/#dom-urlsearchparams-set
                    set: function set(name, value) {
                        validateArgumentsLength(arguments.length, 1);
                        var state = getInternalParamsState(this);
                        var entries = state.entries;
                        var found = false;
                        var key = name + '';
                        var val = value + '';
                        var index = 0;
                        var entry;
                        for(; index < entries.length; index++){
                            entry = entries[index];
                            if (entry.key === key) {
                                if (found) entries.splice(index--, 1);
                                else {
                                    found = true;
                                    entry.value = val;
                                }
                            }
                        }
                        if (!found) entries.push({
                            key: key,
                            value: val
                        });
                        state.updateURL();
                    },
                    // `URLSearchParams.prototype.sort` method
                    // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
                    sort: function sort() {
                        var state = getInternalParamsState(this);
                        var entries = state.entries;
                        // Array#sort is not stable in some engines
                        var slice = entries.slice();
                        var entry, entriesIndex, sliceIndex;
                        entries.length = 0;
                        for(sliceIndex = 0; sliceIndex < slice.length; sliceIndex++){
                            entry = slice[sliceIndex];
                            for(entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++)if (entries[entriesIndex].key > entry.key) {
                                entries.splice(entriesIndex, 0, entry);
                                break;
                            }
                            if (entriesIndex === sliceIndex) entries.push(entry);
                        }
                        state.updateURL();
                    },
                    // `URLSearchParams.prototype.forEach` method
                    forEach: function forEach(callback /* , thisArg */ ) {
                        var entries = getInternalParamsState(this).entries;
                        var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
                        var index = 0;
                        var entry;
                        while(index < entries.length){
                            entry = entries[index++];
                            boundFunction(entry.value, entry.key, this);
                        }
                    },
                    // `URLSearchParams.prototype.keys` method
                    keys: function keys() {
                        return new URLSearchParamsIterator(this, 'keys');
                    },
                    // `URLSearchParams.prototype.values` method
                    values: function values() {
                        return new URLSearchParamsIterator(this, 'values');
                    },
                    // `URLSearchParams.prototype.entries` method
                    entries: function entries() {
                        return new URLSearchParamsIterator(this, 'entries');
                    }
                }, {
                    enumerable: true
                });
                // `URLSearchParams.prototype[@@iterator]` method
                redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries);
                // `URLSearchParams.prototype.toString` method
                // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
                redefine(URLSearchParamsPrototype, 'toString', function toString() {
                    var entries = getInternalParamsState(this).entries;
                    var result = [];
                    var index = 0;
                    var entry;
                    while(index < entries.length){
                        entry = entries[index++];
                        result.push(serialize(entry.key) + '=' + serialize(entry.value));
                    }
                    return result.join('&');
                }, {
                    enumerable: true
                });
                setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
                $({
                    global: true,
                    forced: !USE_NATIVE_URL
                }, {
                    URLSearchParams: URLSearchParamsConstructor
                });
                // Wrap `fetch` for correct work with polyfilled `URLSearchParams`
                // https://github.com/zloirock/core-js/issues/674
                if (!USE_NATIVE_URL && typeof $fetch == 'function' && typeof Headers == 'function') $({
                    global: true,
                    enumerable: true,
                    forced: true
                }, {
                    fetch: function fetch(input /* , init */ ) {
                        var args = [
                            input
                        ];
                        var init, body, headers;
                        if (arguments.length > 1) {
                            init = arguments[1];
                            if (isObject(init)) {
                                body = init.body;
                                if (classof(body) === URL_SEARCH_PARAMS) {
                                    headers = init.headers ? new Headers(init.headers) : new Headers();
                                    if (!headers.has('content-type')) headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                                    init = create(init, {
                                        body: createPropertyDescriptor(0, String(body)),
                                        headers: createPropertyDescriptor(0, headers)
                                    });
                                }
                            }
                            args.push(init);
                        }
                        return $fetch.apply(this, args);
                    }
                });
                module.exports = {
                    URLSearchParams: URLSearchParamsConstructor,
                    getState: getInternalParamsState
                };
            /***/ },
            /***/ 285: /***/ function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
                "use strict";
                // TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
                __webpack_require__(8783);
                var $ = __webpack_require__(2109);
                var DESCRIPTORS = __webpack_require__(9781);
                var USE_NATIVE_URL = __webpack_require__(590);
                var global = __webpack_require__(7854);
                var defineProperties = __webpack_require__(6048);
                var redefine = __webpack_require__(1320);
                var anInstance = __webpack_require__(5787);
                var has = __webpack_require__(6656);
                var assign = __webpack_require__(1574);
                var arrayFrom = __webpack_require__(8457);
                var codeAt = __webpack_require__(8710).codeAt;
                var toASCII = __webpack_require__(3197);
                var setToStringTag = __webpack_require__(8003);
                var URLSearchParamsModule = __webpack_require__(1637);
                var InternalStateModule = __webpack_require__(9909);
                var NativeURL = global.URL;
                var URLSearchParams = URLSearchParamsModule.URLSearchParams;
                var getInternalSearchParamsState = URLSearchParamsModule.getState;
                var setInternalState = InternalStateModule.set;
                var getInternalURLState = InternalStateModule.getterFor('URL');
                var floor = Math.floor;
                var pow = Math.pow;
                var INVALID_AUTHORITY = 'Invalid authority';
                var INVALID_SCHEME = 'Invalid scheme';
                var INVALID_HOST = 'Invalid host';
                var INVALID_PORT = 'Invalid port';
                var ALPHA = /[A-Za-z]/;
                var ALPHANUMERIC = /[\d+-.A-Za-z]/;
                var DIGIT = /\d/;
                var HEX_START = /^(0x|0X)/;
                var OCT = /^[0-7]+$/;
                var DEC = /^\d+$/;
                var HEX = /^[\dA-Fa-f]+$/;
                /* eslint-disable no-control-regex -- safe */ var FORBIDDEN_HOST_CODE_POINT = /[\u0000\t\u000A\u000D #%/:?@[\\]]/;
                var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\t\u000A\u000D #/:?@[\\]]/;
                var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;
                var TAB_AND_NEW_LINE = /[\t\u000A\u000D]/g;
                /* eslint-enable no-control-regex -- safe */ var EOF;
                var parseHost = function(url, input) {
                    var result, codePoints, index;
                    if (input.charAt(0) == '[') {
                        if (input.charAt(input.length - 1) != ']') return INVALID_HOST;
                        result = parseIPv6(input.slice(1, -1));
                        if (!result) return INVALID_HOST;
                        url.host = result;
                    // opaque host
                    } else if (!isSpecial(url)) {
                        if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
                        result = '';
                        codePoints = arrayFrom(input);
                        for(index = 0; index < codePoints.length; index++)result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
                        url.host = result;
                    } else {
                        input = toASCII(input);
                        if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
                        result = parseIPv4(input);
                        if (result === null) return INVALID_HOST;
                        url.host = result;
                    }
                };
                var parseIPv4 = function(input) {
                    var parts = input.split('.');
                    var partsLength, numbers, index, part, radix, number, ipv4;
                    if (parts.length && parts[parts.length - 1] == '') parts.pop();
                    partsLength = parts.length;
                    if (partsLength > 4) return input;
                    numbers = [];
                    for(index = 0; index < partsLength; index++){
                        part = parts[index];
                        if (part == '') return input;
                        radix = 10;
                        if (part.length > 1 && part.charAt(0) == '0') {
                            radix = HEX_START.test(part) ? 16 : 8;
                            part = part.slice(radix == 8 ? 1 : 2);
                        }
                        if (part === '') number = 0;
                        else {
                            if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;
                            number = parseInt(part, radix);
                        }
                        numbers.push(number);
                    }
                    for(index = 0; index < partsLength; index++){
                        number = numbers[index];
                        if (index == partsLength - 1) {
                            if (number >= pow(256, 5 - partsLength)) return null;
                        } else if (number > 255) return null;
                    }
                    ipv4 = numbers.pop();
                    for(index = 0; index < numbers.length; index++)ipv4 += numbers[index] * pow(256, 3 - index);
                    return ipv4;
                };
                // eslint-disable-next-line max-statements -- TODO
                var parseIPv6 = function(input) {
                    var address = [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ];
                    var pieceIndex = 0;
                    var compress = null;
                    var pointer = 0;
                    var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
                    var char = function() {
                        return input.charAt(pointer);
                    };
                    if (char() == ':') {
                        if (input.charAt(1) != ':') return;
                        pointer += 2;
                        pieceIndex++;
                        compress = pieceIndex;
                    }
                    while(char()){
                        if (pieceIndex == 8) return;
                        if (char() == ':') {
                            if (compress !== null) return;
                            pointer++;
                            pieceIndex++;
                            compress = pieceIndex;
                            continue;
                        }
                        value = length = 0;
                        while(length < 4 && HEX.test(char())){
                            value = value * 16 + parseInt(char(), 16);
                            pointer++;
                            length++;
                        }
                        if (char() == '.') {
                            if (length == 0) return;
                            pointer -= length;
                            if (pieceIndex > 6) return;
                            numbersSeen = 0;
                            while(char()){
                                ipv4Piece = null;
                                if (numbersSeen > 0) {
                                    if (char() == '.' && numbersSeen < 4) pointer++;
                                    else return;
                                }
                                if (!DIGIT.test(char())) return;
                                while(DIGIT.test(char())){
                                    number = parseInt(char(), 10);
                                    if (ipv4Piece === null) ipv4Piece = number;
                                    else if (ipv4Piece == 0) return;
                                    else ipv4Piece = ipv4Piece * 10 + number;
                                    if (ipv4Piece > 255) return;
                                    pointer++;
                                }
                                address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
                                numbersSeen++;
                                if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
                            }
                            if (numbersSeen != 4) return;
                            break;
                        } else if (char() == ':') {
                            pointer++;
                            if (!char()) return;
                        } else if (char()) return;
                        address[pieceIndex++] = value;
                    }
                    if (compress !== null) {
                        swaps = pieceIndex - compress;
                        pieceIndex = 7;
                        while(pieceIndex != 0 && swaps > 0){
                            swap = address[pieceIndex];
                            address[pieceIndex--] = address[compress + swaps - 1];
                            address[compress + --swaps] = swap;
                        }
                    } else if (pieceIndex != 8) return;
                    return address;
                };
                var findLongestZeroSequence = function(ipv6) {
                    var maxIndex = null;
                    var maxLength = 1;
                    var currStart = null;
                    var currLength = 0;
                    var index = 0;
                    for(; index < 8; index++)if (ipv6[index] !== 0) {
                        if (currLength > maxLength) {
                            maxIndex = currStart;
                            maxLength = currLength;
                        }
                        currStart = null;
                        currLength = 0;
                    } else {
                        if (currStart === null) currStart = index;
                        ++currLength;
                    }
                    if (currLength > maxLength) {
                        maxIndex = currStart;
                        maxLength = currLength;
                    }
                    return maxIndex;
                };
                var serializeHost = function(host) {
                    var result, index, compress, ignore0;
                    // ipv4
                    if (typeof host == 'number') {
                        result = [];
                        for(index = 0; index < 4; index++){
                            result.unshift(host % 256);
                            host = floor(host / 256);
                        }
                        return result.join('.');
                    // ipv6
                    } else if (typeof host == 'object') {
                        result = '';
                        compress = findLongestZeroSequence(host);
                        for(index = 0; index < 8; index++){
                            if (ignore0 && host[index] === 0) continue;
                            if (ignore0) ignore0 = false;
                            if (compress === index) {
                                result += index ? ':' : '::';
                                ignore0 = true;
                            } else {
                                result += host[index].toString(16);
                                if (index < 7) result += ':';
                            }
                        }
                        return '[' + result + ']';
                    }
                    return host;
                };
                var C0ControlPercentEncodeSet = {};
                var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
                    ' ': 1,
                    '"': 1,
                    '<': 1,
                    '>': 1,
                    '`': 1
                });
                var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
                    '#': 1,
                    '?': 1,
                    '{': 1,
                    '}': 1
                });
                var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
                    '/': 1,
                    ':': 1,
                    ';': 1,
                    '=': 1,
                    '@': 1,
                    '[': 1,
                    '\\': 1,
                    ']': 1,
                    '^': 1,
                    '|': 1
                });
                var percentEncode = function(char, set) {
                    var code = codeAt(char, 0);
                    return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);
                };
                var specialSchemes = {
                    ftp: 21,
                    file: null,
                    http: 80,
                    https: 443,
                    ws: 80,
                    wss: 443
                };
                var isSpecial = function(url) {
                    return has(specialSchemes, url.scheme);
                };
                var includesCredentials = function(url) {
                    return url.username != '' || url.password != '';
                };
                var cannotHaveUsernamePasswordPort = function(url) {
                    return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
                };
                var isWindowsDriveLetter = function(string, normalized) {
                    var second;
                    return string.length == 2 && ALPHA.test(string.charAt(0)) && ((second = string.charAt(1)) == ':' || !normalized && second == '|');
                };
                var startsWithWindowsDriveLetter = function(string) {
                    var third;
                    return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (string.length == 2 || (third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#');
                };
                var shortenURLsPath = function(url) {
                    var path = url.path;
                    var pathSize = path.length;
                    if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) path.pop();
                };
                var isSingleDot = function(segment) {
                    return segment === '.' || segment.toLowerCase() === '%2e';
                };
                var isDoubleDot = function(segment) {
                    segment = segment.toLowerCase();
                    return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
                };
                // States:
                var SCHEME_START = {};
                var SCHEME = {};
                var NO_SCHEME = {};
                var SPECIAL_RELATIVE_OR_AUTHORITY = {};
                var PATH_OR_AUTHORITY = {};
                var RELATIVE = {};
                var RELATIVE_SLASH = {};
                var SPECIAL_AUTHORITY_SLASHES = {};
                var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
                var AUTHORITY = {};
                var HOST = {};
                var HOSTNAME = {};
                var PORT = {};
                var FILE = {};
                var FILE_SLASH = {};
                var FILE_HOST = {};
                var PATH_START = {};
                var PATH = {};
                var CANNOT_BE_A_BASE_URL_PATH = {};
                var QUERY = {};
                var FRAGMENT = {};
                // eslint-disable-next-line max-statements -- TODO
                var parseURL = function(url, input, stateOverride, base) {
                    var state = stateOverride || SCHEME_START;
                    var pointer = 0;
                    var buffer = '';
                    var seenAt = false;
                    var seenBracket = false;
                    var seenPasswordToken = false;
                    var codePoints, char, bufferCodePoints, failure;
                    if (!stateOverride) {
                        url.scheme = '';
                        url.username = '';
                        url.password = '';
                        url.host = null;
                        url.port = null;
                        url.path = [];
                        url.query = null;
                        url.fragment = null;
                        url.cannotBeABaseURL = false;
                        input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
                    }
                    input = input.replace(TAB_AND_NEW_LINE, '');
                    codePoints = arrayFrom(input);
                    while(pointer <= codePoints.length){
                        char = codePoints[pointer];
                        switch(state){
                            case SCHEME_START:
                                if (char && ALPHA.test(char)) {
                                    buffer += char.toLowerCase();
                                    state = SCHEME;
                                } else if (!stateOverride) {
                                    state = NO_SCHEME;
                                    continue;
                                } else return INVALID_SCHEME;
                                break;
                            case SCHEME:
                                if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) buffer += char.toLowerCase();
                                else if (char == ':') {
                                    if (stateOverride && (isSpecial(url) != has(specialSchemes, buffer) || buffer == 'file' && (includesCredentials(url) || url.port !== null) || url.scheme == 'file' && !url.host)) return;
                                    url.scheme = buffer;
                                    if (stateOverride) {
                                        if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
                                        return;
                                    }
                                    buffer = '';
                                    if (url.scheme == 'file') state = FILE;
                                    else if (isSpecial(url) && base && base.scheme == url.scheme) state = SPECIAL_RELATIVE_OR_AUTHORITY;
                                    else if (isSpecial(url)) state = SPECIAL_AUTHORITY_SLASHES;
                                    else if (codePoints[pointer + 1] == '/') {
                                        state = PATH_OR_AUTHORITY;
                                        pointer++;
                                    } else {
                                        url.cannotBeABaseURL = true;
                                        url.path.push('');
                                        state = CANNOT_BE_A_BASE_URL_PATH;
                                    }
                                } else if (!stateOverride) {
                                    buffer = '';
                                    state = NO_SCHEME;
                                    pointer = 0;
                                    continue;
                                } else return INVALID_SCHEME;
                                break;
                            case NO_SCHEME:
                                if (!base || base.cannotBeABaseURL && char != '#') return INVALID_SCHEME;
                                if (base.cannotBeABaseURL && char == '#') {
                                    url.scheme = base.scheme;
                                    url.path = base.path.slice();
                                    url.query = base.query;
                                    url.fragment = '';
                                    url.cannotBeABaseURL = true;
                                    state = FRAGMENT;
                                    break;
                                }
                                state = base.scheme == 'file' ? FILE : RELATIVE;
                                continue;
                            case SPECIAL_RELATIVE_OR_AUTHORITY:
                                if (char == '/' && codePoints[pointer + 1] == '/') {
                                    state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                                    pointer++;
                                } else {
                                    state = RELATIVE;
                                    continue;
                                }
                                break;
                            case PATH_OR_AUTHORITY:
                                if (char == '/') {
                                    state = AUTHORITY;
                                    break;
                                } else {
                                    state = PATH;
                                    continue;
                                }
                            case RELATIVE:
                                url.scheme = base.scheme;
                                if (char == EOF) {
                                    url.username = base.username;
                                    url.password = base.password;
                                    url.host = base.host;
                                    url.port = base.port;
                                    url.path = base.path.slice();
                                    url.query = base.query;
                                } else if (char == '/' || char == '\\' && isSpecial(url)) state = RELATIVE_SLASH;
                                else if (char == '?') {
                                    url.username = base.username;
                                    url.password = base.password;
                                    url.host = base.host;
                                    url.port = base.port;
                                    url.path = base.path.slice();
                                    url.query = '';
                                    state = QUERY;
                                } else if (char == '#') {
                                    url.username = base.username;
                                    url.password = base.password;
                                    url.host = base.host;
                                    url.port = base.port;
                                    url.path = base.path.slice();
                                    url.query = base.query;
                                    url.fragment = '';
                                    state = FRAGMENT;
                                } else {
                                    url.username = base.username;
                                    url.password = base.password;
                                    url.host = base.host;
                                    url.port = base.port;
                                    url.path = base.path.slice();
                                    url.path.pop();
                                    state = PATH;
                                    continue;
                                }
                                break;
                            case RELATIVE_SLASH:
                                if (isSpecial(url) && (char == '/' || char == '\\')) state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                                else if (char == '/') state = AUTHORITY;
                                else {
                                    url.username = base.username;
                                    url.password = base.password;
                                    url.host = base.host;
                                    url.port = base.port;
                                    state = PATH;
                                    continue;
                                }
                                break;
                            case SPECIAL_AUTHORITY_SLASHES:
                                state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                                if (char != '/' || buffer.charAt(pointer + 1) != '/') continue;
                                pointer++;
                                break;
                            case SPECIAL_AUTHORITY_IGNORE_SLASHES:
                                if (char != '/' && char != '\\') {
                                    state = AUTHORITY;
                                    continue;
                                }
                                break;
                            case AUTHORITY:
                                if (char == '@') {
                                    if (seenAt) buffer = '%40' + buffer;
                                    seenAt = true;
                                    bufferCodePoints = arrayFrom(buffer);
                                    for(var i = 0; i < bufferCodePoints.length; i++){
                                        var codePoint = bufferCodePoints[i];
                                        if (codePoint == ':' && !seenPasswordToken) {
                                            seenPasswordToken = true;
                                            continue;
                                        }
                                        var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
                                        if (seenPasswordToken) url.password += encodedCodePoints;
                                        else url.username += encodedCodePoints;
                                    }
                                    buffer = '';
                                } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url)) {
                                    if (seenAt && buffer == '') return INVALID_AUTHORITY;
                                    pointer -= arrayFrom(buffer).length + 1;
                                    buffer = '';
                                    state = HOST;
                                } else buffer += char;
                                break;
                            case HOST:
                            case HOSTNAME:
                                if (stateOverride && url.scheme == 'file') {
                                    state = FILE_HOST;
                                    continue;
                                } else if (char == ':' && !seenBracket) {
                                    if (buffer == '') return INVALID_HOST;
                                    failure = parseHost(url, buffer);
                                    if (failure) return failure;
                                    buffer = '';
                                    state = PORT;
                                    if (stateOverride == HOSTNAME) return;
                                } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url)) {
                                    if (isSpecial(url) && buffer == '') return INVALID_HOST;
                                    if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;
                                    failure = parseHost(url, buffer);
                                    if (failure) return failure;
                                    buffer = '';
                                    state = PATH_START;
                                    if (stateOverride) return;
                                    continue;
                                } else {
                                    if (char == '[') seenBracket = true;
                                    else if (char == ']') seenBracket = false;
                                    buffer += char;
                                }
                                break;
                            case PORT:
                                if (DIGIT.test(char)) buffer += char;
                                else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url) || stateOverride) {
                                    if (buffer != '') {
                                        var port = parseInt(buffer, 10);
                                        if (port > 0xFFFF) return INVALID_PORT;
                                        url.port = isSpecial(url) && port === specialSchemes[url.scheme] ? null : port;
                                        buffer = '';
                                    }
                                    if (stateOverride) return;
                                    state = PATH_START;
                                    continue;
                                } else return INVALID_PORT;
                                break;
                            case FILE:
                                url.scheme = 'file';
                                if (char == '/' || char == '\\') state = FILE_SLASH;
                                else if (base && base.scheme == 'file') {
                                    if (char == EOF) {
                                        url.host = base.host;
                                        url.path = base.path.slice();
                                        url.query = base.query;
                                    } else if (char == '?') {
                                        url.host = base.host;
                                        url.path = base.path.slice();
                                        url.query = '';
                                        state = QUERY;
                                    } else if (char == '#') {
                                        url.host = base.host;
                                        url.path = base.path.slice();
                                        url.query = base.query;
                                        url.fragment = '';
                                        state = FRAGMENT;
                                    } else {
                                        if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
                                            url.host = base.host;
                                            url.path = base.path.slice();
                                            shortenURLsPath(url);
                                        }
                                        state = PATH;
                                        continue;
                                    }
                                } else {
                                    state = PATH;
                                    continue;
                                }
                                break;
                            case FILE_SLASH:
                                if (char == '/' || char == '\\') {
                                    state = FILE_HOST;
                                    break;
                                }
                                if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
                                    if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);
                                    else url.host = base.host;
                                }
                                state = PATH;
                                continue;
                            case FILE_HOST:
                                if (char == EOF || char == '/' || char == '\\' || char == '?' || char == '#') {
                                    if (!stateOverride && isWindowsDriveLetter(buffer)) state = PATH;
                                    else if (buffer == '') {
                                        url.host = '';
                                        if (stateOverride) return;
                                        state = PATH_START;
                                    } else {
                                        failure = parseHost(url, buffer);
                                        if (failure) return failure;
                                        if (url.host == 'localhost') url.host = '';
                                        if (stateOverride) return;
                                        buffer = '';
                                        state = PATH_START;
                                    }
                                    continue;
                                } else buffer += char;
                                break;
                            case PATH_START:
                                if (isSpecial(url)) {
                                    state = PATH;
                                    if (char != '/' && char != '\\') continue;
                                } else if (!stateOverride && char == '?') {
                                    url.query = '';
                                    state = QUERY;
                                } else if (!stateOverride && char == '#') {
                                    url.fragment = '';
                                    state = FRAGMENT;
                                } else if (char != EOF) {
                                    state = PATH;
                                    if (char != '/') continue;
                                }
                                break;
                            case PATH:
                                if (char == EOF || char == '/' || char == '\\' && isSpecial(url) || !stateOverride && (char == '?' || char == '#')) {
                                    if (isDoubleDot(buffer)) {
                                        shortenURLsPath(url);
                                        if (char != '/' && !(char == '\\' && isSpecial(url))) url.path.push('');
                                    } else if (isSingleDot(buffer)) {
                                        if (char != '/' && !(char == '\\' && isSpecial(url))) url.path.push('');
                                    } else {
                                        if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
                                            if (url.host) url.host = '';
                                            buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
                                        }
                                        url.path.push(buffer);
                                    }
                                    buffer = '';
                                    if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) while(url.path.length > 1 && url.path[0] === '')url.path.shift();
                                    if (char == '?') {
                                        url.query = '';
                                        state = QUERY;
                                    } else if (char == '#') {
                                        url.fragment = '';
                                        state = FRAGMENT;
                                    }
                                } else buffer += percentEncode(char, pathPercentEncodeSet);
                                break;
                            case CANNOT_BE_A_BASE_URL_PATH:
                                if (char == '?') {
                                    url.query = '';
                                    state = QUERY;
                                } else if (char == '#') {
                                    url.fragment = '';
                                    state = FRAGMENT;
                                } else if (char != EOF) url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
                                break;
                            case QUERY:
                                if (!stateOverride && char == '#') {
                                    url.fragment = '';
                                    state = FRAGMENT;
                                } else if (char != EOF) {
                                    if (char == "'" && isSpecial(url)) url.query += '%27';
                                    else if (char == '#') url.query += '%23';
                                    else url.query += percentEncode(char, C0ControlPercentEncodeSet);
                                }
                                break;
                            case FRAGMENT:
                                if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet);
                                break;
                        }
                        pointer++;
                    }
                };
                // `URL` constructor
                // https://url.spec.whatwg.org/#url-class
                var URLConstructor = function URL(url /* , base */ ) {
                    var that = anInstance(this, URLConstructor, 'URL');
                    var base = arguments.length > 1 ? arguments[1] : undefined;
                    var urlString = String(url);
                    var state = setInternalState(that, {
                        type: 'URL'
                    });
                    var baseState, failure;
                    if (base !== undefined) {
                        if (base instanceof URLConstructor) baseState = getInternalURLState(base);
                        else {
                            failure = parseURL(baseState = {}, String(base));
                            if (failure) throw TypeError(failure);
                        }
                    }
                    failure = parseURL(state, urlString, null, baseState);
                    if (failure) throw TypeError(failure);
                    var searchParams = state.searchParams = new URLSearchParams();
                    var searchParamsState = getInternalSearchParamsState(searchParams);
                    searchParamsState.updateSearchParams(state.query);
                    searchParamsState.updateURL = function() {
                        state.query = String(searchParams) || null;
                    };
                    if (!DESCRIPTORS) {
                        that.href = serializeURL.call(that);
                        that.origin = getOrigin.call(that);
                        that.protocol = getProtocol.call(that);
                        that.username = getUsername.call(that);
                        that.password = getPassword.call(that);
                        that.host = getHost.call(that);
                        that.hostname = getHostname.call(that);
                        that.port = getPort.call(that);
                        that.pathname = getPathname.call(that);
                        that.search = getSearch.call(that);
                        that.searchParams = getSearchParams.call(that);
                        that.hash = getHash.call(that);
                    }
                };
                var URLPrototype = URLConstructor.prototype;
                var serializeURL = function() {
                    var url = getInternalURLState(this);
                    var scheme = url.scheme;
                    var username = url.username;
                    var password = url.password;
                    var host = url.host;
                    var port = url.port;
                    var path = url.path;
                    var query = url.query;
                    var fragment = url.fragment;
                    var output = scheme + ':';
                    if (host !== null) {
                        output += '//';
                        if (includesCredentials(url)) output += username + (password ? ':' + password : '') + '@';
                        output += serializeHost(host);
                        if (port !== null) output += ':' + port;
                    } else if (scheme == 'file') output += '//';
                    output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
                    if (query !== null) output += '?' + query;
                    if (fragment !== null) output += '#' + fragment;
                    return output;
                };
                var getOrigin = function() {
                    var url = getInternalURLState(this);
                    var scheme = url.scheme;
                    var port = url.port;
                    if (scheme == 'blob') try {
                        return new URL(scheme.path[0]).origin;
                    } catch (error) {
                        return 'null';
                    }
                    if (scheme == 'file' || !isSpecial(url)) return 'null';
                    return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
                };
                var getProtocol = function() {
                    return getInternalURLState(this).scheme + ':';
                };
                var getUsername = function() {
                    return getInternalURLState(this).username;
                };
                var getPassword = function() {
                    return getInternalURLState(this).password;
                };
                var getHost = function() {
                    var url = getInternalURLState(this);
                    var host = url.host;
                    var port = url.port;
                    return host === null ? '' : port === null ? serializeHost(host) : serializeHost(host) + ':' + port;
                };
                var getHostname = function() {
                    var host = getInternalURLState(this).host;
                    return host === null ? '' : serializeHost(host);
                };
                var getPort = function() {
                    var port = getInternalURLState(this).port;
                    return port === null ? '' : String(port);
                };
                var getPathname = function() {
                    var url = getInternalURLState(this);
                    var path = url.path;
                    return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
                };
                var getSearch = function() {
                    var query = getInternalURLState(this).query;
                    return query ? '?' + query : '';
                };
                var getSearchParams = function() {
                    return getInternalURLState(this).searchParams;
                };
                var getHash = function() {
                    var fragment = getInternalURLState(this).fragment;
                    return fragment ? '#' + fragment : '';
                };
                var accessorDescriptor = function(getter, setter) {
                    return {
                        get: getter,
                        set: setter,
                        configurable: true,
                        enumerable: true
                    };
                };
                if (DESCRIPTORS) defineProperties(URLPrototype, {
                    // `URL.prototype.href` accessors pair
                    // https://url.spec.whatwg.org/#dom-url-href
                    href: accessorDescriptor(serializeURL, function(href) {
                        var url = getInternalURLState(this);
                        var urlString = String(href);
                        var failure = parseURL(url, urlString);
                        if (failure) throw TypeError(failure);
                        getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
                    }),
                    // `URL.prototype.origin` getter
                    // https://url.spec.whatwg.org/#dom-url-origin
                    origin: accessorDescriptor(getOrigin),
                    // `URL.prototype.protocol` accessors pair
                    // https://url.spec.whatwg.org/#dom-url-protocol
                    protocol: accessorDescriptor(getProtocol, function(protocol) {
                        var url = getInternalURLState(this);
                        parseURL(url, String(protocol) + ':', SCHEME_START);
                    }),
                    // `URL.prototype.username` accessors pair
                    // https://url.spec.whatwg.org/#dom-url-username
                    username: accessorDescriptor(getUsername, function(username) {
                        var url = getInternalURLState(this);
                        var codePoints = arrayFrom(String(username));
                        if (cannotHaveUsernamePasswordPort(url)) return;
                        url.username = '';
                        for(var i = 0; i < codePoints.length; i++)url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
                    }),
                    // `URL.prototype.password` accessors pair
                    // https://url.spec.whatwg.org/#dom-url-password
                    password: accessorDescriptor(getPassword, function(password) {
                        var url = getInternalURLState(this);
                        var codePoints = arrayFrom(String(password));
                        if (cannotHaveUsernamePasswordPort(url)) return;
                        url.password = '';
                        for(var i = 0; i < codePoints.length; i++)url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
                    }),
                    // `URL.prototype.host` accessors pair
                    // https://url.spec.whatwg.org/#dom-url-host
                    host: accessorDescriptor(getHost, function(host) {
                        var url = getInternalURLState(this);
                        if (url.cannotBeABaseURL) return;
                        parseURL(url, String(host), HOST);
                    }),
                    // `URL.prototype.hostname` accessors pair
                    // https://url.spec.whatwg.org/#dom-url-hostname
                    hostname: accessorDescriptor(getHostname, function(hostname) {
                        var url = getInternalURLState(this);
                        if (url.cannotBeABaseURL) return;
                        parseURL(url, String(hostname), HOSTNAME);
                    }),
                    // `URL.prototype.port` accessors pair
                    // https://url.spec.whatwg.org/#dom-url-port
                    port: accessorDescriptor(getPort, function(port) {
                        var url = getInternalURLState(this);
                        if (cannotHaveUsernamePasswordPort(url)) return;
                        port = String(port);
                        if (port == '') url.port = null;
                        else parseURL(url, port, PORT);
                    }),
                    // `URL.prototype.pathname` accessors pair
                    // https://url.spec.whatwg.org/#dom-url-pathname
                    pathname: accessorDescriptor(getPathname, function(pathname) {
                        var url = getInternalURLState(this);
                        if (url.cannotBeABaseURL) return;
                        url.path = [];
                        parseURL(url, pathname + '', PATH_START);
                    }),
                    // `URL.prototype.search` accessors pair
                    // https://url.spec.whatwg.org/#dom-url-search
                    search: accessorDescriptor(getSearch, function(search) {
                        var url = getInternalURLState(this);
                        search = String(search);
                        if (search == '') url.query = null;
                        else {
                            if ('?' == search.charAt(0)) search = search.slice(1);
                            url.query = '';
                            parseURL(url, search, QUERY);
                        }
                        getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
                    }),
                    // `URL.prototype.searchParams` getter
                    // https://url.spec.whatwg.org/#dom-url-searchparams
                    searchParams: accessorDescriptor(getSearchParams),
                    // `URL.prototype.hash` accessors pair
                    // https://url.spec.whatwg.org/#dom-url-hash
                    hash: accessorDescriptor(getHash, function(hash) {
                        var url = getInternalURLState(this);
                        hash = String(hash);
                        if (hash == '') {
                            url.fragment = null;
                            return;
                        }
                        if ('#' == hash.charAt(0)) hash = hash.slice(1);
                        url.fragment = '';
                        parseURL(url, hash, FRAGMENT);
                    })
                });
                // `URL.prototype.toJSON` method
                // https://url.spec.whatwg.org/#dom-url-tojson
                redefine(URLPrototype, 'toJSON', function toJSON() {
                    return serializeURL.call(this);
                }, {
                    enumerable: true
                });
                // `URL.prototype.toString` method
                // https://url.spec.whatwg.org/#URL-stringification-behavior
                redefine(URLPrototype, 'toString', function toString() {
                    return serializeURL.call(this);
                }, {
                    enumerable: true
                });
                if (NativeURL) {
                    var nativeCreateObjectURL = NativeURL.createObjectURL;
                    var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
                    // `URL.createObjectURL` method
                    // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
                    // eslint-disable-next-line no-unused-vars -- required for `.length`
                    if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
                        return nativeCreateObjectURL.apply(NativeURL, arguments);
                    });
                    // `URL.revokeObjectURL` method
                    // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
                    // eslint-disable-next-line no-unused-vars -- required for `.length`
                    if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
                        return nativeRevokeObjectURL.apply(NativeURL, arguments);
                    });
                }
                setToStringTag(URLConstructor, 'URL');
                $({
                    global: true,
                    forced: !USE_NATIVE_URL,
                    sham: !DESCRIPTORS
                }, {
                    URL: URLConstructor
                });
            /***/ }
        };
        /************************************************************************/ /******/ // The module cache
        /******/ var __webpack_module_cache__ = {};
        /******/ /******/ // The require function
        /******/ function __webpack_require__1(moduleId) {
            /******/ // Check if module is in cache
            /******/ if (__webpack_module_cache__[moduleId]) /******/ return __webpack_module_cache__[moduleId].exports;
            /******/ // Create a new module (and put it into the cache)
            /******/ var module = __webpack_module_cache__[moduleId] = {
                /******/ // no module.id needed
                /******/ // no module.loaded needed
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId](module, module.exports, __webpack_require__1);
            /******/ /******/ // Return the exports of the module
            /******/ return module.exports;
        /******/ }
        /******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ !function() {
            /******/ // define getter functions for harmony exports
            /******/ __webpack_require__1.d = function(exports, definition) {
                /******/ for(var key in definition)/******/ if (__webpack_require__1.o(definition, key) && !__webpack_require__1.o(exports, key)) /******/ Object.defineProperty(exports, key, {
                    enumerable: true,
                    get: definition[key]
                });
            /******/ };
        /******/ }();
        /******/ /******/ /* webpack/runtime/global */ /******/ !function() {
            /******/ __webpack_require__1.g = function() {
                /******/ if (typeof globalThis === 'object') return globalThis;
                /******/ try {
                    /******/ return this || new Function('return this')();
                /******/ } catch (e) {
                    /******/ if (typeof window === 'object') return window;
                /******/ }
            /******/ }();
        /******/ }();
        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ !function() {
            /******/ __webpack_require__1.o = function(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
            };
        /******/ }();
        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ !function() {
            /******/ // define __esModule on exports
            /******/ __webpack_require__1.r = function(exports) {
                /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) /******/ Object.defineProperty(exports, Symbol.toStringTag, {
                    value: 'Module'
                });
                /******/ Object.defineProperty(exports, '__esModule', {
                    value: true
                });
            /******/ };
        /******/ }();
        /******/ /************************************************************************/ var __webpack_exports__ = {};
        // This entry need to be wrapped in an IIFE because it need to be in strict mode.
        !function() {
            // ESM COMPAT FLAG
            __webpack_require__1.r(__webpack_exports__);
            // EXPORTS
            __webpack_require__1.d(__webpack_exports__, {
                "Dropzone": function() {
                    return /* reexport */ Dropzone1;
                },
                "default": function() {
                    return /* binding */ dropzone_dist;
                }
            });
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
            var es_array_concat = __webpack_require__1(2222);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.filter.js
            var es_array_filter = __webpack_require__1(7327);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.index-of.js
            var es_array_index_of = __webpack_require__1(2772);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.iterator.js
            var es_array_iterator = __webpack_require__1(6992);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js
            var es_array_map = __webpack_require__1(1249);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.slice.js
            var es_array_slice = __webpack_require__1(7042);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.splice.js
            var es_array_splice = __webpack_require__1(561);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array-buffer.constructor.js
            var es_array_buffer_constructor = __webpack_require__1(8264);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.function.name.js
            var es_function_name = __webpack_require__1(8309);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-prototype-of.js
            var es_object_get_prototype_of = __webpack_require__1(489);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
            var es_object_to_string = __webpack_require__1(1539);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
            var es_regexp_exec = __webpack_require__1(4916);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.to-string.js
            var es_regexp_to_string = __webpack_require__1(9714);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js
            var es_string_iterator = __webpack_require__1(8783);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.match.js
            var es_string_match = __webpack_require__1(4723);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.replace.js
            var es_string_replace = __webpack_require__1(5306);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.split.js
            var es_string_split = __webpack_require__1(3123);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.trim.js
            var es_string_trim = __webpack_require__1(3210);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.uint8-array.js
            var es_typed_array_uint8_array = __webpack_require__1(2472);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.copy-within.js
            var es_typed_array_copy_within = __webpack_require__1(2990);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.every.js
            var es_typed_array_every = __webpack_require__1(8927);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.fill.js
            var es_typed_array_fill = __webpack_require__1(3105);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.filter.js
            var es_typed_array_filter = __webpack_require__1(5035);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.find.js
            var es_typed_array_find = __webpack_require__1(4345);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.find-index.js
            var es_typed_array_find_index = __webpack_require__1(7174);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.for-each.js
            var es_typed_array_for_each = __webpack_require__1(2846);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.includes.js
            var es_typed_array_includes = __webpack_require__1(4731);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.index-of.js
            var es_typed_array_index_of = __webpack_require__1(7209);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.iterator.js
            var es_typed_array_iterator = __webpack_require__1(6319);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.join.js
            var es_typed_array_join = __webpack_require__1(8867);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.last-index-of.js
            var es_typed_array_last_index_of = __webpack_require__1(7789);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.map.js
            var es_typed_array_map = __webpack_require__1(3739);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reduce.js
            var es_typed_array_reduce = __webpack_require__1(9368);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reduce-right.js
            var es_typed_array_reduce_right = __webpack_require__1(4483);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reverse.js
            var es_typed_array_reverse = __webpack_require__1(2056);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.set.js
            var es_typed_array_set = __webpack_require__1(3462);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.slice.js
            var es_typed_array_slice = __webpack_require__1(678);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.some.js
            var es_typed_array_some = __webpack_require__1(7462);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.sort.js
            var es_typed_array_sort = __webpack_require__1(3824);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.subarray.js
            var es_typed_array_subarray = __webpack_require__1(5021);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.to-locale-string.js
            var es_typed_array_to_locale_string = __webpack_require__1(2974);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.to-string.js
            var es_typed_array_to_string = __webpack_require__1(5016);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js
            var web_dom_collections_for_each = __webpack_require__1(4747);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js
            var web_dom_collections_iterator = __webpack_require__1(3948);
            // EXTERNAL MODULE: ./node_modules/core-js/modules/web.url.js
            var web_url = __webpack_require__1(285);
            function _createForOfIteratorHelper(o, allowArrayLike) {
                var it;
                if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                        if (it) o = it;
                        var i = 0;
                        var F = function F() {};
                        return {
                            s: F,
                            n: function n() {
                                if (i >= o.length) return {
                                    done: true
                                };
                                return {
                                    done: false,
                                    value: o[i++]
                                };
                            },
                            e: function e(_e) {
                                throw _e;
                            },
                            f: F
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return {
                    s: function s() {
                        it = o[Symbol.iterator]();
                    },
                    n: function n() {
                        var step = it.next();
                        normalCompletion = step.done;
                        return step;
                    },
                    e: function e(_e2) {
                        didErr = true;
                        err = _e2;
                    },
                    f: function f() {
                        try {
                            if (!normalCompletion && it.return != null) it.return();
                        } finally{
                            if (didErr) throw err;
                        }
                    }
                };
            }
            function _unsupportedIterableToArray(o, minLen) {
                if (!o) return;
                if (typeof o === "string") return _arrayLikeToArray(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor) n = o.constructor.name;
                if (n === "Map" || n === "Set") return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
            }
            function _arrayLikeToArray(arr, len) {
                if (len == null || len > arr.length) len = arr.length;
                for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
                return arr2;
            }
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            function _defineProperties(target, props) {
                for(var i = 0; i < props.length; i++){
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            function _createClass(Constructor, protoProps, staticProps) {
                if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                if (staticProps) _defineProperties(Constructor, staticProps);
                return Constructor;
            }
            // The Emitter class provides the ability to call `.on()` on Dropzone to listen
            // to events.
            // It is strongly based on component's emitter class, and I removed the
            // functionality because of the dependency hell with different frameworks.
            var Emitter1 = /*#__PURE__*/ function() {
                function Emitter() {
                    _classCallCheck(this, Emitter);
                }
                _createClass(Emitter, [
                    {
                        key: "on",
                        value: function on(event, fn) {
                            this._callbacks = this._callbacks || {}; // Create namespace for this event
                            if (!this._callbacks[event]) this._callbacks[event] = [];
                            this._callbacks[event].push(fn);
                            return this;
                        }
                    },
                    {
                        key: "emit",
                        value: function emit(event) {
                            this._callbacks = this._callbacks || {};
                            var callbacks = this._callbacks[event];
                            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
                            if (callbacks) {
                                var _iterator = _createForOfIteratorHelper(callbacks, true), _step;
                                try {
                                    for(_iterator.s(); !(_step = _iterator.n()).done;){
                                        var callback = _step.value;
                                        callback.apply(this, args);
                                    }
                                } catch (err) {
                                    _iterator.e(err);
                                } finally{
                                    _iterator.f();
                                }
                            } // trigger a corresponding DOM event
                            if (this.element) this.element.dispatchEvent(this.makeEvent("dropzone:" + event, {
                                args: args
                            }));
                            return this;
                        }
                    },
                    {
                        key: "makeEvent",
                        value: function makeEvent(eventName, detail) {
                            var params = {
                                bubbles: true,
                                cancelable: true,
                                detail: detail
                            };
                            if (typeof window.CustomEvent === "function") return new CustomEvent(eventName, params);
                            else {
                                // IE 11 support
                                // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent
                                var evt = document.createEvent("CustomEvent");
                                evt.initCustomEvent(eventName, params.bubbles, params.cancelable, params.detail);
                                return evt;
                            }
                        } // Remove event listener for given event. If fn is not provided, all event
                    },
                    {
                        key: "off",
                        value: function off(event, fn) {
                            if (!this._callbacks || arguments.length === 0) {
                                this._callbacks = {};
                                return this;
                            } // specific event
                            var callbacks = this._callbacks[event];
                            if (!callbacks) return this;
                             // remove all handlers
                            if (arguments.length === 1) {
                                delete this._callbacks[event];
                                return this;
                            } // remove specific handler
                            for(var i = 0; i < callbacks.length; i++){
                                var callback = callbacks[i];
                                if (callback === fn) {
                                    callbacks.splice(i, 1);
                                    break;
                                }
                            }
                            return this;
                        }
                    }
                ]);
                return Emitter;
            }();
            // Module
            var code = "<div class=\"dz-preview dz-file-preview\"> <div class=\"dz-image\"><img data-dz-thumbnail/></div> <div class=\"dz-details\"> <div class=\"dz-size\"><span data-dz-size></span></div> <div class=\"dz-filename\"><span data-dz-name></span></div> </div> <div class=\"dz-progress\"> <span class=\"dz-upload\" data-dz-uploadprogress></span> </div> <div class=\"dz-error-message\"><span data-dz-errormessage></span></div> <div class=\"dz-success-mark\"> <svg width=\"54px\" height=\"54px\" viewBox=\"0 0 54 54\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"> <title>Check</title> <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\"> <path d=\"M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\" stroke-opacity=\"0.198794158\" stroke=\"#747474\" fill-opacity=\"0.816519475\" fill=\"#FFFFFF\"></path> </g> </svg> </div> <div class=\"dz-error-mark\"> <svg width=\"54px\" height=\"54px\" viewBox=\"0 0 54 54\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"> <title>Error</title> <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\"> <g stroke=\"#747474\" stroke-opacity=\"0.198794158\" fill=\"#FFFFFF\" fill-opacity=\"0.816519475\"> <path d=\"M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\"></path> </g> </g> </svg> </div> </div> ";
            // Exports
            /* harmony default export */ var preview_template = code;
            function options_createForOfIteratorHelper(o, allowArrayLike) {
                var it;
                if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                    if (Array.isArray(o) || (it = options_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                        if (it) o = it;
                        var i = 0;
                        var F = function F() {};
                        return {
                            s: F,
                            n: function n() {
                                if (i >= o.length) return {
                                    done: true
                                };
                                return {
                                    done: false,
                                    value: o[i++]
                                };
                            },
                            e: function e(_e) {
                                throw _e;
                            },
                            f: F
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return {
                    s: function s() {
                        it = o[Symbol.iterator]();
                    },
                    n: function n() {
                        var step = it.next();
                        normalCompletion = step.done;
                        return step;
                    },
                    e: function e(_e2) {
                        didErr = true;
                        err = _e2;
                    },
                    f: function f() {
                        try {
                            if (!normalCompletion && it.return != null) it.return();
                        } finally{
                            if (didErr) throw err;
                        }
                    }
                };
            }
            function options_unsupportedIterableToArray(o, minLen) {
                if (!o) return;
                if (typeof o === "string") return options_arrayLikeToArray(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor) n = o.constructor.name;
                if (n === "Map" || n === "Set") return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return options_arrayLikeToArray(o, minLen);
            }
            function options_arrayLikeToArray(arr, len) {
                if (len == null || len > arr.length) len = arr.length;
                for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
                return arr2;
            }
            var defaultOptions = {
                /**
   * Has to be specified on elements other than form (or when the form
   * doesn't have an `action` attribute). You can also
   * provide a function that will be called with `files` and
   * must return the url (since `v3.12.0`)
   */ url: null,
                /**
   * Can be changed to `"put"` if necessary. You can also provide a function
   * that will be called with `files` and must return the method (since `v3.12.0`).
   */ method: "post",
                /**
   * Will be set on the XHRequest.
   */ withCredentials: false,
                /**
   * The timeout for the XHR requests in milliseconds (since `v4.4.0`).
   * If set to null or 0, no timeout is going to be set.
   */ timeout: null,
                /**
   * How many file uploads to process in parallel (See the
   * Enqueuing file uploads documentation section for more info)
   */ parallelUploads: 2,
                /**
   * Whether to send multiple files in one request. If
   * this it set to true, then the fallback file input element will
   * have the `multiple` attribute as well. This option will
   * also trigger additional events (like `processingmultiple`). See the events
   * documentation section for more information.
   */ uploadMultiple: false,
                /**
   * Whether you want files to be uploaded in chunks to your server. This can't be
   * used in combination with `uploadMultiple`.
   *
   * See [chunksUploaded](#config-chunksUploaded) for the callback to finalise an upload.
   */ chunking: false,
                /**
   * If `chunking` is enabled, this defines whether **every** file should be chunked,
   * even if the file size is below chunkSize. This means, that the additional chunk
   * form data will be submitted and the `chunksUploaded` callback will be invoked.
   */ forceChunking: false,
                /**
   * If `chunking` is `true`, then this defines the chunk size in bytes.
   */ chunkSize: 2000000,
                /**
   * If `true`, the individual chunks of a file are being uploaded simultaneously.
   */ parallelChunkUploads: false,
                /**
   * Whether a chunk should be retried if it fails.
   */ retryChunks: false,
                /**
   * If `retryChunks` is true, how many times should it be retried.
   */ retryChunksLimit: 3,
                /**
   * The maximum filesize (in bytes) that is allowed to be uploaded.
   */ maxFilesize: 256,
                /**
   * The name of the file param that gets transferred.
   * **NOTE**: If you have the option  `uploadMultiple` set to `true`, then
   * Dropzone will append `[]` to the name.
   */ paramName: "file",
                /**
   * Whether thumbnails for images should be generated
   */ createImageThumbnails: true,
                /**
   * In MB. When the filename exceeds this limit, the thumbnail will not be generated.
   */ maxThumbnailFilesize: 10,
                /**
   * If `null`, the ratio of the image will be used to calculate it.
   */ thumbnailWidth: 120,
                /**
   * The same as `thumbnailWidth`. If both are null, images will not be resized.
   */ thumbnailHeight: 120,
                /**
   * How the images should be scaled down in case both, `thumbnailWidth` and `thumbnailHeight` are provided.
   * Can be either `contain` or `crop`.
   */ thumbnailMethod: "crop",
                /**
   * If set, images will be resized to these dimensions before being **uploaded**.
   * If only one, `resizeWidth` **or** `resizeHeight` is provided, the original aspect
   * ratio of the file will be preserved.
   *
   * The `options.transformFile` function uses these options, so if the `transformFile` function
   * is overridden, these options don't do anything.
   */ resizeWidth: null,
                /**
   * See `resizeWidth`.
   */ resizeHeight: null,
                /**
   * The mime type of the resized image (before it gets uploaded to the server).
   * If `null` the original mime type will be used. To force jpeg, for example, use `image/jpeg`.
   * See `resizeWidth` for more information.
   */ resizeMimeType: null,
                /**
   * The quality of the resized images. See `resizeWidth`.
   */ resizeQuality: 0.8,
                /**
   * How the images should be scaled down in case both, `resizeWidth` and `resizeHeight` are provided.
   * Can be either `contain` or `crop`.
   */ resizeMethod: "contain",
                /**
   * The base that is used to calculate the **displayed** filesize. You can
   * change this to 1024 if you would rather display kibibytes, mebibytes,
   * etc... 1024 is technically incorrect, because `1024 bytes` are `1 kibibyte`
   * not `1 kilobyte`. You can change this to `1024` if you don't care about
   * validity.
   */ filesizeBase: 1000,
                /**
   * If not `null` defines how many files this Dropzone handles. If it exceeds,
   * the event `maxfilesexceeded` will be called. The dropzone element gets the
   * class `dz-max-files-reached` accordingly so you can provide visual
   * feedback.
   */ maxFiles: null,
                /**
   * An optional object to send additional headers to the server. Eg:
   * `{ "My-Awesome-Header": "header value" }`
   */ headers: null,
                /**
   * If `true`, the dropzone element itself will be clickable, if `false`
   * nothing will be clickable.
   *
   * You can also pass an HTML element, a CSS selector (for multiple elements)
   * or an array of those. In that case, all of those elements will trigger an
   * upload when clicked.
   */ clickable: true,
                /**
   * Whether hidden files in directories should be ignored.
   */ ignoreHiddenFiles: true,
                /**
   * The default implementation of `accept` checks the file's mime type or
   * extension against this list. This is a comma separated list of mime
   * types or file extensions.
   *
   * Eg.: `image/*,application/pdf,.psd`
   *
   * If the Dropzone is `clickable` this option will also be used as
   * [`accept`](https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept)
   * parameter on the hidden file input as well.
   */ acceptedFiles: null,
                /**
   * **Deprecated!**
   * Use acceptedFiles instead.
   */ acceptedMimeTypes: null,
                /**
   * If false, files will be added to the queue but the queue will not be
   * processed automatically.
   * This can be useful if you need some additional user input before sending
   * files (or if you want want all files sent at once).
   * If you're ready to send the file simply call `myDropzone.processQueue()`.
   *
   * See the [enqueuing file uploads](#enqueuing-file-uploads) documentation
   * section for more information.
   */ autoProcessQueue: true,
                /**
   * If false, files added to the dropzone will not be queued by default.
   * You'll have to call `enqueueFile(file)` manually.
   */ autoQueue: true,
                /**
   * If `true`, this will add a link to every file preview to remove or cancel (if
   * already uploading) the file. The `dictCancelUpload`, `dictCancelUploadConfirmation`
   * and `dictRemoveFile` options are used for the wording.
   */ addRemoveLinks: false,
                /**
   * Defines where to display the file previews â€“ if `null` the
   * Dropzone element itself is used. Can be a plain `HTMLElement` or a CSS
   * selector. The element should have the `dropzone-previews` class so
   * the previews are displayed properly.
   */ previewsContainer: null,
                /**
   * Set this to `true` if you don't want previews to be shown.
   */ disablePreviews: false,
                /**
   * This is the element the hidden input field (which is used when clicking on the
   * dropzone to trigger file selection) will be appended to. This might
   * be important in case you use frameworks to switch the content of your page.
   *
   * Can be a selector string, or an element directly.
   */ hiddenInputContainer: "body",
                /**
   * If null, no capture type will be specified
   * If camera, mobile devices will skip the file selection and choose camera
   * If microphone, mobile devices will skip the file selection and choose the microphone
   * If camcorder, mobile devices will skip the file selection and choose the camera in video mode
   * On apple devices multiple must be set to false.  AcceptedFiles may need to
   * be set to an appropriate mime type (e.g. "image/*", "audio/*", or "video/*").
   */ capture: null,
                /**
   * **Deprecated**. Use `renameFile` instead.
   */ renameFilename: null,
                /**
   * A function that is invoked before the file is uploaded to the server and renames the file.
   * This function gets the `File` as argument and can use the `file.name`. The actual name of the
   * file that gets used during the upload can be accessed through `file.upload.filename`.
   */ renameFile: null,
                /**
   * If `true` the fallback will be forced. This is very useful to test your server
   * implementations first and make sure that everything works as
   * expected without dropzone if you experience problems, and to test
   * how your fallbacks will look.
   */ forceFallback: false,
                /**
   * The text used before any files are dropped.
   */ dictDefaultMessage: "Drop files here to upload",
                /**
   * The text that replaces the default message text it the browser is not supported.
   */ dictFallbackMessage: "Your browser does not support drag'n'drop file uploads.",
                /**
   * The text that will be added before the fallback form.
   * If you provide a  fallback element yourself, or if this option is `null` this will
   * be ignored.
   */ dictFallbackText: "Please use the fallback form below to upload your files like in the olden days.",
                /**
   * If the filesize is too big.
   * `{{filesize}}` and `{{maxFilesize}}` will be replaced with the respective configuration values.
   */ dictFileTooBig: "File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.",
                /**
   * If the file doesn't match the file type.
   */ dictInvalidFileType: "You can't upload files of this type.",
                /**
   * If the server response was invalid.
   * `{{statusCode}}` will be replaced with the servers status code.
   */ dictResponseError: "Server responded with {{statusCode}} code.",
                /**
   * If `addRemoveLinks` is true, the text to be used for the cancel upload link.
   */ dictCancelUpload: "Cancel upload",
                /**
   * The text that is displayed if an upload was manually canceled
   */ dictUploadCanceled: "Upload canceled.",
                /**
   * If `addRemoveLinks` is true, the text to be used for confirmation when cancelling upload.
   */ dictCancelUploadConfirmation: "Are you sure you want to cancel this upload?",
                /**
   * If `addRemoveLinks` is true, the text to be used to remove a file.
   */ dictRemoveFile: "Remove file",
                /**
   * If this is not null, then the user will be prompted before removing a file.
   */ dictRemoveFileConfirmation: null,
                /**
   * Displayed if `maxFiles` is st and exceeded.
   * The string `{{maxFiles}}` will be replaced by the configuration value.
   */ dictMaxFilesExceeded: "You can not upload any more files.",
                /**
   * Allows you to translate the different units. Starting with `tb` for terabytes and going down to
   * `b` for bytes.
   */ dictFileSizeUnits: {
                    tb: "TB",
                    gb: "GB",
                    mb: "MB",
                    kb: "KB",
                    b: "b"
                },
                /**
   * Called when dropzone initialized
   * You can add event listeners here
   */ init: function init() {},
                /**
   * Can be an **object** of additional parameters to transfer to the server, **or** a `Function`
   * that gets invoked with the `files`, `xhr` and, if it's a chunked upload, `chunk` arguments. In case
   * of a function, this needs to return a map.
   *
   * The default implementation does nothing for normal uploads, but adds relevant information for
   * chunked uploads.
   *
   * This is the same as adding hidden input fields in the form element.
   */ params: function params(files, xhr, chunk) {
                    if (chunk) return {
                        dzuuid: chunk.file.upload.uuid,
                        dzchunkindex: chunk.index,
                        dztotalfilesize: chunk.file.size,
                        dzchunksize: this.options.chunkSize,
                        dztotalchunkcount: chunk.file.upload.totalChunkCount,
                        dzchunkbyteoffset: chunk.index * this.options.chunkSize
                    };
                },
                /**
   * A function that gets a [file](https://developer.mozilla.org/en-US/docs/DOM/File)
   * and a `done` function as parameters.
   *
   * If the done function is invoked without arguments, the file is "accepted" and will
   * be processed. If you pass an error message, the file is rejected, and the error
   * message will be displayed.
   * This function will not be called if the file is too big or doesn't match the mime types.
   */ accept: function accept(file, done) {
                    return done();
                },
                /**
   * The callback that will be invoked when all chunks have been uploaded for a file.
   * It gets the file for which the chunks have been uploaded as the first parameter,
   * and the `done` function as second. `done()` needs to be invoked when everything
   * needed to finish the upload process is done.
   */ chunksUploaded: function chunksUploaded(file, done) {
                    done();
                },
                /**
   * Gets called when the browser is not supported.
   * The default implementation shows the fallback input field and adds
   * a text.
   */ fallback: function fallback() {
                    // This code should pass in IE7... :(
                    var messageElement;
                    this.element.className = "".concat(this.element.className, " dz-browser-not-supported");
                    var _iterator = options_createForOfIteratorHelper(this.element.getElementsByTagName("div"), true), _step;
                    try {
                        for(_iterator.s(); !(_step = _iterator.n()).done;){
                            var child = _step.value;
                            if (/(^| )dz-message($| )/.test(child.className)) {
                                messageElement = child;
                                child.className = "dz-message"; // Removes the 'dz-default' class
                                break;
                            }
                        }
                    } catch (err) {
                        _iterator.e(err);
                    } finally{
                        _iterator.f();
                    }
                    if (!messageElement) {
                        messageElement = Dropzone1.createElement('<div class="dz-message"><span></span></div>');
                        this.element.appendChild(messageElement);
                    }
                    var span = messageElement.getElementsByTagName("span")[0];
                    if (span) {
                        if (span.textContent != null) span.textContent = this.options.dictFallbackMessage;
                        else if (span.innerText != null) span.innerText = this.options.dictFallbackMessage;
                    }
                    return this.element.appendChild(this.getFallbackForm());
                },
                /**
   * Gets called to calculate the thumbnail dimensions.
   *
   * It gets `file`, `width` and `height` (both may be `null`) as parameters and must return an object containing:
   *
   *  - `srcWidth` & `srcHeight` (required)
   *  - `trgWidth` & `trgHeight` (required)
   *  - `srcX` & `srcY` (optional, default `0`)
   *  - `trgX` & `trgY` (optional, default `0`)
   *
   * Those values are going to be used by `ctx.drawImage()`.
   */ resize: function resize(file, width, height, resizeMethod) {
                    var info = {
                        srcX: 0,
                        srcY: 0,
                        srcWidth: file.width,
                        srcHeight: file.height
                    };
                    var srcRatio = file.width / file.height; // Automatically calculate dimensions if not specified
                    if (width == null && height == null) {
                        width = info.srcWidth;
                        height = info.srcHeight;
                    } else if (width == null) width = height * srcRatio;
                    else if (height == null) height = width / srcRatio;
                     // Make sure images aren't upscaled
                    width = Math.min(width, info.srcWidth);
                    height = Math.min(height, info.srcHeight);
                    var trgRatio = width / height;
                    if (info.srcWidth > width || info.srcHeight > height) {
                        // Image is bigger and needs rescaling
                        if (resizeMethod === "crop") {
                            if (srcRatio > trgRatio) {
                                info.srcHeight = file.height;
                                info.srcWidth = info.srcHeight * trgRatio;
                            } else {
                                info.srcWidth = file.width;
                                info.srcHeight = info.srcWidth / trgRatio;
                            }
                        } else if (resizeMethod === "contain") {
                            // Method 'contain'
                            if (srcRatio > trgRatio) height = width / srcRatio;
                            else width = height * srcRatio;
                        } else throw new Error("Unknown resizeMethod '".concat(resizeMethod, "'"));
                    }
                    info.srcX = (file.width - info.srcWidth) / 2;
                    info.srcY = (file.height - info.srcHeight) / 2;
                    info.trgWidth = width;
                    info.trgHeight = height;
                    return info;
                },
                /**
   * Can be used to transform the file (for example, resize an image if necessary).
   *
   * The default implementation uses `resizeWidth` and `resizeHeight` (if provided) and resizes
   * images according to those dimensions.
   *
   * Gets the `file` as the first parameter, and a `done()` function as the second, that needs
   * to be invoked with the file when the transformation is done.
   */ transformFile: function transformFile(file, done) {
                    if ((this.options.resizeWidth || this.options.resizeHeight) && file.type.match(/image.*/)) return this.resizeImage(file, this.options.resizeWidth, this.options.resizeHeight, this.options.resizeMethod, done);
                    else return done(file);
                },
                /**
   * A string that contains the template used for each dropped
   * file. Change it to fulfill your needs but make sure to properly
   * provide all elements.
   *
   * If you want to use an actual HTML element instead of providing a String
   * as a config option, you could create a div with the id `tpl`,
   * put the template inside it and provide the element like this:
   *
   *     document
   *       .querySelector('#tpl')
   *       .innerHTML
   *
   */ previewTemplate: preview_template,
                /*
   Those functions register themselves to the events on init and handle all
   the user interface specific stuff. Overwriting them won't break the upload
   but can break the way it's displayed.
   You can overwrite them if you don't like the default behavior. If you just
   want to add an additional event handler, register it on the dropzone object
   and don't overwrite those options.
   */ // Those are self explanatory and simply concern the DragnDrop.
                drop: function drop(e) {
                    return this.element.classList.remove("dz-drag-hover");
                },
                dragstart: function dragstart(e) {},
                dragend: function dragend(e) {
                    return this.element.classList.remove("dz-drag-hover");
                },
                dragenter: function dragenter(e) {
                    return this.element.classList.add("dz-drag-hover");
                },
                dragover: function dragover(e) {
                    return this.element.classList.add("dz-drag-hover");
                },
                dragleave: function dragleave(e) {
                    return this.element.classList.remove("dz-drag-hover");
                },
                paste: function paste(e) {},
                // Called whenever there are no files left in the dropzone anymore, and the
                // dropzone should be displayed as if in the initial state.
                reset: function reset() {
                    return this.element.classList.remove("dz-started");
                },
                // Called when a file is added to the queue
                // Receives `file`
                addedfile: function addedfile(file) {
                    var _this = this;
                    if (this.element === this.previewsContainer) this.element.classList.add("dz-started");
                    if (this.previewsContainer && !this.options.disablePreviews) {
                        file.previewElement = Dropzone1.createElement(this.options.previewTemplate.trim());
                        file.previewTemplate = file.previewElement; // Backwards compatibility
                        this.previewsContainer.appendChild(file.previewElement);
                        var _iterator2 = options_createForOfIteratorHelper(file.previewElement.querySelectorAll("[data-dz-name]"), true), _step2;
                        try {
                            for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                                var node = _step2.value;
                                node.textContent = file.name;
                            }
                        } catch (err) {
                            _iterator2.e(err);
                        } finally{
                            _iterator2.f();
                        }
                        var _iterator3 = options_createForOfIteratorHelper(file.previewElement.querySelectorAll("[data-dz-size]"), true), _step3;
                        try {
                            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                                node = _step3.value;
                                node.innerHTML = this.filesize(file.size);
                            }
                        } catch (err1) {
                            _iterator3.e(err1);
                        } finally{
                            _iterator3.f();
                        }
                        if (this.options.addRemoveLinks) {
                            file._removeLink = Dropzone1.createElement("<a class=\"dz-remove\" href=\"javascript:undefined;\" data-dz-remove>".concat(this.options.dictRemoveFile, "</a>"));
                            file.previewElement.appendChild(file._removeLink);
                        }
                        var removeFileEvent = function removeFileEvent(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (file.status === Dropzone1.UPLOADING) return Dropzone1.confirm(_this.options.dictCancelUploadConfirmation, function() {
                                return _this.removeFile(file);
                            });
                            else {
                                if (_this.options.dictRemoveFileConfirmation) return Dropzone1.confirm(_this.options.dictRemoveFileConfirmation, function() {
                                    return _this.removeFile(file);
                                });
                                else return _this.removeFile(file);
                            }
                        };
                        var _iterator4 = options_createForOfIteratorHelper(file.previewElement.querySelectorAll("[data-dz-remove]"), true), _step4;
                        try {
                            for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                                var removeLink = _step4.value;
                                removeLink.addEventListener("click", removeFileEvent);
                            }
                        } catch (err2) {
                            _iterator4.e(err2);
                        } finally{
                            _iterator4.f();
                        }
                    }
                },
                // Called whenever a file is removed.
                removedfile: function removedfile(file) {
                    if (file.previewElement != null && file.previewElement.parentNode != null) file.previewElement.parentNode.removeChild(file.previewElement);
                    return this._updateMaxFilesReachedClass();
                },
                // Called when a thumbnail has been generated
                // Receives `file` and `dataUrl`
                thumbnail: function thumbnail(file, dataUrl) {
                    if (file.previewElement) {
                        file.previewElement.classList.remove("dz-file-preview");
                        var _iterator5 = options_createForOfIteratorHelper(file.previewElement.querySelectorAll("[data-dz-thumbnail]"), true), _step5;
                        try {
                            for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                                var thumbnailElement = _step5.value;
                                thumbnailElement.alt = file.name;
                                thumbnailElement.src = dataUrl;
                            }
                        } catch (err) {
                            _iterator5.e(err);
                        } finally{
                            _iterator5.f();
                        }
                        return setTimeout(function() {
                            return file.previewElement.classList.add("dz-image-preview");
                        }, 1);
                    }
                },
                // Called whenever an error occurs
                // Receives `file` and `message`
                error: function error(file, message) {
                    if (file.previewElement) {
                        file.previewElement.classList.add("dz-error");
                        if (typeof message !== "string" && message.error) message = message.error;
                        var _iterator6 = options_createForOfIteratorHelper(file.previewElement.querySelectorAll("[data-dz-errormessage]"), true), _step6;
                        try {
                            for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){
                                var node = _step6.value;
                                node.textContent = message;
                            }
                        } catch (err) {
                            _iterator6.e(err);
                        } finally{
                            _iterator6.f();
                        }
                    }
                },
                errormultiple: function errormultiple() {},
                // Called when a file gets processed. Since there is a cue, not all added
                // files are processed immediately.
                // Receives `file`
                processing: function processing(file) {
                    if (file.previewElement) {
                        file.previewElement.classList.add("dz-processing");
                        if (file._removeLink) return file._removeLink.innerHTML = this.options.dictCancelUpload;
                    }
                },
                processingmultiple: function processingmultiple() {},
                // Called whenever the upload progress gets updated.
                // Receives `file`, `progress` (percentage 0-100) and `bytesSent`.
                // To get the total number of bytes of the file, use `file.size`
                uploadprogress: function uploadprogress(file, progress, bytesSent) {
                    if (file.previewElement) {
                        var _iterator7 = options_createForOfIteratorHelper(file.previewElement.querySelectorAll("[data-dz-uploadprogress]"), true), _step7;
                        try {
                            for(_iterator7.s(); !(_step7 = _iterator7.n()).done;){
                                var node = _step7.value;
                                node.nodeName === "PROGRESS" ? node.value = progress : node.style.width = "".concat(progress, "%");
                            }
                        } catch (err) {
                            _iterator7.e(err);
                        } finally{
                            _iterator7.f();
                        }
                    }
                },
                // Called whenever the total upload progress gets updated.
                // Called with totalUploadProgress (0-100), totalBytes and totalBytesSent
                totaluploadprogress: function totaluploadprogress() {},
                // Called just before the file is sent. Gets the `xhr` object as second
                // parameter, so you can modify it (for example to add a CSRF token) and a
                // `formData` object to add additional information.
                sending: function sending() {},
                sendingmultiple: function sendingmultiple() {},
                // When the complete upload is finished and successful
                // Receives `file`
                success: function success(file) {
                    if (file.previewElement) return file.previewElement.classList.add("dz-success");
                },
                successmultiple: function successmultiple() {},
                // When the upload is canceled.
                canceled: function canceled(file) {
                    return this.emit("error", file, this.options.dictUploadCanceled);
                },
                canceledmultiple: function canceledmultiple() {},
                // When the upload is finished, either with success or an error.
                // Receives `file`
                complete: function complete(file) {
                    if (file._removeLink) file._removeLink.innerHTML = this.options.dictRemoveFile;
                    if (file.previewElement) return file.previewElement.classList.add("dz-complete");
                },
                completemultiple: function completemultiple() {},
                maxfilesexceeded: function maxfilesexceeded() {},
                maxfilesreached: function maxfilesreached() {},
                queuecomplete: function queuecomplete() {},
                addedfiles: function addedfiles() {}
            };
            /* harmony default export */ var src_options = defaultOptions;
            function _typeof(obj1) {
                if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
                    return typeof obj;
                };
                else _typeof = function _typeof(obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
                return _typeof(obj1);
            }
            function dropzone_createForOfIteratorHelper(o, allowArrayLike) {
                var it;
                if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                    if (Array.isArray(o) || (it = dropzone_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                        if (it) o = it;
                        var i = 0;
                        var F = function F() {};
                        return {
                            s: F,
                            n: function n() {
                                if (i >= o.length) return {
                                    done: true
                                };
                                return {
                                    done: false,
                                    value: o[i++]
                                };
                            },
                            e: function e(_e) {
                                throw _e;
                            },
                            f: F
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return {
                    s: function s() {
                        it = o[Symbol.iterator]();
                    },
                    n: function n() {
                        var step = it.next();
                        normalCompletion = step.done;
                        return step;
                    },
                    e: function e(_e2) {
                        didErr = true;
                        err = _e2;
                    },
                    f: function f() {
                        try {
                            if (!normalCompletion && it.return != null) it.return();
                        } finally{
                            if (didErr) throw err;
                        }
                    }
                };
            }
            function dropzone_unsupportedIterableToArray(o, minLen) {
                if (!o) return;
                if (typeof o === "string") return dropzone_arrayLikeToArray(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor) n = o.constructor.name;
                if (n === "Map" || n === "Set") return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dropzone_arrayLikeToArray(o, minLen);
            }
            function dropzone_arrayLikeToArray(arr, len) {
                if (len == null || len > arr.length) len = arr.length;
                for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
                return arr2;
            }
            function dropzone_classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            function dropzone_defineProperties(target, props) {
                for(var i = 0; i < props.length; i++){
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            function dropzone_createClass(Constructor, protoProps, staticProps) {
                if (protoProps) dropzone_defineProperties(Constructor.prototype, protoProps);
                if (staticProps) dropzone_defineProperties(Constructor, staticProps);
                return Constructor;
            }
            function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass) _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o1, p1) {
                _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                    o.__proto__ = p;
                    return o;
                };
                return _setPrototypeOf(o1, p1);
            }
            function _createSuper(Derived) {
                var hasNativeReflectConstruct = _isNativeReflectConstruct();
                return function _createSuperInternal() {
                    var Super = _getPrototypeOf(Derived), result;
                    if (hasNativeReflectConstruct) {
                        var NewTarget = _getPrototypeOf(this).constructor;
                        result = Reflect.construct(Super, arguments, NewTarget);
                    } else result = Super.apply(this, arguments);
                    return _possibleConstructorReturn(this, result);
                };
            }
            function _possibleConstructorReturn(self, call) {
                if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
                return _assertThisInitialized(self);
            }
            function _assertThisInitialized(self) {
                if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return self;
            }
            function _isNativeReflectConstruct() {
                if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                if (Reflect.construct.sham) return false;
                if (typeof Proxy === "function") return true;
                try {
                    Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                    return true;
                } catch (e) {
                    return false;
                }
            }
            function _getPrototypeOf(o2) {
                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                    return o.__proto__ || Object.getPrototypeOf(o);
                };
                return _getPrototypeOf(o2);
            }
            var Dropzone1 = /*#__PURE__*/ function(_Emitter) {
                _inherits(Dropzone, _Emitter);
                var _super = _createSuper(Dropzone);
                function Dropzone(el, options) {
                    var _this;
                    dropzone_classCallCheck(this, Dropzone);
                    _this = _super.call(this);
                    var fallback, left;
                    _this.element = el; // For backwards compatibility since the version was in the prototype previously
                    _this.version = Dropzone.version;
                    _this.clickableElements = [];
                    _this.listeners = [];
                    _this.files = []; // All files
                    if (typeof _this.element === "string") _this.element = document.querySelector(_this.element);
                     // Not checking if instance of HTMLElement or Element since IE9 is extremely weird.
                    if (!_this.element || _this.element.nodeType == null) throw new Error("Invalid dropzone element.");
                    if (_this.element.dropzone) throw new Error("Dropzone already attached.");
                     // Now add this dropzone to the instances.
                    Dropzone.instances.push(_assertThisInitialized(_this)); // Put the dropzone inside the element itself.
                    _this.element.dropzone = _assertThisInitialized(_this);
                    var elementOptions = (left = Dropzone.optionsForElement(_this.element)) != null ? left : {};
                    _this.options = Dropzone.extend({}, src_options, elementOptions, options != null ? options : {});
                    _this.options.previewTemplate = _this.options.previewTemplate.replace(/\n*/g, ""); // If the browser failed, just call the fallback and leave
                    if (_this.options.forceFallback || !Dropzone.isBrowserSupported()) return _possibleConstructorReturn(_this, _this.options.fallback.call(_assertThisInitialized(_this)));
                     // @options.url = @element.getAttribute "action" unless @options.url?
                    if (_this.options.url == null) _this.options.url = _this.element.getAttribute("action");
                    if (!_this.options.url) throw new Error("No URL provided.");
                    if (_this.options.acceptedFiles && _this.options.acceptedMimeTypes) throw new Error("You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.");
                    if (_this.options.uploadMultiple && _this.options.chunking) throw new Error("You cannot set both: uploadMultiple and chunking.");
                     // Backwards compatibility
                    if (_this.options.acceptedMimeTypes) {
                        _this.options.acceptedFiles = _this.options.acceptedMimeTypes;
                        delete _this.options.acceptedMimeTypes;
                    } // Backwards compatibility
                    if (_this.options.renameFilename != null) _this.options.renameFile = function(file) {
                        return _this.options.renameFilename.call(_assertThisInitialized(_this), file.name, file);
                    };
                    if (typeof _this.options.method === "string") _this.options.method = _this.options.method.toUpperCase();
                    if ((fallback = _this.getExistingFallback()) && fallback.parentNode) // Remove the fallback
                    fallback.parentNode.removeChild(fallback);
                     // Display previews in the previewsContainer element or the Dropzone element unless explicitly set to false
                    if (_this.options.previewsContainer !== false) {
                        if (_this.options.previewsContainer) _this.previewsContainer = Dropzone.getElement(_this.options.previewsContainer, "previewsContainer");
                        else _this.previewsContainer = _this.element;
                    }
                    if (_this.options.clickable) {
                        if (_this.options.clickable === true) _this.clickableElements = [
                            _this.element
                        ];
                        else _this.clickableElements = Dropzone.getElements(_this.options.clickable, "clickable");
                    }
                    _this.init();
                    return _this;
                } // Returns all files that have been accepted
                dropzone_createClass(Dropzone, [
                    {
                        key: "getAcceptedFiles",
                        value: function getAcceptedFiles() {
                            return this.files.filter(function(file) {
                                return file.accepted;
                            }).map(function(file) {
                                return file;
                            });
                        } // Returns all files that have been rejected
                    },
                    {
                        key: "getRejectedFiles",
                        value: function getRejectedFiles() {
                            return this.files.filter(function(file) {
                                return !file.accepted;
                            }).map(function(file) {
                                return file;
                            });
                        }
                    },
                    {
                        key: "getFilesWithStatus",
                        value: function getFilesWithStatus(status) {
                            return this.files.filter(function(file) {
                                return file.status === status;
                            }).map(function(file) {
                                return file;
                            });
                        } // Returns all files that are in the queue
                    },
                    {
                        key: "getQueuedFiles",
                        value: function getQueuedFiles() {
                            return this.getFilesWithStatus(Dropzone.QUEUED);
                        }
                    },
                    {
                        key: "getUploadingFiles",
                        value: function getUploadingFiles() {
                            return this.getFilesWithStatus(Dropzone.UPLOADING);
                        }
                    },
                    {
                        key: "getAddedFiles",
                        value: function getAddedFiles() {
                            return this.getFilesWithStatus(Dropzone.ADDED);
                        } // Files that are either queued or uploading
                    },
                    {
                        key: "getActiveFiles",
                        value: function getActiveFiles() {
                            return this.files.filter(function(file) {
                                return file.status === Dropzone.UPLOADING || file.status === Dropzone.QUEUED;
                            }).map(function(file) {
                                return file;
                            });
                        } // The function that gets called when Dropzone is initialized. You
                    },
                    {
                        key: "init",
                        value: function init() {
                            var _this2 = this;
                            // In case it isn't set already
                            if (this.element.tagName === "form") this.element.setAttribute("enctype", "multipart/form-data");
                            if (this.element.classList.contains("dropzone") && !this.element.querySelector(".dz-message")) this.element.appendChild(Dropzone.createElement("<div class=\"dz-default dz-message\"><button class=\"dz-button\" type=\"button\">".concat(this.options.dictDefaultMessage, "</button></div>")));
                            if (this.clickableElements.length) {
                                var setupHiddenFileInput1 = function setupHiddenFileInput() {
                                    if (_this2.hiddenFileInput) _this2.hiddenFileInput.parentNode.removeChild(_this2.hiddenFileInput);
                                    _this2.hiddenFileInput = document.createElement("input");
                                    _this2.hiddenFileInput.setAttribute("type", "file");
                                    if (_this2.options.maxFiles === null || _this2.options.maxFiles > 1) _this2.hiddenFileInput.setAttribute("multiple", "multiple");
                                    _this2.hiddenFileInput.className = "dz-hidden-input";
                                    if (_this2.options.acceptedFiles !== null) _this2.hiddenFileInput.setAttribute("accept", _this2.options.acceptedFiles);
                                    if (_this2.options.capture !== null) _this2.hiddenFileInput.setAttribute("capture", _this2.options.capture);
                                     // Making sure that no one can "tab" into this field.
                                    _this2.hiddenFileInput.setAttribute("tabindex", "-1"); // Not setting `display="none"` because some browsers don't accept clicks
                                    // on elements that aren't displayed.
                                    _this2.hiddenFileInput.style.visibility = "hidden";
                                    _this2.hiddenFileInput.style.position = "absolute";
                                    _this2.hiddenFileInput.style.top = "0";
                                    _this2.hiddenFileInput.style.left = "0";
                                    _this2.hiddenFileInput.style.height = "0";
                                    _this2.hiddenFileInput.style.width = "0";
                                    Dropzone.getElement(_this2.options.hiddenInputContainer, "hiddenInputContainer").appendChild(_this2.hiddenFileInput);
                                    _this2.hiddenFileInput.addEventListener("change", function() {
                                        var files = _this2.hiddenFileInput.files;
                                        if (files.length) {
                                            var _iterator = dropzone_createForOfIteratorHelper(files, true), _step;
                                            try {
                                                for(_iterator.s(); !(_step = _iterator.n()).done;){
                                                    var file = _step.value;
                                                    _this2.addFile(file);
                                                }
                                            } catch (err) {
                                                _iterator.e(err);
                                            } finally{
                                                _iterator.f();
                                            }
                                        }
                                        _this2.emit("addedfiles", files);
                                        setupHiddenFileInput();
                                    });
                                };
                                setupHiddenFileInput1();
                            }
                            this.URL = window.URL !== null ? window.URL : window.webkitURL; // Setup all event listeners on the Dropzone object itself.
                            // They're not in @setupEventListeners() because they shouldn't be removed
                            // again when the dropzone gets disabled.
                            var _iterator2 = dropzone_createForOfIteratorHelper(this.events, true), _step2;
                            try {
                                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                                    var eventName = _step2.value;
                                    this.on(eventName, this.options[eventName]);
                                }
                            } catch (err) {
                                _iterator2.e(err);
                            } finally{
                                _iterator2.f();
                            }
                            this.on("uploadprogress", function() {
                                return _this2.updateTotalUploadProgress();
                            });
                            this.on("removedfile", function() {
                                return _this2.updateTotalUploadProgress();
                            });
                            this.on("canceled", function(file) {
                                return _this2.emit("complete", file);
                            }); // Emit a `queuecomplete` event if all files finished uploading.
                            this.on("complete", function(file) {
                                if (_this2.getAddedFiles().length === 0 && _this2.getUploadingFiles().length === 0 && _this2.getQueuedFiles().length === 0) // This needs to be deferred so that `queuecomplete` really triggers after `complete`
                                return setTimeout(function() {
                                    return _this2.emit("queuecomplete");
                                }, 0);
                            });
                            var containsFiles = function containsFiles(e) {
                                if (e.dataTransfer.types) // Because e.dataTransfer.types is an Object in
                                // IE, we need to iterate like this instead of
                                // using e.dataTransfer.types.some()
                                for(var i = 0; i < e.dataTransfer.types.length; i++){
                                    if (e.dataTransfer.types[i] === "Files") return true;
                                }
                                return false;
                            };
                            var noPropagation = function noPropagation(e) {
                                // If there are no files, we don't want to stop
                                // propagation so we don't interfere with other
                                // drag and drop behaviour.
                                if (!containsFiles(e)) return;
                                e.stopPropagation();
                                if (e.preventDefault) return e.preventDefault();
                                else return e.returnValue = false;
                            }; // Create the listeners
                            this.listeners = [
                                {
                                    element: this.element,
                                    events: {
                                        dragstart: function dragstart(e) {
                                            return _this2.emit("dragstart", e);
                                        },
                                        dragenter: function dragenter(e) {
                                            noPropagation(e);
                                            return _this2.emit("dragenter", e);
                                        },
                                        dragover: function dragover(e) {
                                            // Makes it possible to drag files from chrome's download bar
                                            // http://stackoverflow.com/questions/19526430/drag-and-drop-file-uploads-from-chrome-downloads-bar
                                            // Try is required to prevent bug in Internet Explorer 11 (SCRIPT65535 exception)
                                            var efct;
                                            try {
                                                efct = e.dataTransfer.effectAllowed;
                                            } catch (error) {}
                                            e.dataTransfer.dropEffect = "move" === efct || "linkMove" === efct ? "move" : "copy";
                                            noPropagation(e);
                                            return _this2.emit("dragover", e);
                                        },
                                        dragleave: function dragleave(e) {
                                            return _this2.emit("dragleave", e);
                                        },
                                        drop: function drop(e) {
                                            noPropagation(e);
                                            return _this2.drop(e);
                                        },
                                        dragend: function dragend(e) {
                                            return _this2.emit("dragend", e);
                                        }
                                    } // This is disabled right now, because the browsers don't implement it properly.
                                }
                            ];
                            this.clickableElements.forEach(function(clickableElement) {
                                return _this2.listeners.push({
                                    element: clickableElement,
                                    events: {
                                        click: function click(evt) {
                                            // Only the actual dropzone or the message element should trigger file selection
                                            if (clickableElement !== _this2.element || evt.target === _this2.element || Dropzone.elementInside(evt.target, _this2.element.querySelector(".dz-message"))) _this2.hiddenFileInput.click(); // Forward the click
                                            return true;
                                        }
                                    }
                                });
                            });
                            this.enable();
                            return this.options.init.call(this);
                        } // Not fully tested yet
                    },
                    {
                        key: "destroy",
                        value: function destroy() {
                            this.disable();
                            this.removeAllFiles(true);
                            if (this.hiddenFileInput != null ? this.hiddenFileInput.parentNode : undefined) {
                                this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);
                                this.hiddenFileInput = null;
                            }
                            delete this.element.dropzone;
                            return Dropzone.instances.splice(Dropzone.instances.indexOf(this), 1);
                        }
                    },
                    {
                        key: "updateTotalUploadProgress",
                        value: function updateTotalUploadProgress() {
                            var totalUploadProgress;
                            var totalBytesSent = 0;
                            var totalBytes = 0;
                            var activeFiles = this.getActiveFiles();
                            if (activeFiles.length) {
                                var _iterator3 = dropzone_createForOfIteratorHelper(this.getActiveFiles(), true), _step3;
                                try {
                                    for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                                        var file = _step3.value;
                                        totalBytesSent += file.upload.bytesSent;
                                        totalBytes += file.upload.total;
                                    }
                                } catch (err) {
                                    _iterator3.e(err);
                                } finally{
                                    _iterator3.f();
                                }
                                totalUploadProgress = 100 * totalBytesSent / totalBytes;
                            } else totalUploadProgress = 100;
                            return this.emit("totaluploadprogress", totalUploadProgress, totalBytes, totalBytesSent);
                        } // @options.paramName can be a function taking one parameter rather than a string.
                    },
                    {
                        key: "_getParamName",
                        value: function _getParamName(n) {
                            if (typeof this.options.paramName === "function") return this.options.paramName(n);
                            else return "".concat(this.options.paramName).concat(this.options.uploadMultiple ? "[".concat(n, "]") : "");
                        } // If @options.renameFile is a function,
                    },
                    {
                        key: "_renameFile",
                        value: function _renameFile(file) {
                            if (typeof this.options.renameFile !== "function") return file.name;
                            return this.options.renameFile(file);
                        } // Returns a form that can be used as fallback if the browser does not support DragnDrop
                    },
                    {
                        key: "getFallbackForm",
                        value: function getFallbackForm() {
                            var existingFallback, form;
                            if (existingFallback = this.getExistingFallback()) return existingFallback;
                            var fieldsString = '<div class="dz-fallback">';
                            if (this.options.dictFallbackText) fieldsString += "<p>".concat(this.options.dictFallbackText, "</p>");
                            fieldsString += "<input type=\"file\" name=\"".concat(this._getParamName(0), "\" ").concat(this.options.uploadMultiple ? 'multiple="multiple"' : undefined, " /><input type=\"submit\" value=\"Upload!\"></div>");
                            var fields = Dropzone.createElement(fieldsString);
                            if (this.element.tagName !== "FORM") {
                                form = Dropzone.createElement("<form action=\"".concat(this.options.url, "\" enctype=\"multipart/form-data\" method=\"").concat(this.options.method, "\"></form>"));
                                form.appendChild(fields);
                            } else {
                                // Make sure that the enctype and method attributes are set properly
                                this.element.setAttribute("enctype", "multipart/form-data");
                                this.element.setAttribute("method", this.options.method);
                            }
                            return form != null ? form : fields;
                        } // Returns the fallback elements if they exist already
                    },
                    {
                        key: "getExistingFallback",
                        value: function getExistingFallback() {
                            var getFallback = function getFallback(elements) {
                                var _iterator4 = dropzone_createForOfIteratorHelper(elements, true), _step4;
                                try {
                                    for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                                        var el = _step4.value;
                                        if (/(^| )fallback($| )/.test(el.className)) return el;
                                    }
                                } catch (err) {
                                    _iterator4.e(err);
                                } finally{
                                    _iterator4.f();
                                }
                            };
                            for(var _i = 0, _arr = [
                                "div",
                                "form"
                            ]; _i < _arr.length; _i++){
                                var tagName = _arr[_i];
                                var fallback;
                                if (fallback = getFallback(this.element.getElementsByTagName(tagName))) return fallback;
                            }
                        } // Activates all listeners stored in @listeners
                    },
                    {
                        key: "setupEventListeners",
                        value: function setupEventListeners() {
                            return this.listeners.map(function(elementListeners) {
                                return function() {
                                    var result = [];
                                    for(var event in elementListeners.events){
                                        var listener = elementListeners.events[event];
                                        result.push(elementListeners.element.addEventListener(event, listener, false));
                                    }
                                    return result;
                                }();
                            });
                        } // Deactivates all listeners stored in @listeners
                    },
                    {
                        key: "removeEventListeners",
                        value: function removeEventListeners() {
                            return this.listeners.map(function(elementListeners) {
                                return function() {
                                    var result = [];
                                    for(var event in elementListeners.events){
                                        var listener = elementListeners.events[event];
                                        result.push(elementListeners.element.removeEventListener(event, listener, false));
                                    }
                                    return result;
                                }();
                            });
                        } // Removes all event listeners and cancels all files in the queue or being processed.
                    },
                    {
                        key: "disable",
                        value: function disable() {
                            var _this3 = this;
                            this.clickableElements.forEach(function(element) {
                                return element.classList.remove("dz-clickable");
                            });
                            this.removeEventListeners();
                            this.disabled = true;
                            return this.files.map(function(file) {
                                return _this3.cancelUpload(file);
                            });
                        }
                    },
                    {
                        key: "enable",
                        value: function enable() {
                            delete this.disabled;
                            this.clickableElements.forEach(function(element) {
                                return element.classList.add("dz-clickable");
                            });
                            return this.setupEventListeners();
                        } // Returns a nicely formatted filesize
                    },
                    {
                        key: "filesize",
                        value: function filesize(size) {
                            var selectedSize = 0;
                            var selectedUnit = "b";
                            if (size > 0) {
                                var units = [
                                    "tb",
                                    "gb",
                                    "mb",
                                    "kb",
                                    "b"
                                ];
                                for(var i = 0; i < units.length; i++){
                                    var unit = units[i];
                                    var cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;
                                    if (size >= cutoff) {
                                        selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);
                                        selectedUnit = unit;
                                        break;
                                    }
                                }
                                selectedSize = Math.round(10 * selectedSize) / 10; // Cutting of digits
                            }
                            return "<strong>".concat(selectedSize, "</strong> ").concat(this.options.dictFileSizeUnits[selectedUnit]);
                        } // Adds or removes the `dz-max-files-reached` class from the form.
                    },
                    {
                        key: "_updateMaxFilesReachedClass",
                        value: function _updateMaxFilesReachedClass() {
                            if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
                                if (this.getAcceptedFiles().length === this.options.maxFiles) this.emit("maxfilesreached", this.files);
                                return this.element.classList.add("dz-max-files-reached");
                            } else return this.element.classList.remove("dz-max-files-reached");
                        }
                    },
                    {
                        key: "drop",
                        value: function drop(e) {
                            if (!e.dataTransfer) return;
                            this.emit("drop", e); // Convert the FileList to an Array
                            // This is necessary for IE11
                            var files = [];
                            for(var i = 0; i < e.dataTransfer.files.length; i++)files[i] = e.dataTransfer.files[i];
                             // Even if it's a folder, files.length will contain the folders.
                            if (files.length) {
                                var items = e.dataTransfer.items;
                                if (items && items.length && items[0].webkitGetAsEntry != null) // The browser supports dropping of folders, so handle items instead of files
                                this._addFilesFromItems(items);
                                else this.handleFiles(files);
                            }
                            this.emit("addedfiles", files);
                        }
                    },
                    {
                        key: "paste",
                        value: function paste(e) {
                            if (__guard__(e != null ? e.clipboardData : undefined, function(x) {
                                return x.items;
                            }) == null) return;
                            this.emit("paste", e);
                            var items = e.clipboardData.items;
                            if (items.length) return this._addFilesFromItems(items);
                        }
                    },
                    {
                        key: "handleFiles",
                        value: function handleFiles(files) {
                            var _iterator5 = dropzone_createForOfIteratorHelper(files, true), _step5;
                            try {
                                for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                                    var file = _step5.value;
                                    this.addFile(file);
                                }
                            } catch (err) {
                                _iterator5.e(err);
                            } finally{
                                _iterator5.f();
                            }
                        } // When a folder is dropped (or files are pasted), items must be handled
                    },
                    {
                        key: "_addFilesFromItems",
                        value: function _addFilesFromItems(items) {
                            var _this4 = this;
                            return function() {
                                var result = [];
                                var _iterator6 = dropzone_createForOfIteratorHelper(items, true), _step6;
                                try {
                                    for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){
                                        var item = _step6.value;
                                        var entry;
                                        if (item.webkitGetAsEntry != null && (entry = item.webkitGetAsEntry())) {
                                            if (entry.isFile) result.push(_this4.addFile(item.getAsFile()));
                                            else if (entry.isDirectory) // Append all files from that directory to files
                                            result.push(_this4._addFilesFromDirectory(entry, entry.name));
                                            else result.push(undefined);
                                        } else if (item.getAsFile != null) {
                                            if (item.kind == null || item.kind === "file") result.push(_this4.addFile(item.getAsFile()));
                                            else result.push(undefined);
                                        } else result.push(undefined);
                                    }
                                } catch (err) {
                                    _iterator6.e(err);
                                } finally{
                                    _iterator6.f();
                                }
                                return result;
                            }();
                        } // Goes through the directory, and adds each file it finds recursively
                    },
                    {
                        key: "_addFilesFromDirectory",
                        value: function _addFilesFromDirectory(directory, path) {
                            var _this5 = this;
                            var dirReader = directory.createReader();
                            var errorHandler = function errorHandler(error) {
                                return __guardMethod__(console, "log", function(o) {
                                    return o.log(error);
                                });
                            };
                            var readEntries1 = function readEntries() {
                                return dirReader.readEntries(function(entries) {
                                    if (entries.length > 0) {
                                        var _iterator7 = dropzone_createForOfIteratorHelper(entries, true), _step7;
                                        try {
                                            for(_iterator7.s(); !(_step7 = _iterator7.n()).done;){
                                                var entry = _step7.value;
                                                if (entry.isFile) entry.file(function(file) {
                                                    if (_this5.options.ignoreHiddenFiles && file.name.substring(0, 1) === ".") return;
                                                    file.fullPath = "".concat(path, "/").concat(file.name);
                                                    return _this5.addFile(file);
                                                });
                                                else if (entry.isDirectory) _this5._addFilesFromDirectory(entry, "".concat(path, "/").concat(entry.name));
                                            } // Recursively call readEntries() again, since browser only handle
                                        // the first 100 entries.
                                        // See: https://developer.mozilla.org/en-US/docs/Web/API/DirectoryReader#readEntries
                                        } catch (err) {
                                            _iterator7.e(err);
                                        } finally{
                                            _iterator7.f();
                                        }
                                        readEntries();
                                    }
                                    return null;
                                }, errorHandler);
                            };
                            return readEntries1();
                        } // If `done()` is called without argument the file is accepted
                    },
                    {
                        key: "accept",
                        value: function accept(file, done) {
                            if (this.options.maxFilesize && file.size > this.options.maxFilesize * 1048576) done(this.options.dictFileTooBig.replace("{{filesize}}", Math.round(file.size / 1024 / 10.24) / 100).replace("{{maxFilesize}}", this.options.maxFilesize));
                            else if (!Dropzone.isValidFile(file, this.options.acceptedFiles)) done(this.options.dictInvalidFileType);
                            else if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
                                done(this.options.dictMaxFilesExceeded.replace("{{maxFiles}}", this.options.maxFiles));
                                this.emit("maxfilesexceeded", file);
                            } else this.options.accept.call(this, file, done);
                        }
                    },
                    {
                        key: "addFile",
                        value: function addFile(file) {
                            var _this6 = this;
                            file.upload = {
                                uuid: Dropzone.uuidv4(),
                                progress: 0,
                                // Setting the total upload size to file.size for the beginning
                                // It's actual different than the size to be transmitted.
                                total: file.size,
                                bytesSent: 0,
                                filename: this._renameFile(file) // Not setting chunking information here, because the acutal data â€” and
                            };
                            this.files.push(file);
                            file.status = Dropzone.ADDED;
                            this.emit("addedfile", file);
                            this._enqueueThumbnail(file);
                            this.accept(file, function(error) {
                                if (error) {
                                    file.accepted = false;
                                    _this6._errorProcessing([
                                        file
                                    ], error); // Will set the file.status
                                } else {
                                    file.accepted = true;
                                    if (_this6.options.autoQueue) _this6.enqueueFile(file);
                                     // Will set .accepted = true
                                }
                                _this6._updateMaxFilesReachedClass();
                            });
                        } // Wrapper for enqueueFile
                    },
                    {
                        key: "enqueueFiles",
                        value: function enqueueFiles(files) {
                            var _iterator8 = dropzone_createForOfIteratorHelper(files, true), _step8;
                            try {
                                for(_iterator8.s(); !(_step8 = _iterator8.n()).done;){
                                    var file = _step8.value;
                                    this.enqueueFile(file);
                                }
                            } catch (err) {
                                _iterator8.e(err);
                            } finally{
                                _iterator8.f();
                            }
                            return null;
                        }
                    },
                    {
                        key: "enqueueFile",
                        value: function enqueueFile(file) {
                            var _this7 = this;
                            if (file.status === Dropzone.ADDED && file.accepted === true) {
                                file.status = Dropzone.QUEUED;
                                if (this.options.autoProcessQueue) return setTimeout(function() {
                                    return _this7.processQueue();
                                }, 0); // Deferring the call
                            } else throw new Error("This file can't be queued because it has already been processed or was rejected.");
                        }
                    },
                    {
                        key: "_enqueueThumbnail",
                        value: function _enqueueThumbnail(file) {
                            var _this8 = this;
                            if (this.options.createImageThumbnails && file.type.match(/image.*/) && file.size <= this.options.maxThumbnailFilesize * 1048576) {
                                this._thumbnailQueue.push(file);
                                return setTimeout(function() {
                                    return _this8._processThumbnailQueue();
                                }, 0); // Deferring the call
                            }
                        }
                    },
                    {
                        key: "_processThumbnailQueue",
                        value: function _processThumbnailQueue() {
                            var _this9 = this;
                            if (this._processingThumbnail || this._thumbnailQueue.length === 0) return;
                            this._processingThumbnail = true;
                            var file = this._thumbnailQueue.shift();
                            return this.createThumbnail(file, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, true, function(dataUrl) {
                                _this9.emit("thumbnail", file, dataUrl);
                                _this9._processingThumbnail = false;
                                return _this9._processThumbnailQueue();
                            });
                        } // Can be called by the user to remove a file
                    },
                    {
                        key: "removeFile",
                        value: function removeFile(file) {
                            if (file.status === Dropzone.UPLOADING) this.cancelUpload(file);
                            this.files = without(this.files, file);
                            this.emit("removedfile", file);
                            if (this.files.length === 0) return this.emit("reset");
                        } // Removes all files that aren't currently processed from the list
                    },
                    {
                        key: "removeAllFiles",
                        value: function removeAllFiles(cancelIfNecessary) {
                            // Create a copy of files since removeFile() changes the @files array.
                            if (cancelIfNecessary == null) cancelIfNecessary = false;
                            var _iterator9 = dropzone_createForOfIteratorHelper(this.files.slice(), true), _step9;
                            try {
                                for(_iterator9.s(); !(_step9 = _iterator9.n()).done;){
                                    var file = _step9.value;
                                    if (file.status !== Dropzone.UPLOADING || cancelIfNecessary) this.removeFile(file);
                                }
                            } catch (err) {
                                _iterator9.e(err);
                            } finally{
                                _iterator9.f();
                            }
                            return null;
                        } // Resizes an image before it gets sent to the server. This function is the default behavior of
                    },
                    {
                        key: "resizeImage",
                        value: function resizeImage(file, width, height, resizeMethod, callback) {
                            var _this10 = this;
                            return this.createThumbnail(file, width, height, resizeMethod, true, function(dataUrl, canvas) {
                                if (canvas == null) // The image has not been resized
                                return callback(file);
                                else {
                                    var resizeMimeType = _this10.options.resizeMimeType;
                                    if (resizeMimeType == null) resizeMimeType = file.type;
                                    var resizedDataURL = canvas.toDataURL(resizeMimeType, _this10.options.resizeQuality);
                                    if (resizeMimeType === "image/jpeg" || resizeMimeType === "image/jpg") // Now add the original EXIF information
                                    resizedDataURL = ExifRestore1.restore(file.dataURL, resizedDataURL);
                                    return callback(Dropzone.dataURItoBlob(resizedDataURL));
                                }
                            });
                        }
                    },
                    {
                        key: "createThumbnail",
                        value: function createThumbnail(file, width, height, resizeMethod, fixOrientation, callback) {
                            var _this11 = this;
                            var fileReader = new FileReader();
                            fileReader.onload = function() {
                                file.dataURL = fileReader.result; // Don't bother creating a thumbnail for SVG images since they're vector
                                if (file.type === "image/svg+xml") {
                                    if (callback != null) callback(fileReader.result);
                                    return;
                                }
                                _this11.createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback);
                            };
                            fileReader.readAsDataURL(file);
                        } // `mockFile` needs to have these attributes:
                    },
                    {
                        key: "displayExistingFile",
                        value: function displayExistingFile(mockFile, imageUrl, callback, crossOrigin) {
                            var _this12 = this;
                            var resizeThumbnail = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
                            this.emit("addedfile", mockFile);
                            this.emit("complete", mockFile);
                            if (!resizeThumbnail) {
                                this.emit("thumbnail", mockFile, imageUrl);
                                if (callback) callback();
                            } else {
                                var onDone = function onDone(thumbnail) {
                                    _this12.emit("thumbnail", mockFile, thumbnail);
                                    if (callback) callback();
                                };
                                mockFile.dataURL = imageUrl;
                                this.createThumbnailFromUrl(mockFile, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, this.options.fixOrientation, onDone, crossOrigin);
                            }
                        }
                    },
                    {
                        key: "createThumbnailFromUrl",
                        value: function createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback1, crossOrigin) {
                            var _this13 = this;
                            // Not using `new Image` here because of a bug in latest Chrome versions.
                            // See https://github.com/enyo/dropzone/pull/226
                            var img = document.createElement("img");
                            if (crossOrigin) img.crossOrigin = crossOrigin;
                             // fixOrientation is not needed anymore with browsers handling imageOrientation
                            fixOrientation = getComputedStyle(document.body)["imageOrientation"] == "from-image" ? false : fixOrientation;
                            img.onload = function() {
                                var loadExif = function loadExif(callback) {
                                    return callback(1);
                                };
                                if (typeof EXIF !== "undefined" && EXIF !== null && fixOrientation) loadExif = function loadExif(callback) {
                                    return EXIF.getData(img, function() {
                                        return callback(EXIF.getTag(this, "Orientation"));
                                    });
                                };
                                return loadExif(function(orientation) {
                                    file.width = img.width;
                                    file.height = img.height;
                                    var resizeInfo = _this13.options.resize.call(_this13, file, width, height, resizeMethod);
                                    var canvas = document.createElement("canvas");
                                    var ctx = canvas.getContext("2d");
                                    canvas.width = resizeInfo.trgWidth;
                                    canvas.height = resizeInfo.trgHeight;
                                    if (orientation > 4) {
                                        canvas.width = resizeInfo.trgHeight;
                                        canvas.height = resizeInfo.trgWidth;
                                    }
                                    switch(orientation){
                                        case 2:
                                            // horizontal flip
                                            ctx.translate(canvas.width, 0);
                                            ctx.scale(-1, 1);
                                            break;
                                        case 3:
                                            // 180Â° rotate left
                                            ctx.translate(canvas.width, canvas.height);
                                            ctx.rotate(Math.PI);
                                            break;
                                        case 4:
                                            // vertical flip
                                            ctx.translate(0, canvas.height);
                                            ctx.scale(1, -1);
                                            break;
                                        case 5:
                                            // vertical flip + 90 rotate right
                                            ctx.rotate(0.5 * Math.PI);
                                            ctx.scale(1, -1);
                                            break;
                                        case 6:
                                            // 90Â° rotate right
                                            ctx.rotate(0.5 * Math.PI);
                                            ctx.translate(0, -canvas.width);
                                            break;
                                        case 7:
                                            // horizontal flip + 90 rotate right
                                            ctx.rotate(0.5 * Math.PI);
                                            ctx.translate(canvas.height, -canvas.width);
                                            ctx.scale(-1, 1);
                                            break;
                                        case 8:
                                            // 90Â° rotate left
                                            ctx.rotate(-0.5 * Math.PI);
                                            ctx.translate(-canvas.height, 0);
                                            break;
                                    } // This is a bugfix for iOS' scaling bug.
                                    drawImageIOSFix(ctx, img, resizeInfo.srcX != null ? resizeInfo.srcX : 0, resizeInfo.srcY != null ? resizeInfo.srcY : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, resizeInfo.trgX != null ? resizeInfo.trgX : 0, resizeInfo.trgY != null ? resizeInfo.trgY : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);
                                    var thumbnail = canvas.toDataURL("image/png");
                                    if (callback1 != null) return callback1(thumbnail, canvas);
                                });
                            };
                            if (callback1 != null) img.onerror = callback1;
                            return img.src = file.dataURL;
                        } // Goes through the queue and processes files if there aren't too many already.
                    },
                    {
                        key: "processQueue",
                        value: function processQueue() {
                            var parallelUploads = this.options.parallelUploads;
                            var processingLength = this.getUploadingFiles().length;
                            var i = processingLength; // There are already at least as many files uploading than should be
                            if (processingLength >= parallelUploads) return;
                            var queuedFiles = this.getQueuedFiles();
                            if (!(queuedFiles.length > 0)) return;
                            if (this.options.uploadMultiple) // The files should be uploaded in one request
                            return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));
                            else while(i < parallelUploads){
                                if (!queuedFiles.length) return;
                                 // Nothing left to process
                                this.processFile(queuedFiles.shift());
                                i++;
                            }
                        } // Wrapper for `processFiles`
                    },
                    {
                        key: "processFile",
                        value: function processFile(file) {
                            return this.processFiles([
                                file
                            ]);
                        } // Loads the file, then calls finishedLoading()
                    },
                    {
                        key: "processFiles",
                        value: function processFiles(files) {
                            var _iterator10 = dropzone_createForOfIteratorHelper(files, true), _step10;
                            try {
                                for(_iterator10.s(); !(_step10 = _iterator10.n()).done;){
                                    var file = _step10.value;
                                    file.processing = true; // Backwards compatibility
                                    file.status = Dropzone.UPLOADING;
                                    this.emit("processing", file);
                                }
                            } catch (err) {
                                _iterator10.e(err);
                            } finally{
                                _iterator10.f();
                            }
                            if (this.options.uploadMultiple) this.emit("processingmultiple", files);
                            return this.uploadFiles(files);
                        }
                    },
                    {
                        key: "_getFilesWithXhr",
                        value: function _getFilesWithXhr(xhr) {
                            var files;
                            return files = this.files.filter(function(file) {
                                return file.xhr === xhr;
                            }).map(function(file) {
                                return file;
                            });
                        } // Cancels the file upload and sets the status to CANCELED
                    },
                    {
                        key: "cancelUpload",
                        value: function cancelUpload(file) {
                            if (file.status === Dropzone.UPLOADING) {
                                var groupedFiles = this._getFilesWithXhr(file.xhr);
                                var _iterator11 = dropzone_createForOfIteratorHelper(groupedFiles, true), _step11;
                                try {
                                    for(_iterator11.s(); !(_step11 = _iterator11.n()).done;){
                                        var groupedFile = _step11.value;
                                        groupedFile.status = Dropzone.CANCELED;
                                    }
                                } catch (err) {
                                    _iterator11.e(err);
                                } finally{
                                    _iterator11.f();
                                }
                                if (typeof file.xhr !== "undefined") file.xhr.abort();
                                var _iterator12 = dropzone_createForOfIteratorHelper(groupedFiles, true), _step12;
                                try {
                                    for(_iterator12.s(); !(_step12 = _iterator12.n()).done;){
                                        var _groupedFile = _step12.value;
                                        this.emit("canceled", _groupedFile);
                                    }
                                } catch (err3) {
                                    _iterator12.e(err3);
                                } finally{
                                    _iterator12.f();
                                }
                                if (this.options.uploadMultiple) this.emit("canceledmultiple", groupedFiles);
                            } else if (file.status === Dropzone.ADDED || file.status === Dropzone.QUEUED) {
                                file.status = Dropzone.CANCELED;
                                this.emit("canceled", file);
                                if (this.options.uploadMultiple) this.emit("canceledmultiple", [
                                    file
                                ]);
                            }
                            if (this.options.autoProcessQueue) return this.processQueue();
                        }
                    },
                    {
                        key: "resolveOption",
                        value: function resolveOption(option) {
                            if (typeof option === "function") {
                                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
                                return option.apply(this, args);
                            }
                            return option;
                        }
                    },
                    {
                        key: "uploadFile",
                        value: function uploadFile(file) {
                            return this.uploadFiles([
                                file
                            ]);
                        }
                    },
                    {
                        key: "uploadFiles",
                        value: function uploadFiles(files) {
                            var _this14 = this;
                            this._transformFiles(files, function(transformedFiles) {
                                if (_this14.options.chunking) {
                                    // Chunking is not allowed to be used with `uploadMultiple` so we know
                                    // that there is only __one__file.
                                    var transformedFile = transformedFiles[0];
                                    files[0].upload.chunked = _this14.options.chunking && (_this14.options.forceChunking || transformedFile.size > _this14.options.chunkSize);
                                    files[0].upload.totalChunkCount = Math.ceil(transformedFile.size / _this14.options.chunkSize);
                                }
                                if (files[0].upload.chunked) {
                                    // This file should be sent in chunks!
                                    // If the chunking option is set, we **know** that there can only be **one** file, since
                                    // uploadMultiple is not allowed with this option.
                                    var file = files[0];
                                    var _transformedFile = transformedFiles[0];
                                    var startedChunkCount = 0;
                                    file.upload.chunks = [];
                                    var handleNextChunk = function handleNextChunk() {
                                        var chunkIndex = 0; // Find the next item in file.upload.chunks that is not defined yet.
                                        while(file.upload.chunks[chunkIndex] !== undefined)chunkIndex++;
                                         // This means, that all chunks have already been started.
                                        if (chunkIndex >= file.upload.totalChunkCount) return;
                                        startedChunkCount++;
                                        var start = chunkIndex * _this14.options.chunkSize;
                                        var end = Math.min(start + _this14.options.chunkSize, _transformedFile.size);
                                        var dataBlock = {
                                            name: _this14._getParamName(0),
                                            data: _transformedFile.webkitSlice ? _transformedFile.webkitSlice(start, end) : _transformedFile.slice(start, end),
                                            filename: file.upload.filename,
                                            chunkIndex: chunkIndex
                                        };
                                        file.upload.chunks[chunkIndex] = {
                                            file: file,
                                            index: chunkIndex,
                                            dataBlock: dataBlock,
                                            // In case we want to retry.
                                            status: Dropzone.UPLOADING,
                                            progress: 0,
                                            retries: 0 // The number of times this block has been retried.
                                        };
                                        _this14._uploadData(files, [
                                            dataBlock
                                        ]);
                                    };
                                    file.upload.finishedChunkUpload = function(chunk, response) {
                                        var allFinished = true;
                                        chunk.status = Dropzone.SUCCESS; // Clear the data from the chunk
                                        chunk.dataBlock = null; // Leaving this reference to xhr intact here will cause memory leaks in some browsers
                                        chunk.xhr = null;
                                        for(var i = 0; i < file.upload.totalChunkCount; i++){
                                            if (file.upload.chunks[i] === undefined) return handleNextChunk();
                                            if (file.upload.chunks[i].status !== Dropzone.SUCCESS) allFinished = false;
                                        }
                                        if (allFinished) _this14.options.chunksUploaded(file, function() {
                                            _this14._finished(files, response, null);
                                        });
                                    };
                                    if (_this14.options.parallelChunkUploads) for(var i1 = 0; i1 < file.upload.totalChunkCount; i1++)handleNextChunk();
                                    else handleNextChunk();
                                } else {
                                    var dataBlocks = [];
                                    for(var _i2 = 0; _i2 < files.length; _i2++)dataBlocks[_i2] = {
                                        name: _this14._getParamName(_i2),
                                        data: transformedFiles[_i2],
                                        filename: files[_i2].upload.filename
                                    };
                                    _this14._uploadData(files, dataBlocks);
                                }
                            });
                        } /// Returns the right chunk for given file and xhr
                    },
                    {
                        key: "_getChunk",
                        value: function _getChunk(file, xhr) {
                            for(var i = 0; i < file.upload.totalChunkCount; i++){
                                if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].xhr === xhr) return file.upload.chunks[i];
                            }
                        } // This function actually uploads the file(s) to the server.
                    },
                    {
                        key: "_uploadData",
                        value: function _uploadData(files, dataBlocks) {
                            var _this15 = this;
                            var xhr = new XMLHttpRequest(); // Put the xhr object in the file objects to be able to reference it later.
                            var _iterator13 = dropzone_createForOfIteratorHelper(files, true), _step13;
                            try {
                                for(_iterator13.s(); !(_step13 = _iterator13.n()).done;){
                                    var file = _step13.value;
                                    file.xhr = xhr;
                                }
                            } catch (err) {
                                _iterator13.e(err);
                            } finally{
                                _iterator13.f();
                            }
                            if (files[0].upload.chunked) // Put the xhr object in the right chunk object, so it can be associated later, and found with _getChunk
                            files[0].upload.chunks[dataBlocks[0].chunkIndex].xhr = xhr;
                            var method = this.resolveOption(this.options.method, files);
                            var url = this.resolveOption(this.options.url, files);
                            xhr.open(method, url, true); // Setting the timeout after open because of IE11 issue: https://gitlab.com/meno/dropzone/issues/8
                            var timeout = this.resolveOption(this.options.timeout, files);
                            if (timeout) xhr.timeout = this.resolveOption(this.options.timeout, files); // Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179
                            xhr.withCredentials = !!this.options.withCredentials;
                            xhr.onload = function(e) {
                                _this15._finishedUploading(files, xhr, e);
                            };
                            xhr.ontimeout = function() {
                                _this15._handleUploadError(files, xhr, "Request timedout after ".concat(_this15.options.timeout / 1000, " seconds"));
                            };
                            xhr.onerror = function() {
                                _this15._handleUploadError(files, xhr);
                            }; // Some browsers do not have the .upload property
                            var progressObj = xhr.upload != null ? xhr.upload : xhr;
                            progressObj.onprogress = function(e) {
                                return _this15._updateFilesUploadProgress(files, xhr, e);
                            };
                            var headers = {
                                Accept: "application/json",
                                "Cache-Control": "no-cache",
                                "X-Requested-With": "XMLHttpRequest"
                            };
                            if (this.options.headers) Dropzone.extend(headers, this.options.headers);
                            for(var headerName in headers){
                                var headerValue = headers[headerName];
                                if (headerValue) xhr.setRequestHeader(headerName, headerValue);
                            }
                            var formData = new FormData(); // Adding all @options parameters
                            if (this.options.params) {
                                var additionalParams = this.options.params;
                                if (typeof additionalParams === "function") additionalParams = additionalParams.call(this, files, xhr, files[0].upload.chunked ? this._getChunk(files[0], xhr) : null);
                                for(var key in additionalParams){
                                    var value = additionalParams[key];
                                    if (Array.isArray(value)) // The additional parameter contains an array,
                                    // so lets iterate over it to attach each value
                                    // individually.
                                    for(var i = 0; i < value.length; i++)formData.append(key, value[i]);
                                    else formData.append(key, value);
                                }
                            } // Let the user add additional data if necessary
                            var _iterator14 = dropzone_createForOfIteratorHelper(files, true), _step14;
                            try {
                                for(_iterator14.s(); !(_step14 = _iterator14.n()).done;){
                                    var _file = _step14.value;
                                    this.emit("sending", _file, xhr, formData);
                                }
                            } catch (err4) {
                                _iterator14.e(err4);
                            } finally{
                                _iterator14.f();
                            }
                            if (this.options.uploadMultiple) this.emit("sendingmultiple", files, xhr, formData);
                            this._addFormElementData(formData); // Finally add the files
                            // Has to be last because some servers (eg: S3) expect the file to be the last parameter
                            for(var _i3 = 0; _i3 < dataBlocks.length; _i3++){
                                var dataBlock = dataBlocks[_i3];
                                formData.append(dataBlock.name, dataBlock.data, dataBlock.filename);
                            }
                            this.submitRequest(xhr, formData, files);
                        } // Transforms all files with this.options.transformFile and invokes done with the transformed files when done.
                    },
                    {
                        key: "_transformFiles",
                        value: function _transformFiles(files, done) {
                            var _this16 = this;
                            var transformedFiles = []; // Clumsy way of handling asynchronous calls, until I get to add a proper Future library.
                            var doneCounter = 0;
                            var _loop = function _loop(i) {
                                _this16.options.transformFile.call(_this16, files[i], function(transformedFile) {
                                    transformedFiles[i] = transformedFile;
                                    if (++doneCounter === files.length) done(transformedFiles);
                                });
                            };
                            for(var i3 = 0; i3 < files.length; i3++)_loop(i3);
                        } // Takes care of adding other input elements of the form to the AJAX request
                    },
                    {
                        key: "_addFormElementData",
                        value: function _addFormElementData(formData) {
                            // Take care of other input elements
                            if (this.element.tagName === "FORM") {
                                var _iterator15 = dropzone_createForOfIteratorHelper(this.element.querySelectorAll("input, textarea, select, button"), true), _step15;
                                try {
                                    for(_iterator15.s(); !(_step15 = _iterator15.n()).done;){
                                        var input = _step15.value;
                                        var inputName = input.getAttribute("name");
                                        var inputType = input.getAttribute("type");
                                        if (inputType) inputType = inputType.toLowerCase(); // If the input doesn't have a name, we can't use it.
                                        if (typeof inputName === "undefined" || inputName === null) continue;
                                        if (input.tagName === "SELECT" && input.hasAttribute("multiple")) {
                                            // Possibly multiple values
                                            var _iterator16 = dropzone_createForOfIteratorHelper(input.options, true), _step16;
                                            try {
                                                for(_iterator16.s(); !(_step16 = _iterator16.n()).done;){
                                                    var option = _step16.value;
                                                    if (option.selected) formData.append(inputName, option.value);
                                                }
                                            } catch (err) {
                                                _iterator16.e(err);
                                            } finally{
                                                _iterator16.f();
                                            }
                                        } else if (!inputType || inputType !== "checkbox" && inputType !== "radio" || input.checked) formData.append(inputName, input.value);
                                    }
                                } catch (err) {
                                    _iterator15.e(err);
                                } finally{
                                    _iterator15.f();
                                }
                            }
                        } // Invoked when there is new progress information about given files.
                    },
                    {
                        key: "_updateFilesUploadProgress",
                        value: function _updateFilesUploadProgress(files, xhr, e) {
                            if (!files[0].upload.chunked) {
                                // Handle file uploads without chunking
                                var _iterator17 = dropzone_createForOfIteratorHelper(files, true), _step17;
                                try {
                                    for(_iterator17.s(); !(_step17 = _iterator17.n()).done;){
                                        var file = _step17.value;
                                        if (file.upload.total && file.upload.bytesSent && file.upload.bytesSent == file.upload.total) continue;
                                        if (e) {
                                            file.upload.progress = 100 * e.loaded / e.total;
                                            file.upload.total = e.total;
                                            file.upload.bytesSent = e.loaded;
                                        } else {
                                            // No event, so we're at 100%
                                            file.upload.progress = 100;
                                            file.upload.bytesSent = file.upload.total;
                                        }
                                        this.emit("uploadprogress", file, file.upload.progress, file.upload.bytesSent);
                                    }
                                } catch (err) {
                                    _iterator17.e(err);
                                } finally{
                                    _iterator17.f();
                                }
                            } else {
                                // Handle chunked file uploads
                                // Chunked upload is not compatible with uploading multiple files in one
                                // request, so we know there's only one file.
                                var _file2 = files[0]; // Since this is a chunked upload, we need to update the appropriate chunk
                                // progress.
                                var chunk = this._getChunk(_file2, xhr);
                                if (e) {
                                    chunk.progress = 100 * e.loaded / e.total;
                                    chunk.total = e.total;
                                    chunk.bytesSent = e.loaded;
                                } else {
                                    // No event, so we're at 100%
                                    chunk.progress = 100;
                                    chunk.bytesSent = chunk.total;
                                } // Now tally the *file* upload progress from its individual chunks
                                _file2.upload.progress = 0;
                                _file2.upload.total = 0;
                                _file2.upload.bytesSent = 0;
                                for(var i = 0; i < _file2.upload.totalChunkCount; i++)if (_file2.upload.chunks[i] && typeof _file2.upload.chunks[i].progress !== "undefined") {
                                    _file2.upload.progress += _file2.upload.chunks[i].progress;
                                    _file2.upload.total += _file2.upload.chunks[i].total;
                                    _file2.upload.bytesSent += _file2.upload.chunks[i].bytesSent;
                                }
                                 // Since the process is a percentage, we need to divide by the amount of
                                // chunks we've used.
                                _file2.upload.progress = _file2.upload.progress / _file2.upload.totalChunkCount;
                                this.emit("uploadprogress", _file2, _file2.upload.progress, _file2.upload.bytesSent);
                            }
                        }
                    },
                    {
                        key: "_finishedUploading",
                        value: function _finishedUploading(files, xhr, e) {
                            var response;
                            if (files[0].status === Dropzone.CANCELED) return;
                            if (xhr.readyState !== 4) return;
                            if (xhr.responseType !== "arraybuffer" && xhr.responseType !== "blob") {
                                response = xhr.responseText;
                                if (xhr.getResponseHeader("content-type") && ~xhr.getResponseHeader("content-type").indexOf("application/json")) try {
                                    response = JSON.parse(response);
                                } catch (error) {
                                    e = error;
                                    response = "Invalid JSON response from server.";
                                }
                            }
                            this._updateFilesUploadProgress(files, xhr);
                            if (!(200 <= xhr.status && xhr.status < 300)) this._handleUploadError(files, xhr, response);
                            else if (files[0].upload.chunked) files[0].upload.finishedChunkUpload(this._getChunk(files[0], xhr), response);
                            else this._finished(files, response, e);
                        }
                    },
                    {
                        key: "_handleUploadError",
                        value: function _handleUploadError(files, xhr, response) {
                            if (files[0].status === Dropzone.CANCELED) return;
                            if (files[0].upload.chunked && this.options.retryChunks) {
                                var chunk = this._getChunk(files[0], xhr);
                                if ((chunk.retries++) < this.options.retryChunksLimit) {
                                    this._uploadData(files, [
                                        chunk.dataBlock
                                    ]);
                                    return;
                                } else console.warn("Retried this chunk too often. Giving up.");
                            }
                            this._errorProcessing(files, response || this.options.dictResponseError.replace("{{statusCode}}", xhr.status), xhr);
                        }
                    },
                    {
                        key: "submitRequest",
                        value: function submitRequest(xhr, formData, files) {
                            if (xhr.readyState != 1) {
                                console.warn("Cannot send this request because the XMLHttpRequest.readyState is not OPENED.");
                                return;
                            }
                            xhr.send(formData);
                        } // Called internally when processing is finished.
                    },
                    {
                        key: "_finished",
                        value: function _finished(files, responseText, e) {
                            var _iterator18 = dropzone_createForOfIteratorHelper(files, true), _step18;
                            try {
                                for(_iterator18.s(); !(_step18 = _iterator18.n()).done;){
                                    var file = _step18.value;
                                    file.status = Dropzone.SUCCESS;
                                    this.emit("success", file, responseText, e);
                                    this.emit("complete", file);
                                }
                            } catch (err) {
                                _iterator18.e(err);
                            } finally{
                                _iterator18.f();
                            }
                            if (this.options.uploadMultiple) {
                                this.emit("successmultiple", files, responseText, e);
                                this.emit("completemultiple", files);
                            }
                            if (this.options.autoProcessQueue) return this.processQueue();
                        } // Called internally when processing is finished.
                    },
                    {
                        key: "_errorProcessing",
                        value: function _errorProcessing(files, message, xhr) {
                            var _iterator19 = dropzone_createForOfIteratorHelper(files, true), _step19;
                            try {
                                for(_iterator19.s(); !(_step19 = _iterator19.n()).done;){
                                    var file = _step19.value;
                                    file.status = Dropzone.ERROR;
                                    this.emit("error", file, message, xhr);
                                    this.emit("complete", file);
                                }
                            } catch (err) {
                                _iterator19.e(err);
                            } finally{
                                _iterator19.f();
                            }
                            if (this.options.uploadMultiple) {
                                this.emit("errormultiple", files, message, xhr);
                                this.emit("completemultiple", files);
                            }
                            if (this.options.autoProcessQueue) return this.processQueue();
                        }
                    }
                ], [
                    {
                        key: "initClass",
                        value: function initClass() {
                            // Exposing the emitter class, mainly for tests
                            this.prototype.Emitter = Emitter1;
                            /*
       This is a list of all available events you can register on a dropzone object.
        You can register an event handler like this:
        dropzone.on("dragEnter", function() { });
        */ this.prototype.events = [
                                "drop",
                                "dragstart",
                                "dragend",
                                "dragenter",
                                "dragover",
                                "dragleave",
                                "addedfile",
                                "addedfiles",
                                "removedfile",
                                "thumbnail",
                                "error",
                                "errormultiple",
                                "processing",
                                "processingmultiple",
                                "uploadprogress",
                                "totaluploadprogress",
                                "sending",
                                "sendingmultiple",
                                "success",
                                "successmultiple",
                                "canceled",
                                "canceledmultiple",
                                "complete",
                                "completemultiple",
                                "reset",
                                "maxfilesexceeded",
                                "maxfilesreached",
                                "queuecomplete"
                            ];
                            this.prototype._thumbnailQueue = [];
                            this.prototype._processingThumbnail = false;
                        } // global utility
                    },
                    {
                        key: "extend",
                        value: function extend(target) {
                            for(var _len2 = arguments.length, objects = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)objects[_key2 - 1] = arguments[_key2];
                            for(var _i4 = 0, _objects = objects; _i4 < _objects.length; _i4++){
                                var object = _objects[_i4];
                                for(var key in object){
                                    var val = object[key];
                                    target[key] = val;
                                }
                            }
                            return target;
                        }
                    },
                    {
                        key: "uuidv4",
                        value: function uuidv4() {
                            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
                                var r = Math.random() * 16 | 0, v = c === "x" ? r : r & 0x3 | 0x8;
                                return v.toString(16);
                            });
                        }
                    }
                ]);
                return Dropzone;
            }(Emitter1);
            Dropzone1.initClass();
            Dropzone1.version = "5.9.3"; // This is a map of options for your different dropzones. Add configurations
            // to this object for your different dropzone elemens.
            //
            // Example:
            //
            //     Dropzone.options.myDropzoneElementId = { maxFilesize: 1 };
            //
            // To disable autoDiscover for a specific element, you can set `false` as an option:
            //
            //     Dropzone.options.myDisabledElementId = false;
            //
            // And in html:
            //
            //     <form action="/upload" id="my-dropzone-element-id" class="dropzone"></form>
            Dropzone1.options = {}; // Returns the options for an element or undefined if none available.
            Dropzone1.optionsForElement = function(element) {
                // Get the `Dropzone.options.elementId` for this element if it exists
                if (element.getAttribute("id")) return Dropzone1.options[camelize(element.getAttribute("id"))];
                else return undefined;
            }; // Holds a list of all dropzone instances
            Dropzone1.instances = []; // Returns the dropzone for given element if any
            Dropzone1.forElement = function(element) {
                if (typeof element === "string") element = document.querySelector(element);
                if ((element != null ? element.dropzone : undefined) == null) throw new Error("No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.");
                return element.dropzone;
            }; // Set to false if you don't want Dropzone to automatically find and attach to .dropzone elements.
            Dropzone1.autoDiscover = true; // Looks for all .dropzone elements and creates a dropzone for them
            Dropzone1.discover = function() {
                var dropzones;
                if (document.querySelectorAll) dropzones = document.querySelectorAll(".dropzone");
                else {
                    dropzones = []; // IE :(
                    var checkElements = function checkElements(elements) {
                        return function() {
                            var result = [];
                            var _iterator20 = dropzone_createForOfIteratorHelper(elements, true), _step20;
                            try {
                                for(_iterator20.s(); !(_step20 = _iterator20.n()).done;){
                                    var el = _step20.value;
                                    if (/(^| )dropzone($| )/.test(el.className)) result.push(dropzones.push(el));
                                    else result.push(undefined);
                                }
                            } catch (err) {
                                _iterator20.e(err);
                            } finally{
                                _iterator20.f();
                            }
                            return result;
                        }();
                    };
                    checkElements(document.getElementsByTagName("div"));
                    checkElements(document.getElementsByTagName("form"));
                }
                return function() {
                    var result = [];
                    var _iterator21 = dropzone_createForOfIteratorHelper(dropzones, true), _step21;
                    try {
                        for(_iterator21.s(); !(_step21 = _iterator21.n()).done;){
                            var dropzone = _step21.value;
                            // Create a dropzone unless auto discover has been disabled for specific element
                            if (Dropzone1.optionsForElement(dropzone) !== false) result.push(new Dropzone1(dropzone));
                            else result.push(undefined);
                        }
                    } catch (err) {
                        _iterator21.e(err);
                    } finally{
                        _iterator21.f();
                    }
                    return result;
                }();
            }; // Some browsers support drag and drog functionality, but not correctly.
            //
            // So I created a blocklist of userAgents. Yes, yes. Browser sniffing, I know.
            // But what to do when browsers *theoretically* support an API, but crash
            // when using it.
            //
            // This is a list of regular expressions tested against navigator.userAgent
            //
            // ** It should only be used on browser that *do* support the API, but
            // incorrectly **
            Dropzone1.blockedBrowsers = [
                /opera.*(Macintosh|Windows Phone).*version\/12/i
            ]; // Checks if the browser is supported
            Dropzone1.isBrowserSupported = function() {
                var capableBrowser = true;
                if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {
                    if (!("classList" in document.createElement("a"))) capableBrowser = false;
                    else {
                        if (Dropzone1.blacklistedBrowsers !== undefined) // Since this has been renamed, this makes sure we don't break older
                        // configuration.
                        Dropzone1.blockedBrowsers = Dropzone1.blacklistedBrowsers;
                         // The browser supports the API, but may be blocked.
                        var _iterator22 = dropzone_createForOfIteratorHelper(Dropzone1.blockedBrowsers, true), _step22;
                        try {
                            for(_iterator22.s(); !(_step22 = _iterator22.n()).done;){
                                var regex = _step22.value;
                                if (regex.test(navigator.userAgent)) {
                                    capableBrowser = false;
                                    continue;
                                }
                            }
                        } catch (err) {
                            _iterator22.e(err);
                        } finally{
                            _iterator22.f();
                        }
                    }
                } else capableBrowser = false;
                return capableBrowser;
            };
            Dropzone1.dataURItoBlob = function(dataURI) {
                // convert base64 to raw binary data held in a string
                // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
                var byteString = atob(dataURI.split(",")[1]); // separate out the mime component
                var mimeString = dataURI.split(",")[0].split(":")[1].split(";")[0]; // write the bytes of the string to an ArrayBuffer
                var ab = new ArrayBuffer(byteString.length);
                var ia = new Uint8Array(ab);
                for(var i = 0, end = byteString.length, asc = 0 <= end; asc ? i <= end : i >= end; asc ? i++ : i--)ia[i] = byteString.charCodeAt(i);
                 // write the ArrayBuffer to a blob
                return new Blob([
                    ab
                ], {
                    type: mimeString
                });
            }; // Returns an array without the rejected item
            var without = function without(list, rejectedItem) {
                return list.filter(function(item) {
                    return item !== rejectedItem;
                }).map(function(item) {
                    return item;
                });
            }; // abc-def_ghi -> abcDefGhi
            var camelize = function camelize(str) {
                return str.replace(/[\-_](\w)/g, function(match) {
                    return match.charAt(1).toUpperCase();
                });
            }; // Creates an element from string
            Dropzone1.createElement = function(string) {
                var div = document.createElement("div");
                div.innerHTML = string;
                return div.childNodes[0];
            }; // Tests if given element is inside (or simply is) the container
            Dropzone1.elementInside = function(element, container) {
                if (element === container) return true;
                 // Coffeescript doesn't support do/while loops
                while(element = element.parentNode){
                    if (element === container) return true;
                }
                return false;
            };
            Dropzone1.getElement = function(el, name) {
                var element;
                if (typeof el === "string") element = document.querySelector(el);
                else if (el.nodeType != null) element = el;
                if (element == null) throw new Error("Invalid `".concat(name, "` option provided. Please provide a CSS selector or a plain HTML element."));
                return element;
            };
            Dropzone1.getElements = function(els, name) {
                var el, elements;
                if (els instanceof Array) {
                    elements = [];
                    try {
                        var _iterator23 = dropzone_createForOfIteratorHelper(els, true), _step23;
                        try {
                            for(_iterator23.s(); !(_step23 = _iterator23.n()).done;){
                                el = _step23.value;
                                elements.push(this.getElement(el, name));
                            }
                        } catch (err) {
                            _iterator23.e(err);
                        } finally{
                            _iterator23.f();
                        }
                    } catch (e) {
                        elements = null;
                    }
                } else if (typeof els === "string") {
                    elements = [];
                    var _iterator24 = dropzone_createForOfIteratorHelper(document.querySelectorAll(els), true), _step24;
                    try {
                        for(_iterator24.s(); !(_step24 = _iterator24.n()).done;){
                            el = _step24.value;
                            elements.push(el);
                        }
                    } catch (err) {
                        _iterator24.e(err);
                    } finally{
                        _iterator24.f();
                    }
                } else if (els.nodeType != null) elements = [
                    els
                ];
                if (elements == null || !elements.length) throw new Error("Invalid `".concat(name, "` option provided. Please provide a CSS selector, a plain HTML element or a list of those."));
                return elements;
            }; // Asks the user the question and calls accepted or rejected accordingly
            //
            // The default implementation just uses `window.confirm` and then calls the
            // appropriate callback.
            Dropzone1.confirm = function(question, accepted, rejected) {
                if (window.confirm(question)) return accepted();
                else if (rejected != null) return rejected();
            }; // Validates the mime type like this:
            //
            // https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept
            Dropzone1.isValidFile = function(file, acceptedFiles) {
                if (!acceptedFiles) return true;
                 // If there are no accepted mime types, it's OK
                acceptedFiles = acceptedFiles.split(",");
                var mimeType = file.type;
                var baseMimeType = mimeType.replace(/\/.*$/, "");
                var _iterator25 = dropzone_createForOfIteratorHelper(acceptedFiles, true), _step25;
                try {
                    for(_iterator25.s(); !(_step25 = _iterator25.n()).done;){
                        var validType = _step25.value;
                        validType = validType.trim();
                        if (validType.charAt(0) === ".") {
                            if (file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.length - validType.length) !== -1) return true;
                        } else if (/\/\*$/.test(validType)) {
                            // This is something like a image/* mime type
                            if (baseMimeType === validType.replace(/\/.*$/, "")) return true;
                        } else {
                            if (mimeType === validType) return true;
                        }
                    }
                } catch (err) {
                    _iterator25.e(err);
                } finally{
                    _iterator25.f();
                }
                return false;
            }; // Augment jQuery
            if (typeof jQuery !== "undefined" && jQuery !== null) jQuery.fn.dropzone = function(options) {
                return this.each(function() {
                    return new Dropzone1(this, options);
                });
            };
             // Dropzone file status codes
            Dropzone1.ADDED = "added";
            Dropzone1.QUEUED = "queued"; // For backwards compatibility. Now, if a file is accepted, it's either queued
            // or uploading.
            Dropzone1.ACCEPTED = Dropzone1.QUEUED;
            Dropzone1.UPLOADING = "uploading";
            Dropzone1.PROCESSING = Dropzone1.UPLOADING; // alias
            Dropzone1.CANCELED = "canceled";
            Dropzone1.ERROR = "error";
            Dropzone1.SUCCESS = "success";
            /*

 Bugfix for iOS 6 and 7
 Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios
 based on the work of https://github.com/stomita/ios-imagefile-megapixel

 */ // Detecting vertical squash in loaded image.
            // Fixes a bug which squash image vertically while drawing into canvas for some images.
            // This is a bug in iOS6 devices. This function from https://github.com/stomita/ios-imagefile-megapixel
            var detectVerticalSquash = function detectVerticalSquash(img) {
                var iw = img.naturalWidth;
                var ih = img.naturalHeight;
                var canvas = document.createElement("canvas");
                canvas.width = 1;
                canvas.height = ih;
                var ctx = canvas.getContext("2d");
                ctx.drawImage(img, 0, 0);
                var _ctx$getImageData = ctx.getImageData(1, 0, 1, ih), data = _ctx$getImageData.data; // search image edge pixel position in case it is squashed vertically.
                var sy = 0;
                var ey = ih;
                var py = ih;
                while(py > sy){
                    var alpha = data[(py - 1) * 4 + 3];
                    if (alpha === 0) ey = py;
                    else sy = py;
                    py = ey + sy >> 1;
                }
                var ratio = py / ih;
                if (ratio === 0) return 1;
                else return ratio;
            }; // A replacement for context.drawImage
            // (args are for source and destination).
            var drawImageIOSFix = function drawImageIOSFix(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {
                var vertSquashRatio = detectVerticalSquash(img);
                return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);
            }; // Based on MinifyJpeg
            // Source: http://www.perry.cz/files/ExifRestorer.js
            // http://elicon.blog57.fc2.com/blog-entry-206.html
            var ExifRestore1 = /*#__PURE__*/ function() {
                function ExifRestore() {
                    dropzone_classCallCheck(this, ExifRestore);
                }
                dropzone_createClass(ExifRestore, null, [
                    {
                        key: "initClass",
                        value: function initClass() {
                            this.KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                        }
                    },
                    {
                        key: "encode64",
                        value: function encode64(input) {
                            var output = "";
                            var chr1 = undefined;
                            var chr2 = undefined;
                            var chr3 = "";
                            var enc1 = undefined;
                            var enc2 = undefined;
                            var enc3 = undefined;
                            var enc4 = "";
                            var i = 0;
                            while(true){
                                chr1 = input[i++];
                                chr2 = input[i++];
                                chr3 = input[i++];
                                enc1 = chr1 >> 2;
                                enc2 = (chr1 & 3) << 4 | chr2 >> 4;
                                enc3 = (chr2 & 15) << 2 | chr3 >> 6;
                                enc4 = chr3 & 63;
                                if (isNaN(chr2)) enc3 = enc4 = 64;
                                else if (isNaN(chr3)) enc4 = 64;
                                output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);
                                chr1 = chr2 = chr3 = "";
                                enc1 = enc2 = enc3 = enc4 = "";
                                if (!(i < input.length)) break;
                            }
                            return output;
                        }
                    },
                    {
                        key: "restore",
                        value: function restore(origFileBase64, resizedFileBase64) {
                            if (!origFileBase64.match("data:image/jpeg;base64,")) return resizedFileBase64;
                            var rawImage = this.decode64(origFileBase64.replace("data:image/jpeg;base64,", ""));
                            var segments = this.slice2Segments(rawImage);
                            var image = this.exifManipulation(resizedFileBase64, segments);
                            return "data:image/jpeg;base64,".concat(this.encode64(image));
                        }
                    },
                    {
                        key: "exifManipulation",
                        value: function exifManipulation(resizedFileBase64, segments) {
                            var exifArray = this.getExifArray(segments);
                            var newImageArray = this.insertExif(resizedFileBase64, exifArray);
                            var aBuffer = new Uint8Array(newImageArray);
                            return aBuffer;
                        }
                    },
                    {
                        key: "getExifArray",
                        value: function getExifArray(segments) {
                            var seg = undefined;
                            var x = 0;
                            while(x < segments.length){
                                seg = segments[x];
                                if (seg[0] === 255 & seg[1] === 225) return seg;
                                x++;
                            }
                            return [];
                        }
                    },
                    {
                        key: "insertExif",
                        value: function insertExif(resizedFileBase64, exifArray) {
                            var imageData = resizedFileBase64.replace("data:image/jpeg;base64,", "");
                            var buf = this.decode64(imageData);
                            var separatePoint = buf.indexOf(255, 3);
                            var mae = buf.slice(0, separatePoint);
                            var ato = buf.slice(separatePoint);
                            var array = mae;
                            array = array.concat(exifArray);
                            array = array.concat(ato);
                            return array;
                        }
                    },
                    {
                        key: "slice2Segments",
                        value: function slice2Segments(rawImageArray) {
                            var head = 0;
                            var segments = [];
                            while(true){
                                var length;
                                if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) break;
                                if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) head += 2;
                                else {
                                    length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3];
                                    var endPoint = head + length + 2;
                                    var seg = rawImageArray.slice(head, endPoint);
                                    segments.push(seg);
                                    head = endPoint;
                                }
                                if (head > rawImageArray.length) break;
                            }
                            return segments;
                        }
                    },
                    {
                        key: "decode64",
                        value: function decode64(input) {
                            var output = "";
                            var chr1 = undefined;
                            var chr2 = undefined;
                            var chr3 = "";
                            var enc1 = undefined;
                            var enc2 = undefined;
                            var enc3 = undefined;
                            var enc4 = "";
                            var i = 0;
                            var buf = []; // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
                            var base64test = /[^A-Za-z0-9\+\/\=]/g;
                            if (base64test.exec(input)) console.warn("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\nExpect errors in decoding.");
                            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                            while(true){
                                enc1 = this.KEY_STR.indexOf(input.charAt(i++));
                                enc2 = this.KEY_STR.indexOf(input.charAt(i++));
                                enc3 = this.KEY_STR.indexOf(input.charAt(i++));
                                enc4 = this.KEY_STR.indexOf(input.charAt(i++));
                                chr1 = enc1 << 2 | enc2 >> 4;
                                chr2 = (enc2 & 15) << 4 | enc3 >> 2;
                                chr3 = (enc3 & 3) << 6 | enc4;
                                buf.push(chr1);
                                if (enc3 !== 64) buf.push(chr2);
                                if (enc4 !== 64) buf.push(chr3);
                                chr1 = chr2 = chr3 = "";
                                enc1 = enc2 = enc3 = enc4 = "";
                                if (!(i < input.length)) break;
                            }
                            return buf;
                        }
                    }
                ]);
                return ExifRestore;
            }();
            ExifRestore1.initClass();
            /*
 * contentloaded.js
 *
 * Author: Diego Perini (diego.perini at gmail.com)
 * Summary: cross-browser wrapper for DOMContentLoaded
 * Updated: 20101020
 * License: MIT
 * Version: 1.2
 *
 * URL:
 * http://javascript.nwbox.com/ContentLoaded/
 * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE
 */ // @win window reference
            // @fn function reference
            var contentLoaded = function contentLoaded(win, fn) {
                var done = false;
                var top = true;
                var doc = win.document;
                var root = doc.documentElement;
                var add = doc.addEventListener ? "addEventListener" : "attachEvent";
                var rem = doc.addEventListener ? "removeEventListener" : "detachEvent";
                var pre = doc.addEventListener ? "" : "on";
                var init1 = function init(e) {
                    if (e.type === "readystatechange" && doc.readyState !== "complete") return;
                    (e.type === "load" ? win : doc)[rem](pre + e.type, init, false);
                    if (!done && (done = true)) return fn.call(win, e.type || e);
                };
                var poll1 = function poll() {
                    try {
                        root.doScroll("left");
                    } catch (e) {
                        setTimeout(poll, 50);
                        return;
                    }
                    return init1("poll");
                };
                if (doc.readyState !== "complete") {
                    if (doc.createEventObject && root.doScroll) {
                        try {
                            top = !win.frameElement;
                        } catch (error) {}
                        if (top) poll1();
                    }
                    doc[add](pre + "DOMContentLoaded", init1, false);
                    doc[add](pre + "readystatechange", init1, false);
                    return win[add](pre + "load", init1, false);
                }
            }; // As a single function to be able to write tests.
            Dropzone1._autoDiscoverFunction = function() {
                if (Dropzone1.autoDiscover) return Dropzone1.discover();
            };
            contentLoaded(window, Dropzone1._autoDiscoverFunction);
            function __guard__(value, transform) {
                return typeof value !== "undefined" && value !== null ? transform(value) : undefined;
            }
            function __guardMethod__(obj, methodName, transform) {
                if (typeof obj !== "undefined" && obj !== null && typeof obj[methodName] === "function") return transform(obj, methodName);
                else return undefined;
            }
            /// Make Dropzone a global variable.
            window.Dropzone = Dropzone1;
            /* harmony default export */ var dropzone_dist = Dropzone1;
        }();
        /******/ return __webpack_exports__;
    /******/ }();
});

},{}],"fYCNr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ListView", ()=>ListView
);
/*!
FullCalendar v5.10.2
Docs & License: https://fullcalendar.io/
(c) 2021 Adam Shaw
*/ var _mainCss = require("./main.css");
var _common = require("@fullcalendar/common");
var _tslib = require("tslib");
var ListViewHeaderRow = /** @class */ function(_super) {
    _tslib.__extends(ListViewHeaderRow1, _super);
    function ListViewHeaderRow1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            textId: _common.getUniqueDomId()
        };
        return _this;
    }
    ListViewHeaderRow1.prototype.render = function() {
        var _a = this.context, theme = _a.theme, dateEnv = _a.dateEnv, options = _a.options, viewApi = _a.viewApi;
        var _b = this.props, cellId = _b.cellId, dayDate = _b.dayDate, todayRange = _b.todayRange;
        var textId = this.state.textId;
        var dayMeta = _common.getDateMeta(dayDate, todayRange);
        // will ever be falsy?
        var text = options.listDayFormat ? dateEnv.format(dayDate, options.listDayFormat) : '';
        // will ever be falsy? also, BAD NAME "alt"
        var sideText = options.listDaySideFormat ? dateEnv.format(dayDate, options.listDaySideFormat) : '';
        var hookProps = _tslib.__assign({
            date: dateEnv.toDate(dayDate),
            view: viewApi,
            textId: textId,
            text: text,
            sideText: sideText,
            navLinkAttrs: _common.buildNavLinkAttrs(this.context, dayDate),
            sideNavLinkAttrs: _common.buildNavLinkAttrs(this.context, dayDate, 'day', false)
        }, dayMeta);
        var classNames = [
            'fc-list-day'
        ].concat(_common.getDayClassNames(dayMeta, theme));
        // TODO: make a reusable HOC for dayHeader (used in daygrid/timegrid too)
        return _common.createElement(_common.RenderHook, {
            hookProps: hookProps,
            classNames: options.dayHeaderClassNames,
            content: options.dayHeaderContent,
            defaultContent: renderInnerContent,
            didMount: options.dayHeaderDidMount,
            willUnmount: options.dayHeaderWillUnmount
        }, function(rootElRef, customClassNames, innerElRef, innerContent) {
            return _common.createElement("tr", {
                ref: rootElRef,
                className: classNames.concat(customClassNames).join(' '),
                "data-date": _common.formatDayString(dayDate)
            }, _common.createElement("th", {
                scope: "colgroup",
                colSpan: 3,
                id: cellId,
                "aria-labelledby": textId
            }, _common.createElement("div", {
                className: 'fc-list-day-cushion ' + theme.getClass('tableCellShaded'),
                ref: innerElRef
            }, innerContent)));
        });
    };
    return ListViewHeaderRow1;
}(_common.BaseComponent);
function renderInnerContent(props) {
    return _common.createElement(_common.Fragment, null, props.text && _common.createElement("a", _tslib.__assign({
        id: props.textId,
        className: "fc-list-day-text"
    }, props.navLinkAttrs), props.text), props.sideText && /* not keyboard tabbable */ _common.createElement("a", _tslib.__assign({
        "aria-hidden": true,
        className: "fc-list-day-side-text"
    }, props.sideNavLinkAttrs), props.sideText));
}
var DEFAULT_TIME_FORMAT = _common.createFormatter({
    hour: 'numeric',
    minute: '2-digit',
    meridiem: 'short'
});
var ListViewEventRow = /** @class */ function(_super) {
    _tslib.__extends(ListViewEventRow1, _super);
    function ListViewEventRow1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ListViewEventRow1.prototype.render = function() {
        var _a = this, props = _a.props, context = _a.context;
        var seg = props.seg, timeHeaderId = props.timeHeaderId, eventHeaderId = props.eventHeaderId, dateHeaderId = props.dateHeaderId;
        var timeFormat = context.options.eventTimeFormat || DEFAULT_TIME_FORMAT;
        return _common.createElement(_common.EventRoot, {
            seg: seg,
            timeText: "" // BAD. because of all-day content
            ,
            disableDragging: true,
            disableResizing: true,
            defaultContent: function() {
                return renderEventInnerContent(seg, context);
            } /* weird */ ,
            isPast: props.isPast,
            isFuture: props.isFuture,
            isToday: props.isToday,
            isSelected: props.isSelected,
            isDragging: props.isDragging,
            isResizing: props.isResizing,
            isDateSelecting: props.isDateSelecting
        }, function(rootElRef, classNames, innerElRef, innerContent, hookProps) {
            return _common.createElement("tr", {
                className: [
                    'fc-list-event',
                    hookProps.event.url ? 'fc-event-forced-url' : ''
                ].concat(classNames).join(' '),
                ref: rootElRef
            }, buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId), _common.createElement("td", {
                "aria-hidden": true,
                className: "fc-list-event-graphic"
            }, _common.createElement("span", {
                className: "fc-list-event-dot",
                style: {
                    borderColor: hookProps.borderColor || hookProps.backgroundColor
                }
            })), _common.createElement("td", {
                ref: innerElRef,
                headers: eventHeaderId + " " + dateHeaderId,
                className: "fc-list-event-title"
            }, innerContent));
        });
    };
    return ListViewEventRow1;
}(_common.BaseComponent);
function renderEventInnerContent(seg, context) {
    var interactiveAttrs = _common.getSegAnchorAttrs(seg, context);
    return _common.createElement("a", _tslib.__assign({}, interactiveAttrs), seg.eventRange.def.title);
}
function buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId) {
    var options = context.options;
    if (options.displayEventTime !== false) {
        var eventDef = seg.eventRange.def;
        var eventInstance = seg.eventRange.instance;
        var doAllDay = false;
        var timeText = void 0;
        if (eventDef.allDay) doAllDay = true;
        else if (_common.isMultiDayRange(seg.eventRange.range)) {
            if (seg.isStart) timeText = _common.buildSegTimeText(seg, timeFormat, context, null, null, eventInstance.range.start, seg.end);
            else if (seg.isEnd) timeText = _common.buildSegTimeText(seg, timeFormat, context, null, null, seg.start, eventInstance.range.end);
            else doAllDay = true;
        } else timeText = _common.buildSegTimeText(seg, timeFormat, context);
        if (doAllDay) {
            var hookProps = {
                text: context.options.allDayText,
                view: context.viewApi
            };
            return _common.createElement(_common.RenderHook, {
                hookProps: hookProps,
                classNames: options.allDayClassNames,
                content: options.allDayContent,
                defaultContent: renderAllDayInner,
                didMount: options.allDayDidMount,
                willUnmount: options.allDayWillUnmount
            }, function(rootElRef, classNames, innerElRef, innerContent) {
                return _common.createElement("td", {
                    ref: rootElRef,
                    headers: timeHeaderId + " " + dateHeaderId,
                    className: [
                        'fc-list-event-time'
                    ].concat(classNames).join(' ')
                }, innerContent);
            });
        }
        return _common.createElement("td", {
            className: "fc-list-event-time"
        }, timeText);
    }
    return null;
}
function renderAllDayInner(hookProps) {
    return hookProps.text;
}
/*
Responsible for the scroller, and forwarding event-related actions into the "grid".
*/ var ListView = /** @class */ function(_super) {
    _tslib.__extends(ListView1, _super);
    function ListView1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.computeDateVars = _common.memoize(computeDateVars);
        _this.eventStoreToSegs = _common.memoize(_this._eventStoreToSegs);
        _this.state = {
            timeHeaderId: _common.getUniqueDomId(),
            eventHeaderId: _common.getUniqueDomId(),
            dateHeaderIdRoot: _common.getUniqueDomId()
        };
        _this.setRootEl = function(rootEl) {
            if (rootEl) _this.context.registerInteractiveComponent(_this, {
                el: rootEl
            });
            else _this.context.unregisterInteractiveComponent(_this);
        };
        return _this;
    }
    ListView1.prototype.render = function() {
        var _this = this;
        var _a = this, props = _a.props, context = _a.context;
        var extraClassNames = [
            'fc-list',
            context.theme.getClass('table'),
            context.options.stickyHeaderDates !== false ? 'fc-list-sticky' : '', 
        ];
        var _b = this.computeDateVars(props.dateProfile), dayDates = _b.dayDates, dayRanges = _b.dayRanges;
        var eventSegs = this.eventStoreToSegs(props.eventStore, props.eventUiBases, dayRanges);
        return _common.createElement(_common.ViewRoot, {
            viewSpec: context.viewSpec,
            elRef: this.setRootEl
        }, function(rootElRef, classNames) {
            return _common.createElement("div", {
                ref: rootElRef,
                className: extraClassNames.concat(classNames).join(' ')
            }, _common.createElement(_common.Scroller, {
                liquid: !props.isHeightAuto,
                overflowX: props.isHeightAuto ? 'visible' : 'hidden',
                overflowY: props.isHeightAuto ? 'visible' : 'auto'
            }, eventSegs.length > 0 ? _this.renderSegList(eventSegs, dayDates) : _this.renderEmptyMessage()));
        });
    };
    ListView1.prototype.renderEmptyMessage = function() {
        var _a = this.context, options = _a.options, viewApi = _a.viewApi;
        var hookProps = {
            text: options.noEventsText,
            view: viewApi
        };
        return _common.createElement(_common.RenderHook, {
            hookProps: hookProps,
            classNames: options.noEventsClassNames,
            content: options.noEventsContent,
            defaultContent: renderNoEventsInner,
            didMount: options.noEventsDidMount,
            willUnmount: options.noEventsWillUnmount
        }, function(rootElRef, classNames, innerElRef, innerContent) {
            return _common.createElement("div", {
                className: [
                    'fc-list-empty'
                ].concat(classNames).join(' '),
                ref: rootElRef
            }, _common.createElement("div", {
                className: "fc-list-empty-cushion",
                ref: innerElRef
            }, innerContent));
        });
    };
    ListView1.prototype.renderSegList = function(allSegs, dayDates) {
        var _a = this.context, theme = _a.theme, options = _a.options;
        var _b = this.state, timeHeaderId = _b.timeHeaderId, eventHeaderId = _b.eventHeaderId, dateHeaderIdRoot = _b.dateHeaderIdRoot;
        var segsByDay = groupSegsByDay(allSegs); // sparse array
        return _common.createElement(_common.NowTimer, {
            unit: "day"
        }, function(nowDate, todayRange) {
            var innerNodes = [];
            for(var dayIndex = 0; dayIndex < segsByDay.length; dayIndex += 1){
                var daySegs = segsByDay[dayIndex];
                if (daySegs) {
                    var dayStr = _common.formatDayString(dayDates[dayIndex]);
                    var dateHeaderId = dateHeaderIdRoot + '-' + dayStr;
                    // append a day header
                    innerNodes.push(_common.createElement(ListViewHeaderRow, {
                        key: dayStr,
                        cellId: dateHeaderId,
                        dayDate: dayDates[dayIndex],
                        todayRange: todayRange
                    }));
                    daySegs = _common.sortEventSegs(daySegs, options.eventOrder);
                    for(var _i = 0, daySegs_1 = daySegs; _i < daySegs_1.length; _i++){
                        var seg = daySegs_1[_i];
                        innerNodes.push(_common.createElement(ListViewEventRow, _tslib.__assign({
                            key: dayStr + ':' + seg.eventRange.instance.instanceId /* are multiple segs for an instanceId */ ,
                            seg: seg,
                            isDragging: false,
                            isResizing: false,
                            isDateSelecting: false,
                            isSelected: false,
                            timeHeaderId: timeHeaderId,
                            eventHeaderId: eventHeaderId,
                            dateHeaderId: dateHeaderId
                        }, _common.getSegMeta(seg, todayRange, nowDate))));
                    }
                }
            }
            return _common.createElement("table", {
                className: 'fc-list-table ' + theme.getClass('table')
            }, _common.createElement("thead", null, _common.createElement("tr", null, _common.createElement("th", {
                scope: "col",
                id: timeHeaderId
            }, options.timeHint), _common.createElement("th", {
                scope: "col",
                "aria-hidden": true
            }), _common.createElement("th", {
                scope: "col",
                id: eventHeaderId
            }, options.eventHint))), _common.createElement("tbody", null, innerNodes));
        });
    };
    ListView1.prototype._eventStoreToSegs = function(eventStore, eventUiBases, dayRanges) {
        return this.eventRangesToSegs(_common.sliceEventStore(eventStore, eventUiBases, this.props.dateProfile.activeRange, this.context.options.nextDayThreshold).fg, dayRanges);
    };
    ListView1.prototype.eventRangesToSegs = function(eventRanges, dayRanges) {
        var segs = [];
        for(var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++){
            var eventRange = eventRanges_1[_i];
            segs.push.apply(segs, this.eventRangeToSegs(eventRange, dayRanges));
        }
        return segs;
    };
    ListView1.prototype.eventRangeToSegs = function(eventRange, dayRanges) {
        var dateEnv = this.context.dateEnv;
        var nextDayThreshold = this.context.options.nextDayThreshold;
        var range = eventRange.range;
        var allDay = eventRange.def.allDay;
        var dayIndex;
        var segRange;
        var seg;
        var segs = [];
        for(dayIndex = 0; dayIndex < dayRanges.length; dayIndex += 1){
            segRange = _common.intersectRanges(range, dayRanges[dayIndex]);
            if (segRange) {
                seg = {
                    component: this,
                    eventRange: eventRange,
                    start: segRange.start,
                    end: segRange.end,
                    isStart: eventRange.isStart && segRange.start.valueOf() === range.start.valueOf(),
                    isEnd: eventRange.isEnd && segRange.end.valueOf() === range.end.valueOf(),
                    dayIndex: dayIndex
                };
                segs.push(seg);
                // detect when range won't go fully into the next day,
                // and mutate the latest seg to the be the end.
                if (!seg.isEnd && !allDay && dayIndex + 1 < dayRanges.length && range.end < dateEnv.add(dayRanges[dayIndex + 1].start, nextDayThreshold)) {
                    seg.end = range.end;
                    seg.isEnd = true;
                    break;
                }
            }
        }
        return segs;
    };
    return ListView1;
}(_common.DateComponent);
function renderNoEventsInner(hookProps) {
    return hookProps.text;
}
function computeDateVars(dateProfile) {
    var dayStart = _common.startOfDay(dateProfile.renderRange.start);
    var viewEnd = dateProfile.renderRange.end;
    var dayDates = [];
    var dayRanges = [];
    while(dayStart < viewEnd){
        dayDates.push(dayStart);
        dayRanges.push({
            start: dayStart,
            end: _common.addDays(dayStart, 1)
        });
        dayStart = _common.addDays(dayStart, 1);
    }
    return {
        dayDates: dayDates,
        dayRanges: dayRanges
    };
}
// Returns a sparse array of arrays, segs grouped by their dayIndex
function groupSegsByDay(segs) {
    var segsByDay = []; // sparse array
    var i;
    var seg;
    for(i = 0; i < segs.length; i += 1){
        seg = segs[i];
        (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = [])).push(seg);
    }
    return segsByDay;
}
var OPTION_REFINERS = {
    listDayFormat: createFalsableFormatter,
    listDaySideFormat: createFalsableFormatter,
    noEventsClassNames: _common.identity,
    noEventsContent: _common.identity,
    noEventsDidMount: _common.identity,
    noEventsWillUnmount: _common.identity
};
function createFalsableFormatter(input) {
    return input === false ? null : _common.createFormatter(input);
}
var main = _common.createPlugin({
    optionRefiners: OPTION_REFINERS,
    views: {
        list: {
            component: ListView,
            buttonTextKey: 'list',
            listDayFormat: {
                month: 'long',
                day: 'numeric',
                year: 'numeric'
            }
        },
        listDay: {
            type: 'list',
            duration: {
                days: 1
            },
            listDayFormat: {
                weekday: 'long'
            }
        },
        listWeek: {
            type: 'list',
            duration: {
                weeks: 1
            },
            listDayFormat: {
                weekday: 'long'
            },
            listDaySideFormat: {
                month: 'long',
                day: 'numeric',
                year: 'numeric'
            }
        },
        listMonth: {
            type: 'list',
            duration: {
                month: 1
            },
            listDaySideFormat: {
                weekday: 'long'
            }
        },
        listYear: {
            type: 'list',
            duration: {
                year: 1
            },
            listDaySideFormat: {
                weekday: 'long'
            }
        }
    }
});
exports.default = main;

},{"./main.css":"fPMPN","@fullcalendar/common":"cnjgQ","tslib":"5i9Vz","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}],"fPMPN":[function() {},{}],"2Lwrt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Draggable", ()=>ExternalDraggable
);
parcelHelpers.export(exports, "FeaturefulElementDragging", ()=>FeaturefulElementDragging
);
parcelHelpers.export(exports, "PointerDragging", ()=>PointerDragging
);
parcelHelpers.export(exports, "ThirdPartyDraggable", ()=>ThirdPartyDraggable
);
/*!
FullCalendar v5.10.2
Docs & License: https://fullcalendar.io/
(c) 2021 Adam Shaw
*/ var _common = require("@fullcalendar/common");
var _tslib = require("tslib");
_common.config.touchMouseIgnoreWait = 500;
var ignoreMouseDepth = 0;
var listenerCnt = 0;
var isWindowTouchMoveCancelled = false;
/*
Uses a "pointer" abstraction, which monitors UI events for both mouse and touch.
Tracks when the pointer "drags" on a certain element, meaning down+move+up.

Also, tracks if there was touch-scrolling.
Also, can prevent touch-scrolling from happening.
Also, can fire pointermove events when scrolling happens underneath, even when no real pointer movement.

emits:
- pointerdown
- pointermove
- pointerup
*/ var PointerDragging = /** @class */ function() {
    function PointerDragging1(containerEl) {
        var _this = this;
        this.subjectEl = null;
        // options that can be directly assigned by caller
        this.selector = ''; // will cause subjectEl in all emitted events to be this element
        this.handleSelector = '';
        this.shouldIgnoreMove = false;
        this.shouldWatchScroll = true; // for simulating pointermove on scroll
        // internal states
        this.isDragging = false;
        this.isTouchDragging = false;
        this.wasTouchScroll = false;
        // Mouse
        // ----------------------------------------------------------------------------------------------------
        this.handleMouseDown = function(ev) {
            if (!_this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && _this.tryStart(ev)) {
                var pev = _this.createEventFromMouse(ev, true);
                _this.emitter.trigger('pointerdown', pev);
                _this.initScrollWatch(pev);
                if (!_this.shouldIgnoreMove) document.addEventListener('mousemove', _this.handleMouseMove);
                document.addEventListener('mouseup', _this.handleMouseUp);
            }
        };
        this.handleMouseMove = function(ev) {
            var pev = _this.createEventFromMouse(ev);
            _this.recordCoords(pev);
            _this.emitter.trigger('pointermove', pev);
        };
        this.handleMouseUp = function(ev) {
            document.removeEventListener('mousemove', _this.handleMouseMove);
            document.removeEventListener('mouseup', _this.handleMouseUp);
            _this.emitter.trigger('pointerup', _this.createEventFromMouse(ev));
            _this.cleanup(); // call last so that pointerup has access to props
        };
        // Touch
        // ----------------------------------------------------------------------------------------------------
        this.handleTouchStart = function(ev) {
            if (_this.tryStart(ev)) {
                _this.isTouchDragging = true;
                var pev = _this.createEventFromTouch(ev, true);
                _this.emitter.trigger('pointerdown', pev);
                _this.initScrollWatch(pev);
                // unlike mouse, need to attach to target, not document
                // https://stackoverflow.com/a/45760014
                var targetEl = ev.target;
                if (!_this.shouldIgnoreMove) targetEl.addEventListener('touchmove', _this.handleTouchMove);
                targetEl.addEventListener('touchend', _this.handleTouchEnd);
                targetEl.addEventListener('touchcancel', _this.handleTouchEnd); // treat it as a touch end
                // attach a handler to get called when ANY scroll action happens on the page.
                // this was impossible to do with normal on/off because 'scroll' doesn't bubble.
                // http://stackoverflow.com/a/32954565/96342
                window.addEventListener('scroll', _this.handleTouchScroll, true);
            }
        };
        this.handleTouchMove = function(ev) {
            var pev = _this.createEventFromTouch(ev);
            _this.recordCoords(pev);
            _this.emitter.trigger('pointermove', pev);
        };
        this.handleTouchEnd = function(ev) {
            if (_this.isDragging) {
                var targetEl = ev.target;
                targetEl.removeEventListener('touchmove', _this.handleTouchMove);
                targetEl.removeEventListener('touchend', _this.handleTouchEnd);
                targetEl.removeEventListener('touchcancel', _this.handleTouchEnd);
                window.removeEventListener('scroll', _this.handleTouchScroll, true); // useCaptured=true
                _this.emitter.trigger('pointerup', _this.createEventFromTouch(ev));
                _this.cleanup(); // call last so that pointerup has access to props
                _this.isTouchDragging = false;
                startIgnoringMouse();
            }
        };
        this.handleTouchScroll = function() {
            _this.wasTouchScroll = true;
        };
        this.handleScroll = function(ev) {
            if (!_this.shouldIgnoreMove) {
                var pageX = window.pageXOffset - _this.prevScrollX + _this.prevPageX;
                var pageY = window.pageYOffset - _this.prevScrollY + _this.prevPageY;
                _this.emitter.trigger('pointermove', {
                    origEvent: ev,
                    isTouch: _this.isTouchDragging,
                    subjectEl: _this.subjectEl,
                    pageX: pageX,
                    pageY: pageY,
                    deltaX: pageX - _this.origPageX,
                    deltaY: pageY - _this.origPageY
                });
            }
        };
        this.containerEl = containerEl;
        this.emitter = new _common.Emitter();
        containerEl.addEventListener('mousedown', this.handleMouseDown);
        containerEl.addEventListener('touchstart', this.handleTouchStart, {
            passive: true
        });
        listenerCreated();
    }
    PointerDragging1.prototype.destroy = function() {
        this.containerEl.removeEventListener('mousedown', this.handleMouseDown);
        this.containerEl.removeEventListener('touchstart', this.handleTouchStart, {
            passive: true
        });
        listenerDestroyed();
    };
    PointerDragging1.prototype.tryStart = function(ev) {
        var subjectEl = this.querySubjectEl(ev);
        var downEl = ev.target;
        if (subjectEl && (!this.handleSelector || _common.elementClosest(downEl, this.handleSelector))) {
            this.subjectEl = subjectEl;
            this.isDragging = true; // do this first so cancelTouchScroll will work
            this.wasTouchScroll = false;
            return true;
        }
        return false;
    };
    PointerDragging1.prototype.cleanup = function() {
        isWindowTouchMoveCancelled = false;
        this.isDragging = false;
        this.subjectEl = null;
        // keep wasTouchScroll around for later access
        this.destroyScrollWatch();
    };
    PointerDragging1.prototype.querySubjectEl = function(ev) {
        if (this.selector) return _common.elementClosest(ev.target, this.selector);
        return this.containerEl;
    };
    PointerDragging1.prototype.shouldIgnoreMouse = function() {
        return ignoreMouseDepth || this.isTouchDragging;
    };
    // can be called by user of this class, to cancel touch-based scrolling for the current drag
    PointerDragging1.prototype.cancelTouchScroll = function() {
        if (this.isDragging) isWindowTouchMoveCancelled = true;
    };
    // Scrolling that simulates pointermoves
    // ----------------------------------------------------------------------------------------------------
    PointerDragging1.prototype.initScrollWatch = function(ev) {
        if (this.shouldWatchScroll) {
            this.recordCoords(ev);
            window.addEventListener('scroll', this.handleScroll, true); // useCapture=true
        }
    };
    PointerDragging1.prototype.recordCoords = function(ev) {
        if (this.shouldWatchScroll) {
            this.prevPageX = ev.pageX;
            this.prevPageY = ev.pageY;
            this.prevScrollX = window.pageXOffset;
            this.prevScrollY = window.pageYOffset;
        }
    };
    PointerDragging1.prototype.destroyScrollWatch = function() {
        if (this.shouldWatchScroll) window.removeEventListener('scroll', this.handleScroll, true); // useCaptured=true
    };
    // Event Normalization
    // ----------------------------------------------------------------------------------------------------
    PointerDragging1.prototype.createEventFromMouse = function(ev, isFirst) {
        var deltaX = 0;
        var deltaY = 0;
        // TODO: repeat code
        if (isFirst) {
            this.origPageX = ev.pageX;
            this.origPageY = ev.pageY;
        } else {
            deltaX = ev.pageX - this.origPageX;
            deltaY = ev.pageY - this.origPageY;
        }
        return {
            origEvent: ev,
            isTouch: false,
            subjectEl: this.subjectEl,
            pageX: ev.pageX,
            pageY: ev.pageY,
            deltaX: deltaX,
            deltaY: deltaY
        };
    };
    PointerDragging1.prototype.createEventFromTouch = function(ev, isFirst) {
        var touches = ev.touches;
        var pageX;
        var pageY;
        var deltaX = 0;
        var deltaY = 0;
        // if touch coords available, prefer,
        // because FF would give bad ev.pageX ev.pageY
        if (touches && touches.length) {
            pageX = touches[0].pageX;
            pageY = touches[0].pageY;
        } else {
            pageX = ev.pageX;
            pageY = ev.pageY;
        }
        // TODO: repeat code
        if (isFirst) {
            this.origPageX = pageX;
            this.origPageY = pageY;
        } else {
            deltaX = pageX - this.origPageX;
            deltaY = pageY - this.origPageY;
        }
        return {
            origEvent: ev,
            isTouch: true,
            subjectEl: this.subjectEl,
            pageX: pageX,
            pageY: pageY,
            deltaX: deltaX,
            deltaY: deltaY
        };
    };
    return PointerDragging1;
}();
// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)
function isPrimaryMouseButton(ev) {
    return ev.button === 0 && !ev.ctrlKey;
}
// Ignoring fake mouse events generated by touch
// ----------------------------------------------------------------------------------------------------
function startIgnoringMouse() {
    ignoreMouseDepth += 1;
    setTimeout(function() {
        ignoreMouseDepth -= 1;
    }, _common.config.touchMouseIgnoreWait);
}
// We want to attach touchmove as early as possible for Safari
// ----------------------------------------------------------------------------------------------------
function listenerCreated() {
    listenerCnt += 1;
    if (listenerCnt === 1) window.addEventListener('touchmove', onWindowTouchMove, {
        passive: false
    });
}
function listenerDestroyed() {
    listenerCnt -= 1;
    if (!listenerCnt) window.removeEventListener('touchmove', onWindowTouchMove, {
        passive: false
    });
}
function onWindowTouchMove(ev) {
    if (isWindowTouchMoveCancelled) ev.preventDefault();
}
/*
An effect in which an element follows the movement of a pointer across the screen.
The moving element is a clone of some other element.
Must call start + handleMove + stop.
*/ var ElementMirror = /** @class */ function() {
    function ElementMirror1() {
        this.isVisible = false; // must be explicitly enabled
        this.sourceEl = null;
        this.mirrorEl = null;
        this.sourceElRect = null; // screen coords relative to viewport
        // options that can be set directly by caller
        this.parentNode = document.body; // HIGHLY SUGGESTED to set this to sidestep ShadowDOM issues
        this.zIndex = 9999;
        this.revertDuration = 0;
    }
    ElementMirror1.prototype.start = function(sourceEl, pageX, pageY) {
        this.sourceEl = sourceEl;
        this.sourceElRect = this.sourceEl.getBoundingClientRect();
        this.origScreenX = pageX - window.pageXOffset;
        this.origScreenY = pageY - window.pageYOffset;
        this.deltaX = 0;
        this.deltaY = 0;
        this.updateElPosition();
    };
    ElementMirror1.prototype.handleMove = function(pageX, pageY) {
        this.deltaX = pageX - window.pageXOffset - this.origScreenX;
        this.deltaY = pageY - window.pageYOffset - this.origScreenY;
        this.updateElPosition();
    };
    // can be called before start
    ElementMirror1.prototype.setIsVisible = function(bool) {
        if (bool) {
            if (!this.isVisible) {
                if (this.mirrorEl) this.mirrorEl.style.display = '';
                this.isVisible = bool; // needs to happen before updateElPosition
                this.updateElPosition(); // because was not updating the position while invisible
            }
        } else if (this.isVisible) {
            if (this.mirrorEl) this.mirrorEl.style.display = 'none';
            this.isVisible = bool;
        }
    };
    // always async
    ElementMirror1.prototype.stop = function(needsRevertAnimation, callback) {
        var _this = this;
        var done = function() {
            _this.cleanup();
            callback();
        };
        if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && (this.deltaX || this.deltaY // if same coords, transition won't work
        )) this.doRevertAnimation(done, this.revertDuration);
        else setTimeout(done, 0);
    };
    ElementMirror1.prototype.doRevertAnimation = function(callback, revertDuration) {
        var mirrorEl = this.mirrorEl;
        var finalSourceElRect = this.sourceEl.getBoundingClientRect(); // because autoscrolling might have happened
        mirrorEl.style.transition = 'top ' + revertDuration + 'ms,' + 'left ' + revertDuration + 'ms';
        _common.applyStyle(mirrorEl, {
            left: finalSourceElRect.left,
            top: finalSourceElRect.top
        });
        _common.whenTransitionDone(mirrorEl, function() {
            mirrorEl.style.transition = '';
            callback();
        });
    };
    ElementMirror1.prototype.cleanup = function() {
        if (this.mirrorEl) {
            _common.removeElement(this.mirrorEl);
            this.mirrorEl = null;
        }
        this.sourceEl = null;
    };
    ElementMirror1.prototype.updateElPosition = function() {
        if (this.sourceEl && this.isVisible) _common.applyStyle(this.getMirrorEl(), {
            left: this.sourceElRect.left + this.deltaX,
            top: this.sourceElRect.top + this.deltaY
        });
    };
    ElementMirror1.prototype.getMirrorEl = function() {
        var sourceElRect = this.sourceElRect;
        var mirrorEl = this.mirrorEl;
        if (!mirrorEl) {
            mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true); // cloneChildren=true
            // we don't want long taps or any mouse interaction causing selection/menus.
            // would use preventSelection(), but that prevents selectstart, causing problems.
            mirrorEl.classList.add('fc-unselectable');
            mirrorEl.classList.add('fc-event-dragging');
            _common.applyStyle(mirrorEl, {
                position: 'fixed',
                zIndex: this.zIndex,
                visibility: '',
                boxSizing: 'border-box',
                width: sourceElRect.right - sourceElRect.left,
                height: sourceElRect.bottom - sourceElRect.top,
                right: 'auto',
                bottom: 'auto',
                margin: 0
            });
            this.parentNode.appendChild(mirrorEl);
        }
        return mirrorEl;
    };
    return ElementMirror1;
}();
/*
Is a cache for a given element's scroll information (all the info that ScrollController stores)
in addition the "client rectangle" of the element.. the area within the scrollbars.

The cache can be in one of two modes:
- doesListening:false - ignores when the container is scrolled by someone else
- doesListening:true - watch for scrolling and update the cache
*/ var ScrollGeomCache = /** @class */ function(_super) {
    _tslib.__extends(ScrollGeomCache1, _super);
    function ScrollGeomCache1(scrollController, doesListening) {
        var _this = _super.call(this) || this;
        _this.handleScroll = function() {
            _this.scrollTop = _this.scrollController.getScrollTop();
            _this.scrollLeft = _this.scrollController.getScrollLeft();
            _this.handleScrollChange();
        };
        _this.scrollController = scrollController;
        _this.doesListening = doesListening;
        _this.scrollTop = _this.origScrollTop = scrollController.getScrollTop();
        _this.scrollLeft = _this.origScrollLeft = scrollController.getScrollLeft();
        _this.scrollWidth = scrollController.getScrollWidth();
        _this.scrollHeight = scrollController.getScrollHeight();
        _this.clientWidth = scrollController.getClientWidth();
        _this.clientHeight = scrollController.getClientHeight();
        _this.clientRect = _this.computeClientRect(); // do last in case it needs cached values
        if (_this.doesListening) _this.getEventTarget().addEventListener('scroll', _this.handleScroll);
        return _this;
    }
    ScrollGeomCache1.prototype.destroy = function() {
        if (this.doesListening) this.getEventTarget().removeEventListener('scroll', this.handleScroll);
    };
    ScrollGeomCache1.prototype.getScrollTop = function() {
        return this.scrollTop;
    };
    ScrollGeomCache1.prototype.getScrollLeft = function() {
        return this.scrollLeft;
    };
    ScrollGeomCache1.prototype.setScrollTop = function(top) {
        this.scrollController.setScrollTop(top);
        if (!this.doesListening) {
            // we are not relying on the element to normalize out-of-bounds scroll values
            // so we need to sanitize ourselves
            this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);
            this.handleScrollChange();
        }
    };
    ScrollGeomCache1.prototype.setScrollLeft = function(top) {
        this.scrollController.setScrollLeft(top);
        if (!this.doesListening) {
            // we are not relying on the element to normalize out-of-bounds scroll values
            // so we need to sanitize ourselves
            this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);
            this.handleScrollChange();
        }
    };
    ScrollGeomCache1.prototype.getClientWidth = function() {
        return this.clientWidth;
    };
    ScrollGeomCache1.prototype.getClientHeight = function() {
        return this.clientHeight;
    };
    ScrollGeomCache1.prototype.getScrollWidth = function() {
        return this.scrollWidth;
    };
    ScrollGeomCache1.prototype.getScrollHeight = function() {
        return this.scrollHeight;
    };
    ScrollGeomCache1.prototype.handleScrollChange = function() {};
    return ScrollGeomCache1;
}(_common.ScrollController);
var ElementScrollGeomCache = /** @class */ function(_super) {
    _tslib.__extends(ElementScrollGeomCache1, _super);
    function ElementScrollGeomCache1(el, doesListening) {
        return _super.call(this, new _common.ElementScrollController(el), doesListening) || this;
    }
    ElementScrollGeomCache1.prototype.getEventTarget = function() {
        return this.scrollController.el;
    };
    ElementScrollGeomCache1.prototype.computeClientRect = function() {
        return _common.computeInnerRect(this.scrollController.el);
    };
    return ElementScrollGeomCache1;
}(ScrollGeomCache);
var WindowScrollGeomCache = /** @class */ function(_super) {
    _tslib.__extends(WindowScrollGeomCache1, _super);
    function WindowScrollGeomCache1(doesListening) {
        return _super.call(this, new _common.WindowScrollController(), doesListening) || this;
    }
    WindowScrollGeomCache1.prototype.getEventTarget = function() {
        return window;
    };
    WindowScrollGeomCache1.prototype.computeClientRect = function() {
        return {
            left: this.scrollLeft,
            right: this.scrollLeft + this.clientWidth,
            top: this.scrollTop,
            bottom: this.scrollTop + this.clientHeight
        };
    };
    // the window is the only scroll object that changes it's rectangle relative
    // to the document's topleft as it scrolls
    WindowScrollGeomCache1.prototype.handleScrollChange = function() {
        this.clientRect = this.computeClientRect();
    };
    return WindowScrollGeomCache1;
}(ScrollGeomCache);
// If available we are using native "performance" API instead of "Date"
// Read more about it on MDN:
// https://developer.mozilla.org/en-US/docs/Web/API/Performance
var getTime = typeof performance === 'function' ? performance.now : Date.now;
/*
For a pointer interaction, automatically scrolls certain scroll containers when the pointer
approaches the edge.

The caller must call start + handleMove + stop.
*/ var AutoScroller = /** @class */ function() {
    function AutoScroller1() {
        var _this = this;
        // options that can be set by caller
        this.isEnabled = true;
        this.scrollQuery = [
            window,
            '.fc-scroller'
        ];
        this.edgeThreshold = 50; // pixels
        this.maxVelocity = 300; // pixels per second
        // internal state
        this.pointerScreenX = null;
        this.pointerScreenY = null;
        this.isAnimating = false;
        this.scrollCaches = null;
        // protect against the initial pointerdown being too close to an edge and starting the scroll
        this.everMovedUp = false;
        this.everMovedDown = false;
        this.everMovedLeft = false;
        this.everMovedRight = false;
        this.animate = function() {
            if (_this.isAnimating) {
                var edge = _this.computeBestEdge(_this.pointerScreenX + window.pageXOffset, _this.pointerScreenY + window.pageYOffset);
                if (edge) {
                    var now = getTime();
                    _this.handleSide(edge, (now - _this.msSinceRequest) / 1000);
                    _this.requestAnimation(now);
                } else _this.isAnimating = false; // will stop animation
            }
        };
    }
    AutoScroller1.prototype.start = function(pageX, pageY, scrollStartEl) {
        if (this.isEnabled) {
            this.scrollCaches = this.buildCaches(scrollStartEl);
            this.pointerScreenX = null;
            this.pointerScreenY = null;
            this.everMovedUp = false;
            this.everMovedDown = false;
            this.everMovedLeft = false;
            this.everMovedRight = false;
            this.handleMove(pageX, pageY);
        }
    };
    AutoScroller1.prototype.handleMove = function(pageX, pageY) {
        if (this.isEnabled) {
            var pointerScreenX = pageX - window.pageXOffset;
            var pointerScreenY = pageY - window.pageYOffset;
            var yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;
            var xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;
            if (yDelta < 0) this.everMovedUp = true;
            else if (yDelta > 0) this.everMovedDown = true;
            if (xDelta < 0) this.everMovedLeft = true;
            else if (xDelta > 0) this.everMovedRight = true;
            this.pointerScreenX = pointerScreenX;
            this.pointerScreenY = pointerScreenY;
            if (!this.isAnimating) {
                this.isAnimating = true;
                this.requestAnimation(getTime());
            }
        }
    };
    AutoScroller1.prototype.stop = function() {
        if (this.isEnabled) {
            this.isAnimating = false; // will stop animation
            for(var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++){
                var scrollCache = _a[_i];
                scrollCache.destroy();
            }
            this.scrollCaches = null;
        }
    };
    AutoScroller1.prototype.requestAnimation = function(now) {
        this.msSinceRequest = now;
        requestAnimationFrame(this.animate);
    };
    AutoScroller1.prototype.handleSide = function(edge, seconds) {
        var scrollCache = edge.scrollCache;
        var edgeThreshold = this.edgeThreshold;
        var invDistance = edgeThreshold - edge.distance;
        var velocity = invDistance * invDistance / (edgeThreshold * edgeThreshold) * this.maxVelocity * seconds;
        var sign = 1;
        switch(edge.name){
            case 'left':
                sign = -1;
            // falls through
            case 'right':
                scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);
                break;
            case 'top':
                sign = -1;
            // falls through
            case 'bottom':
                scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);
                break;
        }
    };
    // left/top are relative to document topleft
    AutoScroller1.prototype.computeBestEdge = function(left, top) {
        var edgeThreshold = this.edgeThreshold;
        var bestSide = null;
        var scrollCaches = this.scrollCaches || [];
        for(var _i = 0, scrollCaches_1 = scrollCaches; _i < scrollCaches_1.length; _i++){
            var scrollCache = scrollCaches_1[_i];
            var rect = scrollCache.clientRect;
            var leftDist = left - rect.left;
            var rightDist = rect.right - left;
            var topDist = top - rect.top;
            var bottomDist = rect.bottom - top;
            // completely within the rect?
            if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {
                if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) bestSide = {
                    scrollCache: scrollCache,
                    name: 'top',
                    distance: topDist
                };
                if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) bestSide = {
                    scrollCache: scrollCache,
                    name: 'bottom',
                    distance: bottomDist
                };
                if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) bestSide = {
                    scrollCache: scrollCache,
                    name: 'left',
                    distance: leftDist
                };
                if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) bestSide = {
                    scrollCache: scrollCache,
                    name: 'right',
                    distance: rightDist
                };
            }
        }
        return bestSide;
    };
    AutoScroller1.prototype.buildCaches = function(scrollStartEl) {
        return this.queryScrollEls(scrollStartEl).map(function(el) {
            if (el === window) return new WindowScrollGeomCache(false); // false = don't listen to user-generated scrolls
            return new ElementScrollGeomCache(el, false); // false = don't listen to user-generated scrolls
        });
    };
    AutoScroller1.prototype.queryScrollEls = function(scrollStartEl) {
        var els = [];
        for(var _i = 0, _a = this.scrollQuery; _i < _a.length; _i++){
            var query = _a[_i];
            if (typeof query === 'object') els.push(query);
            else els.push.apply(els, Array.prototype.slice.call(_common.getElRoot(scrollStartEl).querySelectorAll(query)));
        }
        return els;
    };
    return AutoScroller1;
}();
/*
Monitors dragging on an element. Has a number of high-level features:
- minimum distance required before dragging
- minimum wait time ("delay") before dragging
- a mirror element that follows the pointer
*/ var FeaturefulElementDragging = /** @class */ function(_super) {
    _tslib.__extends(FeaturefulElementDragging1, _super);
    function FeaturefulElementDragging1(containerEl, selector) {
        var _this = _super.call(this, containerEl) || this;
        _this.containerEl = containerEl;
        // options that can be directly set by caller
        // the caller can also set the PointerDragging's options as well
        _this.delay = null;
        _this.minDistance = 0;
        _this.touchScrollAllowed = true; // prevents drag from starting and blocks scrolling during drag
        _this.mirrorNeedsRevert = false;
        _this.isInteracting = false; // is the user validly moving the pointer? lasts until pointerup
        _this.isDragging = false; // is it INTENTFULLY dragging? lasts until after revert animation
        _this.isDelayEnded = false;
        _this.isDistanceSurpassed = false;
        _this.delayTimeoutId = null;
        _this.onPointerDown = function(ev) {
            if (!_this.isDragging) {
                _this.isInteracting = true;
                _this.isDelayEnded = false;
                _this.isDistanceSurpassed = false;
                _common.preventSelection(document.body);
                _common.preventContextMenu(document.body);
                // prevent links from being visited if there's an eventual drag.
                // also prevents selection in older browsers (maybe?).
                // not necessary for touch, besides, browser would complain about passiveness.
                if (!ev.isTouch) ev.origEvent.preventDefault();
                _this.emitter.trigger('pointerdown', ev);
                if (_this.isInteracting && !_this.pointer.shouldIgnoreMove) {
                    // actions related to initiating dragstart+dragmove+dragend...
                    _this.mirror.setIsVisible(false); // reset. caller must set-visible
                    _this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY); // must happen on first pointer down
                    _this.startDelay(ev);
                    if (!_this.minDistance) _this.handleDistanceSurpassed(ev);
                }
            }
        };
        _this.onPointerMove = function(ev) {
            if (_this.isInteracting) {
                _this.emitter.trigger('pointermove', ev);
                if (!_this.isDistanceSurpassed) {
                    var minDistance = _this.minDistance;
                    var distanceSq = void 0; // current distance from the origin, squared
                    var deltaX = ev.deltaX, deltaY = ev.deltaY;
                    distanceSq = deltaX * deltaX + deltaY * deltaY;
                    if (distanceSq >= minDistance * minDistance) _this.handleDistanceSurpassed(ev);
                }
                if (_this.isDragging) {
                    // a real pointer move? (not one simulated by scrolling)
                    if (ev.origEvent.type !== 'scroll') {
                        _this.mirror.handleMove(ev.pageX, ev.pageY);
                        _this.autoScroller.handleMove(ev.pageX, ev.pageY);
                    }
                    _this.emitter.trigger('dragmove', ev);
                }
            }
        };
        _this.onPointerUp = function(ev) {
            if (_this.isInteracting) {
                _this.isInteracting = false;
                _common.allowSelection(document.body);
                _common.allowContextMenu(document.body);
                _this.emitter.trigger('pointerup', ev); // can potentially set mirrorNeedsRevert
                if (_this.isDragging) {
                    _this.autoScroller.stop();
                    _this.tryStopDrag(ev); // which will stop the mirror
                }
                if (_this.delayTimeoutId) {
                    clearTimeout(_this.delayTimeoutId);
                    _this.delayTimeoutId = null;
                }
            }
        };
        var pointer = _this.pointer = new PointerDragging(containerEl);
        pointer.emitter.on('pointerdown', _this.onPointerDown);
        pointer.emitter.on('pointermove', _this.onPointerMove);
        pointer.emitter.on('pointerup', _this.onPointerUp);
        if (selector) pointer.selector = selector;
        _this.mirror = new ElementMirror();
        _this.autoScroller = new AutoScroller();
        return _this;
    }
    FeaturefulElementDragging1.prototype.destroy = function() {
        this.pointer.destroy();
        // HACK: simulate a pointer-up to end the current drag
        // TODO: fire 'dragend' directly and stop interaction. discourage use of pointerup event (b/c might not fire)
        this.onPointerUp({});
    };
    FeaturefulElementDragging1.prototype.startDelay = function(ev) {
        var _this = this;
        if (typeof this.delay === 'number') this.delayTimeoutId = setTimeout(function() {
            _this.delayTimeoutId = null;
            _this.handleDelayEnd(ev);
        }, this.delay); // not assignable to number!
        else this.handleDelayEnd(ev);
    };
    FeaturefulElementDragging1.prototype.handleDelayEnd = function(ev) {
        this.isDelayEnded = true;
        this.tryStartDrag(ev);
    };
    FeaturefulElementDragging1.prototype.handleDistanceSurpassed = function(ev) {
        this.isDistanceSurpassed = true;
        this.tryStartDrag(ev);
    };
    FeaturefulElementDragging1.prototype.tryStartDrag = function(ev) {
        if (this.isDelayEnded && this.isDistanceSurpassed) {
            if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {
                this.isDragging = true;
                this.mirrorNeedsRevert = false;
                this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);
                this.emitter.trigger('dragstart', ev);
                if (this.touchScrollAllowed === false) this.pointer.cancelTouchScroll();
            }
        }
    };
    FeaturefulElementDragging1.prototype.tryStopDrag = function(ev) {
        // .stop() is ALWAYS asynchronous, which we NEED because we want all pointerup events
        // that come from the document to fire beforehand. much more convenient this way.
        this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));
    };
    FeaturefulElementDragging1.prototype.stopDrag = function(ev) {
        this.isDragging = false;
        this.emitter.trigger('dragend', ev);
    };
    // fill in the implementations...
    FeaturefulElementDragging1.prototype.setIgnoreMove = function(bool) {
        this.pointer.shouldIgnoreMove = bool;
    };
    FeaturefulElementDragging1.prototype.setMirrorIsVisible = function(bool) {
        this.mirror.setIsVisible(bool);
    };
    FeaturefulElementDragging1.prototype.setMirrorNeedsRevert = function(bool) {
        this.mirrorNeedsRevert = bool;
    };
    FeaturefulElementDragging1.prototype.setAutoScrollEnabled = function(bool) {
        this.autoScroller.isEnabled = bool;
    };
    return FeaturefulElementDragging1;
}(_common.ElementDragging);
/*
When this class is instantiated, it records the offset of an element (relative to the document topleft),
and continues to monitor scrolling, updating the cached coordinates if it needs to.
Does not access the DOM after instantiation, so highly performant.

Also keeps track of all scrolling/overflow:hidden containers that are parents of the given element
and an determine if a given point is inside the combined clipping rectangle.
*/ var OffsetTracker = /** @class */ function() {
    function OffsetTracker1(el) {
        this.origRect = _common.computeRect(el);
        // will work fine for divs that have overflow:hidden
        this.scrollCaches = _common.getClippingParents(el).map(function(scrollEl) {
            return new ElementScrollGeomCache(scrollEl, true);
        });
    }
    OffsetTracker1.prototype.destroy = function() {
        for(var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++){
            var scrollCache = _a[_i];
            scrollCache.destroy();
        }
    };
    OffsetTracker1.prototype.computeLeft = function() {
        var left = this.origRect.left;
        for(var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++){
            var scrollCache = _a[_i];
            left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();
        }
        return left;
    };
    OffsetTracker1.prototype.computeTop = function() {
        var top = this.origRect.top;
        for(var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++){
            var scrollCache = _a[_i];
            top += scrollCache.origScrollTop - scrollCache.getScrollTop();
        }
        return top;
    };
    OffsetTracker1.prototype.isWithinClipping = function(pageX, pageY) {
        var point = {
            left: pageX,
            top: pageY
        };
        for(var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++){
            var scrollCache = _a[_i];
            if (!isIgnoredClipping(scrollCache.getEventTarget()) && !_common.pointInsideRect(point, scrollCache.clientRect)) return false;
        }
        return true;
    };
    return OffsetTracker1;
}();
// certain clipping containers should never constrain interactions, like <html> and <body>
// https://github.com/fullcalendar/fullcalendar/issues/3615
function isIgnoredClipping(node) {
    var tagName = node.tagName;
    return tagName === 'HTML' || tagName === 'BODY';
}
/*
Tracks movement over multiple droppable areas (aka "hits")
that exist in one or more DateComponents.
Relies on an existing draggable.

emits:
- pointerdown
- dragstart
- hitchange - fires initially, even if not over a hit
- pointerup
- (hitchange - again, to null, if ended over a hit)
- dragend
*/ var HitDragging = /** @class */ function() {
    function HitDragging1(dragging1, droppableStore) {
        var _this = this;
        // options that can be set by caller
        this.useSubjectCenter = false;
        this.requireInitial = true; // if doesn't start out on a hit, won't emit any events
        this.initialHit = null;
        this.movingHit = null;
        this.finalHit = null; // won't ever be populated if shouldIgnoreMove
        this.handlePointerDown = function(ev) {
            var dragging = _this.dragging;
            _this.initialHit = null;
            _this.movingHit = null;
            _this.finalHit = null;
            _this.prepareHits();
            _this.processFirstCoord(ev);
            if (_this.initialHit || !_this.requireInitial) {
                dragging.setIgnoreMove(false);
                // TODO: fire this before computing processFirstCoord, so listeners can cancel. this gets fired by almost every handler :(
                _this.emitter.trigger('pointerdown', ev);
            } else dragging.setIgnoreMove(true);
        };
        this.handleDragStart = function(ev) {
            _this.emitter.trigger('dragstart', ev);
            _this.handleMove(ev, true); // force = fire even if initially null
        };
        this.handleDragMove = function(ev) {
            _this.emitter.trigger('dragmove', ev);
            _this.handleMove(ev);
        };
        this.handlePointerUp = function(ev) {
            _this.releaseHits();
            _this.emitter.trigger('pointerup', ev);
        };
        this.handleDragEnd = function(ev) {
            if (_this.movingHit) _this.emitter.trigger('hitupdate', null, true, ev);
            _this.finalHit = _this.movingHit;
            _this.movingHit = null;
            _this.emitter.trigger('dragend', ev);
        };
        this.droppableStore = droppableStore;
        dragging1.emitter.on('pointerdown', this.handlePointerDown);
        dragging1.emitter.on('dragstart', this.handleDragStart);
        dragging1.emitter.on('dragmove', this.handleDragMove);
        dragging1.emitter.on('pointerup', this.handlePointerUp);
        dragging1.emitter.on('dragend', this.handleDragEnd);
        this.dragging = dragging1;
        this.emitter = new _common.Emitter();
    }
    // sets initialHit
    // sets coordAdjust
    HitDragging1.prototype.processFirstCoord = function(ev) {
        var origPoint = {
            left: ev.pageX,
            top: ev.pageY
        };
        var adjustedPoint = origPoint;
        var subjectEl = ev.subjectEl;
        var subjectRect;
        if (subjectEl instanceof HTMLElement) {
            subjectRect = _common.computeRect(subjectEl);
            adjustedPoint = _common.constrainPoint(adjustedPoint, subjectRect);
        }
        var initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);
        if (initialHit) {
            if (this.useSubjectCenter && subjectRect) {
                var slicedSubjectRect = _common.intersectRects(subjectRect, initialHit.rect);
                if (slicedSubjectRect) adjustedPoint = _common.getRectCenter(slicedSubjectRect);
            }
            this.coordAdjust = _common.diffPoints(adjustedPoint, origPoint);
        } else this.coordAdjust = {
            left: 0,
            top: 0
        };
    };
    HitDragging1.prototype.handleMove = function(ev, forceHandle) {
        var hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);
        if (forceHandle || !isHitsEqual(this.movingHit, hit)) {
            this.movingHit = hit;
            this.emitter.trigger('hitupdate', hit, false, ev);
        }
    };
    HitDragging1.prototype.prepareHits = function() {
        this.offsetTrackers = _common.mapHash(this.droppableStore, function(interactionSettings) {
            interactionSettings.component.prepareHits();
            return new OffsetTracker(interactionSettings.el);
        });
    };
    HitDragging1.prototype.releaseHits = function() {
        var offsetTrackers = this.offsetTrackers;
        for(var id in offsetTrackers)offsetTrackers[id].destroy();
        this.offsetTrackers = {};
    };
    HitDragging1.prototype.queryHitForOffset = function(offsetLeft, offsetTop) {
        var _a = this, droppableStore = _a.droppableStore, offsetTrackers = _a.offsetTrackers;
        var bestHit = null;
        for(var id in droppableStore){
            var component = droppableStore[id].component;
            var offsetTracker = offsetTrackers[id];
            if (offsetTracker && offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {
                var originLeft = offsetTracker.computeLeft();
                var originTop = offsetTracker.computeTop();
                var positionLeft = offsetLeft - originLeft;
                var positionTop = offsetTop - originTop;
                var origRect = offsetTracker.origRect;
                var width = origRect.right - origRect.left;
                var height = origRect.bottom - origRect.top;
                if (// must be within the element's bounds
                positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height) {
                    var hit = component.queryHit(positionLeft, positionTop, width, height);
                    if (hit && // make sure the hit is within activeRange, meaning it's not a dead cell
                    _common.rangeContainsRange(hit.dateProfile.activeRange, hit.dateSpan.range) && (!bestHit || hit.layer > bestHit.layer)) {
                        hit.componentId = id;
                        hit.context = component.context;
                        // TODO: better way to re-orient rectangle
                        hit.rect.left += originLeft;
                        hit.rect.right += originLeft;
                        hit.rect.top += originTop;
                        hit.rect.bottom += originTop;
                        bestHit = hit;
                    }
                }
            }
        }
        return bestHit;
    };
    return HitDragging1;
}();
function isHitsEqual(hit0, hit1) {
    if (!hit0 && !hit1) return true;
    if (Boolean(hit0) !== Boolean(hit1)) return false;
    return _common.isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);
}
function buildDatePointApiWithContext(dateSpan, context) {
    var props = {};
    for(var _i = 0, _a = context.pluginHooks.datePointTransforms; _i < _a.length; _i++){
        var transform = _a[_i];
        _tslib.__assign(props, transform(dateSpan, context));
    }
    _tslib.__assign(props, buildDatePointApi(dateSpan, context.dateEnv));
    return props;
}
function buildDatePointApi(span, dateEnv) {
    return {
        date: dateEnv.toDate(span.range.start),
        dateStr: dateEnv.formatIso(span.range.start, {
            omitTime: span.allDay
        }),
        allDay: span.allDay
    };
}
/*
Monitors when the user clicks on a specific date/time of a component.
A pointerdown+pointerup on the same "hit" constitutes a click.
*/ var DateClicking = /** @class */ function(_super) {
    _tslib.__extends(DateClicking1, _super);
    function DateClicking1(settings) {
        var _this = _super.call(this, settings) || this;
        _this.handlePointerDown = function(pev) {
            var dragging = _this.dragging;
            var downEl = pev.origEvent.target;
            // do this in pointerdown (not dragend) because DOM might be mutated by the time dragend is fired
            dragging.setIgnoreMove(!_this.component.isValidDateDownEl(downEl));
        };
        // won't even fire if moving was ignored
        _this.handleDragEnd = function(ev) {
            var component = _this.component;
            var pointer = _this.dragging.pointer;
            if (!pointer.wasTouchScroll) {
                var _a = _this.hitDragging, initialHit = _a.initialHit, finalHit = _a.finalHit;
                if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {
                    var context = component.context;
                    var arg = _tslib.__assign(_tslib.__assign({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), {
                        dayEl: initialHit.dayEl,
                        jsEvent: ev.origEvent,
                        view: context.viewApi || context.calendarApi.view
                    });
                    context.emitter.trigger('dateClick', arg);
                }
            }
        };
        // we DO want to watch pointer moves because otherwise finalHit won't get populated
        _this.dragging = new FeaturefulElementDragging(settings.el);
        _this.dragging.autoScroller.isEnabled = false;
        var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, _common.interactionSettingsToStore(settings));
        hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
        hitDragging.emitter.on('dragend', _this.handleDragEnd);
        return _this;
    }
    DateClicking1.prototype.destroy = function() {
        this.dragging.destroy();
    };
    return DateClicking1;
}(_common.Interaction);
/*
Tracks when the user selects a portion of time of a component,
constituted by a drag over date cells, with a possible delay at the beginning of the drag.
*/ var DateSelecting = /** @class */ function(_super) {
    _tslib.__extends(DateSelecting1, _super);
    function DateSelecting1(settings) {
        var _this = _super.call(this, settings) || this;
        _this.dragSelection = null;
        _this.handlePointerDown = function(ev) {
            var _a = _this, component = _a.component, dragging = _a.dragging;
            var options = component.context.options;
            var canSelect = options.selectable && component.isValidDateDownEl(ev.origEvent.target);
            // don't bother to watch expensive moves if component won't do selection
            dragging.setIgnoreMove(!canSelect);
            // if touch, require user to hold down
            dragging.delay = ev.isTouch ? getComponentTouchDelay$1(component) : null;
        };
        _this.handleDragStart = function(ev) {
            _this.component.context.calendarApi.unselect(ev); // unselect previous selections
        };
        _this.handleHitUpdate = function(hit, isFinal) {
            var context = _this.component.context;
            var dragSelection = null;
            var isInvalid = false;
            if (hit) {
                var initialHit = _this.hitDragging.initialHit;
                var disallowed = hit.componentId === initialHit.componentId && _this.isHitComboAllowed && !_this.isHitComboAllowed(initialHit, hit);
                if (!disallowed) dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);
                if (!dragSelection || !_common.isDateSelectionValid(dragSelection, hit.dateProfile, context)) {
                    isInvalid = true;
                    dragSelection = null;
                }
            }
            if (dragSelection) context.dispatch({
                type: 'SELECT_DATES',
                selection: dragSelection
            });
            else if (!isFinal) context.dispatch({
                type: 'UNSELECT_DATES'
            });
            if (!isInvalid) _common.enableCursor();
            else _common.disableCursor();
            if (!isFinal) _this.dragSelection = dragSelection; // only clear if moved away from all hits while dragging
        };
        _this.handlePointerUp = function(pev) {
            if (_this.dragSelection) {
                // selection is already rendered, so just need to report selection
                _common.triggerDateSelect(_this.dragSelection, pev, _this.component.context);
                _this.dragSelection = null;
            }
        };
        var component1 = settings.component;
        var options1 = component1.context.options;
        var dragging2 = _this.dragging = new FeaturefulElementDragging(settings.el);
        dragging2.touchScrollAllowed = false;
        dragging2.minDistance = options1.selectMinDistance || 0;
        dragging2.autoScroller.isEnabled = options1.dragScroll;
        var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, _common.interactionSettingsToStore(settings));
        hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
        hitDragging.emitter.on('dragstart', _this.handleDragStart);
        hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);
        hitDragging.emitter.on('pointerup', _this.handlePointerUp);
        return _this;
    }
    DateSelecting1.prototype.destroy = function() {
        this.dragging.destroy();
    };
    return DateSelecting1;
}(_common.Interaction);
function getComponentTouchDelay$1(component) {
    var options = component.context.options;
    var delay = options.selectLongPressDelay;
    if (delay == null) delay = options.longPressDelay;
    return delay;
}
function joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {
    var dateSpan0 = hit0.dateSpan;
    var dateSpan1 = hit1.dateSpan;
    var ms = [
        dateSpan0.range.start,
        dateSpan0.range.end,
        dateSpan1.range.start,
        dateSpan1.range.end, 
    ];
    ms.sort(_common.compareNumbers);
    var props = {};
    for(var _i = 0, dateSelectionTransformers_1 = dateSelectionTransformers; _i < dateSelectionTransformers_1.length; _i++){
        var transformer = dateSelectionTransformers_1[_i];
        var res = transformer(hit0, hit1);
        if (res === false) return null;
        if (res) _tslib.__assign(props, res);
    }
    props.range = {
        start: ms[0],
        end: ms[3]
    };
    props.allDay = dateSpan0.allDay;
    return props;
}
var EventDragging = /** @class */ function(_super) {
    _tslib.__extends(EventDragging1, _super);
    function EventDragging1(settings) {
        var _this = _super.call(this, settings) || this;
        // internal state
        _this.subjectEl = null;
        _this.subjectSeg = null; // the seg being selected/dragged
        _this.isDragging = false;
        _this.eventRange = null;
        _this.relevantEvents = null; // the events being dragged
        _this.receivingContext = null;
        _this.validMutation = null;
        _this.mutatedRelevantEvents = null;
        _this.handlePointerDown = function(ev) {
            var origTarget = ev.origEvent.target;
            var _a = _this, component = _a.component, dragging = _a.dragging;
            var mirror = dragging.mirror;
            var options = component.context.options;
            var initialContext = component.context;
            _this.subjectEl = ev.subjectEl;
            var subjectSeg = _this.subjectSeg = _common.getElSeg(ev.subjectEl);
            var eventRange = _this.eventRange = subjectSeg.eventRange;
            var eventInstanceId = eventRange.instance.instanceId;
            _this.relevantEvents = _common.getRelevantEvents(initialContext.getCurrentData().eventStore, eventInstanceId);
            dragging.minDistance = ev.isTouch ? 0 : options.eventDragMinDistance;
            dragging.delay = // only do a touch delay if touch and this event hasn't been selected yet
            ev.isTouch && eventInstanceId !== component.props.eventSelection ? getComponentTouchDelay(component) : null;
            if (options.fixedMirrorParent) mirror.parentNode = options.fixedMirrorParent;
            else mirror.parentNode = _common.elementClosest(origTarget, '.fc');
            mirror.revertDuration = options.dragRevertDuration;
            var isValid = component.isValidSegDownEl(origTarget) && !_common.elementClosest(origTarget, '.fc-event-resizer'); // NOT on a resizer
            dragging.setIgnoreMove(!isValid);
            // disable dragging for elements that are resizable (ie, selectable)
            // but are not draggable
            _this.isDragging = isValid && ev.subjectEl.classList.contains('fc-event-draggable');
        };
        _this.handleDragStart = function(ev) {
            var initialContext = _this.component.context;
            var eventRange = _this.eventRange;
            var eventInstanceId = eventRange.instance.instanceId;
            if (ev.isTouch) // need to select a different event?
            {
                if (eventInstanceId !== _this.component.props.eventSelection) initialContext.dispatch({
                    type: 'SELECT_EVENT',
                    eventInstanceId: eventInstanceId
                });
            } else // if now using mouse, but was previous touch interaction, clear selected event
            initialContext.dispatch({
                type: 'UNSELECT_EVENT'
            });
            if (_this.isDragging) {
                initialContext.calendarApi.unselect(ev); // unselect *date* selection
                initialContext.emitter.trigger('eventDragStart', {
                    el: _this.subjectEl,
                    event: new _common.EventApi(initialContext, eventRange.def, eventRange.instance),
                    jsEvent: ev.origEvent,
                    view: initialContext.viewApi
                });
            }
        };
        _this.handleHitUpdate = function(hit, isFinal) {
            if (!_this.isDragging) return;
            var relevantEvents = _this.relevantEvents;
            var initialHit = _this.hitDragging.initialHit;
            var initialContext = _this.component.context;
            // states based on new hit
            var receivingContext = null;
            var mutation = null;
            var mutatedRelevantEvents = null;
            var isInvalid = false;
            var interaction = {
                affectedEvents: relevantEvents,
                mutatedEvents: _common.createEmptyEventStore(),
                isEvent: true
            };
            if (hit) {
                receivingContext = hit.context;
                var receivingOptions = receivingContext.options;
                if (initialContext === receivingContext || receivingOptions.editable && receivingOptions.droppable) {
                    mutation = computeEventMutation(initialHit, hit, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);
                    if (mutation) {
                        mutatedRelevantEvents = _common.applyMutationToEventStore(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);
                        interaction.mutatedEvents = mutatedRelevantEvents;
                        if (!_common.isInteractionValid(interaction, hit.dateProfile, receivingContext)) {
                            isInvalid = true;
                            mutation = null;
                            mutatedRelevantEvents = null;
                            interaction.mutatedEvents = _common.createEmptyEventStore();
                        }
                    }
                } else receivingContext = null;
            }
            _this.displayDrag(receivingContext, interaction);
            if (!isInvalid) _common.enableCursor();
            else _common.disableCursor();
            if (!isFinal) {
                if (initialContext === receivingContext && isHitsEqual(initialHit, hit)) mutation = null;
                _this.dragging.setMirrorNeedsRevert(!mutation);
                // render the mirror if no already-rendered mirror
                // TODO: wish we could somehow wait for dispatch to guarantee render
                _this.dragging.setMirrorIsVisible(!hit || !_common.getElRoot(_this.subjectEl).querySelector('.fc-event-mirror'));
                // assign states based on new hit
                _this.receivingContext = receivingContext;
                _this.validMutation = mutation;
                _this.mutatedRelevantEvents = mutatedRelevantEvents;
            }
        };
        _this.handlePointerUp = function() {
            if (!_this.isDragging) _this.cleanup(); // because handleDragEnd won't fire
        };
        _this.handleDragEnd = function(ev) {
            if (_this.isDragging) {
                var initialContext_1 = _this.component.context;
                var initialView = initialContext_1.viewApi;
                var _a = _this, receivingContext_1 = _a.receivingContext, validMutation = _a.validMutation;
                var eventDef = _this.eventRange.def;
                var eventInstance = _this.eventRange.instance;
                var eventApi = new _common.EventApi(initialContext_1, eventDef, eventInstance);
                var relevantEvents_1 = _this.relevantEvents;
                var mutatedRelevantEvents_1 = _this.mutatedRelevantEvents;
                var finalHit = _this.hitDragging.finalHit;
                _this.clearDrag(); // must happen after revert animation
                initialContext_1.emitter.trigger('eventDragStop', {
                    el: _this.subjectEl,
                    event: eventApi,
                    jsEvent: ev.origEvent,
                    view: initialView
                });
                if (validMutation) {
                    // dropped within same calendar
                    if (receivingContext_1 === initialContext_1) {
                        var updatedEventApi = new _common.EventApi(initialContext_1, mutatedRelevantEvents_1.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents_1.instances[eventInstance.instanceId] : null);
                        initialContext_1.dispatch({
                            type: 'MERGE_EVENTS',
                            eventStore: mutatedRelevantEvents_1
                        });
                        var eventChangeArg = {
                            oldEvent: eventApi,
                            event: updatedEventApi,
                            relatedEvents: _common.buildEventApis(mutatedRelevantEvents_1, initialContext_1, eventInstance),
                            revert: function() {
                                initialContext_1.dispatch({
                                    type: 'MERGE_EVENTS',
                                    eventStore: relevantEvents_1
                                });
                            }
                        };
                        var transformed = {};
                        for(var _i = 0, _b = initialContext_1.getCurrentData().pluginHooks.eventDropTransformers; _i < _b.length; _i++){
                            var transformer = _b[_i];
                            _tslib.__assign(transformed, transformer(validMutation, initialContext_1));
                        }
                        initialContext_1.emitter.trigger('eventDrop', _tslib.__assign(_tslib.__assign(_tslib.__assign({}, eventChangeArg), transformed), {
                            el: ev.subjectEl,
                            delta: validMutation.datesDelta,
                            jsEvent: ev.origEvent,
                            view: initialView
                        }));
                        initialContext_1.emitter.trigger('eventChange', eventChangeArg);
                    // dropped in different calendar
                    } else if (receivingContext_1) {
                        var eventRemoveArg = {
                            event: eventApi,
                            relatedEvents: _common.buildEventApis(relevantEvents_1, initialContext_1, eventInstance),
                            revert: function() {
                                initialContext_1.dispatch({
                                    type: 'MERGE_EVENTS',
                                    eventStore: relevantEvents_1
                                });
                            }
                        };
                        initialContext_1.emitter.trigger('eventLeave', _tslib.__assign(_tslib.__assign({}, eventRemoveArg), {
                            draggedEl: ev.subjectEl,
                            view: initialView
                        }));
                        initialContext_1.dispatch({
                            type: 'REMOVE_EVENTS',
                            eventStore: relevantEvents_1
                        });
                        initialContext_1.emitter.trigger('eventRemove', eventRemoveArg);
                        var addedEventDef = mutatedRelevantEvents_1.defs[eventDef.defId];
                        var addedEventInstance = mutatedRelevantEvents_1.instances[eventInstance.instanceId];
                        var addedEventApi = new _common.EventApi(receivingContext_1, addedEventDef, addedEventInstance);
                        receivingContext_1.dispatch({
                            type: 'MERGE_EVENTS',
                            eventStore: mutatedRelevantEvents_1
                        });
                        var eventAddArg = {
                            event: addedEventApi,
                            relatedEvents: _common.buildEventApis(mutatedRelevantEvents_1, receivingContext_1, addedEventInstance),
                            revert: function() {
                                receivingContext_1.dispatch({
                                    type: 'REMOVE_EVENTS',
                                    eventStore: mutatedRelevantEvents_1
                                });
                            }
                        };
                        receivingContext_1.emitter.trigger('eventAdd', eventAddArg);
                        if (ev.isTouch) receivingContext_1.dispatch({
                            type: 'SELECT_EVENT',
                            eventInstanceId: eventInstance.instanceId
                        });
                        receivingContext_1.emitter.trigger('drop', _tslib.__assign(_tslib.__assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext_1)), {
                            draggedEl: ev.subjectEl,
                            jsEvent: ev.origEvent,
                            view: finalHit.context.viewApi
                        }));
                        receivingContext_1.emitter.trigger('eventReceive', _tslib.__assign(_tslib.__assign({}, eventAddArg), {
                            draggedEl: ev.subjectEl,
                            view: finalHit.context.viewApi
                        }));
                    }
                } else initialContext_1.emitter.trigger('_noEventDrop');
            }
            _this.cleanup();
        };
        var component2 = _this.component;
        var options2 = component2.context.options;
        var dragging3 = _this.dragging = new FeaturefulElementDragging(settings.el);
        dragging3.pointer.selector = EventDragging1.SELECTOR;
        dragging3.touchScrollAllowed = false;
        dragging3.autoScroller.isEnabled = options2.dragScroll;
        var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, _common.interactionSettingsStore);
        hitDragging.useSubjectCenter = settings.useEventCenter;
        hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
        hitDragging.emitter.on('dragstart', _this.handleDragStart);
        hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);
        hitDragging.emitter.on('pointerup', _this.handlePointerUp);
        hitDragging.emitter.on('dragend', _this.handleDragEnd);
        return _this;
    }
    EventDragging1.prototype.destroy = function() {
        this.dragging.destroy();
    };
    // render a drag state on the next receivingCalendar
    EventDragging1.prototype.displayDrag = function(nextContext, state) {
        var initialContext = this.component.context;
        var prevContext = this.receivingContext;
        // does the previous calendar need to be cleared?
        if (prevContext && prevContext !== nextContext) {
            // does the initial calendar need to be cleared?
            // if so, don't clear all the way. we still need to to hide the affectedEvents
            if (prevContext === initialContext) prevContext.dispatch({
                type: 'SET_EVENT_DRAG',
                state: {
                    affectedEvents: state.affectedEvents,
                    mutatedEvents: _common.createEmptyEventStore(),
                    isEvent: true
                }
            });
            else prevContext.dispatch({
                type: 'UNSET_EVENT_DRAG'
            });
        }
        if (nextContext) nextContext.dispatch({
            type: 'SET_EVENT_DRAG',
            state: state
        });
    };
    EventDragging1.prototype.clearDrag = function() {
        var initialCalendar = this.component.context;
        var receivingContext = this.receivingContext;
        if (receivingContext) receivingContext.dispatch({
            type: 'UNSET_EVENT_DRAG'
        });
        // the initial calendar might have an dummy drag state from displayDrag
        if (initialCalendar !== receivingContext) initialCalendar.dispatch({
            type: 'UNSET_EVENT_DRAG'
        });
    };
    EventDragging1.prototype.cleanup = function() {
        this.subjectSeg = null;
        this.isDragging = false;
        this.eventRange = null;
        this.relevantEvents = null;
        this.receivingContext = null;
        this.validMutation = null;
        this.mutatedRelevantEvents = null;
    };
    // TODO: test this in IE11
    // QUESTION: why do we need it on the resizable???
    EventDragging1.SELECTOR = '.fc-event-draggable, .fc-event-resizable';
    return EventDragging1;
}(_common.Interaction);
function computeEventMutation(hit0, hit1, massagers) {
    var dateSpan0 = hit0.dateSpan;
    var dateSpan1 = hit1.dateSpan;
    var date0 = dateSpan0.range.start;
    var date1 = dateSpan1.range.start;
    var standardProps = {};
    if (dateSpan0.allDay !== dateSpan1.allDay) {
        standardProps.allDay = dateSpan1.allDay;
        standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;
        if (dateSpan1.allDay) // means date1 is already start-of-day,
        // but date0 needs to be converted
        date0 = _common.startOfDay(date0);
    }
    var delta = _common.diffDates(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ? hit0.largeUnit : null);
    if (delta.milliseconds) standardProps.allDay = false;
    var mutation = {
        datesDelta: delta,
        standardProps: standardProps
    };
    for(var _i = 0, massagers_1 = massagers; _i < massagers_1.length; _i++){
        var massager = massagers_1[_i];
        massager(mutation, hit0, hit1);
    }
    return mutation;
}
function getComponentTouchDelay(component) {
    var options = component.context.options;
    var delay = options.eventLongPressDelay;
    if (delay == null) delay = options.longPressDelay;
    return delay;
}
var EventResizing = /** @class */ function(_super) {
    _tslib.__extends(EventResizing1, _super);
    function EventResizing1(settings) {
        var _this = _super.call(this, settings) || this;
        // internal state
        _this.draggingSegEl = null;
        _this.draggingSeg = null; // TODO: rename to resizingSeg? subjectSeg?
        _this.eventRange = null;
        _this.relevantEvents = null;
        _this.validMutation = null;
        _this.mutatedRelevantEvents = null;
        _this.handlePointerDown = function(ev) {
            var component = _this.component;
            var segEl = _this.querySegEl(ev);
            var seg = _common.getElSeg(segEl);
            var eventRange = _this.eventRange = seg.eventRange;
            _this.dragging.minDistance = component.context.options.eventDragMinDistance;
            // if touch, need to be working with a selected event
            _this.dragging.setIgnoreMove(!_this.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && _this.component.props.eventSelection !== eventRange.instance.instanceId);
        };
        _this.handleDragStart = function(ev) {
            var context = _this.component.context;
            var eventRange = _this.eventRange;
            _this.relevantEvents = _common.getRelevantEvents(context.getCurrentData().eventStore, _this.eventRange.instance.instanceId);
            var segEl = _this.querySegEl(ev);
            _this.draggingSegEl = segEl;
            _this.draggingSeg = _common.getElSeg(segEl);
            context.calendarApi.unselect();
            context.emitter.trigger('eventResizeStart', {
                el: segEl,
                event: new _common.EventApi(context, eventRange.def, eventRange.instance),
                jsEvent: ev.origEvent,
                view: context.viewApi
            });
        };
        _this.handleHitUpdate = function(hit, isFinal, ev) {
            var context = _this.component.context;
            var relevantEvents = _this.relevantEvents;
            var initialHit = _this.hitDragging.initialHit;
            var eventInstance = _this.eventRange.instance;
            var mutation = null;
            var mutatedRelevantEvents = null;
            var isInvalid = false;
            var interaction = {
                affectedEvents: relevantEvents,
                mutatedEvents: _common.createEmptyEventStore(),
                isEvent: true
            };
            if (hit) {
                var disallowed = hit.componentId === initialHit.componentId && _this.isHitComboAllowed && !_this.isHitComboAllowed(initialHit, hit);
                if (!disallowed) mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains('fc-event-resizer-start'), eventInstance.range);
            }
            if (mutation) {
                mutatedRelevantEvents = _common.applyMutationToEventStore(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);
                interaction.mutatedEvents = mutatedRelevantEvents;
                if (!_common.isInteractionValid(interaction, hit.dateProfile, context)) {
                    isInvalid = true;
                    mutation = null;
                    mutatedRelevantEvents = null;
                    interaction.mutatedEvents = null;
                }
            }
            if (mutatedRelevantEvents) context.dispatch({
                type: 'SET_EVENT_RESIZE',
                state: interaction
            });
            else context.dispatch({
                type: 'UNSET_EVENT_RESIZE'
            });
            if (!isInvalid) _common.enableCursor();
            else _common.disableCursor();
            if (!isFinal) {
                if (mutation && isHitsEqual(initialHit, hit)) mutation = null;
                _this.validMutation = mutation;
                _this.mutatedRelevantEvents = mutatedRelevantEvents;
            }
        };
        _this.handleDragEnd = function(ev) {
            var context = _this.component.context;
            var eventDef = _this.eventRange.def;
            var eventInstance = _this.eventRange.instance;
            var eventApi = new _common.EventApi(context, eventDef, eventInstance);
            var relevantEvents = _this.relevantEvents;
            var mutatedRelevantEvents = _this.mutatedRelevantEvents;
            context.emitter.trigger('eventResizeStop', {
                el: _this.draggingSegEl,
                event: eventApi,
                jsEvent: ev.origEvent,
                view: context.viewApi
            });
            if (_this.validMutation) {
                var updatedEventApi = new _common.EventApi(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
                context.dispatch({
                    type: 'MERGE_EVENTS',
                    eventStore: mutatedRelevantEvents
                });
                var eventChangeArg = {
                    oldEvent: eventApi,
                    event: updatedEventApi,
                    relatedEvents: _common.buildEventApis(mutatedRelevantEvents, context, eventInstance),
                    revert: function() {
                        context.dispatch({
                            type: 'MERGE_EVENTS',
                            eventStore: relevantEvents
                        });
                    }
                };
                context.emitter.trigger('eventResize', _tslib.__assign(_tslib.__assign({}, eventChangeArg), {
                    el: _this.draggingSegEl,
                    startDelta: _this.validMutation.startDelta || _common.createDuration(0),
                    endDelta: _this.validMutation.endDelta || _common.createDuration(0),
                    jsEvent: ev.origEvent,
                    view: context.viewApi
                }));
                context.emitter.trigger('eventChange', eventChangeArg);
            } else context.emitter.trigger('_noEventResize');
            // reset all internal state
            _this.draggingSeg = null;
            _this.relevantEvents = null;
            _this.validMutation = null;
        // okay to keep eventInstance around. useful to set it in handlePointerDown
        };
        var component3 = settings.component;
        var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);
        dragging.pointer.selector = '.fc-event-resizer';
        dragging.touchScrollAllowed = false;
        dragging.autoScroller.isEnabled = component3.context.options.dragScroll;
        var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, _common.interactionSettingsToStore(settings));
        hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
        hitDragging.emitter.on('dragstart', _this.handleDragStart);
        hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);
        hitDragging.emitter.on('dragend', _this.handleDragEnd);
        return _this;
    }
    EventResizing1.prototype.destroy = function() {
        this.dragging.destroy();
    };
    EventResizing1.prototype.querySegEl = function(ev) {
        return _common.elementClosest(ev.subjectEl, '.fc-event');
    };
    return EventResizing1;
}(_common.Interaction);
function computeMutation(hit0, hit1, isFromStart, instanceRange) {
    var dateEnv = hit0.context.dateEnv;
    var date0 = hit0.dateSpan.range.start;
    var date1 = hit1.dateSpan.range.start;
    var delta = _common.diffDates(date0, date1, dateEnv, hit0.largeUnit);
    if (isFromStart) {
        if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) return {
            startDelta: delta
        };
    } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) return {
        endDelta: delta
    };
    return null;
}
var UnselectAuto = /** @class */ function() {
    function UnselectAuto1(context1) {
        var _this = this;
        this.context = context1;
        this.isRecentPointerDateSelect = false; // wish we could use a selector to detect date selection, but uses hit system
        this.matchesCancel = false;
        this.matchesEvent = false;
        this.onSelect = function(selectInfo) {
            if (selectInfo.jsEvent) _this.isRecentPointerDateSelect = true;
        };
        this.onDocumentPointerDown = function(pev) {
            var unselectCancel = _this.context.options.unselectCancel;
            var downEl = _common.getEventTargetViaRoot(pev.origEvent);
            _this.matchesCancel = !!_common.elementClosest(downEl, unselectCancel);
            _this.matchesEvent = !!_common.elementClosest(downEl, EventDragging.SELECTOR); // interaction started on an event?
        };
        this.onDocumentPointerUp = function(pev) {
            var context = _this.context;
            var documentPointer = _this.documentPointer;
            var calendarState = context.getCurrentData();
            // touch-scrolling should never unfocus any type of selection
            if (!documentPointer.wasTouchScroll) {
                if (calendarState.dateSelection && !_this.isRecentPointerDateSelect // a new pointer-initiated date selection since last onDocumentPointerUp?
                ) {
                    var unselectAuto = context.options.unselectAuto;
                    if (unselectAuto && (!unselectAuto || !_this.matchesCancel)) context.calendarApi.unselect(pev);
                }
                if (calendarState.eventSelection && !_this.matchesEvent // interaction DIDN'T start on an event
                ) context.dispatch({
                    type: 'UNSELECT_EVENT'
                });
            }
            _this.isRecentPointerDateSelect = false;
        };
        var documentPointer1 = this.documentPointer = new PointerDragging(document);
        documentPointer1.shouldIgnoreMove = true;
        documentPointer1.shouldWatchScroll = false;
        documentPointer1.emitter.on('pointerdown', this.onDocumentPointerDown);
        documentPointer1.emitter.on('pointerup', this.onDocumentPointerUp);
        /*
        TODO: better way to know about whether there was a selection with the pointer
        */ context1.emitter.on('select', this.onSelect);
    }
    UnselectAuto1.prototype.destroy = function() {
        this.context.emitter.off('select', this.onSelect);
        this.documentPointer.destroy();
    };
    return UnselectAuto1;
}();
var OPTION_REFINERS = {
    fixedMirrorParent: _common.identity
};
var LISTENER_REFINERS = {
    dateClick: _common.identity,
    eventDragStart: _common.identity,
    eventDragStop: _common.identity,
    eventDrop: _common.identity,
    eventResizeStart: _common.identity,
    eventResizeStop: _common.identity,
    eventResize: _common.identity,
    drop: _common.identity,
    eventReceive: _common.identity,
    eventLeave: _common.identity
};
/*
Given an already instantiated draggable object for one-or-more elements,
Interprets any dragging as an attempt to drag an events that lives outside
of a calendar onto a calendar.
*/ var ExternalElementDragging = /** @class */ function() {
    function ExternalElementDragging1(dragging4, suppliedDragMeta) {
        var _this = this;
        this.receivingContext = null;
        this.droppableEvent = null; // will exist for all drags, even if create:false
        this.suppliedDragMeta = null;
        this.dragMeta = null;
        this.handleDragStart = function(ev) {
            _this.dragMeta = _this.buildDragMeta(ev.subjectEl);
        };
        this.handleHitUpdate = function(hit, isFinal, ev) {
            var dragging = _this.hitDragging.dragging;
            var receivingContext = null;
            var droppableEvent = null;
            var isInvalid = false;
            var interaction = {
                affectedEvents: _common.createEmptyEventStore(),
                mutatedEvents: _common.createEmptyEventStore(),
                isEvent: _this.dragMeta.create
            };
            if (hit) {
                receivingContext = hit.context;
                if (_this.canDropElOnCalendar(ev.subjectEl, receivingContext)) {
                    droppableEvent = computeEventForDateSpan(hit.dateSpan, _this.dragMeta, receivingContext);
                    interaction.mutatedEvents = _common.eventTupleToStore(droppableEvent);
                    isInvalid = !_common.isInteractionValid(interaction, hit.dateProfile, receivingContext);
                    if (isInvalid) {
                        interaction.mutatedEvents = _common.createEmptyEventStore();
                        droppableEvent = null;
                    }
                }
            }
            _this.displayDrag(receivingContext, interaction);
            // show mirror if no already-rendered mirror element OR if we are shutting down the mirror (?)
            // TODO: wish we could somehow wait for dispatch to guarantee render
            dragging.setMirrorIsVisible(isFinal || !droppableEvent || !document.querySelector('.fc-event-mirror'));
            if (!isInvalid) _common.enableCursor();
            else _common.disableCursor();
            if (!isFinal) {
                dragging.setMirrorNeedsRevert(!droppableEvent);
                _this.receivingContext = receivingContext;
                _this.droppableEvent = droppableEvent;
            }
        };
        this.handleDragEnd = function(pev) {
            var _a = _this, receivingContext = _a.receivingContext, droppableEvent = _a.droppableEvent;
            _this.clearDrag();
            if (receivingContext && droppableEvent) {
                var finalHit = _this.hitDragging.finalHit;
                var finalView = finalHit.context.viewApi;
                var dragMeta = _this.dragMeta;
                receivingContext.emitter.trigger('drop', _tslib.__assign(_tslib.__assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), {
                    draggedEl: pev.subjectEl,
                    jsEvent: pev.origEvent,
                    view: finalView
                }));
                if (dragMeta.create) {
                    var addingEvents_1 = _common.eventTupleToStore(droppableEvent);
                    receivingContext.dispatch({
                        type: 'MERGE_EVENTS',
                        eventStore: addingEvents_1
                    });
                    if (pev.isTouch) receivingContext.dispatch({
                        type: 'SELECT_EVENT',
                        eventInstanceId: droppableEvent.instance.instanceId
                    });
                    // signal that an external event landed
                    receivingContext.emitter.trigger('eventReceive', {
                        event: new _common.EventApi(receivingContext, droppableEvent.def, droppableEvent.instance),
                        relatedEvents: [],
                        revert: function() {
                            receivingContext.dispatch({
                                type: 'REMOVE_EVENTS',
                                eventStore: addingEvents_1
                            });
                        },
                        draggedEl: pev.subjectEl,
                        view: finalView
                    });
                }
            }
            _this.receivingContext = null;
            _this.droppableEvent = null;
        };
        var hitDragging = this.hitDragging = new HitDragging(dragging4, _common.interactionSettingsStore);
        hitDragging.requireInitial = false; // will start outside of a component
        hitDragging.emitter.on('dragstart', this.handleDragStart);
        hitDragging.emitter.on('hitupdate', this.handleHitUpdate);
        hitDragging.emitter.on('dragend', this.handleDragEnd);
        this.suppliedDragMeta = suppliedDragMeta;
    }
    ExternalElementDragging1.prototype.buildDragMeta = function(subjectEl) {
        if (typeof this.suppliedDragMeta === 'object') return _common.parseDragMeta(this.suppliedDragMeta);
        if (typeof this.suppliedDragMeta === 'function') return _common.parseDragMeta(this.suppliedDragMeta(subjectEl));
        return getDragMetaFromEl(subjectEl);
    };
    ExternalElementDragging1.prototype.displayDrag = function(nextContext, state) {
        var prevContext = this.receivingContext;
        if (prevContext && prevContext !== nextContext) prevContext.dispatch({
            type: 'UNSET_EVENT_DRAG'
        });
        if (nextContext) nextContext.dispatch({
            type: 'SET_EVENT_DRAG',
            state: state
        });
    };
    ExternalElementDragging1.prototype.clearDrag = function() {
        if (this.receivingContext) this.receivingContext.dispatch({
            type: 'UNSET_EVENT_DRAG'
        });
    };
    ExternalElementDragging1.prototype.canDropElOnCalendar = function(el, receivingContext) {
        var dropAccept = receivingContext.options.dropAccept;
        if (typeof dropAccept === 'function') return dropAccept.call(receivingContext.calendarApi, el);
        if (typeof dropAccept === 'string' && dropAccept) return Boolean(_common.elementMatches(el, dropAccept));
        return true;
    };
    return ExternalElementDragging1;
}();
// Utils for computing event store from the DragMeta
// ----------------------------------------------------------------------------------------------------
function computeEventForDateSpan(dateSpan, dragMeta, context) {
    var defProps = _tslib.__assign({}, dragMeta.leftoverProps);
    for(var _i = 0, _a = context.pluginHooks.externalDefTransforms; _i < _a.length; _i++){
        var transform = _a[_i];
        _tslib.__assign(defProps, transform(dateSpan, dragMeta));
    }
    var _b = _common.refineEventDef(defProps, context), refined = _b.refined, extra = _b.extra;
    var def = _common.parseEventDef(refined, extra, dragMeta.sourceId, dateSpan.allDay, context.options.forceEventDuration || Boolean(dragMeta.duration), context);
    var start = dateSpan.range.start;
    // only rely on time info if drop zone is all-day,
    // otherwise, we already know the time
    if (dateSpan.allDay && dragMeta.startTime) start = context.dateEnv.add(start, dragMeta.startTime);
    var end = dragMeta.duration ? context.dateEnv.add(start, dragMeta.duration) : _common.getDefaultEventEnd(dateSpan.allDay, start, context);
    var instance = _common.createEventInstance(def.defId, {
        start: start,
        end: end
    });
    return {
        def: def,
        instance: instance
    };
}
// Utils for extracting data from element
// ----------------------------------------------------------------------------------------------------
function getDragMetaFromEl(el) {
    var str = getEmbeddedElData(el, 'event');
    var obj = str ? JSON.parse(str) : {
        create: false
    }; // if no embedded data, assume no event creation
    return _common.parseDragMeta(obj);
}
_common.config.dataAttrPrefix = '';
function getEmbeddedElData(el, name) {
    var prefix = _common.config.dataAttrPrefix;
    var prefixedName = (prefix ? prefix + '-' : '') + name;
    return el.getAttribute('data-' + prefixedName) || '';
}
/*
Makes an element (that is *external* to any calendar) draggable.
Can pass in data that determines how an event will be created when dropped onto a calendar.
Leverages FullCalendar's internal drag-n-drop functionality WITHOUT a third-party drag system.
*/ var ExternalDraggable = /** @class */ function() {
    function ExternalDraggable1(el, settings) {
        var _this = this;
        if (settings === void 0) settings = {};
        this.handlePointerDown = function(ev) {
            var dragging = _this.dragging;
            var _a = _this.settings, minDistance = _a.minDistance, longPressDelay = _a.longPressDelay;
            dragging.minDistance = minDistance != null ? minDistance : ev.isTouch ? 0 : _common.BASE_OPTION_DEFAULTS.eventDragMinDistance;
            dragging.delay = ev.isTouch ? longPressDelay != null ? longPressDelay : _common.BASE_OPTION_DEFAULTS.longPressDelay : 0;
        };
        this.handleDragStart = function(ev) {
            if (ev.isTouch && _this.dragging.delay && ev.subjectEl.classList.contains('fc-event')) _this.dragging.mirror.getMirrorEl().classList.add('fc-event-selected');
        };
        this.settings = settings;
        var dragging5 = this.dragging = new FeaturefulElementDragging(el);
        dragging5.touchScrollAllowed = false;
        if (settings.itemSelector != null) dragging5.pointer.selector = settings.itemSelector;
        if (settings.appendTo != null) dragging5.mirror.parentNode = settings.appendTo; // TODO: write tests
        dragging5.emitter.on('pointerdown', this.handlePointerDown);
        dragging5.emitter.on('dragstart', this.handleDragStart);
        new ExternalElementDragging(dragging5, settings.eventData); // eslint-disable-line no-new
    }
    ExternalDraggable1.prototype.destroy = function() {
        this.dragging.destroy();
    };
    return ExternalDraggable1;
}();
/*
Detects when a *THIRD-PARTY* drag-n-drop system interacts with elements.
The third-party system is responsible for drawing the visuals effects of the drag.
This class simply monitors for pointer movements and fires events.
It also has the ability to hide the moving element (the "mirror") during the drag.
*/ var InferredElementDragging = /** @class */ function(_super) {
    _tslib.__extends(InferredElementDragging1, _super);
    function InferredElementDragging1(containerEl) {
        var _this = _super.call(this, containerEl) || this;
        _this.shouldIgnoreMove = false;
        _this.mirrorSelector = '';
        _this.currentMirrorEl = null;
        _this.handlePointerDown = function(ev) {
            _this.emitter.trigger('pointerdown', ev);
            if (!_this.shouldIgnoreMove) // fire dragstart right away. does not support delay or min-distance
            _this.emitter.trigger('dragstart', ev);
        };
        _this.handlePointerMove = function(ev) {
            if (!_this.shouldIgnoreMove) _this.emitter.trigger('dragmove', ev);
        };
        _this.handlePointerUp = function(ev) {
            _this.emitter.trigger('pointerup', ev);
            if (!_this.shouldIgnoreMove) // fire dragend right away. does not support a revert animation
            _this.emitter.trigger('dragend', ev);
        };
        var pointer = _this.pointer = new PointerDragging(containerEl);
        pointer.emitter.on('pointerdown', _this.handlePointerDown);
        pointer.emitter.on('pointermove', _this.handlePointerMove);
        pointer.emitter.on('pointerup', _this.handlePointerUp);
        return _this;
    }
    InferredElementDragging1.prototype.destroy = function() {
        this.pointer.destroy();
    };
    InferredElementDragging1.prototype.setIgnoreMove = function(bool) {
        this.shouldIgnoreMove = bool;
    };
    InferredElementDragging1.prototype.setMirrorIsVisible = function(bool) {
        if (bool) // restore a previously hidden element.
        // use the reference in case the selector class has already been removed.
        {
            if (this.currentMirrorEl) {
                this.currentMirrorEl.style.visibility = '';
                this.currentMirrorEl = null;
            }
        } else {
            var mirrorEl = this.mirrorSelector ? document.querySelector(this.mirrorSelector) : null;
            if (mirrorEl) {
                this.currentMirrorEl = mirrorEl;
                mirrorEl.style.visibility = 'hidden';
            }
        }
    };
    return InferredElementDragging1;
}(_common.ElementDragging);
/*
Bridges third-party drag-n-drop systems with FullCalendar.
Must be instantiated and destroyed by caller.
*/ var ThirdPartyDraggable = /** @class */ function() {
    function ThirdPartyDraggable1(containerOrSettings, settings) {
        var containerEl = document;
        if (// wish we could just test instanceof EventTarget, but doesn't work in IE11
        containerOrSettings === document || containerOrSettings instanceof Element) {
            containerEl = containerOrSettings;
            settings = settings || {};
        } else settings = containerOrSettings || {};
        var dragging = this.dragging = new InferredElementDragging(containerEl);
        if (typeof settings.itemSelector === 'string') dragging.pointer.selector = settings.itemSelector;
        else if (containerEl === document) dragging.pointer.selector = '[data-event]';
        if (typeof settings.mirrorSelector === 'string') dragging.mirrorSelector = settings.mirrorSelector;
        new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new
    }
    ThirdPartyDraggable1.prototype.destroy = function() {
        this.dragging.destroy();
    };
    return ThirdPartyDraggable1;
}();
var main = _common.createPlugin({
    componentInteractions: [
        DateClicking,
        DateSelecting,
        EventDragging,
        EventResizing
    ],
    calendarInteractions: [
        UnselectAuto
    ],
    elementDraggingImpl: FeaturefulElementDragging,
    optionRefiners: OPTION_REFINERS,
    listenerRefiners: LISTENER_REFINERS
});
exports.default = main;

},{"@fullcalendar/common":"cnjgQ","tslib":"5i9Vz","@parcel/transformer-js/src/esmodule-helpers.js":"6jXwo"}]},["hGrKA","iGeph"], "iGeph", "parcelRequire15ff")

//# sourceMappingURL=main.js.map
